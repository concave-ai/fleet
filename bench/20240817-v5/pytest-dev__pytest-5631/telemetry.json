{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5631",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:38.485466",
        "usage": "2605.342149734497 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "getfirstlinesource",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "writelines",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "ensuretemp",
          "capture_fixtures",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "RAISES_MESSAGE_PARAMETER",
          "PYTEST_LOGWARNING",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "tmpdir_factory",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "_ConfigDeprecated",
          "_format_boolop",
          "PytestArg",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "exec_module",
          "category",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "_getscopeitem",
          "SysCapture",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "GETFUNCARGVALUE",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "_setup_cli_logging",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Junit",
          "TestReport",
          "_find_spec",
          "_done",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "showheader",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "FuncargnamesCompatAttr",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "_compare_eq_verbose",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "FIXTURE_NAMED_REQUEST",
          "finish_recording",
          "TerminalRepr",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_getcapture",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_get_non_fixture_func",
          "_finalize",
          "pytest_runtest_logfinish",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_perform_collect",
          "repr",
          "putaround",
          "_factorytraceback",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "resolve_from_str",
          "Entry",
          "report_collect",
          "cacheshow",
          "_show_fixture_action",
          "resume_fixture",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "exists",
          "write",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "defaultfuncargprefixmarker",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "node",
          "HookRecorder",
          "_getentrysource",
          "head_line",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "Class",
          "find",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingStreamHandler",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "find_spec",
          "_ensure_only_one_capture_fixture",
          "get_statement_startend2",
          "_for_parametrize",
          "get_actual_log_level",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "get_skip_exceptions",
          "_setup_fixtures",
          "tbfilter",
          "NodeMarkers",
          "from_config",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "PYTEST_CONFIG_GLOBAL",
          "suspend",
          "NFPlugin",
          "RemovedInPytest4Warning",
          "truncate_locals",
          "record_property",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "KeywordMapping",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "_handle_skip",
          "__bool__",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "setall",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "strip",
          "compile_",
          "python_keywords_allowed_list",
          "pytest_runtestloop",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "__setattr__",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_setup_collect_fakemodule",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "__module__",
          "args",
          "_seen",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_call_and_format_exception",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "_runtest_for_main",
          "pytest_sessionfinish",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "errisinstance",
          "__exit__",
          "make_properties_node",
          "result",
          "config",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "linecomp",
          "scope2index",
          "RAISES_EXEC",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "logging",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "safe_text_dupfile",
          "get_fslocation_from_item",
          "listoutcomes",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "matchmark",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "matchkeyword",
          "id",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "yield_fixture",
          "truncate_if_required",
          "DummyRewriteHook",
          "spawn",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "freeze_includes",
          "ApproxDecimal",
          "_readline_workaround",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "PyobjContext",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "_is_setup_py",
          "pop",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "add_property",
          "update",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "last_failed_paths",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "getfuncargvalue",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "TEST_OUTCOME",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "activate_fixture",
          "alias",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_test_pytest_function",
          "_truncate_explanation",
          "ReprExceptionInfo",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_write_pyc",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "ParameterSet",
          "listnames",
          "create_cleanup_lock",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_callhelper",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "_setoption",
          "PYTEST_ENSURETEMP",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "own_markers",
          "setns",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "fnmatch_ex",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "match",
          "_istrue",
          "popcall",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "FIXTURE_FUNCTION_CALL",
          "gethookproxy",
          "_genfunctions",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "warn_about_none_ast",
          "visit_Starred",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "_get_xunit_setup_teardown",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "FunctionMixin",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "__nonzero__",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "WARNS_EXEC",
          "start",
          "LoggingPlugin",
          "_get_marks",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "is_generator",
          "get_common_ancestor",
          "PdbInvoke",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "_validate_args",
          "WarningReport",
          "module",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "MarkMapping",
          "errors",
          "MarkGenerator",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "line",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "print_teardown_sections",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "YIELD_TESTS",
          "maybe_delete_a_numbered_dir",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "getdecoded",
          "getstatementrange",
          "pyobj_property",
          "makepyfile",
          "SetupState",
          "_is_doctest",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "pytest_itemstart",
          "AssertionRewritingHook",
          "_install_capture_fixture_on_item",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "repr_unicode",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "pytest_logwarning",
          "get_default_arg_names",
          "names_closure",
          "out",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "num_mock_patch_args",
          "getfuncargnames",
          "pytest_pycollect_makeitem",
          "pytest_pycollect_makemodule",
          "valueError",
          "unittest",
          "compat",
          "_getfixtureinfo",
          "pytest_exception_interact",
          "testdir"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:41.090823",
        "usage": "162.73093223571777 ms"
      },
      "request": {
        "tokens": [
          "num_mock_patch_args",
          "getfuncargnames",
          "pytest_pycollect_makeitem",
          "pytest_pycollect_makemodule",
          "valueError",
          "unittest",
          "compat",
          "_getfixtureinfo",
          "pytest_exception_interact",
          "testdir"
        ]
      },
      "response": {
        "results": {
          "pytest_exception_interact": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py"
          ],
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "compat": [
            "src/pytest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/unittest.py",
            "src/_pytest/doctest.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest_pycollect_makeitem": [
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py"
          ],
          "pytest_pycollect_makemodule": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py"
          ],
          "getfuncargnames": [
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "num_mock_patch_args": [
            "src/_pytest/compat.py"
          ],
          "testdir": [
            "src/_pytest/warning_types.py",
            "src/_pytest/pytester.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:41.253562",
        "usage": "5319.454908370972 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_exception_interact": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py"
          ],
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "compat": [
            "src/pytest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/unittest.py",
            "src/_pytest/doctest.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest_pycollect_makeitem": [
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py"
          ],
          "pytest_pycollect_makemodule": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py"
          ],
          "getfuncargnames": [
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "num_mock_patch_args": [
            "src/_pytest/compat.py"
          ],
          "testdir": [
            "src/_pytest/warning_types.py",
            "src/_pytest/pytester.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue describes a ValueError during test collection in pytest related to mocking with arrays. The traceback and issue report trace the problem to `getfuncargnames` and specifically to a check involving `num_mock_patch_args` in `compat.py` which handles function argument inspection.\n\nBased on the issue description and traceback, the key parts of the problem seem to originate from how `arg_names` are derived:\n- `getfuncargnames` is mentioned with a problematic line in `compat.py` (line 93 and especially 94), which suggests that the source of the problem lies in how patched objects with array values are being handled.\n- `num_mock_patch_args` is explicitly called out in the traceback as the function where the issue is being triggered.\n\nGiven the traceback and the content of the issue, it seems the files related to `compat.py` are most likely to hold the relevant code addressing the problem, especially the ones covering `getfuncargnames` and `num_mock_patch_args` logic.\n\nNow, let's map these out using the keyword search:\n1. 'getfuncargnames' has two file paths but 'src/_pytest/compat.py' is more relevant because it handles the function argument names where the issue is reported.\n2. 'num_mock_patch_args' clearly points to 'src/_pytest/compat.py'.\n3. 'unittest' can provide context for mocking in tests, with 'src/_pytest/compat.py' being relevant again.\n\nOverall, the file 'src/_pytest/compat.py' appears multiple times under keywords that are directly related to the issue and is likely where the problem originates from and should be addressed.",
        "file_paths": [
          "src/_pytest/compat.py",
          "src/_pytest/fixtures.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:46.573029",
        "usage": "5804.375886917114 ms"
      },
      "request": {
        "file_path": "src/_pytest/compat.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the User Instructions:\n\n1.1. The user is experiencing a `ValueError` during the collection phase when running `pytest` on a test file that uses `@patch` to mock an object with `new` set to a numpy array.\n\n1.2. The error is caused in the `compat.py` file of `_pytest`, specifically due to the check `p.new in sentinels`. This comparison returns an array of booleans instead of a single boolean when `p.new` is a numpy array, leading to the `ValueError`.\n\n1.3. The user expects not to encounter this `ValueError` when using arrays in the `@patch` decorator with `pytest`. They expect the `pytest` collection to handle this case gracefully as it did in version 3.1.3.\n\n1.4. If they didn't describe the expected result, it should be for the code to handle numpy arrays correctly during this phase and not raise a `ValueError`.\n\n1.5. The issue may be fixed by adjusting the logic in handling patched numpy arrays, possibly ensuring the sentinel check considers the array context properly without causing boolean ambiguity.\n\n2. Making the File Evaluation:\n\n2.1. The file is `_pytest/compat.py`, which contains a critical section in the `num_mock_patch_args` function that processes mock patches.\n\n2.2. Key line of interest:\n   ```python\n   return len([p for p in patchings if not p.attribute_name and p.new in sentinels])\n   ```\n   This line can cause the ambiguous truth value error when `p.new` is a numpy array.\n\n2.3. This line specifically checks `p.new in sentinels`, and the issue is likely because numpy arrays do not support such an operation reliably.\n\n2.4. The issue directly traces back to this line, suggesting this is highly relevant to the issue reported. Reviewing this in the context given, it is responsible for the `ValueError`.\n\n2.5. No other references or files are explicitly mentioned in the user's issue description.\n\n2.6. Given the information, the `num_mock_patch_args()` function's logic when handling numpy arrays seems to be the root cause of the issue.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "num_mock_patch_args"
        ],
        "root_cause_symbols": [
          "num_mock_patch_args"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:52.377418",
        "usage": "7691.825866699219 ms"
      },
      "request": {
        "file_path": "src/_pytest/fixtures.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is describing a ValueError encountered when running pytest 3.6.0. Specifically, the error occurs when collecting tests that patch an object with an array using numpy.\n\n1.2 How was this issue caused?\n- The issue arises due to a truth value evaluation on a numpy array, where \"p.new in sentinels\" returns an array of booleans instead of a single boolean. This is because numpy arrays do not inherently support truth value in Python by returning boolean values, thus resulting in a ValueError.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The user expects that the patching should work without errors as it did in pytest 3.1.3.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- The expectation would be that the evaluation should correctly handle numpy arrays or any special objects without triggering errors during the test collection.\n\n1.5 How should the issue be fixed to meet the expectation?\n- The issue can be fixed by performing checks using methods specific to arrays, such as using np.array_equal, or explicitly converting to a Python native structure for the comparison where appropriate.\n\n2. Make file evaluation:\n2.1. Analysis on the file content.\n- Look for parts related to test collection or fixture setup since the ValueError emerges during test collection.\n\n2.2. Evaluation:\n- The file is primarily concerned with fixture management, including the definitions, setup, and teardown of fixtures. \n- There's no direct evaluation of data like numpy arrays, but the closest relevant part could be related to where arguments for fixture methods are managed.\n\n2.3 & 2.4: Review and Context:\n- It seems there is a reference to getfuncargnames and FixtureDef class in the file content.\n- Comparisons and truth checks might not reside in this file but could rather be involved at fixture or test collection point.\n\n2.5: Determine if the file is the root cause:\n- This file doesn't reference or imply operations directly evaluated causing the ValueError described (evaluation involving numpy objects). Hence, it's not direct root cause but related to the processing framework.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/compat.py"
        ],
        "relevant_symbols": [
          "FixtureManager",
          "FixtureDef",
          "FixtureRequest",
          "getfixtureinfo"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:00.069288",
        "usage": "122.0247745513916 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/compat.py",
            "relevant_symbol_keys": [
              "num_mock_patch_args"
            ],
            "root_cause_symbol_keys": [
              "num_mock_patch_args"
            ]
          },
          {
            "file_path": "src/_pytest/fixtures.py",
            "relevant_symbol_keys": [
              "FixtureManager",
              "FixtureDef",
              "FixtureRequest",
              "getfixtureinfo"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef:\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 39,
            "start_column": 1112,
            "end_line": 0,
            "end_column": 1208,
            "start_byte": 1112,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 41,
            "start_column": 1161,
            "end_line": 4,
            "end_column": 1186,
            "start_byte": 1161,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 42,
            "start_column": 1191,
            "end_line": 4,
            "end_column": 1208,
            "start_byte": 1191,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 338,
            "start_column": 12539,
            "end_line": 0,
            "end_column": 24390,
            "start_byte": 12539,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 346,
            "start_column": 12825,
            "end_line": 4,
            "end_column": 13358,
            "start_byte": 12825,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 358,
            "start_column": 13364,
            "end_line": 4,
            "end_column": 13615,
            "start_byte": 13364,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 365,
            "start_column": 13621,
            "end_line": 4,
            "end_column": 13773,
            "start_byte": 13621,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 370,
            "start_column": 13779,
            "end_line": 4,
            "end_column": 14594,
            "start_byte": 13779,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 386,
            "start_column": 14600,
            "end_line": 4,
            "end_column": 14741,
            "start_byte": 14600,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 391,
            "start_column": 14747,
            "end_line": 4,
            "end_column": 14901,
            "start_byte": 14747,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 396,
            "start_column": 14907,
            "end_line": 4,
            "end_column": 15139,
            "start_byte": 14907,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 403,
            "start_column": 15145,
            "end_line": 4,
            "end_column": 15526,
            "start_byte": 15145,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 413,
            "start_column": 15532,
            "end_line": 4,
            "end_column": 15715,
            "start_byte": 15532,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 418,
            "start_column": 15721,
            "end_line": 4,
            "end_column": 15881,
            "start_byte": 15721,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 423,
            "start_column": 15887,
            "end_line": 4,
            "end_column": 16023,
            "start_byte": 15887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 428,
            "start_column": 16029,
            "end_line": 4,
            "end_column": 16140,
            "start_byte": 16029,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 433,
            "start_column": 16146,
            "end_line": 4,
            "end_column": 16462,
            "start_byte": 16146,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 440,
            "start_column": 16468,
            "end_line": 4,
            "end_column": 16672,
            "start_byte": 16468,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 446,
            "start_column": 16678,
            "end_line": 4,
            "end_column": 17062,
            "start_byte": 16678,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 456,
            "start_column": 17068,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 17068,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 460,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 17519,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 467,
            "start_column": 17525,
            "end_line": 4,
            "end_column": 17959,
            "start_byte": 17525,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 477,
            "start_column": 17965,
            "end_line": 4,
            "end_column": 18198,
            "start_byte": 17965,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 484,
            "start_column": 18204,
            "end_line": 4,
            "end_column": 18888,
            "start_byte": 18204,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 502,
            "start_column": 18894,
            "end_line": 4,
            "end_column": 19227,
            "start_byte": 18894,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 513,
            "start_column": 19233,
            "end_line": 4,
            "end_column": 22396,
            "start_byte": 19233,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 583,
            "start_column": 22402,
            "end_line": 4,
            "end_column": 22673,
            "start_byte": 22402,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 589,
            "start_column": 22679,
            "end_line": 4,
            "end_column": 23263,
            "start_byte": 22679,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 603,
            "start_column": 23269,
            "end_line": 4,
            "end_column": 23665,
            "start_byte": 23269,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 613,
            "start_column": 23671,
            "end_line": 4,
            "end_column": 24310,
            "start_byte": 23671,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 629,
            "start_column": 24316,
            "end_line": 4,
            "end_column": 24390,
            "start_byte": 24316,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef:\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 804,
            "start_column": 30655,
            "end_line": 0,
            "end_column": 33885,
            "start_byte": 30655,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 807,
            "start_column": 30728,
            "end_line": 4,
            "end_column": 31460,
            "start_byte": 30728,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 835,
            "start_column": 31466,
            "end_line": 4,
            "end_column": 31543,
            "start_byte": 31466,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 838,
            "start_column": 31549,
            "end_line": 4,
            "end_column": 32566,
            "start_byte": 31549,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 863,
            "start_column": 32572,
            "end_line": 4,
            "end_column": 33726,
            "start_byte": 32572,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 889,
            "start_column": 33732,
            "end_line": 4,
            "end_column": 33885,
            "start_byte": 33732,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager:\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1078,
            "start_column": 40779,
            "end_line": 0,
            "end_column": 51564,
            "start_byte": 40779,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1110,
            "start_column": 42080,
            "end_line": 4,
            "end_column": 42119,
            "start_byte": 42080,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1111,
            "start_column": 42124,
            "end_line": 4,
            "end_column": 42171,
            "start_byte": 42124,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1113,
            "start_column": 42177,
            "end_line": 4,
            "end_column": 42522,
            "start_byte": 42177,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._get_direct_parametrize_args",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames",
            "start_line": 1122,
            "start_column": 42528,
            "end_line": 4,
            "end_column": 43322,
            "start_byte": 42528,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1143,
            "start_column": 43328,
            "end_line": 4,
            "end_column": 44032,
            "start_byte": 43328,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1159,
            "start_column": 44038,
            "end_line": 4,
            "end_column": 44673,
            "start_byte": 44038,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1176,
            "start_column": 44679,
            "end_line": 4,
            "end_column": 45184,
            "start_byte": 44679,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1189,
            "start_column": 45190,
            "end_line": 4,
            "end_column": 47182,
            "start_byte": 45190,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1237,
            "start_column": 47188,
            "end_line": 4,
            "end_column": 48545,
            "start_byte": 47188,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1267,
            "start_column": 48551,
            "end_line": 4,
            "end_column": 48677,
            "start_byte": 48551,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1271,
            "start_column": 48683,
            "end_line": 4,
            "end_column": 50887,
            "start_byte": 48683,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1327,
            "start_column": 50893,
            "end_line": 4,
            "end_column": 51378,
            "start_byte": 50893,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1341,
            "start_column": 51384,
            "end_line": 4,
            "end_column": 51564,
            "start_byte": 51384,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.compat.num_mock_patch_args",
            "file_path": "src/_pytest/compat.py",
            "file_content": "def num_mock_patch_args(function):\n    \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n    mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n    if any(mock_modules):\n        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n        return len(\n            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n        )\n    return len(patchings)",
            "start_line": 61,
            "start_column": 1479,
            "end_line": 0,
            "end_column": 1993,
            "start_byte": 1479,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:00.191319",
        "usage": "13166.259050369263 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef:\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 39,
            "start_column": 1112,
            "end_line": 0,
            "end_column": 1208,
            "start_byte": 1112,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 41,
            "start_column": 1161,
            "end_line": 4,
            "end_column": 1186,
            "start_byte": 1161,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 42,
            "start_column": 1191,
            "end_line": 4,
            "end_column": 1208,
            "start_byte": 1191,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 338,
            "start_column": 12539,
            "end_line": 0,
            "end_column": 24390,
            "start_byte": 12539,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 346,
            "start_column": 12825,
            "end_line": 4,
            "end_column": 13358,
            "start_byte": 12825,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 358,
            "start_column": 13364,
            "end_line": 4,
            "end_column": 13615,
            "start_byte": 13364,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 365,
            "start_column": 13621,
            "end_line": 4,
            "end_column": 13773,
            "start_byte": 13621,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 370,
            "start_column": 13779,
            "end_line": 4,
            "end_column": 14594,
            "start_byte": 13779,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 386,
            "start_column": 14600,
            "end_line": 4,
            "end_column": 14741,
            "start_byte": 14600,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 391,
            "start_column": 14747,
            "end_line": 4,
            "end_column": 14901,
            "start_byte": 14747,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 396,
            "start_column": 14907,
            "end_line": 4,
            "end_column": 15139,
            "start_byte": 14907,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 403,
            "start_column": 15145,
            "end_line": 4,
            "end_column": 15526,
            "start_byte": 15145,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 413,
            "start_column": 15532,
            "end_line": 4,
            "end_column": 15715,
            "start_byte": 15532,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 418,
            "start_column": 15721,
            "end_line": 4,
            "end_column": 15881,
            "start_byte": 15721,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 423,
            "start_column": 15887,
            "end_line": 4,
            "end_column": 16023,
            "start_byte": 15887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 428,
            "start_column": 16029,
            "end_line": 4,
            "end_column": 16140,
            "start_byte": 16029,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 433,
            "start_column": 16146,
            "end_line": 4,
            "end_column": 16462,
            "start_byte": 16146,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 440,
            "start_column": 16468,
            "end_line": 4,
            "end_column": 16672,
            "start_byte": 16468,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 446,
            "start_column": 16678,
            "end_line": 4,
            "end_column": 17062,
            "start_byte": 16678,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 456,
            "start_column": 17068,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 17068,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 460,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 17519,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 467,
            "start_column": 17525,
            "end_line": 4,
            "end_column": 17959,
            "start_byte": 17525,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 477,
            "start_column": 17965,
            "end_line": 4,
            "end_column": 18198,
            "start_byte": 17965,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 484,
            "start_column": 18204,
            "end_line": 4,
            "end_column": 18888,
            "start_byte": 18204,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 502,
            "start_column": 18894,
            "end_line": 4,
            "end_column": 19227,
            "start_byte": 18894,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 513,
            "start_column": 19233,
            "end_line": 4,
            "end_column": 22396,
            "start_byte": 19233,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 583,
            "start_column": 22402,
            "end_line": 4,
            "end_column": 22673,
            "start_byte": 22402,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 589,
            "start_column": 22679,
            "end_line": 4,
            "end_column": 23263,
            "start_byte": 22679,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 603,
            "start_column": 23269,
            "end_line": 4,
            "end_column": 23665,
            "start_byte": 23269,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 613,
            "start_column": 23671,
            "end_line": 4,
            "end_column": 24310,
            "start_byte": 23671,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 629,
            "start_column": 24316,
            "end_line": 4,
            "end_column": 24390,
            "start_byte": 24316,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef:\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 804,
            "start_column": 30655,
            "end_line": 0,
            "end_column": 33885,
            "start_byte": 30655,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 807,
            "start_column": 30728,
            "end_line": 4,
            "end_column": 31460,
            "start_byte": 30728,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 835,
            "start_column": 31466,
            "end_line": 4,
            "end_column": 31543,
            "start_byte": 31466,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 838,
            "start_column": 31549,
            "end_line": 4,
            "end_column": 32566,
            "start_byte": 31549,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 863,
            "start_column": 32572,
            "end_line": 4,
            "end_column": 33726,
            "start_byte": 32572,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 889,
            "start_column": 33732,
            "end_line": 4,
            "end_column": 33885,
            "start_byte": 33732,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager:\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1078,
            "start_column": 40779,
            "end_line": 0,
            "end_column": 51564,
            "start_byte": 40779,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1110,
            "start_column": 42080,
            "end_line": 4,
            "end_column": 42119,
            "start_byte": 42080,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1111,
            "start_column": 42124,
            "end_line": 4,
            "end_column": 42171,
            "start_byte": 42124,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1113,
            "start_column": 42177,
            "end_line": 4,
            "end_column": 42522,
            "start_byte": 42177,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._get_direct_parametrize_args",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames",
            "start_line": 1122,
            "start_column": 42528,
            "end_line": 4,
            "end_column": 43322,
            "start_byte": 42528,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1143,
            "start_column": 43328,
            "end_line": 4,
            "end_column": 44032,
            "start_byte": 43328,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1159,
            "start_column": 44038,
            "end_line": 4,
            "end_column": 44673,
            "start_byte": 44038,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1176,
            "start_column": 44679,
            "end_line": 4,
            "end_column": 45184,
            "start_byte": 44679,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1189,
            "start_column": 45190,
            "end_line": 4,
            "end_column": 47182,
            "start_byte": 45190,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1237,
            "start_column": 47188,
            "end_line": 4,
            "end_column": 48545,
            "start_byte": 47188,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1267,
            "start_column": 48551,
            "end_line": 4,
            "end_column": 48677,
            "start_byte": 48551,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1271,
            "start_column": 48683,
            "end_line": 4,
            "end_column": 50887,
            "start_byte": 48683,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1327,
            "start_column": 50893,
            "end_line": 4,
            "end_column": 51378,
            "start_byte": 50893,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1341,
            "start_column": 51384,
            "end_line": 4,
            "end_column": 51564,
            "start_byte": 51384,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.compat.num_mock_patch_args",
            "file_path": "src/_pytest/compat.py",
            "file_content": "def num_mock_patch_args(function):\n    \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n    mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n    if any(mock_modules):\n        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n        return len(\n            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n        )\n    return len(patchings)",
            "start_line": 61,
            "start_column": 1479,
            "end_line": 0,
            "end_column": 1993,
            "start_byte": 1479,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The issue described is a ValueError occurring when collecting tests that patch an array using pytest version 3.6.0. The error occurs during the checking process where p.new is an array, and the truth value operation on it causes ambiguity, which is not handled in the code.\n\n2. Analyzing the provided code:\n\n3. The function `num_mock_patch_args` is directly related to the issue described because this function checks if `p.new in sentinels` returns a boolean value, which causes the issue when `p.new` is an array. \n\n4. The issue arises because of the use of the `in` operator with an array and resulting in a boolean array instead of a single boolean value.\n\n5. The expected fix should ensure compatibility with arrays by correctly checking membership or presence of `p.new` when it's an array. It should use appropriate methods like `.any()` or `.all()` to handle the truth value of an array correctly.\n\n6. Other symbols provided do not seem related to the specific line causing the issue in `num_mock_patch_args`.\n\nDecision:\n- Only the `num_mock_patch_args` function needs modification.",
        "symbols": [
          {
            "name": "_pytest.compat.num_mock_patch_args",
            "file_path": "src/_pytest/compat.py",
            "reason": "This function directly causes the ValueError due to its handling of the 'in' operation on arrays, which is the root cause of the issue described."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "`num_mock_patch_args` function checks for mock patch arguments, particularly checking if `p.new in sentinels`. This line is directly related to the issue since it fails when `p.new` is an array, hence causing the ValueError. This function needs modification to address the described problem.",
          "`PseudoFixtureDef` class in the fixtures module does not seem directly related to the issue of handling array truthiness in mock patching.",
          "`PseudoFixtureDef.cached_result` is an attribute related to caching results in fixture definitions but unrelated to the mock.patch issue concerning ValueError.",
          "`PseudoFixtureDef.scope` relates to the scoping of fixture definitions, not directly tied to the array or mock.patch handling issue.",
          "`FixtureRequest` class provides mechanisms for handling fixture requests but doesn't directly relate to mock.patch argument counting or the array truthiness issue.",
          "`FixtureRequest.__init__` initializes the FixtureRequest objects, managing various aspects of test requests, with no direct relation to the issue.",
          "`FixtureRequest.fixturenames` lists active fixtures, but doesn't handle mock.patch arguments or relate to the array truthiness problem.",
          "`FixtureRequest.node` method provides node-related information, unrelated to the issue with mock.patch and arrays.",
          "`FixtureRequest._getnextfixturedef` fetches the next fixture definition dynamically, unrelated to the mock.patch issue.",
          "`FixtureRequest.config` fetches config details, not connected to mock.patch or array handling.",
          "`FixtureRequest.function`, `cls`, `instance`, `module`, `fspath`, essentially deal with meta information about the function or class, with no interaction with mock.patch arguments.",
          "`FixtureRequest.addfinalizer` and `_addfinalizer` handle finalizer functions unrelated to mock patch argument issues.",
          "`FixtureRequest.applymarker` and `raiseerror` are meta-handling facilities for markers and raising fixture-related errors but not affecting mock arguments or their patching.",
          "`FixtureRequest._fillfixtures` and `getfixturevalue` deal with obtaining fixture values, again not influencing mock patch arguments directly or their core issue.",
          "`_get_active_fixturedef`, `_get_fixturestack`, `_compute_fixture_value`: operational methods dealing with fixture handling but unrelated to mock patch problem.",
          "Various FixtureRequest properties simply fetch or manage information about requests but do not touch mock patches or the truthiness problem.",
          "`FixtureDef` and its methods handle various fixture-related execution aspects, not directly related to the mock.patch issue faced.",
          "`FixtureDef.execute`, `finish`: Task execution and cleanup functions but do not influence mock patches or resolve the issue.",
          "`FixtureManager` class and its methods handle fixture management within pytest, focusing on fixture application, separate from the discussed problem of array truthiness.",
          "`FixtureManager.__init__`, `_get_direct_parametrize_args`, `pytest_plugin_registered`, deal with fixture and plugin registration and general setup, unrelated to mock patches.",
          "`FixtureManager.getfixtureinfo`, `_getautousenames`, `getfixtureclosure`, provide fixture and autouse management utilities but are not directly responsible for the array issue.",
          "Methods like `pytest_generate_tests`, `pytest_collection_modifyitems` are geared towards test collection and order, separate from mock.patch argument logic.",
          "Functions like `parsefactories`, `getfixturedefs`, `_matchfactories` are largely informational or sorting-related functions in fixtures, not touching the core issue."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:13.357605",
        "usage": "3.493785858154297 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.fixtures.PseudoFixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef:\n    cached_result = attr.ib()\n    scope = attr.ib()",
              "start_line": 39,
              "start_column": 1112,
              "end_line": 0,
              "end_column": 1208,
              "start_byte": 1112,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "cached_result = attr.ib()",
              "start_line": 41,
              "start_column": 1161,
              "end_line": 4,
              "end_column": 1186,
              "start_byte": 1161,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scope = attr.ib()",
              "start_line": 42,
              "start_column": 1191,
              "end_line": 4,
              "end_column": 1208,
              "start_byte": 1191,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
              "start_line": 338,
              "start_column": 12539,
              "end_line": 0,
              "end_column": 24390,
              "start_byte": 12539,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
              "start_line": 346,
              "start_column": 12825,
              "end_line": 4,
              "end_column": 13358,
              "start_byte": 12825,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.fixturenames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
              "start_line": 358,
              "start_column": 13364,
              "end_line": 4,
              "end_column": 13615,
              "start_byte": 13364,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.node",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
              "start_line": 365,
              "start_column": 13621,
              "end_line": 4,
              "end_column": 13773,
              "start_byte": 13621,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
              "start_line": 370,
              "start_column": 13779,
              "end_line": 4,
              "end_column": 14594,
              "start_byte": 13779,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.config",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
              "start_line": 386,
              "start_column": 14600,
              "end_line": 4,
              "end_column": 14741,
              "start_byte": 14600,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.function",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
              "start_line": 391,
              "start_column": 14747,
              "end_line": 4,
              "end_column": 14901,
              "start_byte": 14747,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.cls",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
              "start_line": 396,
              "start_column": 14907,
              "end_line": 4,
              "end_column": 15139,
              "start_byte": 14907,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.instance",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
              "start_line": 403,
              "start_column": 15145,
              "end_line": 4,
              "end_column": 15526,
              "start_byte": 15145,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.module",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
              "start_line": 413,
              "start_column": 15532,
              "end_line": 4,
              "end_column": 15715,
              "start_byte": 15532,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.fspath",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
              "start_line": 418,
              "start_column": 15721,
              "end_line": 4,
              "end_column": 15881,
              "start_byte": 15721,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.keywords",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
              "start_line": 423,
              "start_column": 15887,
              "end_line": 4,
              "end_column": 16023,
              "start_byte": 15887,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.session",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
              "start_line": 428,
              "start_column": 16029,
              "end_line": 4,
              "end_column": 16140,
              "start_byte": 16029,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
              "start_line": 433,
              "start_column": 16146,
              "end_line": 4,
              "end_column": 16462,
              "start_byte": 16146,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
              "start_line": 440,
              "start_column": 16468,
              "end_line": 4,
              "end_column": 16672,
              "start_byte": 16468,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.applymarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
              "start_line": 446,
              "start_column": 16678,
              "end_line": 4,
              "end_column": 17062,
              "start_byte": 16678,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.raiseerror",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
              "start_line": 456,
              "start_column": 17068,
              "end_line": 4,
              "end_column": 17232,
              "start_byte": 17068,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
              "start_line": 460,
              "start_column": 17238,
              "end_line": 4,
              "end_column": 17519,
              "start_byte": 17238,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
              "start_line": 467,
              "start_column": 17525,
              "end_line": 4,
              "end_column": 17959,
              "start_byte": 17525,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
              "start_line": 477,
              "start_column": 17965,
              "end_line": 4,
              "end_column": 18198,
              "start_byte": 17965,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
              "start_line": 484,
              "start_column": 18204,
              "end_line": 4,
              "end_column": 18888,
              "start_byte": 18204,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
              "start_line": 502,
              "start_column": 18894,
              "end_line": 4,
              "end_column": 19227,
              "start_byte": 18894,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
              "start_line": 513,
              "start_column": 19233,
              "end_line": 4,
              "end_column": 22396,
              "start_byte": 19233,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
              "start_line": 583,
              "start_column": 22402,
              "end_line": 4,
              "end_column": 22673,
              "start_byte": 22402,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._check_scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
              "start_line": 589,
              "start_column": 22679,
              "end_line": 4,
              "end_column": 23263,
              "start_byte": 22679,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
              "start_line": 603,
              "start_column": 23269,
              "end_line": 4,
              "end_column": 23665,
              "start_byte": 23269,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
              "start_line": 613,
              "start_column": 23671,
              "end_line": 4,
              "end_column": 24310,
              "start_byte": 23671,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
              "start_line": 629,
              "start_column": 24316,
              "end_line": 4,
              "end_column": 24390,
              "start_byte": 24316,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureDef:\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
              "start_line": 804,
              "start_column": 30655,
              "end_line": 0,
              "end_column": 33885,
              "start_byte": 30655,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
              "start_line": 807,
              "start_column": 30728,
              "end_line": 4,
              "end_column": 31460,
              "start_byte": 30728,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
              "start_line": 835,
              "start_column": 31466,
              "end_line": 4,
              "end_column": 31543,
              "start_byte": 31466,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.finish",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
              "start_line": 838,
              "start_column": 31549,
              "end_line": 4,
              "end_column": 32566,
              "start_byte": 31549,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.execute",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
              "start_line": 863,
              "start_column": 32572,
              "end_line": 4,
              "end_column": 33726,
              "start_byte": 32572,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
              "start_line": 889,
              "start_column": 33732,
              "end_line": 4,
              "end_column": 33885,
              "start_byte": 33732,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureManager:\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1078,
              "start_column": 40779,
              "end_line": 0,
              "end_column": 51564,
              "start_byte": 40779,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupError = FixtureLookupError",
              "start_line": 1110,
              "start_column": 42080,
              "end_line": 4,
              "end_column": 42119,
              "start_byte": 42080,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
              "start_line": 1111,
              "start_column": 42124,
              "end_line": 4,
              "end_column": 42171,
              "start_byte": 42124,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
              "start_line": 1113,
              "start_column": 42177,
              "end_line": 4,
              "end_column": 42522,
              "start_byte": 42177,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._get_direct_parametrize_args",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames",
              "start_line": 1122,
              "start_column": 42528,
              "end_line": 4,
              "end_column": 43322,
              "start_byte": 42528,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
              "start_line": 1143,
              "start_column": 43328,
              "end_line": 4,
              "end_column": 44032,
              "start_byte": 43328,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
              "start_line": 1159,
              "start_column": 44038,
              "end_line": 4,
              "end_column": 44673,
              "start_byte": 44038,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._getautousenames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
              "start_line": 1176,
              "start_column": 44679,
              "end_line": 4,
              "end_column": 45184,
              "start_byte": 44679,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
              "start_line": 1189,
              "start_column": 45190,
              "end_line": 4,
              "end_column": 47182,
              "start_byte": 45190,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
              "start_line": 1237,
              "start_column": 47188,
              "end_line": 4,
              "end_column": 48545,
              "start_byte": 47188,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
              "start_line": 1267,
              "start_column": 48551,
              "end_line": 4,
              "end_column": 48677,
              "start_byte": 48551,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.parsefactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
              "start_line": 1271,
              "start_column": 48683,
              "end_line": 4,
              "end_column": 50887,
              "start_byte": 48683,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
              "start_line": 1327,
              "start_column": 50893,
              "end_line": 4,
              "end_column": 51378,
              "start_byte": 50893,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._matchfactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1341,
              "start_column": 51384,
              "end_line": 4,
              "end_column": 51564,
              "start_byte": 51384,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.compat.num_mock_patch_args",
              "file_path": "src/_pytest/compat.py",
              "file_content": "def num_mock_patch_args(function):\n    \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n    mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n    if any(mock_modules):\n        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n        return len(\n            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n        )\n    return len(patchings)",
              "start_line": 61,
              "start_column": 1479,
              "end_line": 0,
              "end_column": 1993,
              "start_byte": 1479,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The issue described is a ValueError occurring when collecting tests that patch an array using pytest version 3.6.0. The error occurs during the checking process where p.new is an array, and the truth value operation on it causes ambiguity, which is not handled in the code.\n\n2. Analyzing the provided code:\n\n3. The function `num_mock_patch_args` is directly related to the issue described because this function checks if `p.new in sentinels` returns a boolean value, which causes the issue when `p.new` is an array. \n\n4. The issue arises because of the use of the `in` operator with an array and resulting in a boolean array instead of a single boolean value.\n\n5. The expected fix should ensure compatibility with arrays by correctly checking membership or presence of `p.new` when it's an array. It should use appropriate methods like `.any()` or `.all()` to handle the truth value of an array correctly.\n\n6. Other symbols provided do not seem related to the specific line causing the issue in `num_mock_patch_args`.\n\nDecision:\n- Only the `num_mock_patch_args` function needs modification.",
          "symbols": [
            {
              "name": "_pytest.compat.num_mock_patch_args",
              "file_path": "src/_pytest/compat.py",
              "reason": "This function directly causes the ValueError due to its handling of the 'in' operation on arrays, which is the root cause of the issue described."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "`num_mock_patch_args` function checks for mock patch arguments, particularly checking if `p.new in sentinels`. This line is directly related to the issue since it fails when `p.new` is an array, hence causing the ValueError. This function needs modification to address the described problem.",
            "`PseudoFixtureDef` class in the fixtures module does not seem directly related to the issue of handling array truthiness in mock patching.",
            "`PseudoFixtureDef.cached_result` is an attribute related to caching results in fixture definitions but unrelated to the mock.patch issue concerning ValueError.",
            "`PseudoFixtureDef.scope` relates to the scoping of fixture definitions, not directly tied to the array or mock.patch handling issue.",
            "`FixtureRequest` class provides mechanisms for handling fixture requests but doesn't directly relate to mock.patch argument counting or the array truthiness issue.",
            "`FixtureRequest.__init__` initializes the FixtureRequest objects, managing various aspects of test requests, with no direct relation to the issue.",
            "`FixtureRequest.fixturenames` lists active fixtures, but doesn't handle mock.patch arguments or relate to the array truthiness problem.",
            "`FixtureRequest.node` method provides node-related information, unrelated to the issue with mock.patch and arrays.",
            "`FixtureRequest._getnextfixturedef` fetches the next fixture definition dynamically, unrelated to the mock.patch issue.",
            "`FixtureRequest.config` fetches config details, not connected to mock.patch or array handling.",
            "`FixtureRequest.function`, `cls`, `instance`, `module`, `fspath`, essentially deal with meta information about the function or class, with no interaction with mock.patch arguments.",
            "`FixtureRequest.addfinalizer` and `_addfinalizer` handle finalizer functions unrelated to mock patch argument issues.",
            "`FixtureRequest.applymarker` and `raiseerror` are meta-handling facilities for markers and raising fixture-related errors but not affecting mock arguments or their patching.",
            "`FixtureRequest._fillfixtures` and `getfixturevalue` deal with obtaining fixture values, again not influencing mock patch arguments directly or their core issue.",
            "`_get_active_fixturedef`, `_get_fixturestack`, `_compute_fixture_value`: operational methods dealing with fixture handling but unrelated to mock patch problem.",
            "Various FixtureRequest properties simply fetch or manage information about requests but do not touch mock patches or the truthiness problem.",
            "`FixtureDef` and its methods handle various fixture-related execution aspects, not directly related to the mock.patch issue faced.",
            "`FixtureDef.execute`, `finish`: Task execution and cleanup functions but do not influence mock patches or resolve the issue.",
            "`FixtureManager` class and its methods handle fixture management within pytest, focusing on fixture application, separate from the discussed problem of array truthiness.",
            "`FixtureManager.__init__`, `_get_direct_parametrize_args`, `pytest_plugin_registered`, deal with fixture and plugin registration and general setup, unrelated to mock patches.",
            "`FixtureManager.getfixtureinfo`, `_getautousenames`, `getfixtureclosure`, provide fixture and autouse management utilities but are not directly responsible for the array issue.",
            "Methods like `pytest_generate_tests`, `pytest_collection_modifyitems` are geared towards test collection and order, separate from mock.patch argument logic.",
            "Functions like `parsefactories`, `getfixturedefs`, `_matchfactories` are largely informational or sorting-related functions in fixtures, not touching the core issue."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/compat.py"
        ],
        "symbols": [
          "_pytest.compat.num_mock_patch_args"
        ],
        "code_spans": {
          "_pytest.fixtures.PseudoFixtureDef": {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef:\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 39,
            "start_column": 1112,
            "end_line": 0,
            "end_column": 1208,
            "start_byte": 1112,
            "end_byte": 0
          },
          "_pytest.fixtures.PseudoFixtureDef.cached_result": {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 41,
            "start_column": 1161,
            "end_line": 4,
            "end_column": 1186,
            "start_byte": 1161,
            "end_byte": 4
          },
          "_pytest.fixtures.PseudoFixtureDef.scope": {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 42,
            "start_column": 1191,
            "end_line": 4,
            "end_column": 1208,
            "start_byte": 1191,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest": {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 338,
            "start_column": 12539,
            "end_line": 0,
            "end_column": 24390,
            "start_byte": 12539,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureRequest.__init__": {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 346,
            "start_column": 12825,
            "end_line": 4,
            "end_column": 13358,
            "start_byte": 12825,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.fixturenames": {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 358,
            "start_column": 13364,
            "end_line": 4,
            "end_column": 13615,
            "start_byte": 13364,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.node": {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 365,
            "start_column": 13621,
            "end_line": 4,
            "end_column": 13773,
            "start_byte": 13621,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._getnextfixturedef": {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 370,
            "start_column": 13779,
            "end_line": 4,
            "end_column": 14594,
            "start_byte": 13779,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.config": {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 386,
            "start_column": 14600,
            "end_line": 4,
            "end_column": 14741,
            "start_byte": 14600,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.function": {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 391,
            "start_column": 14747,
            "end_line": 4,
            "end_column": 14901,
            "start_byte": 14747,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.cls": {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 396,
            "start_column": 14907,
            "end_line": 4,
            "end_column": 15139,
            "start_byte": 14907,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.instance": {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 403,
            "start_column": 15145,
            "end_line": 4,
            "end_column": 15526,
            "start_byte": 15145,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.module": {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 413,
            "start_column": 15532,
            "end_line": 4,
            "end_column": 15715,
            "start_byte": 15532,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.fspath": {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 418,
            "start_column": 15721,
            "end_line": 4,
            "end_column": 15881,
            "start_byte": 15721,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.keywords": {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 423,
            "start_column": 15887,
            "end_line": 4,
            "end_column": 16023,
            "start_byte": 15887,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.session": {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 428,
            "start_column": 16029,
            "end_line": 4,
            "end_column": 16140,
            "start_byte": 16029,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.addfinalizer": {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 433,
            "start_column": 16146,
            "end_line": 4,
            "end_column": 16462,
            "start_byte": 16146,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._addfinalizer": {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 440,
            "start_column": 16468,
            "end_line": 4,
            "end_column": 16672,
            "start_byte": 16468,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.applymarker": {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 446,
            "start_column": 16678,
            "end_line": 4,
            "end_column": 17062,
            "start_byte": 16678,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.raiseerror": {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 456,
            "start_column": 17068,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 17068,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._fillfixtures": {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 460,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 17519,
            "start_byte": 17238,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.getfixturevalue": {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 467,
            "start_column": 17525,
            "end_line": 4,
            "end_column": 17959,
            "start_byte": 17525,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.getfuncargvalue": {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 477,
            "start_column": 17965,
            "end_line": 4,
            "end_column": 18198,
            "start_byte": 17965,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._get_active_fixturedef": {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 484,
            "start_column": 18204,
            "end_line": 4,
            "end_column": 18888,
            "start_byte": 18204,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._get_fixturestack": {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 502,
            "start_column": 18894,
            "end_line": 4,
            "end_column": 19227,
            "start_byte": 18894,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._compute_fixture_value": {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 513,
            "start_column": 19233,
            "end_line": 4,
            "end_column": 22396,
            "start_byte": 19233,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._schedule_finalizers": {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 583,
            "start_column": 22402,
            "end_line": 4,
            "end_column": 22673,
            "start_byte": 22402,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._check_scope": {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 589,
            "start_column": 22679,
            "end_line": 4,
            "end_column": 23263,
            "start_byte": 22679,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._factorytraceback": {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 603,
            "start_column": 23269,
            "end_line": 4,
            "end_column": 23665,
            "start_byte": 23269,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._getscopeitem": {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 613,
            "start_column": 23671,
            "end_line": 4,
            "end_column": 24310,
            "start_byte": 23671,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.__repr__": {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 629,
            "start_column": 24316,
            "end_line": 4,
            "end_column": 24390,
            "start_byte": 24316,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef": {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef:\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 804,
            "start_column": 30655,
            "end_line": 0,
            "end_column": 33885,
            "start_byte": 30655,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureDef.__init__": {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 807,
            "start_column": 30728,
            "end_line": 4,
            "end_column": 31460,
            "start_byte": 30728,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.addfinalizer": {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 835,
            "start_column": 31466,
            "end_line": 4,
            "end_column": 31543,
            "start_byte": 31466,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.finish": {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                _, val, tb = exceptions[0]\n                # Ensure to not keep frame references through traceback.\n                del exceptions\n                raise val.with_traceback(tb)\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 838,
            "start_column": 31549,
            "end_line": 4,
            "end_column": 32566,
            "start_byte": 31549,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.execute": {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    _, val, tb = err\n                    raise val.with_traceback(tb)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 863,
            "start_column": 32572,
            "end_line": 4,
            "end_column": 33726,
            "start_byte": 32572,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.__repr__": {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname={!r} scope={!r} baseid={!r}>\".format(\n            self.argname, self.scope, self.baseid\n        )",
            "start_line": 889,
            "start_column": 33732,
            "end_line": 4,
            "end_column": 33885,
            "start_byte": 33732,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager": {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager:\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1078,
            "start_column": 40779,
            "end_line": 0,
            "end_column": 51564,
            "start_byte": 40779,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupError": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1110,
            "start_column": 42080,
            "end_line": 4,
            "end_column": 42119,
            "start_byte": 42080,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1111,
            "start_column": 42124,
            "end_line": 4,
            "end_column": 42171,
            "start_byte": 42124,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.__init__": {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1113,
            "start_column": 42177,
            "end_line": 4,
            "end_column": 42522,
            "start_byte": 42177,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._get_direct_parametrize_args": {
            "name": "_pytest.fixtures.FixtureManager._get_direct_parametrize_args",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_direct_parametrize_args(self, node):\n        \"\"\"This function returns all the direct parametrization\n        arguments of a node, so we don't mistake them for fixtures\n\n        Check https://github.com/pytest-dev/pytest/issues/5036\n\n        This things are done later as well when dealing with parametrization\n        so this could be improved\n        \"\"\"\n        from _pytest.mark import ParameterSet\n\n        parametrize_argnames = []\n        for marker in node.iter_markers(name=\"parametrize\"):\n            if not marker.kwargs.get(\"indirect\", False):\n                p_argnames, _ = ParameterSet._parse_parametrize_args(\n                    *marker.args, **marker.kwargs\n                )\n                parametrize_argnames.extend(p_argnames)\n\n        return parametrize_argnames",
            "start_line": 1122,
            "start_column": 42528,
            "end_line": 4,
            "end_column": 43322,
            "start_byte": 42528,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureinfo": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node, ignore_args=self._get_direct_parametrize_args(node)\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1143,
            "start_column": 43328,
            "end_line": 4,
            "end_column": 44032,
            "start_byte": 43328,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_plugin_registered": {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1159,
            "start_column": 44038,
            "end_line": 4,
            "end_column": 44673,
            "start_byte": 44038,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._getautousenames": {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1176,
            "start_column": 44679,
            "end_line": 4,
            "end_column": 45184,
            "start_byte": 44679,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureclosure": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode, ignore_args=()):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in ignore_args:\n                    continue\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1189,
            "start_column": 45190,
            "end_line": 4,
            "end_column": 47182,
            "start_byte": 45190,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_generate_tests": {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1237,
            "start_column": 47188,
            "end_line": 4,
            "end_column": 48545,
            "start_byte": 47188,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1267,
            "start_column": 48551,
            "end_line": 4,
            "end_column": 48677,
            "start_byte": 48551,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.parsefactories": {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1271,
            "start_column": 48683,
            "end_line": 4,
            "end_column": 50887,
            "start_byte": 48683,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixturedefs": {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1327,
            "start_column": 50893,
            "end_line": 4,
            "end_column": 51378,
            "start_byte": 50893,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._matchfactories": {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1341,
            "start_column": 51384,
            "end_line": 4,
            "end_column": 51564,
            "start_byte": 51384,
            "end_byte": 4
          },
          "_pytest.compat.num_mock_patch_args": {
            "name": "_pytest.compat.num_mock_patch_args",
            "file_path": "src/_pytest/compat.py",
            "file_content": "def num_mock_patch_args(function):\n    \"\"\" return number of arguments used up by mock arguments (if any) \"\"\"\n    patchings = getattr(function, \"patchings\", None)\n    if not patchings:\n        return 0\n    mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n    if any(mock_modules):\n        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n        return len(\n            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n        )\n    return len(patchings)",
            "start_line": 61,
            "start_column": 1479,
            "end_line": 0,
            "end_column": 1993,
            "start_byte": 1479,
            "end_byte": 0
          }
        }
      }
    }
  ]
}