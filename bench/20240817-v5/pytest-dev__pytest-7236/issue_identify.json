{
    "file_paths": [
        "src/_pytest/unittest.py"
    ],
    "symbols": [
        "_pytest.unittest.TestCaseFunction.runtest"
    ],
    "code_spans": {
        "_pytest.unittest._make_xunit_fixture": {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture",
            "start_line": 83,
            "start_column": 2910,
            "end_line": 0,
            "end_column": 3683,
            "start_byte": 2910,
            "end_byte": 0
        },
        "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
        },
        "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "      )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n   ",
            "start_line": 20,
            "start_column": 497,
            "end_line": 0,
            "end_column": 1273,
            "start_byte": 497,
            "end_byte": 0
        },
        "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 384,
            "start_column": 14196,
            "end_line": 0,
            "end_column": 15963,
            "start_byte": 14196,
            "end_byte": 0
        },
        "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal",
            "start_line": 28,
            "start_column": 587,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 587,
            "end_byte": 0
        },
        "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
        },
        "_pytest.debugging.pytestPDB": {
            "name": "_pytest.debugging.pytestPDB",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 72,
            "start_column": 2052,
            "end_line": 0,
            "end_column": 8407,
            "start_byte": 2052,
            "end_byte": 0
        },
        "_pytest.debugging.pytestPDB._pluginmanager": {
            "name": "_pytest.debugging.pytestPDB._pluginmanager",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_pluginmanager = None",
            "start_line": 75,
            "start_column": 2126,
            "end_line": 4,
            "end_column": 2147,
            "start_byte": 2126,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._config": {
            "name": "_pytest.debugging.pytestPDB._config",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_config = None",
            "start_line": 76,
            "start_column": 2152,
            "end_line": 4,
            "end_column": 2166,
            "start_byte": 2152,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._saved": {
            "name": "_pytest.debugging.pytestPDB._saved",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_saved = []",
            "start_line": 77,
            "start_column": 2171,
            "end_line": 4,
            "end_column": 2182,
            "start_byte": 2171,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._recursive_debug": {
            "name": "_pytest.debugging.pytestPDB._recursive_debug",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_recursive_debug = 0",
            "start_line": 78,
            "start_column": 2201,
            "end_line": 4,
            "end_column": 2221,
            "start_byte": 2201,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._wrapped_pdb_cls": {
            "name": "_pytest.debugging.pytestPDB._wrapped_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_wrapped_pdb_cls = None",
            "start_line": 79,
            "start_column": 2226,
            "end_line": 4,
            "end_column": 2249,
            "start_byte": 2226,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._is_capturing": {
            "name": "_pytest.debugging.pytestPDB._is_capturing",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False",
            "start_line": 81,
            "start_column": 2255,
            "end_line": 4,
            "end_column": 2384,
            "start_byte": 2255,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._import_pdb_cls": {
            "name": "_pytest.debugging.pytestPDB._import_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls",
            "start_line": 87,
            "start_column": 2390,
            "end_line": 4,
            "end_column": 3628,
            "start_byte": 2390,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._get_pdb_wrapper_class": {
            "name": "_pytest.debugging.pytestPDB._get_pdb_wrapper_class",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper",
            "start_line": 126,
            "start_column": 3634,
            "end_line": 4,
            "end_column": 6672,
            "start_byte": 3634,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB._init_pdb": {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 208,
            "start_column": 6678,
            "end_line": 4,
            "end_column": 8139,
            "start_byte": 6678,
            "end_byte": 4
        },
        "_pytest.debugging.pytestPDB.set_trace": {
            "name": "_pytest.debugging.pytestPDB.set_trace",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 248,
            "start_column": 8145,
            "end_line": 4,
            "end_column": 8407,
            "start_byte": 8145,
            "end_byte": 4
        },
        "_pytest.debugging.PdbInvoke.pytest_exception_interact": {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test ite",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
        },
        "_pytest.debugging._enter_pdb": {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep",
            "start_line": 304,
            "start_column": 10146,
            "end_line": 0,
            "end_column": 11019,
            "start_byte": 10146,
            "end_byte": 0
        },
        "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "testPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                m",
            "start_line": 54,
            "start_column": 1486,
            "end_line": 0,
            "end_column": 2904,
            "start_byte": 1486,
            "end_byte": 0
        },
        "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "port hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueEr",
            "start_line": 12,
            "start_column": 157,
            "end_line": 0,
            "end_column": 374,
            "start_byte": 157,
            "end_byte": 0
        },
        "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "e``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal an",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
        },
        "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 1202,
            "start_column": 45360,
            "end_line": 0,
            "end_column": 45548,
            "start_byte": 45360,
            "end_byte": 0
        },
        "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "rue\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n      ",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2499,
            "start_byte": 1168,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "nfig.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n         ",
            "start_line": 50,
            "start_column": 1425,
            "end_line": 0,
            "end_column": 3012,
            "start_byte": 1425,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_enter_pdb": {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
        },
        "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 365,
            "start_column": 12037,
            "end_line": 0,
            "end_column": 13376,
            "start_byte": 12037,
            "end_byte": 0
        },
        "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)\n\n\nclass PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_",
            "start_line": 182,
            "start_column": 6378,
            "end_line": 0,
            "end_column": 8992,
            "start_byte": 6378,
            "end_byte": 0
        },
        "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "er on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._conti",
            "start_line": 40,
            "start_column": 989,
            "end_line": 0,
            "end_column": 5037,
            "start_byte": 989,
            "end_byte": 0
        },
        "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "fig = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                ",
            "start_line": 53,
            "start_column": 1694,
            "end_line": 0,
            "end_column": 3297,
            "start_byte": 1694,
            "end_byte": 0
        },
        "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "date_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption",
            "start_line": 12,
            "start_column": 231,
            "end_line": 0,
            "end_column": 559,
            "start_byte": 231,
            "end_byte": 0
        },
        "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "race\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n   ",
            "start_line": 55,
            "start_column": 1374,
            "end_line": 0,
            "end_column": 1985,
            "start_byte": 1374,
            "end_byte": 0
        },
        "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n     ",
            "start_line": 59,
            "start_column": 1875,
            "end_line": 0,
            "end_column": 3550,
            "start_byte": 1875,
            "end_byte": 0
        },
        "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ",\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef ",
            "start_line": 34,
            "start_column": 933,
            "end_line": 0,
            "end_column": 1244,
            "start_byte": 933,
            "end_byte": 0
        },
        "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the form",
            "start_line": 4,
            "start_column": 58,
            "end_line": 0,
            "end_column": 457,
            "start_byte": 58,
            "end_byte": 0
        },
        "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls opt",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modu",
            "start_line": 14,
            "start_column": 401,
            "end_line": 0,
            "end_column": 881,
            "start_byte": 401,
            "end_byte": 0
        },
        "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
        },
        "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                       ",
            "start_line": 78,
            "start_column": 1896,
            "end_line": 0,
            "end_column": 4639,
            "start_byte": 1896,
            "end_byte": 0
        },
        "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ", pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n       ",
            "start_line": 51,
            "start_column": 1531,
            "end_line": 0,
            "end_column": 1989,
            "start_byte": 1531,
            "end_byte": 0
        },
        "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "onfig.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n      ",
            "start_line": 13,
            "start_column": 185,
            "end_line": 0,
            "end_column": 501,
            "start_byte": 185,
            "end_byte": 0
        },
        "_pytest.capture.CaptureManager.pytest_runtest_setup": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 245,
            "start_column": 8284,
            "end_line": 4,
            "end_column": 8425,
            "start_byte": 8284,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_runtest_setup": {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 378,
            "start_column": 12657,
            "end_line": 0,
            "end_column": 12745,
            "start_byte": 12657,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 13232,
            "end_line": 0,
            "end_column": 13535,
            "start_byte": 13232,
            "end_byte": 0
        },
        "_pytest.logging.LoggingPlugin.pytest_runtest_setup": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 649,
            "start_column": 23082,
            "end_line": 4,
            "end_column": 23306,
            "start_byte": 23082,
            "end_byte": 4
        },
        "_pytest.runner.pytest_runtest_setup": {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "alxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_s",
            "start_line": 125,
            "start_column": 3822,
            "end_line": 0,
            "end_column": 3940,
            "start_byte": 3822,
            "end_byte": 0
        },
        "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 284,
            "start_column": 8918,
            "end_line": 0,
            "end_column": 9013,
            "start_byte": 8918,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_runtest_setup": {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)",
            "start_line": 73,
            "start_column": 2452,
            "end_line": 0,
            "end_column": 3179,
            "start_byte": 2452,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 125,
            "start_column": 4192,
            "end_line": 0,
            "end_column": 6240,
            "start_byte": 4192,
            "end_byte": 0
        },
        "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 243,
            "start_column": 8721,
            "end_line": 0,
            "end_column": 9351,
            "start_byte": 8721,
            "end_byte": 0
        },
        "_pytest.nose.pytest_runtest_setup": {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "r\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n      ",
            "start_line": 6,
            "start_column": 136,
            "end_line": 0,
            "end_column": 548,
            "start_byte": 136,
            "end_byte": 0
        },
        "_pytest.capture.CaptureManager.pytest_runtest_teardown": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished co",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_runtest_teardown": {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
        },
        "_pytest.logging.LoggingPlugin.pytest_runtest_teardown": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
        },
        "_pytest.runner.pytest_runtest_teardown": {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for s",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
        },
        "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first n",
            "start_line": 104,
            "start_column": 3662,
            "end_line": 4,
            "end_column": 3920,
            "start_byte": 3662,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_exception_interact": {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 675,
            "start_column": 22873,
            "end_line": 0,
            "end_column": 23146,
            "start_byte": 22873,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_leave_pdb": {
            "name": "_pytest.hookspec.pytest_leave_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 693,
            "start_column": 23441,
            "end_line": 0,
            "end_column": 23770,
            "start_byte": 23441,
            "end_byte": 0
        },
        "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 207,
            "start_column": 7152,
            "end_line": 4,
            "end_column": 8447,
            "start_byte": 7152,
            "end_byte": 4
        },
        "_pytest.runner.runtestprotocol": {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
        },
        "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 187,
            "start_column": 5534,
            "end_line": 0,
            "end_column": 5976,
            "start_byte": 5534,
            "end_byte": 0
        },
        "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 200,
            "start_column": 5979,
            "end_line": 0,
            "end_column": 6199,
            "start_byte": 5979,
            "end_byte": 0
        }
    }
}