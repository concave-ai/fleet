{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7236",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:39.227350",
        "usage": "1395.0231075286865 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "_CACHE_PREFIX_DIRS",
          "getfirstlinesource",
          "FaultHandlerHooks",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "T",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "pytest",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "rex_session_duration",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "MINUS_K_COLON",
          "accept",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "reprfileloc",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "RPAREN",
          "reprcrash",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "_color_for_type_default",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "get_line_width",
          "tmpdir_factory",
          "__slots__",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "clear_cache",
          "_format_boolop",
          "PytestArg",
          "no_re_match_line",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "_WithException",
          "exec_module",
          "LFPluginCollSkipfiles",
          "category",
          "ParseError",
          "builtin_plugins",
          "evalxfail_key",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "Expression",
          "_getscopeitem",
          "SysCapture",
          "MINUS_K_DASH",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "lineno",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "_PluggyPlugin",
          "writer",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Store",
          "Junit",
          "_W",
          "TestReport",
          "_find_spec",
          "_done",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "sections",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "_CACHE_PREFIX_VALUES",
          "showheader",
          "stream",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "_make_plural",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "extraline",
          "_compare_eq_verbose",
          "longrepr",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "_set_main_color",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "width_of_current_line",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "flush",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "finish_recording",
          "TerminalRepr",
          "duration",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "_get_multicapture",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "NODE_USE_FROM_PARENT",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "TERMINALWRITER_WRITER",
          "FakeCollectModule",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "_perform_collect",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "repr",
          "putaround",
          "_factorytraceback",
          "get_terminal_width",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "OR",
          "resolve_from_str",
          "report_collect",
          "_split_lines",
          "cacheshow",
          "_show_fixture_action",
          "resume_fixture",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "get_last_failed_paths",
          "exists",
          "write",
          "_write_content",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "_esctable",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "fullwidth",
          "_compare_eq_iterable",
          "COLLECT_DIRECTORY_HOOK",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_fail",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "pos",
          "catch_log_handler_key",
          "node",
          "_names",
          "HookRecorder",
          "_getentrysource",
          "should_do_markup",
          "Scanner",
          "head_line",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "maybe_wrap_pytest_function_for_tracing",
          "Class",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingNullHandler",
          "_LiveLoggingStreamHandler",
          "sep",
          "fault_handler_stderr_key",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "_get_teardown_reports",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "markup",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "Exception",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "TerminalWriter",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "setdefault",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "_validate_ids",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "from_parent",
          "_setupstate",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "CHECKER_CLASS",
          "find_spec",
          "get_statement_startend2",
          "try_makedirs",
          "old_mark_config_key",
          "_for_parametrize",
          "Token",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "from_config",
          "console_main",
          "lex",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "__attrs_post_init__",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "JUNIT_XML_DEFAULT_FAMILY",
          "truncate_locals",
          "record_property",
          "reprlocals",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "__bool__",
          "TeeSysCapture",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "assertstate_key",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "_AnyPurePath",
          "LFPluginCollWrapper",
          "strip",
          "compile_",
          "pytest_runtestloop",
          "exitstatus",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "evalcache_key",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "_expecting_failure",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_add_stats",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "reprentries",
          "args",
          "__module__",
          "_seen",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "reject",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "pytest_sessionfinish",
          "fill_unfilled",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "D",
          "errisinstance",
          "_init_checker_class",
          "__exit__",
          "make_properties_node",
          "result",
          "config",
          "_is_last_item",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "reprfuncargs",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "AND",
          "linecomp",
          "scope2index",
          "KNOWN_TYPES",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "__dir__",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "LPAREN",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "IDENT",
          "logging",
          "xml_key",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "invocation_dir",
          "not_expr",
          "get_fslocation_from_item",
          "listoutcomes",
          "EOF",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "KeywordMatcher",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "_param_ids_from",
          "id",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "_param_ids_generated",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "freeze_includes",
          "ApproxDecimal",
          "_readline_workaround",
          "lines",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "_write_entry_lines",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "expression",
          "MatcherAdapter",
          "_is_setup_py",
          "pop",
          "TokenType",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "_write_pyc_fp",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "TeeCaptureIO",
          "add_property",
          "resultlog_key",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "cache_key",
          "TEST_OUTCOME",
          "NOT",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "_F",
          "activate_fixture",
          "catch_log_records_key",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "_has_param_ids",
          "NodeMeta",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "char_width",
          "_truncate_explanation",
          "_T",
          "get_cache_dir",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "_ensure_relative_to_basetemp",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_check_non_top_pytest_plugins",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "_capturing_for_request",
          "ihook",
          "Session",
          "_surrounding_parens_on_own_lines",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "ParameterSet",
          "listnames",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "_with_exception",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "_pformat_dispatch",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "and_expr",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "_format",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_color_for_type",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "async_warn_and_skip",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "evaluate",
          "_REPORTCHARS_DEFAULT",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "fnmatch_ex",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "skipped_by_mark_key",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "_istrue",
          "popcall",
          "_no_match_line",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "_highlight",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "_get_auto_indent",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "get_timeout_config_value",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "_gethookproxy",
          "visit_Starred",
          "_ET",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "_parse_filter",
          "ReprFuncArgs",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_handle_teardown_sections",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "start",
          "_write_source",
          "LoggingPlugin",
          "_get_marks",
          "_determine_main_color",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_try_repr_or_str",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "_fixturemanager",
          "is_generator",
          "get_common_ancestor",
          "PdbInvoke",
          "__contains__",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "MarkMatcher",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "_create",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "FILLFUNCARGS",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "store",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "_get_main_color",
          "no_fnmatch_line",
          "MarkGenerator",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "line",
          "StoreKey",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "is_async_function",
          "AlwaysDispatchingPrettyPrinter",
          "print_teardown_sections",
          "wrap_pytest_function_for_tracing",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "_S",
          "maybe_delete_a_numbered_dir",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "pastebinfile_key",
          "getstatementrange",
          "makepyfile",
          "reprtraceback",
          "_is_doctest",
          "SetupState",
          "_prepare_content",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "AssertionRewritingHook",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "map_fixname_class",
          "chain",
          "repr_locals",
          "_in_suspended",
          "get_default_arg_names",
          "names_closure",
          "out",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "expr",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "unexpectedsuccess_key",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "_eval_scope_callable",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "unittest",
          "pytest",
          "tearDown",
          "skip",
          "MyTestCase",
          "test_one",
          "pytestPDB",
          "pytest",
          "pytest_cmdline_main",
          "xunit"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:40.622388",
        "usage": "170.2871322631836 ms"
      },
      "request": {
        "tokens": [
          "unittest",
          "pytest",
          "tearDown",
          "skip",
          "MyTestCase",
          "test_one",
          "pytestPDB",
          "pytest",
          "pytest_cmdline_main",
          "xunit"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/pytest/collect.py",
            "src/_pytest/warnings.py",
            "src/pytest/__main__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/pytester.py"
          ],
          "skip": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/doctest.py",
            "src/pytest/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "pytest_cmdline_main": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/python.py"
          ],
          "pytestPDB": [
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py"
          ],
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/skipping.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "tearDown": [
            "src/_pytest/unittest.py"
          ],
          "xunit": [
            "src/_pytest/junitxml.py",
            "src/_pytest/python.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:40.792683",
        "usage": "4446.191787719727 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/pytest/collect.py",
            "src/_pytest/warnings.py",
            "src/pytest/__main__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/pytester.py"
          ],
          "skip": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/doctest.py",
            "src/pytest/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "pytest_cmdline_main": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/python.py"
          ],
          "pytestPDB": [
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py"
          ],
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/skipping.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "tearDown": [
            "src/_pytest/unittest.py"
          ],
          "xunit": [
            "src/_pytest/junitxml.py",
            "src/_pytest/python.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "1. The issue describes a behavior change in pytest between versions 5.4.1 and 5.4.2 when running with `--pdb`, where the `unittest.TestCase.tearDown` method is unexpectedly executed even if the test is skipped.\n\n2. The relevant keywords to this issue are:\n   - `pytest`: since it involves the pytest test runner.\n   - `unittest`: because it pertains to behaviors of unittest test cases.\n   - `skip`: because the issue concerns tests marked for skipping.\n   - `tearDown`: as it's explicitly mentioned that this method is involved in the bug.\n   - `pytestPDB`: because the issue occurs when running tests with the `--pdb` flag.\n\n3. Examining the files for these keywords:\n   - `src/_pytest/unittest.py`: likely handles unittest integrations, making it highly relevant since `tearDown` is called in a unittest test case.\n   - `src/_pytest/debugging.py`: could relate to `--pdb` functionality, as it contains the keyword `pytestPDB`.\n   - `src/_pytest/skipping.py`: may contain logic related to skipping tests.\n\n4. Other files with broader or less specific relevance might include those dealing with pytest configuration or execution but are less specific to the `tearDown` or skipping logic.\n\n5. Conclusion: Prioritize files that are most likely directly involved with either integration of unittest or specific functionality changes introduced in pytest 5.4.2 related to skipping and debugging.",
        "file_paths": [
          "src/_pytest/unittest.py",
          "src/_pytest/debugging.py",
          "src/_pytest/skipping.py",
          "src/_pytest/runner.py",
          "src/_pytest/hookspec.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:45.238908",
        "usage": "7253.573179244995 ms"
      },
      "request": {
        "file_path": "src/_pytest/unittest.py"
      },
      "response": {
        "scratch_pad": "### Analysis of User Instructions:\n\n1. **Issue Described**: \n   - The `unittest.TestCase.tearDown` method is being executed for a test case even when the test is marked as skipped when running with `--pdb` using `pytest`.\n\n2. **Cause**: \n   - This is caused when `pytest` version `5.4.2` is used with `--pdb` option. The `tearDown` method still executes, unlike in version `5.4.1`, where the test remained truly skipped.\n\n3. **Expected Result**: \n   - The expected result is that `tearDown` should not execute if a test is skipped, even with the use of `--pdb`.\n\n4. **Expectation**: \n   - The test should be skipped entirely, including setup and teardown methods, regardless of the use of `--pdb`.\n\n5. **Fix**: \n   - Modify `pytest` or `unittest` integration so that the teardown is not triggered when a test is skipped, even if `--pdb` is used.\n\n### Evaluation of File Content:\n\n1. **`TestCaseFunction.setup()` and `TestCaseFunction.teardown()`**:\n   - The setup and teardown methods are heavily associated with managing resources for each test function. Analysis here is crucial because the issue is related to the `tearDown` being run despite the test being skipped.\n\n2. **`TestCaseFunction.runtest()`**:\n   - This method contains logic to postpone the calling of `tearDown()` when `--pdb` is used, indicating direct relevance to the issue. The specific section is:\n     ```python\n     if self.config.getoption(\"usepdb\"):\n         self._explicit_tearDown = self._testcase.tearDown\n         setattr(self._testcase, \"tearDown\", lambda *args: None)\n     ```\n   - This code postpones teardown by assigning a no-op, suggesting the logic is introduced correctly but might have unintended execution impacts or scoping issues/errors.\n\n3. **Other Methods/Classes**:\n   - `_make_xunit_fixture` may indirectly affect the behavior in terms of how the setup/teardown methods are wrapped or manipulated as pytest fixtures.\n   - No other immediate calls ensure if setup/teardown are conditions to skip tests entirely.\n\n### Conclusion:\n- The file contains code that directly attempts to mediate the behavior of teardown upon invoking `--pdb`, particularly in `TestCaseFunction.runtest()`.\n- This file likely contains the necessary logic but may need adjustments to enforce the skip behavior stronger when `--pdb` is active.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "TestCaseFunction.runtest",
          "TestCaseFunction.teardown",
          "_make_xunit_fixture"
        ],
        "root_cause_symbols": [
          "TestCaseFunction.runtest"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:52.492498",
        "usage": "6027.477025985718 ms"
      },
      "request": {
        "file_path": "src/_pytest/debugging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is that when running tests using `--pdb` with pytest on a skipped test, the `tearDown` method is executed, causing an unexpected `NameError`.\n1.2 This issue was likely introduced between versions 5.4.1 and 5.4.2 of pytest, as mentioned by the user.\n1.3 The user expected the test to be skipped, even when using `--pdb`, and therefore not execute `tearDown`.\n1.4 The expected result is for skipped tests to have neither `setUp` nor `tearDown` executed when using `--pdb`.\n1.5 The issue could be fixed by modifying the logic in pytest to ensure `tearDown` is not called when a test is marked as skipped, even when `--pdb` is active.\n\n2. Make file evaluation:\n2.1 The file seems to define the way PDB interacts with pytest, including how it manages exceptions and enters the PDB post-mortem state.\n2.2 The `PdbInvoke` and `pytest_exception_interact` are particularly interesting as they deal with how pytest interacts with exceptions and enters PDB (which is likely when `tearDown` is mistakenly being called).\n2.3 `_enter_pdb` function is also related to the issue since it handles entering PDB after exceptions have been triggered.\n2.4 The function `wrap_pytest_function_for_tracing` could also be relevant if it changes how tests are called in relation with PDB tracing.\n2.5 The file doesn't directly reference test skipping, `setUp`, or `tearDown`, so the issue could lie in the integration point between pytest's test discovery/execution and its debugging capabilities.\n2.6 Thus the evaluation suggests the file is relevant but might not be the root cause as no direct interaction with `setUp` or `tearDown` is found.\n\n3. Output Your Decision:\n- The file is relevant to the issue because it defines how pytest manages debugging sessions.\n- However, the root cause is more likely to be in the part of the codebase that decides which parts of the test lifecycle to run when skipping tests.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config.py",
          "src/_pytest/skipping.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [
          "pytestPDB",
          "pytestPDB._init_pdb",
          "pytest_addoption",
          "PdbInvoke.pytest_exception_interact",
          "_enter_pdb"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:58.520010",
        "usage": "9850.07095336914 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "### Analyzing the Reported Issue\n\n**1. What issue is the user describing?**\nThe user is reporting that when using the `--pdb` flag with pytest version 5.4.2, the `tearDown()` method of the `unittest.TestCase` class is being executed for tests that are marked as skipped, which was not happening in pytest version 5.4.1.\n\n**2. How was this issue caused?**\nThe specific cause is not detailed in the issue description, but it occurs when pytest is invoked with the `--pdb` argument for debugging, leading to unexpected execution of `tearDown()` on skipped tests.\n\n**3. If the user described the expected result, what should it be fixed to? / 4. Expectation**\nThe expected behavior is that the `tearDown()` method should not be executed for skipped tests, even when the `--pdb` flag is used.\n\n**5. How should the issue be fixed to meet the expectation?**\nEnsure that the skipping logic is applied consistently, whether or not `--pdb` is used. The teardown should not be called for skipped tests.\n\n### Analyzing Provided File\n\n**File Path:** `src/_pytest/skipping.py`\n\n1. **Purpose:** This file is concerned with handling skip, xfail, and related markers in pytest.\n\n2. **Potentially Relevant Sections:**\n   - The `pytest_runtest_setup()` function uses the `skipped_by_mark_key` to determine if a test should be skipped. This might not be directly affecting teardown execution.\n   - Function `pytest_runtest_makereport()`: Modifies the test report outcomes based on skip and xfail conditions. It's plausible this might incorrectly signal the need for a teardown or interaction with `--pdb` mode.\n   \n3. **What We Might Be Looking for:**\n   - Evidence of `--pdb` handling or hooks that might lead to unexpected behavior if not configured to respect skipped states.\n   - Interaction points in the report/test status logic indicating how the skipped state is maintained throughout test execution phases.\n\n4. **Analyze if root cause:**\n   - While the file deals extensively with test states (e.g., skipped, xfailed), there's no direct reference to pdb or the finalization/teardown step that would indicate a certainty of being the root cause.\n\n### Conclusion\n**Relevance of Symbols Identified:**\n- `pytest_runtest_setup()` and `pytest_runtest_makereport()` are both relevant symbols since they influence test execution states and reporting around skips which might indirectly involve teardown logic or failing to halt expected execution paths.\n\n**Root cause determination:** Not enough information to conclude as the root cause solely from this file.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/debugging.py",
          "src/_pytest/unittest.py"
        ],
        "relevant_symbols": [
          "pytest_runtest_setup",
          "pytest_runtest_makereport"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:08.370107",
        "usage": "8970.378875732422 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n   1.1 The issue is that the `tearDown` method in `unittest.TestCase` is executed for skipped tests when running with `--pdb` option in pytest.\n   1.2 The issue seems to occur due to recent changes in pytest, as it worked correctly in version 5.4.1 but not in 5.4.2.\n   1.3/1.4 The expected behavior is for the `tearDown` method not to be executed if the test is skipped, even when using the `--pdb` option.\n   1.5 The issue should be fixed by ensuring that when a test is skipped, its `tearDown` method is not executed, regardless of the `--pdb` option.\n\n2. **Make file evaluation:**\n   2.1 Looking at the `src/_pytest/runner.py` content, especially focusing on the handling of `setup`, `call`, and `teardown` phases.\n   2.2 The `runtestprotocol` function appears relevant as it handles the `setup`, `call`, and `teardown` phases.\n   2.3 The `call_and_report` function is also relevant as it's involved in reporting and handling test results in these phases.\n   2.4 There is a specific check in `check_interactive_exception` for interactive exceptions like a skipped test when using pdb.\n   2.5 Additional related parts can include how `pytest_runtest_teardown` and `pytest_runtest_protocol` functions operate with pdb option.\n   2.6 Overall, these functions are crucial to managing the runtest lifecycle and thus can be the root cause of this issue.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "runtestprotocol",
          "call_and_report",
          "check_interactive_exception",
          "pytest_runtest_teardown",
          "runtestprotocol"
        ],
        "root_cause_symbols": [
          "runtestprotocol",
          "call_and_report",
          "check_interactive_exception",
          "runtestprotocol"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:17.340519",
        "usage": "7811.101198196411 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the issue:**\n   The issue reported is that when running unittest with pytest using the `--pdb` option, the `tearDown` method is being executed even for tests that are marked to be skipped. The expected behavior mentioned is that the `tearDown` should not execute on skipped tests, as confirmed in previous pytest versions (5.4.1).\n\n2. **Analyzing the provided file:**\n   The file presented is `_pytest/hookspec.py`, which defines various hook specifications for pytest plugins.\n   \n   - There are multiple hooks related to test execution such as `pytest_runtest_protocol`, `pytest_runtest_setup`, `pytest_runtest_call`, and `pytest_runtest_teardown`. Among them, `pytest_runtest_teardown` is the most relevant to the issue of `tearDown` being called.\n   - The hooks associated with pdb interaction are `pytest_enter_pdb` and `pytest_leave_pdb`. While these hooks mention interactions with pdb, they don't directly address conditions related to test skipping.\n\n3. **Relevance and Root Cause:**\n   - The hook `pytest_runtest_teardown` is directly relevant as it specifies the teardown process after test execution, which is where the unexpected behavior lies.\n   - Additionally, `pytest_exception_interact` may be relevant as it deals with handling exceptions which might occur when a `NameError` (as illustrated with `xxx` being undefined) is raised and interacts with pdb.\n   \n4. **Is the file causing the issue?**\n   This file alone is not likely to be the root cause; instead, it defines the hooks expected behavior. How these hooks are implemented in the hook implementations is more likely where the issue resides.\n\n5. **Conclusion:**\n   While `_pytest/hookspec.py` provides the scaffolding for test behavior, it doesn't cause the issue. It merely defines the specifications. We need to explore the implementations of these hooks in other parts of the codebase to identify potential pitfalls with handling skipped tests when `--pdb` is used.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/runtest.py",
          "src/_pytest/debugging.py"
        ],
        "relevant_symbols": [
          "pytest_runtest_teardown",
          "pytest_exception_interact",
          "pytest_enter_pdb",
          "pytest_leave_pdb"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:25.151681",
        "usage": "250.28514862060547 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/unittest.py",
            "relevant_symbol_keys": [
              "TestCaseFunction.runtest",
              "TestCaseFunction.teardown",
              "_make_xunit_fixture"
            ],
            "root_cause_symbol_keys": [
              "TestCaseFunction.runtest"
            ]
          },
          {
            "file_path": "src/_pytest/debugging.py",
            "relevant_symbol_keys": [
              "pytestPDB",
              "pytestPDB._init_pdb",
              "pytest_addoption",
              "PdbInvoke.pytest_exception_interact",
              "_enter_pdb"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [
              "pytest_runtest_setup",
              "pytest_runtest_makereport"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "runtestprotocol",
              "call_and_report",
              "check_interactive_exception",
              "pytest_runtest_teardown",
              "runtestprotocol"
            ],
            "root_cause_symbol_keys": [
              "runtestprotocol",
              "call_and_report",
              "check_interactive_exception",
              "runtestprotocol"
            ]
          },
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [
              "pytest_runtest_teardown",
              "pytest_exception_interact",
              "pytest_enter_pdb",
              "pytest_leave_pdb"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture",
            "start_line": 83,
            "start_column": 2910,
            "end_line": 0,
            "end_column": 3683,
            "start_byte": 2910,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "      )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n   ",
            "start_line": 20,
            "start_column": 497,
            "end_line": 0,
            "end_column": 1273,
            "start_byte": 497,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 384,
            "start_column": 14196,
            "end_line": 0,
            "end_column": 15963,
            "start_byte": 14196,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal",
            "start_line": 28,
            "start_column": 587,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 587,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 72,
            "start_column": 2052,
            "end_line": 0,
            "end_column": 8407,
            "start_byte": 2052,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB._pluginmanager",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_pluginmanager = None",
            "start_line": 75,
            "start_column": 2126,
            "end_line": 4,
            "end_column": 2147,
            "start_byte": 2126,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._config",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_config = None",
            "start_line": 76,
            "start_column": 2152,
            "end_line": 4,
            "end_column": 2166,
            "start_byte": 2152,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._saved",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_saved = []",
            "start_line": 77,
            "start_column": 2171,
            "end_line": 4,
            "end_column": 2182,
            "start_byte": 2171,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._recursive_debug",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_recursive_debug = 0",
            "start_line": 78,
            "start_column": 2201,
            "end_line": 4,
            "end_column": 2221,
            "start_byte": 2201,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._wrapped_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_wrapped_pdb_cls = None",
            "start_line": 79,
            "start_column": 2226,
            "end_line": 4,
            "end_column": 2249,
            "start_byte": 2226,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._is_capturing",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False",
            "start_line": 81,
            "start_column": 2255,
            "end_line": 4,
            "end_column": 2384,
            "start_byte": 2255,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._import_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls",
            "start_line": 87,
            "start_column": 2390,
            "end_line": 4,
            "end_column": 3628,
            "start_byte": 2390,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._get_pdb_wrapper_class",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper",
            "start_line": 126,
            "start_column": 3634,
            "end_line": 4,
            "end_column": 6672,
            "start_byte": 3634,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 208,
            "start_column": 6678,
            "end_line": 4,
            "end_column": 8139,
            "start_byte": 6678,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB.set_trace",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 248,
            "start_column": 8145,
            "end_line": 4,
            "end_column": 8407,
            "start_byte": 8145,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep",
            "start_line": 304,
            "start_column": 10146,
            "end_line": 0,
            "end_column": 11019,
            "start_byte": 10146,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "testPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                m",
            "start_line": 54,
            "start_column": 1486,
            "end_line": 0,
            "end_column": 2904,
            "start_byte": 1486,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "port hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueEr",
            "start_line": 12,
            "start_column": 157,
            "end_line": 0,
            "end_column": 374,
            "start_byte": 157,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "           import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 1202,
            "start_column": 45360,
            "end_line": 0,
            "end_column": 45548,
            "start_byte": 45360,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "rue\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n      ",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2499,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "nfig.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n         ",
            "start_line": 50,
            "start_column": 1425,
            "end_line": 0,
            "end_column": 3012,
            "start_byte": 1425,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 365,
            "start_column": 12037,
            "end_line": 0,
            "end_column": 13376,
            "start_byte": 12037,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)\n\n\nclass PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_",
            "start_line": 182,
            "start_column": 6378,
            "end_line": 0,
            "end_column": 8992,
            "start_byte": 6378,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "er on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._conti",
            "start_line": 40,
            "start_column": 989,
            "end_line": 0,
            "end_column": 5037,
            "start_byte": 989,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "fig = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                ",
            "start_line": 53,
            "start_column": 1694,
            "end_line": 0,
            "end_column": 3297,
            "start_byte": 1694,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "date_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption",
            "start_line": 12,
            "start_column": 231,
            "end_line": 0,
            "end_column": 559,
            "start_byte": 231,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "race\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n   ",
            "start_line": 55,
            "start_column": 1374,
            "end_line": 0,
            "end_column": 1985,
            "start_byte": 1374,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n     ",
            "start_line": 59,
            "start_column": 1875,
            "end_line": 0,
            "end_column": 3550,
            "start_byte": 1875,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ",\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef ",
            "start_line": 34,
            "start_column": 933,
            "end_line": 0,
            "end_column": 1244,
            "start_byte": 933,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the form",
            "start_line": 4,
            "start_column": 58,
            "end_line": 0,
            "end_column": 457,
            "start_byte": 58,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls opt",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modu",
            "start_line": 14,
            "start_column": 401,
            "end_line": 0,
            "end_column": 881,
            "start_byte": 401,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                       ",
            "start_line": 78,
            "start_column": 1896,
            "end_line": 0,
            "end_column": 4639,
            "start_byte": 1896,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ", pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n       ",
            "start_line": 51,
            "start_column": 1531,
            "end_line": 0,
            "end_column": 1989,
            "start_byte": 1531,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "onfig.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n      ",
            "start_line": 13,
            "start_column": 185,
            "end_line": 0,
            "end_column": 501,
            "start_byte": 185,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 245,
            "start_column": 8284,
            "end_line": 4,
            "end_column": 8425,
            "start_byte": 8284,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 378,
            "start_column": 12657,
            "end_line": 0,
            "end_column": 12745,
            "start_byte": 12657,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 13232,
            "end_line": 0,
            "end_column": 13535,
            "start_byte": 13232,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 649,
            "start_column": 23082,
            "end_line": 4,
            "end_column": 23306,
            "start_byte": 23082,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "alxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_s",
            "start_line": 125,
            "start_column": 3822,
            "end_line": 0,
            "end_column": 3940,
            "start_byte": 3822,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 284,
            "start_column": 8918,
            "end_line": 0,
            "end_column": 9013,
            "start_byte": 8918,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)",
            "start_line": 73,
            "start_column": 2452,
            "end_line": 0,
            "end_column": 3179,
            "start_byte": 2452,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 125,
            "start_column": 4192,
            "end_line": 0,
            "end_column": 6240,
            "start_byte": 4192,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 243,
            "start_column": 8721,
            "end_line": 0,
            "end_column": 9351,
            "start_byte": 8721,
            "end_byte": 0
          },
          {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "r\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n      ",
            "start_line": 6,
            "start_column": 136,
            "end_line": 0,
            "end_column": 548,
            "start_byte": 136,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "    duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n        )\n\n    def __repr__(self):\n        if",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc\n                raise exc\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e\n                raise e\n\n\ndef ",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished co",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test ite",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "e``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal an",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first n",
            "start_line": 104,
            "start_column": 3662,
            "end_line": 4,
            "end_column": 3920,
            "start_byte": 3662,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 675,
            "start_column": 22873,
            "end_line": 0,
            "end_column": 23146,
            "start_byte": 22873,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_leave_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 693,
            "start_column": 23441,
            "end_line": 0,
            "end_column": 23770,
            "start_byte": 23441,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for s",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 207,
            "start_column": 7152,
            "end_line": 4,
            "end_column": 8447,
            "start_byte": 7152,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 187,
            "start_column": 5534,
            "end_line": 0,
            "end_column": 5976,
            "start_byte": 5534,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 200,
            "start_column": 5979,
            "end_line": 0,
            "end_column": 6199,
            "start_byte": 5979,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:25.401972",
        "usage": "6949.781894683838 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture",
            "start_line": 83,
            "start_column": 2910,
            "end_line": 0,
            "end_column": 3683,
            "start_byte": 2910,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "      )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n   ",
            "start_line": 20,
            "start_column": 497,
            "end_line": 0,
            "end_column": 1273,
            "start_byte": 497,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 384,
            "start_column": 14196,
            "end_line": 0,
            "end_column": 15963,
            "start_byte": 14196,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal",
            "start_line": 28,
            "start_column": 587,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 587,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 72,
            "start_column": 2052,
            "end_line": 0,
            "end_column": 8407,
            "start_byte": 2052,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB._pluginmanager",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_pluginmanager = None",
            "start_line": 75,
            "start_column": 2126,
            "end_line": 4,
            "end_column": 2147,
            "start_byte": 2126,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._config",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_config = None",
            "start_line": 76,
            "start_column": 2152,
            "end_line": 4,
            "end_column": 2166,
            "start_byte": 2152,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._saved",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_saved = []",
            "start_line": 77,
            "start_column": 2171,
            "end_line": 4,
            "end_column": 2182,
            "start_byte": 2171,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._recursive_debug",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_recursive_debug = 0",
            "start_line": 78,
            "start_column": 2201,
            "end_line": 4,
            "end_column": 2221,
            "start_byte": 2201,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._wrapped_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_wrapped_pdb_cls = None",
            "start_line": 79,
            "start_column": 2226,
            "end_line": 4,
            "end_column": 2249,
            "start_byte": 2226,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._is_capturing",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False",
            "start_line": 81,
            "start_column": 2255,
            "end_line": 4,
            "end_column": 2384,
            "start_byte": 2255,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._import_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls",
            "start_line": 87,
            "start_column": 2390,
            "end_line": 4,
            "end_column": 3628,
            "start_byte": 2390,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._get_pdb_wrapper_class",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper",
            "start_line": 126,
            "start_column": 3634,
            "end_line": 4,
            "end_column": 6672,
            "start_byte": 3634,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 208,
            "start_column": 6678,
            "end_line": 4,
            "end_column": 8139,
            "start_byte": 6678,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytestPDB.set_trace",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 248,
            "start_column": 8145,
            "end_line": 4,
            "end_column": 8407,
            "start_byte": 8145,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep",
            "start_line": 304,
            "start_column": 10146,
            "end_line": 0,
            "end_column": 11019,
            "start_byte": 10146,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "testPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                m",
            "start_line": 54,
            "start_column": 1486,
            "end_line": 0,
            "end_column": 2904,
            "start_byte": 1486,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "port hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueEr",
            "start_line": 12,
            "start_column": 157,
            "end_line": 0,
            "end_column": 374,
            "start_byte": 157,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "           import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 1202,
            "start_column": 45360,
            "end_line": 0,
            "end_column": 45548,
            "start_byte": 45360,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "rue\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n      ",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2499,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "nfig.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n         ",
            "start_line": 50,
            "start_column": 1425,
            "end_line": 0,
            "end_column": 3012,
            "start_byte": 1425,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 365,
            "start_column": 12037,
            "end_line": 0,
            "end_column": 13376,
            "start_byte": 12037,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)\n\n\nclass PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_",
            "start_line": 182,
            "start_column": 6378,
            "end_line": 0,
            "end_column": 8992,
            "start_byte": 6378,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "er on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._conti",
            "start_line": 40,
            "start_column": 989,
            "end_line": 0,
            "end_column": 5037,
            "start_byte": 989,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "fig = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                ",
            "start_line": 53,
            "start_column": 1694,
            "end_line": 0,
            "end_column": 3297,
            "start_byte": 1694,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "date_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption",
            "start_line": 12,
            "start_column": 231,
            "end_line": 0,
            "end_column": 559,
            "start_byte": 231,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "race\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n   ",
            "start_line": 55,
            "start_column": 1374,
            "end_line": 0,
            "end_column": 1985,
            "start_byte": 1374,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n     ",
            "start_line": 59,
            "start_column": 1875,
            "end_line": 0,
            "end_column": 3550,
            "start_byte": 1875,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ",\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef ",
            "start_line": 34,
            "start_column": 933,
            "end_line": 0,
            "end_column": 1244,
            "start_byte": 933,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the form",
            "start_line": 4,
            "start_column": 58,
            "end_line": 0,
            "end_column": 457,
            "start_byte": 58,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls opt",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modu",
            "start_line": 14,
            "start_column": 401,
            "end_line": 0,
            "end_column": 881,
            "start_byte": 401,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                       ",
            "start_line": 78,
            "start_column": 1896,
            "end_line": 0,
            "end_column": 4639,
            "start_byte": 1896,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ", pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n       ",
            "start_line": 51,
            "start_column": 1531,
            "end_line": 0,
            "end_column": 1989,
            "start_byte": 1531,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "onfig.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n      ",
            "start_line": 13,
            "start_column": 185,
            "end_line": 0,
            "end_column": 501,
            "start_byte": 185,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 245,
            "start_column": 8284,
            "end_line": 4,
            "end_column": 8425,
            "start_byte": 8284,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 378,
            "start_column": 12657,
            "end_line": 0,
            "end_column": 12745,
            "start_byte": 12657,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 13232,
            "end_line": 0,
            "end_column": 13535,
            "start_byte": 13232,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 649,
            "start_column": 23082,
            "end_line": 4,
            "end_column": 23306,
            "start_byte": 23082,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "alxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_s",
            "start_line": 125,
            "start_column": 3822,
            "end_line": 0,
            "end_column": 3940,
            "start_byte": 3822,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 284,
            "start_column": 8918,
            "end_line": 0,
            "end_column": 9013,
            "start_byte": 8918,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)",
            "start_line": 73,
            "start_column": 2452,
            "end_line": 0,
            "end_column": 3179,
            "start_byte": 2452,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 125,
            "start_column": 4192,
            "end_line": 0,
            "end_column": 6240,
            "start_byte": 4192,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 243,
            "start_column": 8721,
            "end_line": 0,
            "end_column": 9351,
            "start_byte": 8721,
            "end_byte": 0
          },
          {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "r\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n      ",
            "start_line": 6,
            "start_column": 136,
            "end_line": 0,
            "end_column": 548,
            "start_byte": 136,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "    duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n        )\n\n    def __repr__(self):\n        if",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc\n                raise exc\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e\n                raise e\n\n\ndef ",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished co",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test ite",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "e``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal an",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first n",
            "start_line": 104,
            "start_column": 3662,
            "end_line": 4,
            "end_column": 3920,
            "start_byte": 3662,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 675,
            "start_column": 22873,
            "end_line": 0,
            "end_column": 23146,
            "start_byte": 22873,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_leave_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 693,
            "start_column": 23441,
            "end_line": 0,
            "end_column": 23770,
            "start_byte": 23441,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for s",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 207,
            "start_column": 7152,
            "end_line": 4,
            "end_column": 8447,
            "start_byte": 7152,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 187,
            "start_column": 5534,
            "end_line": 0,
            "end_column": 5976,
            "start_byte": 5534,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 200,
            "start_column": 5979,
            "end_line": 0,
            "end_column": 6199,
            "start_byte": 5979,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Issue: The main issue is that the `tearDown` method of a `unittest.TestCase` is being executed even when the test is skipped and the `--pdb` flag is used. \n2. Cause: This behavior was not present in version 5.4.1 and seems to have changed in version 5.4.2, implying that some modifications relating to how the `--pdb` option influences skipping of tests might have been introduced.\n3. Expected Result: The `tearDown` method should not run for tests that are specifically skipped, akin to the behavior seen without `--pdb` or in version 5.4.1.\n4. Fix: The likely fix involves altering the logic so that skipping works as expected even with `--pdb`. This may involve bypassing tearDown logic when a test is skipped and `--pdb` is used.",
        "symbols": [
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "reason": "The key logic around unittest and how tests are executed. Particularly, the area checking for the `usepdb` flag needs to adequately handle skipped tests without executing `tearDown`. One possible addition to the existing logic is to integrate a condition to skip `tearDown` for skipped tests, regardless of pdb usage."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "1. `_pytest.unittest.TestCaseFunction.runtest`\n- This function handles the running of unittest test cases. It has logic to postpone `tearDown` when `--pdb` is used to handle the case where variable cleanup might affect debugging.\n- The relevant code line in question is:\n  ```python\n  if self.config.getoption('usepdb'):\n  ```\n  which modifies the behavior of `tearDown` based on whether pdb should be used.\n- The issue here is that this logic also affects tests that are skipped. It should be adjusted to ensure that when a test is marked to be skipped, `tearDown` is not executed even if `--pdb` is used.\n- One potential adjustment would be to incorporate a check for skipped tests before making changes to `tearDown`."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:32.351784",
        "usage": "3.0498504638671875 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.unittest._make_xunit_fixture",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture",
              "start_line": 83,
              "start_column": 2910,
              "end_line": 0,
              "end_column": 3683,
              "start_byte": 2910,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.teardown",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None",
              "start_line": 122,
              "start_column": 4117,
              "end_line": 4,
              "end_column": 4320,
              "start_byte": 4117,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "      )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n   ",
              "start_line": 20,
              "start_column": 497,
              "end_line": 0,
              "end_column": 1273,
              "start_byte": 497,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "",
              "start_line": 384,
              "start_column": 14196,
              "end_line": 0,
              "end_column": 15963,
              "start_byte": 14196,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": ".getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal",
              "start_line": 28,
              "start_column": 587,
              "end_line": 0,
              "end_column": 1052,
              "start_byte": 587,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )",
              "start_line": 21,
              "start_column": 539,
              "end_line": 0,
              "end_column": 1237,
              "start_byte": 539,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytestPDB",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
              "start_line": 72,
              "start_column": 2052,
              "end_line": 0,
              "end_column": 8407,
              "start_byte": 2052,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytestPDB._pluginmanager",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "_pluginmanager = None",
              "start_line": 75,
              "start_column": 2126,
              "end_line": 4,
              "end_column": 2147,
              "start_byte": 2126,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._config",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "_config = None",
              "start_line": 76,
              "start_column": 2152,
              "end_line": 4,
              "end_column": 2166,
              "start_byte": 2152,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._saved",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "_saved = []",
              "start_line": 77,
              "start_column": 2171,
              "end_line": 4,
              "end_column": 2182,
              "start_byte": 2171,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._recursive_debug",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "_recursive_debug = 0",
              "start_line": 78,
              "start_column": 2201,
              "end_line": 4,
              "end_column": 2221,
              "start_byte": 2201,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._wrapped_pdb_cls",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "_wrapped_pdb_cls = None",
              "start_line": 79,
              "start_column": 2226,
              "end_line": 4,
              "end_column": 2249,
              "start_byte": 2226,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._is_capturing",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False",
              "start_line": 81,
              "start_column": 2255,
              "end_line": 4,
              "end_column": 2384,
              "start_byte": 2255,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._import_pdb_cls",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls",
              "start_line": 87,
              "start_column": 2390,
              "end_line": 4,
              "end_column": 3628,
              "start_byte": 2390,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._get_pdb_wrapper_class",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper",
              "start_line": 126,
              "start_column": 3634,
              "end_line": 4,
              "end_column": 6672,
              "start_byte": 3634,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB._init_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
              "start_line": 208,
              "start_column": 6678,
              "end_line": 4,
              "end_column": 8139,
              "start_byte": 6678,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.pytestPDB.set_trace",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
              "start_line": 248,
              "start_column": 8145,
              "end_line": 4,
              "end_column": 8407,
              "start_byte": 8145,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)",
              "start_line": 257,
              "start_column": 8431,
              "end_line": 4,
              "end_column": 8796,
              "start_byte": 8431,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging._enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "def _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep",
              "start_line": 304,
              "start_column": 10146,
              "end_line": 0,
              "end_column": 11019,
              "start_byte": 10146,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "testPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                m",
              "start_line": 54,
              "start_column": 1486,
              "end_line": 0,
              "end_column": 2904,
              "start_byte": 1486,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "port hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueEr",
              "start_line": 12,
              "start_column": 157,
              "end_line": 0,
              "end_column": 374,
              "start_byte": 157,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "           import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _",
              "start_line": 96,
              "start_column": 3425,
              "end_line": 4,
              "end_column": 3656,
              "start_byte": 3425,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "",
              "start_line": 1202,
              "start_column": 45360,
              "end_line": 0,
              "end_column": 45548,
              "start_byte": 45360,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "rue\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n      ",
              "start_line": 38,
              "start_column": 1168,
              "end_line": 0,
              "end_column": 2499,
              "start_byte": 1168,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "nfig.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n         ",
              "start_line": 50,
              "start_column": 1425,
              "end_line": 0,
              "end_column": 3012,
              "start_byte": 1425,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "",
              "start_line": 684,
              "start_column": 23149,
              "end_line": 0,
              "end_column": 23438,
              "start_byte": 23149,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "",
              "start_line": 365,
              "start_column": 12037,
              "end_line": 0,
              "end_column": 13376,
              "start_byte": 12037,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "  if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)\n\n\nclass PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_",
              "start_line": 182,
              "start_column": 6378,
              "end_line": 0,
              "end_column": 8992,
              "start_byte": 6378,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "er on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._conti",
              "start_line": 40,
              "start_column": 989,
              "end_line": 0,
              "end_column": 5037,
              "start_byte": 989,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "fig = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                ",
              "start_line": 53,
              "start_column": 1694,
              "end_line": 0,
              "end_column": 3297,
              "start_byte": 1694,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "date_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption",
              "start_line": 12,
              "start_column": 231,
              "end_line": 0,
              "end_column": 559,
              "start_byte": 231,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "race\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n   ",
              "start_line": 55,
              "start_column": 1374,
              "end_line": 0,
              "end_column": 1985,
              "start_byte": 1374,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n     ",
              "start_line": 59,
              "start_column": 1875,
              "end_line": 0,
              "end_column": 3550,
              "start_byte": 1875,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": ",\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef ",
              "start_line": 34,
              "start_column": 933,
              "end_line": 0,
              "end_column": 1244,
              "start_byte": 933,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the form",
              "start_line": 4,
              "start_column": 58,
              "end_line": 0,
              "end_column": 457,
              "start_byte": 58,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls opt",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 293,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": ".ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modu",
              "start_line": 14,
              "start_column": 401,
              "end_line": 0,
              "end_column": 881,
              "start_byte": 401,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 479,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "  pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                       ",
              "start_line": 78,
              "start_column": 1896,
              "end_line": 0,
              "end_column": 4639,
              "start_byte": 1896,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": ", pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n       ",
              "start_line": 51,
              "start_column": 1531,
              "end_line": 0,
              "end_column": 1989,
              "start_byte": 1531,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "onfig.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n      ",
              "start_line": 13,
              "start_column": 185,
              "end_line": 0,
              "end_column": 501,
              "start_byte": 185,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 245,
              "start_column": 8284,
              "end_line": 4,
              "end_column": 8425,
              "start_byte": 8284,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 378,
              "start_column": 12657,
              "end_line": 0,
              "end_column": 12745,
              "start_byte": 12657,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 396,
              "start_column": 13232,
              "end_line": 0,
              "end_column": 13535,
              "start_byte": 13232,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 649,
              "start_column": 23082,
              "end_line": 4,
              "end_column": 23306,
              "start_byte": 23082,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "alxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_s",
              "start_line": 125,
              "start_column": 3822,
              "end_line": 0,
              "end_column": 3940,
              "start_byte": 3822,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 284,
              "start_column": 8918,
              "end_line": 0,
              "end_column": 9013,
              "start_byte": 8918,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)",
              "start_line": 73,
              "start_column": 2452,
              "end_line": 0,
              "end_column": 3179,
              "start_byte": 2452,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason",
              "start_line": 125,
              "start_column": 4192,
              "end_line": 0,
              "end_column": 6240,
              "start_byte": 4192,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 243,
              "start_column": 8721,
              "end_line": 0,
              "end_column": 9351,
              "start_byte": 8721,
              "end_byte": 0
            },
            {
              "name": "_pytest.nose.pytest_runtest_setup",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "r\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n      ",
              "start_line": 6,
              "start_column": 136,
              "end_line": 0,
              "end_column": 548,
              "start_byte": 136,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "    duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n        )\n\n    def __repr__(self):\n        if",
              "start_line": 255,
              "start_column": 8576,
              "end_line": 4,
              "end_column": 8723,
              "start_byte": 8576,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc\n                raise exc\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e\n                raise e\n\n\ndef ",
              "start_line": 386,
              "start_column": 12830,
              "end_line": 0,
              "end_column": 13229,
              "start_byte": 12830,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 662,
              "start_column": 23491,
              "end_line": 4,
              "end_column": 23770,
              "start_byte": 23491,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)",
              "start_line": 150,
              "start_column": 4467,
              "end_line": 0,
              "end_column": 4659,
              "start_byte": 4467,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": " \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished co",
              "start_line": 255,
              "start_column": 8576,
              "end_line": 4,
              "end_column": 8723,
              "start_byte": 8576,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": ".local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test ite",
              "start_line": 257,
              "start_column": 8431,
              "end_line": 4,
              "end_column": 8796,
              "start_byte": 8431,
              "end_byte": 4
            },
            {
              "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "e``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal an",
              "start_line": 96,
              "start_column": 3425,
              "end_line": 4,
              "end_column": 3656,
              "start_byte": 3425,
              "end_byte": 4
            },
            {
              "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first n",
              "start_line": 104,
              "start_column": 3662,
              "end_line": 4,
              "end_column": 3920,
              "start_byte": 3662,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_teardown",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"",
              "start_line": 386,
              "start_column": 12830,
              "end_line": 0,
              "end_column": 13229,
              "start_byte": 12830,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"",
              "start_line": 675,
              "start_column": 22873,
              "end_line": 0,
              "end_column": 23146,
              "start_byte": 22873,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_enter_pdb",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
              "start_line": 684,
              "start_column": 23149,
              "end_line": 0,
              "end_column": 23438,
              "start_byte": 23149,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_leave_pdb",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
              "start_line": 693,
              "start_column": 23441,
              "end_line": 0,
              "end_column": 23770,
              "start_byte": 23441,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
              "start_line": 662,
              "start_column": 23491,
              "end_line": 4,
              "end_column": 23770,
              "start_byte": 23491,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_teardown",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": " removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for s",
              "start_line": 150,
              "start_column": 4467,
              "end_line": 0,
              "end_column": 4659,
              "start_byte": 4467,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)",
              "start_line": 207,
              "start_column": 7152,
              "end_line": 4,
              "end_column": 8447,
              "start_byte": 7152,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.runtestprotocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
              "start_line": 93,
              "start_column": 2710,
              "end_line": 0,
              "end_column": 3437,
              "start_byte": 2710,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 187,
              "start_column": 5534,
              "end_line": 0,
              "end_column": 5976,
              "start_byte": 5534,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.check_interactive_exception",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
              "start_line": 200,
              "start_column": 5979,
              "end_line": 0,
              "end_column": 6199,
              "start_byte": 5979,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Issue: The main issue is that the `tearDown` method of a `unittest.TestCase` is being executed even when the test is skipped and the `--pdb` flag is used. \n2. Cause: This behavior was not present in version 5.4.1 and seems to have changed in version 5.4.2, implying that some modifications relating to how the `--pdb` option influences skipping of tests might have been introduced.\n3. Expected Result: The `tearDown` method should not run for tests that are specifically skipped, akin to the behavior seen without `--pdb` or in version 5.4.1.\n4. Fix: The likely fix involves altering the logic so that skipping works as expected even with `--pdb`. This may involve bypassing tearDown logic when a test is skipped and `--pdb` is used.",
          "symbols": [
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/unittest.py",
              "reason": "The key logic around unittest and how tests are executed. Particularly, the area checking for the `usepdb` flag needs to adequately handle skipped tests without executing `tearDown`. One possible addition to the existing logic is to integrate a condition to skip `tearDown` for skipped tests, regardless of pdb usage."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "1. `_pytest.unittest.TestCaseFunction.runtest`\n- This function handles the running of unittest test cases. It has logic to postpone `tearDown` when `--pdb` is used to handle the case where variable cleanup might affect debugging.\n- The relevant code line in question is:\n  ```python\n  if self.config.getoption('usepdb'):\n  ```\n  which modifies the behavior of `tearDown` based on whether pdb should be used.\n- The issue here is that this logic also affects tests that are skipped. It should be adjusted to ensure that when a test is marked to be skipped, `tearDown` is not executed even if `--pdb` is used.\n- One potential adjustment would be to incorporate a check for skipped tests before making changes to `tearDown`."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/unittest.py"
        ],
        "symbols": [
          "_pytest.unittest.TestCaseFunction.runtest"
        ],
        "code_spans": {
          "_pytest.unittest._make_xunit_fixture": {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(obj, setup_name, teardown_name, scope, pass_self):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    @pytest.fixture(scope=scope, autouse=True)\n    def fixture(self, request):\n        if getattr(self, \"__unittest_skip__\", None):\n            reason = self.__unittest_skip_why__\n            pytest.skip(reason)\n        if setup is not None:\n            if pass_self:\n                setup(self, request.function)\n            else:\n                setup()\n        yield\n        if teardown is not None:\n            if pass_self:\n                teardown(self, request.function)\n            else:\n                teardown()\n\n    return fixture",
            "start_line": 83,
            "start_column": 2910,
            "end_line": 0,
            "end_column": 3683,
            "start_byte": 2910,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def teardown(self):\n        if self._explicit_tearDown is not None:\n            self._explicit_tearDown()\n            self._explicit_tearDown = None\n        self._testcase = None\n        self._obj = None",
            "start_line": 122,
            "start_column": 4117,
            "end_line": 4,
            "end_column": 4320,
            "start_byte": 4117,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "      )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n   ",
            "start_line": 20,
            "start_column": 497,
            "end_line": 0,
            "end_column": 1273,
            "start_byte": 497,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 384,
            "start_column": 14196,
            "end_line": 0,
            "end_column": 15963,
            "start_byte": 14196,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal",
            "start_line": 28,
            "start_column": 587,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 587,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modulename:classname\",\n        type=_validate_usepdb_cls,\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          "_pytest.debugging.pytestPDB": {
            "name": "_pytest.debugging.pytestPDB",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "class pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 72,
            "start_column": 2052,
            "end_line": 0,
            "end_column": 8407,
            "start_byte": 2052,
            "end_byte": 0
          },
          "_pytest.debugging.pytestPDB._pluginmanager": {
            "name": "_pytest.debugging.pytestPDB._pluginmanager",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_pluginmanager = None",
            "start_line": 75,
            "start_column": 2126,
            "end_line": 4,
            "end_column": 2147,
            "start_byte": 2126,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._config": {
            "name": "_pytest.debugging.pytestPDB._config",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_config = None",
            "start_line": 76,
            "start_column": 2152,
            "end_line": 4,
            "end_column": 2166,
            "start_byte": 2152,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._saved": {
            "name": "_pytest.debugging.pytestPDB._saved",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_saved = []",
            "start_line": 77,
            "start_column": 2171,
            "end_line": 4,
            "end_column": 2182,
            "start_byte": 2171,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._recursive_debug": {
            "name": "_pytest.debugging.pytestPDB._recursive_debug",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_recursive_debug = 0",
            "start_line": 78,
            "start_column": 2201,
            "end_line": 4,
            "end_column": 2221,
            "start_byte": 2201,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._wrapped_pdb_cls": {
            "name": "_pytest.debugging.pytestPDB._wrapped_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "_wrapped_pdb_cls = None",
            "start_line": 79,
            "start_column": 2226,
            "end_line": 4,
            "end_column": 2249,
            "start_byte": 2226,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._is_capturing": {
            "name": "_pytest.debugging.pytestPDB._is_capturing",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False",
            "start_line": 81,
            "start_column": 2255,
            "end_line": 4,
            "end_column": 2384,
            "start_byte": 2255,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._import_pdb_cls": {
            "name": "_pytest.debugging.pytestPDB._import_pdb_cls",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls",
            "start_line": 87,
            "start_column": 2390,
            "end_line": 4,
            "end_column": 3628,
            "start_byte": 2390,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._get_pdb_wrapper_class": {
            "name": "_pytest.debugging.pytestPDB._get_pdb_wrapper_class",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._continued = True\n                return ret\n\n            do_c = do_cont = do_continue\n\n            def do_quit(self, arg):\n                \"\"\"Raise Exit outcome when quit command is used in pdb.\n\n                This is a bit of a hack - it would be better if BdbQuit\n                could be handled, but this would require to wrap the\n                whole pytest run, and adjust the report etc.\n                \"\"\"\n                ret = super().do_quit(arg)\n\n                if cls._recursive_debug == 0:\n                    outcomes.exit(\"Quitting debugger\")\n\n                return ret\n\n            do_q = do_quit\n            do_exit = do_quit\n\n            def setup(self, f, tb):\n                \"\"\"Suspend on setup().\n\n                Needed after do_continue resumed, and entering another\n                breakpoint again.\n                \"\"\"\n                ret = super().setup(f, tb)\n                if not ret and self._continued:\n                    # pdb.setup() returns True if the command wants to exit\n                    # from the interaction: do not suspend capturing then.\n                    if self._pytest_capman:\n                        self._pytest_capman.suspend_global_capture(in_=True)\n                return ret\n\n            def get_stack(self, f, t):\n                stack, i = super().get_stack(f, t)\n                if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper",
            "start_line": 126,
            "start_column": 3634,
            "end_line": 4,
            "end_column": 6672,
            "start_byte": 3634,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB._init_pdb": {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 208,
            "start_column": 6678,
            "end_line": 4,
            "end_column": 8139,
            "start_byte": 6678,
            "end_byte": 4
          },
          "_pytest.debugging.pytestPDB.set_trace": {
            "name": "_pytest.debugging.pytestPDB.set_trace",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)",
            "start_line": 248,
            "start_column": 8145,
            "end_line": 4,
            "end_column": 8407,
            "start_byte": 8145,
            "end_byte": 4
          },
          "_pytest.debugging.PdbInvoke.pytest_exception_interact": {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test ite",
            "start_line": 257,
            "start_column": 8431,
            "end_line": 4,
            "end_column": 8796,
            "start_byte": 8431,
            "end_byte": 4
          },
          "_pytest.debugging._enter_pdb": {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(node, excinfo, rep):\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True\n    post_mortem(tb)\n    return rep",
            "start_line": 304,
            "start_column": 10146,
            "end_line": 0,
            "end_column": 11019,
            "start_byte": 10146,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "testPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                m",
            "start_line": 54,
            "start_column": 1486,
            "end_line": 0,
            "end_column": 2904,
            "start_byte": 1486,
            "end_byte": 0
          },
          "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "port hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueEr",
            "start_line": 12,
            "start_column": 157,
            "end_line": 0,
            "end_column": 374,
            "start_byte": 157,
            "end_byte": 0
          },
          "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "e``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal an",
            "start_line": 96,
            "start_column": 3425,
            "end_line": 4,
            "end_column": 3656,
            "start_byte": 3425,
            "end_byte": 4
          },
          "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 1202,
            "start_column": 45360,
            "end_line": 0,
            "end_column": 45548,
            "start_byte": 45360,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "rue\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n      ",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2499,
            "start_byte": 1168,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "nfig.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n         ",
            "start_line": 50,
            "start_column": 1425,
            "end_line": 0,
            "end_column": 3012,
            "start_byte": 1425,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_enter_pdb": {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 684,
            "start_column": 23149,
            "end_line": 0,
            "end_column": 23438,
            "start_byte": 23149,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 365,
            "start_column": 12037,
            "end_line": 0,
            "end_column": 13376,
            "start_byte": 12037,
            "end_byte": 0
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  if f is None:\n                    # Find last non-hidden frame.\n                    i = max(0, len(stack) - 1)\n                    while i and stack[i][0].f_locals.get(\"__tracebackhide__\", False):\n                        i -= 1\n                return stack, i\n\n        return PytestPdbWrapper\n\n    @classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\" Initialize PDB debugging, dropping any IO capturing. \"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is not None:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        else:\n            capman = None\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", \"PDB {} (IO-capturing turned off)\".format(method))\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", \"PDB {}\".format(method))\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb\n\n    @classmethod\n    def set_trace(cls, *args, **kwargs):\n        \"\"\"Invoke debugging via ``Pdb.set_trace``, dropping any IO capturing.\"\"\"\n        frame = sys._getframe().f_back\n        _pdb = cls._init_pdb(\"set_trace\", *args, **kwargs)\n        _pdb.set_trace(frame)\n\n\nclass PdbInvoke:\n    def pytest_exception_interact(self, node, call, report):\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        _enter_pdb(node, call.excinfo, report)\n\n    def pytest_internalerror(self, excrepr, excinfo):\n        tb = _postmortem_traceback(excinfo)\n        post_mortem(tb)\n\n\nclass PdbTrace:\n    @hookimpl(hookwrapper=True)\n    def pytest_pyfunc_",
            "start_line": 182,
            "start_column": 6378,
            "end_line": 0,
            "end_column": 8992,
            "start_byte": 6378,
            "end_byte": 0
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "er on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef pytest_configure(config):\n    import pdb\n\n    if config.getvalue(\"trace\"):\n        config.pluginmanager.register(PdbTrace(), \"pdbtrace\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                                \">\",\n                                \"PDB continue (IO-capturing resumed for %s)\"\n                                % capturing,\n                            )\n                        capman.resume()\n                    else:\n                        tw.sep(\">\", \"PDB continue\")\n                cls._pluginmanager.hook.pytest_leave_pdb(config=cls._config, pdb=self)\n                self._conti",
            "start_line": 40,
            "start_column": 989,
            "end_line": 0,
            "end_column": 5037,
            "start_byte": 989,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "fig = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                ",
            "start_line": 53,
            "start_column": 1694,
            "end_line": 0,
            "end_column": 3297,
            "start_byte": 1694,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "date_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption",
            "start_line": 12,
            "start_column": 231,
            "end_line": 0,
            "end_column": 559,
            "start_byte": 231,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "race\")\n    if config.getvalue(\"usepdb\"):\n        config.pluginmanager.register(PdbInvoke(), \"pdbinvoke\")\n\n    pytestPDB._saved.append(\n        (pdb.set_trace, pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n   ",
            "start_line": 55,
            "start_column": 1374,
            "end_line": 0,
            "end_column": 1985,
            "start_byte": 1374,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n     ",
            "start_line": 59,
            "start_column": 1875,
            "end_line": 0,
            "end_column": 3550,
            "start_byte": 1875,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ",\n        help=\"start a custom interactive Python debugger on errors. \"\n        \"For example: --pdbcls=IPython.terminal.debugger:TerminalPdb\",\n    )\n    group._addoption(\n        \"--trace\",\n        dest=\"trace\",\n        action=\"store_true\",\n        help=\"Immediately break when running each test.\",\n    )\n\n\ndef ",
            "start_line": 34,
            "start_column": 933,
            "end_line": 0,
            "end_column": 1244,
            "start_byte": 933,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the form",
            "start_line": 4,
            "start_column": 58,
            "end_line": 0,
            "end_column": 457,
            "start_byte": 58,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls opt",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ".ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n        )\n    return (modname, classname)\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"--pdb\",\n        dest=\"usepdb\",\n        action=\"store_true\",\n        help=\"start the interactive Python debugger on errors or KeyboardInterrupt.\",\n    )\n    group._addoption(\n        \"--pdbcls\",\n        dest=\"usepdb_cls\",\n        metavar=\"modu",
            "start_line": 14,
            "start_column": 401,
            "end_line": 0,
            "end_column": 881,
            "start_byte": 401,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "debugging with PDB, the Python Debugger. \"\"\"\nimport argparse\nimport functools\nimport sys\n\nfrom _pytest import outcomes\nfrom _pytest.config import hookimpl\nfrom _pytest.config.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "  pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n        ) = pytestPDB._saved.pop()\n\n    config._cleanup.append(fin)\n\n\nclass pytestPDB:\n    \"\"\" Pseudo PDB that defers to the real pdb. \"\"\"\n\n    _pluginmanager = None\n    _config = None\n    _saved = []  # type: list\n    _recursive_debug = 0\n    _wrapped_pdb_cls = None\n\n    @classmethod\n    def _is_capturing(cls, capman):\n        if capman:\n            return capman.is_capturing()\n        return False\n\n    @classmethod\n    def _import_pdb_cls(cls, capman):\n        if not cls._config:\n            import pdb\n\n            # Happens when using pytest.set_trace outside of a test.\n            return pdb.Pdb\n\n        usepdb_cls = cls._config.getvalue(\"usepdb_cls\")\n\n        if cls._wrapped_pdb_cls and cls._wrapped_pdb_cls[0] == usepdb_cls:\n            return cls._wrapped_pdb_cls[1]\n\n        if usepdb_cls:\n            modname, classname = usepdb_cls\n\n            try:\n                __import__(modname)\n                mod = sys.modules[modname]\n\n                # Handle --pdbcls=pdb:pdb.Pdb (useful e.g. with pdbpp).\n                parts = classname.split(\".\")\n                pdb_cls = getattr(mod, parts[0])\n                for part in parts[1:]:\n                    pdb_cls = getattr(pdb_cls, part)\n            except Exception as exc:\n                value = \":\".join((modname, classname))\n                raise UsageError(\n                    \"--pdbcls: could not import {!r}: {}\".format(value, exc)\n                )\n        else:\n            import pdb\n\n            pdb_cls = pdb.Pdb\n\n        wrapped_cls = cls._get_pdb_wrapper_class(pdb_cls, capman)\n        cls._wrapped_pdb_cls = (usepdb_cls, wrapped_cls)\n        return wrapped_cls\n\n    @classmethod\n    def _get_pdb_wrapper_class(cls, pdb_cls, capman):\n        import _pytest.config\n\n        class PytestPdbWrapper(pdb_cls):\n            _pytest_capman = capman\n            _continued = False\n\n            def do_debug(self, arg):\n                cls._recursive_debug += 1\n                ret = super().do_debug(arg)\n                cls._recursive_debug -= 1\n                return ret\n\n            def do_continue(self, arg):\n                ret = super().do_continue(arg)\n                if cls._recursive_debug == 0:\n                    tw = _pytest.config.create_terminal_writer(cls._config)\n                    tw.line()\n\n                    capman = self._pytest_capman\n                    capturing = pytestPDB._is_capturing(capman)\n                    if capturing:\n                        if capturing == \"global\":\n                            tw.sep(\">\", \"PDB continue (IO-capturing resumed)\")\n                        else:\n                            tw.sep(\n                       ",
            "start_line": 78,
            "start_column": 1896,
            "end_line": 0,
            "end_column": 4639,
            "start_byte": 1896,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": ", pytestPDB._pluginmanager, pytestPDB._config)\n    )\n    pdb.set_trace = pytestPDB.set_trace\n    pytestPDB._pluginmanager = config.pluginmanager\n    pytestPDB._config = config\n\n    # NOTE: not using pytest_unconfigure, since it might get called although\n    #       pytest_configure was not (if another plugin raises UsageError).\n    def fin():\n        (\n            pdb.set_trace,\n            pytestPDB._pluginmanager,\n            pytestPDB._config,\n       ",
            "start_line": 51,
            "start_column": 1531,
            "end_line": 0,
            "end_column": 1989,
            "start_byte": 1531,
            "end_byte": 0
          },
          "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "onfig.exceptions import UsageError\n\n\ndef _validate_usepdb_cls(value):\n    \"\"\"Validate syntax of --pdbcls option.\"\"\"\n    try:\n        modname, classname = value.split(\":\")\n    except ValueError:\n        raise argparse.ArgumentTypeError(\n            \"{!r} is not in the format 'modname:classname'\".format(value)\n      ",
            "start_line": 13,
            "start_column": 185,
            "end_line": 0,
            "end_column": 501,
            "start_byte": 185,
            "end_byte": 0
          },
          "_pytest.capture.CaptureManager.pytest_runtest_setup": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 245,
            "start_column": 8284,
            "end_line": 4,
            "end_column": 8425,
            "start_byte": 8284,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_setup": {
            "name": "_pytest.hookspec.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 378,
            "start_column": 12657,
            "end_line": 0,
            "end_column": 12745,
            "start_byte": 12657,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 13232,
            "end_line": 0,
            "end_column": 13535,
            "start_byte": 13232,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_setup": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 649,
            "start_column": 23082,
            "end_line": 4,
            "end_column": 23306,
            "start_byte": 23082,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_setup": {
            "name": "_pytest.runner.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "alxfail_key]\n    if evalxfail.istrue():\n        strict_default = pyfuncitem.config.getini(\"xfail_strict\")\n        is_s",
            "start_line": 125,
            "start_column": 3822,
            "end_line": 0,
            "end_column": 3940,
            "start_byte": 3822,
            "end_byte": 0
          },
          "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 284,
            "start_column": 8918,
            "end_line": 0,
            "end_column": 9013,
            "start_byte": 8918,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_setup": {
            "name": "_pytest.skipping.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(tryfirst=True)\ndef pytest_runtest_setup(item):\n    # Check if skip or skipif are specified as pytest marks\n    item._store[skipped_by_mark_key] = False\n    eval_skipif = MarkEvaluator(item, \"skipif\")\n    if eval_skipif.istrue():\n        item._store[skipped_by_mark_key] = True\n        skip(eval_skipif.getexplanation())\n\n    for skip_info in item.iter_markers(name=\"skip\"):\n        item._store[skipped_by_mark_key] = True\n        if \"reason\" in skip_info.kwargs:\n            skip(skip_info.kwargs[\"reason\"])\n        elif skip_info.args:\n            skip(skip_info.args[0])\n        else:\n            skip(\"unconditional skip\")\n\n    item._store[evalxfail_key] = MarkEvaluator(item, \"xfail\")\n    check_xfail_no_run(item)",
            "start_line": 73,
            "start_column": 2452,
            "end_line": 0,
            "end_column": 3179,
            "start_byte": 2452,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item, call):\n    outcome = yield\n    rep = outcome.get_result()\n    evalxfail = item._store.get(evalxfail_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and call.excinfo.errisinstance(xfail.Exception):\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif evalxfail and not rep.skipped and evalxfail.wasvalid() and evalxfail.istrue():\n        if call.excinfo:\n            if evalxfail.invalidraise(call.excinfo.value):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = evalxfail.getexplanation()\n        elif call.when == \"call\":\n            strict_default = item.config.getini(\"xfail_strict\")\n            is_strict_xfail = evalxfail.get(\"strict\", strict_default)\n            explanation = evalxfail.getexplanation()\n            if is_strict_xfail:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] {}\".format(explanation)\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = explanation\n    elif (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 125,
            "start_column": 4192,
            "end_line": 0,
            "end_column": 6240,
            "start_byte": 4192,
            "end_byte": 0
          },
          "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 243,
            "start_column": 8721,
            "end_line": 0,
            "end_column": 9351,
            "start_byte": 8721,
            "end_byte": 0
          },
          "_pytest.nose.pytest_runtest_setup": {
            "name": "_pytest.nose.pytest_runtest_setup",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "r\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import skip\nfrom _pytest.outcomes import xfail\nfrom _pytest.store import StoreKey\n\n\nskipped_by_mark_key = StoreKey[bool]()\nevalxfail_key = StoreKey[MarkEvaluator]()\nunexpectedsuccess_key = StoreKey[str]()\n\n\ndef pytest_addoption(parser):\n    group = parser.getgroup(\"general\")\n    group.addoption(\n        \"--runxfail\",\n        action=\"store_true\",\n      ",
            "start_line": 6,
            "start_column": 136,
            "end_line": 0,
            "end_column": 548,
            "start_byte": 136,
            "end_byte": 0
          },
          "_pytest.capture.CaptureManager.pytest_runtest_teardown": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished co",
            "start_line": 255,
            "start_column": 8576,
            "end_line": 4,
            "end_column": 8723,
            "start_byte": 8576,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_teardown": {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"",
            "start_line": 386,
            "start_column": 12830,
            "end_line": 0,
            "end_column": 13229,
            "start_byte": 12830,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_teardown": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 662,
            "start_column": 23491,
            "end_line": 4,
            "end_column": 23770,
            "start_byte": 23491,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_teardown": {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for s",
            "start_line": 150,
            "start_column": 4467,
            "end_line": 0,
            "end_column": 4659,
            "start_byte": 4467,
            "end_byte": 0
          },
          "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first n",
            "start_line": 104,
            "start_column": 3662,
            "end_line": 4,
            "end_column": 3920,
            "start_byte": 3662,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_exception_interact": {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 675,
            "start_column": 22873,
            "end_line": 0,
            "end_column": 23146,
            "start_byte": 22873,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_leave_pdb": {
            "name": "_pytest.hookspec.pytest_leave_pdb",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_leave_pdb(config, pdb):\n    \"\"\" called when leaving pdb (e.g. with continue after pdb.set_trace()).\n\n    Can be used by plugins to take special action just after the python\n    debugger leaves interactive mode.\n\n    :param _pytest.config.Config config: pytest config object\n    :param pdb.Pdb pdb: Pdb instance\n    \"\"\"",
            "start_line": 693,
            "start_column": 23441,
            "end_line": 0,
            "end_column": 23770,
            "start_byte": 23441,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self):\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # let the unittest framework handle async functions\n        if is_async_function(self.obj):\n            self._testcase(self)\n        else:\n            # when --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug\n            # arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed\n            if self.config.getoption(\"usepdb\"):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # we need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 207,
            "start_column": 7152,
            "end_line": 4,
            "end_column": 8447,
            "start_byte": 7152,
            "end_byte": 4
          },
          "_pytest.runner.runtestprotocol": {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 187,
            "start_column": 5534,
            "end_line": 0,
            "end_column": 5976,
            "start_byte": 5534,
            "end_byte": 0
          },
          "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 200,
            "start_column": 5979,
            "end_line": 0,
            "end_column": 6199,
            "start_byte": 5979,
            "end_byte": 0
          }
        }
      }
    }
  ]
}