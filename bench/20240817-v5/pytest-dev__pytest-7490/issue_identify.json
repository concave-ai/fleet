{
    "file_paths": [
        "src/_pytest/nodes.py",
        "src/_pytest/mark/structures.py",
        "src/_pytest/skipping.py"
    ],
    "symbols": [
        "_pytest.nodes.Node.add_marker",
        "_pytest.mark.MarkDecorator",
        "_pytest.mark.MarkGenerator",
        "_pytest.skipping.evaluate_xfail_marks",
        "_pytest.skipping.pytest_runtest_makereport"
    ],
    "code_spans": {
        "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
        },
        "_pytest.mark.store_mark": {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
        },
        "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 289,
            "start_column": 10558,
            "end_line": 4,
            "end_column": 12796,
            "start_byte": 10558,
            "end_byte": 4
        },
        "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 361,
            "start_column": 13534,
            "end_line": 4,
            "end_column": 14397,
            "start_byte": 13534,
            "end_byte": 4
        },
        "_pytest.cacheprovider.pytest_configure": {
            "name": "_pytest.cacheprovider.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16918,
            "end_line": 0,
            "end_column": 17167,
            "start_byte": 16918,
            "end_byte": 0
        },
        "_pytest.config.PytestPluginManager.pytest_configure": {
            "name": "_pytest.config.PytestPluginManager.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 442,
            "start_column": 13883,
            "end_line": 4,
            "end_column": 14533,
            "start_byte": 13883,
            "end_byte": 4
        },
        "_pytest.debugging.pytest_configure": {
            "name": "_pytest.debugging.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "f marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches ",
            "start_line": 61,
            "start_column": 1816,
            "end_line": 0,
            "end_column": 2649,
            "start_byte": 1816,
            "end_byte": 0
        },
        "_pytest.faulthandler.pytest_configure": {
            "name": "_pytest.faulthandler.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "from .structures import ParameterSet\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n          ",
            "start_line": 24,
            "start_column": 532,
            "end_line": 0,
            "end_column": 1486,
            "start_byte": 532,
            "end_byte": 0
        },
        "_pytest.faulthandler.FaultHandlerHooks.pytest_configure": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSe",
            "start_line": 52,
            "start_column": 1666,
            "end_line": 4,
            "end_column": 1955,
            "start_byte": 1666,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
        },
        "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 1613,
            "start_column": 62458,
            "end_line": 4,
            "end_column": 62612,
            "start_byte": 62458,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_configure": {
            "name": "_pytest.hookspec.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "line()\n        config._ensure_unconfigure()\n        return 0\n\n    return None\n\n\n@attr.s(slots=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_key",
            "start_line": 117,
            "start_column": 4131,
            "end_line": 0,
            "end_column": 4632,
            "start_byte": 4131,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_collection_modifyitems": {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": ", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)\n\n\ndef pytest_configure(config: Config) -> None:\n    config._store[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageEr",
            "start_line": 231,
            "start_column": 8250,
            "end_line": 0,
            "end_column": 8658,
            "start_byte": 8250,
            "end_byte": 0
        },
        "_pytest.junitxml.pytest_configure": {
            "name": "_pytest.junitxml.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 439,
            "start_column": 15188,
            "end_line": 0,
            "end_column": 15980,
            "start_byte": 15188,
            "end_byte": 0
        },
        "_pytest.logging.pytest_configure": {
            "name": "_pytest.logging.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 501,
            "start_column": 17763,
            "end_line": 0,
            "end_column": 17914,
            "start_byte": 17763,
            "end_byte": 0
        },
        "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 372,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12584,
            "start_byte": 12071,
            "end_byte": 0
        },
        "_pytest.mark.MarkMatcher": {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
        },
        "_pytest.mark.MarkMatcher.own_mark_names": {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": " Mark.\n\n        Combines b",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
        },
        "_pytest.mark.MarkMatcher.from_item": {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
        },
        "_pytest.mark.MarkMatcher.__call__": {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
        },
        "_pytest.mark.deselect_by_mark": {
            "name": "_pytest.mark.deselect_by_mark",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    try:\n        expression = Expression.compile(matchexpr)\n    except ParseError as e:\n        raise UsageError(\n            \"Wrong expression passed to '-m': {}: {}\".format(matchexpr, e)\n        ) from None\n\n    remaining = []\n    deselected = []\n    for item in items:\n        if expression.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 232,
            "start_column": 7528,
            "end_line": 0,
            "end_column": 8194,
            "start_byte": 7528,
            "end_byte": 0
        },
        "_pytest.mark.pytest_collection_modifyitems": {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
            "start_line": 257,
            "start_column": 8197,
            "end_line": 0,
            "end_column": 8351,
            "start_byte": 8197,
            "end_byte": 0
        },
        "_pytest.mark.pytest_configure": {
            "name": "_pytest.mark.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_configure(config: Config) -> None:\n    config._store[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            \"{!s} must be one of skip, xfail or fail_at_collect\"\n            \" but it is {!r}\".format(EMPTY_PARAMETERSET_OPTION, empty_parameterset)\n        )",
            "start_line": 262,
            "start_column": 8354,
            "end_line": 0,
            "end_column": 8821,
            "start_byte": 8354,
            "end_byte": 0
        },
        "_pytest.mark.Mark": {
            "name": "_pytest.mark.Mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 195,
            "start_column": 6452,
            "end_line": 0,
            "end_column": 7948,
            "start_byte": 6452,
            "end_byte": 0
        },
        "_pytest.mark.Mark.name": {
            "name": "_pytest.mark.Mark.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "name = attr.ib(type=str)",
            "start_line": 198,
            "start_column": 6514,
            "end_line": 4,
            "end_column": 6538,
            "start_byte": 6514,
            "end_byte": 4
        },
        "_pytest.mark.Mark.args": {
            "name": "_pytest.mark.Mark.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "args = attr.ib(type=Tuple[Any, ...])",
            "start_line": 200,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6630,
            "start_byte": 6594,
            "end_byte": 4
        },
        "_pytest.mark.Mark.kwargs": {
            "name": "_pytest.mark.Mark.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
            "start_line": 202,
            "start_column": 6683,
            "end_line": 4,
            "end_column": 6723,
            "start_byte": 6683,
            "end_byte": 4
        },
        "_pytest.mark.Mark._param_ids_from": {
            "name": "_pytest.mark.Mark._param_ids_from",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
            "start_line": 205,
            "start_column": 6780,
            "end_line": 4,
            "end_column": 6854,
            "start_byte": 6780,
            "end_byte": 4
        },
        "_pytest.mark.Mark._param_ids_generated": {
            "name": "_pytest.mark.Mark._param_ids_generated",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
            "start_line": 207,
            "start_column": 6913,
            "end_line": 4,
            "end_column": 7013,
            "start_byte": 6913,
            "end_byte": 4
        },
        "_pytest.mark.Mark._has_param_ids": {
            "name": "_pytest.mark.Mark._has_param_ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
            "start_line": 211,
            "start_column": 7019,
            "end_line": 4,
            "end_column": 7111,
            "start_byte": 7019,
            "end_byte": 4
        },
        "_pytest.mark.Mark.combined_with": {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 214,
            "start_column": 7117,
            "end_line": 4,
            "end_column": 7948,
            "start_byte": 7117,
            "end_byte": 4
        },
        "_pytest.mark._Markable": {
            "name": "_pytest.mark._Markable",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
            "start_line": 245,
            "start_column": 8132,
            "end_line": 0,
            "end_column": 8206,
            "start_byte": 8132,
            "end_byte": 0
        },
        "_pytest.mark.MarkDecorator": {
            "name": "_pytest.mark.MarkDecorator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 248,
            "start_column": 8209,
            "end_line": 0,
            "end_column": 11549,
            "start_byte": 8209,
            "end_byte": 0
        },
        "_pytest.mark.MarkDecorator.mark": {
            "name": "_pytest.mark.MarkDecorator.mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
            "start_line": 284,
            "start_column": 9608,
            "end_line": 4,
            "end_column": 9678,
            "start_byte": 9608,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.name": {
            "name": "_pytest.mark.MarkDecorator.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
            "start_line": 286,
            "start_column": 9684,
            "end_line": 4,
            "end_column": 9785,
            "start_byte": 9684,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.args": {
            "name": "_pytest.mark.MarkDecorator.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
            "start_line": 291,
            "start_column": 9791,
            "end_line": 4,
            "end_column": 9904,
            "start_byte": 9791,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.kwargs": {
            "name": "_pytest.mark.MarkDecorator.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
            "start_line": 296,
            "start_column": 9910,
            "end_line": 4,
            "end_column": 10031,
            "start_byte": 9910,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.markname": {
            "name": "_pytest.mark.MarkDecorator.markname",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
            "start_line": 301,
            "start_column": 10037,
            "end_line": 4,
            "end_column": 10147,
            "start_byte": 10037,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.__repr__": {
            "name": "_pytest.mark.MarkDecorator.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
            "start_line": 305,
            "start_column": 10153,
            "end_line": 4,
            "end_column": 10235,
            "start_byte": 10153,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.with_args": {
            "name": "_pytest.mark.MarkDecorator.with_args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
            "start_line": 308,
            "start_column": 10241,
            "end_line": 4,
            "end_column": 10647,
            "start_byte": 10241,
            "end_byte": 4
        },
        "_pytest.mark.MarkDecorator.__call__": {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
        },
        "_pytest.mark.MarkGenerator": {
            "name": "_pytest.mark.MarkGenerator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 450,
            "start_column": 15252,
            "end_line": 0,
            "end_column": 18166,
            "start_byte": 15252,
            "end_byte": 0
        },
        "_pytest.mark.MarkGenerator._config": {
            "name": "_pytest.mark.MarkGenerator._config",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_config = None",
            "start_line": 465,
            "start_column": 15571,
            "end_line": 4,
            "end_column": 15585,
            "start_byte": 15571,
            "end_byte": 4
        },
        "_pytest.mark.MarkGenerator._markers": {
            "name": "_pytest.mark.MarkGenerator._markers",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_markers = set()",
            "start_line": 466,
            "start_column": 15616,
            "end_line": 4,
            "end_column": 15632,
            "start_byte": 15616,
            "end_byte": 4
        },
        "_pytest.mark.MarkGenerator.__getattr__": {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
        },
        "_pytest.pastebin.pytest_configure": {
            "name": "_pytest.pastebin.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "arsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def",
            "start_line": 30,
            "start_column": 778,
            "end_line": 0,
            "end_column": 1609,
            "start_byte": 778,
            "end_byte": 0
        },
        "_pytest.pytester.pytest_configure": {
            "name": "_pytest.pytester.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions a",
            "start_line": 83,
            "start_column": 2138,
            "end_line": 0,
            "end_column": 2530,
            "start_byte": 2138,
            "end_byte": 0
        },
        "_pytest.python.pytest_configure": {
            "name": "_pytest.python.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names = attr.ib(type=AbstractSet[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"",
            "start_line": 138,
            "start_column": 4458,
            "end_line": 0,
            "end_column": 5374,
            "start_byte": 4458,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_configure": {
            "name": "_pytest.skipping.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "lection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywor",
            "start_line": 47,
            "start_column": 1193,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1193,
            "end_byte": 0
        },
        "_pytest.stepwise.pytest_configure": {
            "name": "_pytest.stepwise.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": ".config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecate",
            "start_line": 28,
            "start_column": 728,
            "end_line": 0,
            "end_column": 866,
            "start_byte": 728,
            "end_byte": 0
        },
        "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems": {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "ize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and cl",
            "start_line": 48,
            "start_column": 1400,
            "end_line": 4,
            "end_column": 2535,
            "start_byte": 1400,
            "end_byte": 4
        },
        "_pytest.terminal.pytest_configure": {
            "name": "_pytest.terminal.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " config.option.keyword.lstrip()\n    if not keywordexpr:\n        return\n\n    if keywordexpr.startswith(\"-\"):\n        # To be removed in pytest 7.0.0.\n        warnings.warn(MINUS_K_DASH, stacklevel=2)\n        keywordexpr = \"not \" + keywordexpr[1:]\n    selectuntil = False\n    if keywordexpr[-1:] == \":\":\n        # To be removed in pytest 7.0.0.\n        warnings.warn(MINUS_K_COLON, stacklevel=2)\n        selectuntil = Tru",
            "start_line": 224,
            "start_column": 5991,
            "end_line": 0,
            "end_column": 6410,
            "start_byte": 5991,
            "end_byte": 0
        },
        "_pytest.tmpdir.pytest_configure": {
            "name": "_pytest.tmpdir.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "t[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"",
            "start_line": 138,
            "start_column": 4766,
            "end_line": 0,
            "end_column": 5374,
            "start_byte": 4766,
            "end_byte": 0
        },
        "_pytest.warning_types.PytestUnknownMarkWarning": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
            "start_line": 77,
            "start_column": 1903,
            "end_line": 0,
            "end_column": 2100,
            "start_byte": 1903,
            "end_byte": 0
        },
        "_pytest.warning_types.PytestUnknownMarkWarning.__module__": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "   @classmethod\n    d",
            "start_line": 83,
            "start_column": 2079,
            "end_line": 4,
            "end_column": 2100,
            "start_byte": 2079,
            "end_byte": 4
        },
        "_pytest.warnings.pytest_configure": {
            "name": "_pytest.warnings.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other'",
            "start_line": 74,
            "start_column": 2235,
            "end_line": 0,
            "end_column": 2501,
            "start_byte": 2235,
            "end_byte": 0
        },
        "_pytest.resultlog.pytest_configure": {
            "name": "_pytest.resultlog.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "est.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: ",
            "start_line": 30,
            "start_column": 725,
            "end_line": 0,
            "end_column": 1434,
            "start_byte": 725,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
        },
        "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
        },
        "_pytest.skipping.evaluate_condition": {
            "name": "_pytest.skipping.evaluate_condition",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_condition(item: Item, mark: Mark, condition: object) -> Tuple[bool, str]:\n    \"\"\"Evaluate a single skipif/xfail condition.\n\n    If an old-style string condition is given, it is eval()'d, otherwise the\n    condition is bool()'d. If this fails, an appropriately formatted pytest.fail\n    is raised.\n\n    Returns (result, reason). The reason is only relevant if the result is True.\n    \"\"\"\n    # String condition.\n    if isinstance(condition, str):\n        globals_ = {\n            \"os\": os,\n            \"sys\": sys,\n            \"platform\": platform,\n            \"config\": item.config,\n        }\n        if hasattr(item, \"obj\"):\n            globals_.update(item.obj.__globals__)  # type: ignore[attr-defined]\n        try:\n            filename = \"<{} condition>\".format(mark.name)\n            condition_code = compile(condition, filename, \"eval\")\n            result = eval(condition_code, globals_)\n        except SyntaxError as exc:\n            msglines = [\n                \"Error evaluating %r condition\" % mark.name,\n                \"    \" + condition,\n                \"    \" + \" \" * (exc.offset or 0) + \"^\",\n                \"SyntaxError: invalid syntax\",\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n        except Exception as exc:\n            msglines = [\n                \"Error evaluating %r condition\" % mark.name,\n                \"    \" + condition,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    # Boolean condition.\n    else:\n        try:\n            result = bool(condition)\n        except Exception as exc:\n            msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n                + \"you need to specify reason=STRING when using booleans as conditions.\"\n            )\n            fail(msg, pytrace=False)\n\n    return result, reason",
            "start_line": 86,
            "start_column": 2816,
            "end_line": 0,
            "end_column": 5151,
            "start_byte": 2816,
            "end_byte": 0
        },
        "_pytest.skipping.evaluate_xfail_marks": {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
        },
        "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
        }
    }
}