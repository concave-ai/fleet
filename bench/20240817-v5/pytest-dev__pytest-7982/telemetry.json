{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7982",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:24:04.569560",
        "usage": "1587.7320766448975 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "_CACHE_PREFIX_DIRS",
          "getfirstlinesource",
          "FaultHandlerHooks",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "test_tmproot",
          "T",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "evaluate_xfail_marks",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "pytest",
          "fullsource",
          "_FixtureFunction",
          "rex_session_duration",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "TResult",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "ImportPathMismatchError",
          "get_scope_node",
          "evaluate_condition",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "SEP",
          "makedir",
          "MINUS_K_COLON",
          "accept",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "symlink_or_skip",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getfailedcollections",
          "reprfileloc",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "RPAREN",
          "reprcrash",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "_color_for_type_default",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "pytest_warning_recorded",
          "tmpdir_factory",
          "__slots__",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "is_started",
          "WarningsRecorder",
          "clear_cache",
          "_format_boolop",
          "PytestArg",
          "no_re_match_line",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "_WithException",
          "exec_module",
          "LFPluginCollSkipfiles",
          "category",
          "ParseError",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "__str__",
          "from_current",
          "_initrequest",
          "handleError",
          "reorder_items_atscope",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "Expression",
          "_getscopeitem",
          "SysCapture",
          "MINUS_K_DASH",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "_is_skipped",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "lineno",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "_PluggyPlugin",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "request",
          "USAGE_ERROR",
          "Store",
          "_W",
          "TestReport",
          "_find_spec",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
          "sections",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "__lt__",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "_CACHE_PREFIX_VALUES",
          "showheader",
          "stream",
          "commonpath",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "no_summary",
          "name",
          "_make_plural",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "extraline",
          "_compare_eq_verbose",
          "longrepr",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "_set_main_color",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "width_of_current_line",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "flush",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "reason",
          "finish_recording",
          "TerminalRepr",
          "duration",
          "__enter__",
          "_repr_failure_py",
          "caplog_records_key",
          "pytest_runtest_logstart",
          "_format_action_invocation",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "_get_multicapture",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "FakeCollectModule",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "STEPWISE_CACHE_DIR",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "repr",
          "_factorytraceback",
          "get_terminal_width",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "OR",
          "resolve_from_str",
          "assert_never",
          "report_collect",
          "_split_lines",
          "cacheshow",
          "_show_fixture_action",
          "_FixtureCachedResult",
          "resume_fixture",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "get_last_failed_paths",
          "write",
          "_write_content",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "makepyprojecttoml",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "_esctable",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "filter_traceback_for_conftest_import_failure",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "fullwidth",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_fail",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "pos",
          "node",
          "_names",
          "HookRecorder",
          "_getentrysource",
          "should_do_markup",
          "Scanner",
          "resolve_package_path",
          "head_line",
          "_FileHandler",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "IGNORED_ATTRIBUTES",
          "_do_configure",
          "families",
          "search_pypath",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "IDENT_PREFIX",
          "_check_all_skipped",
          "get_terminal_writer",
          "maybe_wrap_pytest_function_for_tracing",
          "Class",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_warn_about_skipped_plugins",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingNullHandler",
          "_LiveLoggingStreamHandler",
          "sep",
          "fault_handler_stderr_key",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "_get_teardown_reports",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "markup",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "Exception",
          "reports",
          "_ensure_basetemp",
          "_compare_eq_any",
          "_collectfile",
          "_check_initialpaths_for_relpath",
          "type",
          "TerminalWriter",
          "pytest_runtest_setup",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "WARNING_CAPTURED_HOOK",
          "setdefault",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "xfailed_key",
          "_validate_ids",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "from_parent",
          "_setupstate",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "CHECKER_CLASS",
          "find_spec",
          "get_statement_startend2",
          "try_makedirs",
          "old_mark_config_key",
          "_for_parametrize",
          "Token",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "from_config",
          "console_main",
          "resolve_collection_argument",
          "lex",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "inifile",
          "__attrs_post_init__",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "timing",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "truncate_locals",
          "record_property",
          "_pytester",
          "visit",
          "reprlocals",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "__iter__",
          "no_header",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "assertstate_key",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "_AnyPurePath",
          "LFPluginCollWrapper",
          "strip",
          "pytest_runtestloop",
          "exitstatus",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "strict",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "_expecting_failure",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_add_stats",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "reprentries",
          "args",
          "_seen",
          "__module__",
          "_get_unknown_ini_keys",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "count",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "reject",
          "cache_dir_from_config",
          "tracebackcutdir",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "pytest_sessionfinish",
          "fill_unfilled",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "ImportMode",
          "D",
          "errisinstance",
          "_init_checker_class",
          "__exit__",
          "_assert_state",
          "make_properties_node",
          "result",
          "config",
          "_is_last_item",
          "parse_warning_filter",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "reprfuncargs",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "rootdir",
          "keywords",
          "AND",
          "linecomp",
          "scope2index",
          "_parse_ini_config",
          "KNOWN_TYPES",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "__dir__",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "record_testsuite_property",
          "_update_current_test_var",
          "LPAREN",
          "_ANSI_ESCAPE_SEQ",
          "parse_known_and_unknown_args",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "IDENT",
          "logging",
          "xml_key",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "invocation_dir",
          "not_expr",
          "get_fslocation_from_item",
          "listoutcomes",
          "EOF",
          "get",
          "pytest_unconfigure",
          "_start",
          "_mk_tmp",
          "_FixtureFunc",
          "_initini",
          "consider_conftest",
          "apply_warning_filters",
          "addinivalue_line",
          "KeywordMatcher",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_NodeType",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "parse_summary_nouns",
          "index",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_param_ids_from",
          "inipath",
          "id",
          "_FixtureValue",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "_param_ids_generated",
          "display",
          "template",
          "_get_continue_on_failure",
          "K",
          "prog",
          "setuponly",
          "_resume",
          "NotSetType",
          "freeze_includes",
          "unset_fixture",
          "ApproxDecimal",
          "_readline_workaround",
          "lines",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "_write_entry_lines",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "_validate_config_options",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "getitems",
          "Skip",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "expression",
          "MatcherAdapter",
          "getworkerinfoline",
          "_is_setup_py",
          "pop",
          "TokenType",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_replace",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "ensure_extended_length_path",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "_Markable",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "_write_pyc_fp",
          "delitem",
          "V",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "TeeCaptureIO",
          "add_property",
          "get_extended_length_path_str",
          "prepend",
          "compile",
          "__version__",
          "USAGE_MSG",
          "_is_numpy_array",
          "_args_converter",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "cache_key",
          "TEST_OUTCOME",
          "NOT",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "rootpath",
          "_F",
          "activate_fixture",
          "evaluate_skip_marks",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "_has_param_ids",
          "NodeMeta",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_truncate_explanation",
          "_T",
          "get_cache_dir",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "_ensure_relative_to_basetemp",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_check_non_top_pytest_plugins",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_surrounding_parens_on_own_lines",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "ParameterSet",
          "locate_config",
          "listnames",
          "caplog_handler_key",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "_with_exception",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "_pformat_dispatch",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "and_expr",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "_format",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_color_for_type",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "async_warn_and_skip",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "_is_started",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "showlongtestinfo",
          "append_failure",
          "importlib",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "NodeKeywords",
          "evaluate",
          "_REPORTCHARS_DEFAULT",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "python",
          "_tmppath_factory",
          "issue_config_time_warning",
          "wcswidth",
          "fnmatch_ex",
          "name2pseudofixturedef_key",
          "_Key",
          "absolutepath",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "cache",
          "validate_basetemp",
          "skipped_by_mark_key",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "token",
          "popcall",
          "_no_match_line",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "_highlight",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "_get_auto_indent",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "get_timeout_config_value",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "visit_Starred",
          "_ET",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "_HandlerType",
          "assert_contains_lines",
          "repr_traceback_entry",
          "count_towards_summary",
          "_fill_fixtures_impl",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "wcwidth",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "Xfail",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "Pytester",
          "ids",
          "_handle_teardown_sections",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "_fillfuncargs",
          "start",
          "_write_source",
          "LoggingPlugin",
          "_determine_main_color",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_try_repr_or_str",
          "_folded_skips",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "load_config_dict_from_file",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "_fixturemanager",
          "is_generator",
          "set_fixture",
          "get_common_ancestor",
          "PdbInvoke",
          "__contains__",
          "deactivate_fixture",
          "PercentStyleMultiline",
          "MarkMatcher",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "_create",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "FILLFUNCARGS",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "FDCaptureBinary",
          "store",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "_get_main_color",
          "no_fnmatch_line",
          "MarkGenerator",
          "_R",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "_EmptyClass",
          "line",
          "StoreKey",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "iterparentnodeids",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "is_async_function",
          "AlwaysDispatchingPrettyPrinter",
          "print_teardown_sections",
          "wrap_pytest_function_for_tracing",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "_S",
          "maybe_delete_a_numbered_dir",
          "_params_converter",
          "import_path",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "bestrelpath",
          "pastebinfile_key",
          "getstatementrange",
          "makepyfile",
          "reprtraceback",
          "_is_doctest",
          "SetupState",
          "_prepare_content",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "AssertionRewritingHook",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "_validate_plugins",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "_in_suspended",
          "get_default_arg_names",
          "names_closure",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "expr",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "unexpectedsuccess_key",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "_warn_or_fail_if_strict",
          "PytestDeprecationWarning",
          "genitems",
          "_eval_scope_callable",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "symlink_or_skip",
          "collect",
          "pytest_ignore_collect",
          "pytest_collect_file",
          "FSCollector",
          "collect_one_node",
          "FSHookProxy",
          "_collectfile",
          "resolve_collection_argument",
          "pytest_collection"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:24:06.157307",
        "usage": "175.44221878051758 ms"
      },
      "request": {
        "tokens": [
          "symlink_or_skip",
          "collect",
          "pytest_ignore_collect",
          "pytest_collect_file",
          "FSCollector",
          "collect_one_node",
          "FSHookProxy",
          "_collectfile",
          "resolve_collection_argument",
          "pytest_collection"
        ]
      },
      "response": {
        "results": {
          "collect": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/pytest/collect.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/pytester.py"
          ],
          "collect_one_node": [
            "src/_pytest/main.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "FSCollector": [
            "src/_pytest/nodes.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "_collectfile": [
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "symlink_or_skip": [
            "src/_pytest/pathlib.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/terminal.py"
          ],
          "FSHookProxy": [
            "src/_pytest/main.py"
          ],
          "resolve_collection_argument": [
            "src/_pytest/main.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:24:06.332759",
        "usage": "5727.11706161499 ms"
      },
      "request": {
        "keyword_search_results": {
          "collect": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/pytest/collect.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/pytester.py"
          ],
          "collect_one_node": [
            "src/_pytest/main.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "FSCollector": [
            "src/_pytest/nodes.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "_collectfile": [
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "symlink_or_skip": [
            "src/_pytest/pathlib.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/terminal.py"
          ],
          "FSHookProxy": [
            "src/_pytest/main.py"
          ],
          "resolve_collection_argument": [
            "src/_pytest/main.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is about symlinked directories not being collected since a particular commit, and it mentions that a 'follow_symlinks=False' was added. The problem is likely related to how directories and symlinks are handled during the collection phase of pytest.\n\nBased on the keywords:\n\n- **collect**: This keyword appears frequently and in the context of pytest, it is highly relevant since 'collection' refers to the initial phase pytest goes through when discovering tests to run. \n  - 'src/_pytest/main.py': Appears many times in conjunction with collection and symlinks, which suggests it might have relevant code.\n  - 'src/_pytest/python.py': Also related to collection, potentially involves directory handling.\n  \n- **FSCollector**: This specifically deals with the collection of filesystem items, which might include code related to symlinks.\n  - 'src/_pytest/nodes.py': This might contain the class that implements collecting filesystem entities.\n  \n- **symlink_or_skip**: This file name directly mentions symlinks, indicating high relevance.\n  - 'src/_pytest/pathlib.py': Specifically mentions managing symlinks, likely to contain necessary logic.\n  \n- **pytest_collect_file**: This keyword relates directly to the file collection, which should be looking into symlinked directories.\n  \nBy examining the intersections of these keywords, it seems that 'src/_pytest/main.py', 'src/_pytest/pathlib.py', and 'src/_pytest/python.py' are the most relevant to the issue, likely containing the code logic responsible for handling collection, including symlinks. Files like 'src/_pytest/nodes.py' might also be closely related if they manage or collect filesystem nodes.\n\nThese files are likely to provide understanding and necessary adjustment points to resolve the issue of symlinks not being followed during collection accordingly.",
        "file_paths": [
          "src/_pytest/main.py",
          "src/_pytest/pathlib.py",
          "src/_pytest/python.py",
          "src/_pytest/nodes.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:12.059890",
        "usage": "8244.550943374634 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is reporting an issue where directories that are symlinked are not being collected during test collection in pytest. This issue appeared starting from version 6.1.0.\n1.2 This issue was caused by a change identified by a commit (b473e515bc57ff1133fe650f1e7e6d7e22e5d841) that added `follow_symlinks=False`, altering the collection behavior when encountering symlinks.\n1.3 The user expects the behavior to revert to pre-6.1.0, where symlinks to directories would be followed and those directories would be collected.\n1.4 Since the expected behavior was detailed, no need to redefine expectations.\n1.5 The fix involves removing the `follow_symlinks=False` setting.\n\n2. Make file evaluation:\n2.1 Looking for code that handles file/directory collection, particularly anything associated with symlink handling, to find `follow_symlinks` or similar mechanisms.\n2.2 There's a method `Session.collect` that deals with collecting files and directories.\n2.3 The `_recurse` method is potentially responsible for directory recursion logic, looking at how it processes directories.\n2.4 `_recurse` method does not explicitly show handling `follow_symlinks`, but it determines whether to recurse into directories.\n2.5 `perform_collect` references `_recurse`, potentially tied to directory scanning for tests.\n2.6 The methods `_recurse` and `collect` are likely involved in skipping symlink directories.\n2.7 No `follow_symlinks=False` found directly, but collection logic in these methods seems pertinent.\n2.8 High possibility that the `Session.collect` and `_recurse` are impacting symlink directory behavior.\n\nOverall, while there's no explicit `follow_symlinks` parameter found in this file, the methods mentioned have roles in determining what directories get examined, and are likely to respond to the presence or absence of such parameters if called/modified elsewhere. The file appears to be relevant to the issue, though the specific problematic line may not be here.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "src/_pytest/nodes.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [
          "Session.collect",
          "Session._recurse"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:20.304467",
        "usage": "4957.9150676727295 ms"
      },
      "request": {
        "file_path": "src/_pytest/pathlib.py"
      },
      "response": {
        "scratch_pad": "1. **Reported Issue Analysis**:\n   - The issue describes that symlinked directories are not being collected as they used to be in pytest version 6.1.0.\n   - This was caused by a change in the behavior where `follow_symlinks` was set to `False`, which does not follow symlinked directories for collection, contrary to previous behavior.\n   - The expected result should be that symlinks are followed and collected.\n   - The fix should involve ensuring that symlinks are followed when collecting directories, likely by setting `follow_symlinks` to `True`.\n\n2. **File Content Analysis**:\n   - The file contains various utility functions related to file path manipulation, such as resolving paths, managing symlinks, and more.\n   - A key function related to the issue is `visit()`, which is responsible for walking through directories with an option to recurse over directories.\n   - The `visit` function explicitly sets `follow_symlinks=False` when checking if an entry is a directory with `entry.is_dir(follow_symlinks=False)`.\n   - Other functions in the file don't seem directly related to symlink handling or collection behavior that pertains to the issue described.\n\n3. **Conclusion**:\n   - The `visit()` function is relevant to the issue as it deals with directory traversal and has a `follow_symlinks` parameter set to `False`. This aligns with the problem described, where symlinks are not followed.\n   - To address the issue, modifying the `visit()` function to set `follow_symlinks=True` would likely resolve the problem where symlinked directories are not being collected.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "visit"
        ],
        "root_cause_symbols": [
          "visit"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:25.262401",
        "usage": "7012.631893157959 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "1. **Issue Analysis**:\n   - **Described Issue**: Symlinked directories in test directories are being skipped during collection since pytest 6.1.0.\n   - **Cause**: This regression occurred due to a change where `follow_symlinks=False` was added, which does not match previous behavior. This change was included in the commit identified by hash `b473e515bc57ff1133fe650f1e7e6d7e22e5d841` in version 6.1.0.\n   - **Expected Behavior**: Symlinked directories should be followed and collected as they were before this change.\n   - **Solution**: Remove or modify the `follow_symlinks=False` setting to ensure symlinked directories are followed during collection, restoring previous behavior.\n\n2. **File Evaluation**:\n   - **File Content Analysis**: This file contains various functions related to discovering and collecting test files, classes, and functions in pytest.\n   - **Key Function for Collection**: The function `pytest_collect_file()` is responsible for collecting test modules by inspecting the file extension and checking patterns.\n   - **Symlink Handling**: However, there is no immediate indication that `follow_symlinks` is set in this function.\n   - **Potential Relevance**: Since `pytest_collect_file()` is directly responsible for collecting files, any symlink-related functionality or configuration would likely be influenced here or in related functions.\n   - **Decision**: Though no direct handling for symlinks is visible in the code snippet provided, the function is clearly relevant as changes here or related hooks could affect similar behavior.\n   \n3. **Conclusion**:\n   - **Relevance**: The `pytest_collect_file()` function is relevant because it controls the file collection process, and symlink handling could be influenced by adjustments or additional parameters affecting file system interaction, even if not directly visible in this snippet.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "src/_pytest/hookspec.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "pytest_collect_file"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:32.275068",
        "usage": "5545.528173446655 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an issue where symlinked directories are not collected by pytest since version 6.1.0.\n1.2 The issue was caused by a regression where `follow_symlinks=False` was introduced in the offending commit, leading to symlinks being skipped instead of being followed and collected.\n1.3 The user expects the previous behavior, where symlinks are followed and collected, to be restored.\n1.4 The expected result should be that symlinked directories are collected as they were prior to version 6.1.0.\n1.5 To fix the issue, the `follow_symlinks=False` attribute or behavior should be removed, allowing symlinked directories to be followed and collected again.\n\n2. Make file evaluation:\n2.1 In the provided file, `nodes.py`, there isn't an explicit mention or implementation directly referring to `follow_symlinks` parameter or logic. The classes here deal with Node management (e.g., Collector, Item) but don't include symlink behavior.\n2.3 The relevant symbols should ideally involve functions or methods handling the file system or collecting files, possibly in relation to nodes/collectors.\n2.4 The file seems to serve more as a base structure for node and item representation, along with collectors. \n2.5 There are references to FSCollector and other nodes, but these may not be immediately responsible for filesystem traversal settings.\n\n3. Decision:\n- The current file does not directly implement or reference a mechanism to handle symlinks in directory collection, so it's not the root cause.\n- This file appears more related to Node structural definitions rather than the symlink collection logic.\n\nIt might be more relevant to check `main.py` or parts where the directory tree is actively traversed and collected, such as the instantiation or configuration of a `Session`.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/config.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:37.820612",
        "usage": "110.20779609680176 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "Session.collect",
              "Session._recurse"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/pathlib.py",
            "relevant_symbol_keys": [
              "visit"
            ],
            "root_cause_symbol_keys": [
              "visit"
            ]
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "pytest_collect_file"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        path = py.path.local(direntry.path)\n        ihook = self.gethookproxy(path.dirpath())\n        if ihook.pytest_ignore_collect(path=path, config=self.config):\n            return False\n        norecursepatterns = self.config.getini(\"norecursedirs\")\n        if any(path.check(fnmatch=pat) for pat in norecursepatterns):\n            return False\n        return True",
            "start_line": 518,
            "start_column": 16811,
            "end_line": 4,
            "end_column": 17305,
            "start_byte": 16811,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n        from _pytest.python import Package\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures.\n        node_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}\n        node_cache2: Dict[\n            Tuple[Type[nodes.Collector], py.path.local], nodes.Collector\n        ] = ({})\n\n        # Keep track of any collected collectors in matchnodes paths, so they\n        # are not collected more than once.\n        matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})\n\n        # Dirnames of pkgs with dunder-init files.\n        pkg_roots: Dict[str, Package] = {}\n\n        for argpath, names in self._initial_parts:\n            self.trace(\"processing argument\", (argpath, names))\n            self.trace.root.indent += 1\n\n            # Start with a Session root, and delve to argpath item (dir or file)\n            # and stack all Packages found on the way.\n            # No point in finding packages when collecting doctests.\n            if not self.config.getoption(\"doctestmodules\", False):\n                pm = self.config.pluginmanager\n                for parent in reversed(argpath.parts()):\n                    if pm._confcutdir and pm._confcutdir.relto(parent):\n                        break\n\n                    if parent.isdir():\n                        pkginit = parent.join(\"__init__.py\")\n                        if pkginit.isfile() and pkginit not in node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    pkg_roots[str(parent)] = col[0]\n                                node_cache1[col[0].fspath] = [col[0]]\n\n            # If it's a directory argument, recurse and look for any Subpackages.\n            # Let the Package collector deal with subnodes, don't collect here.\n            if argpath.check(dir=1):\n                assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n                seen_dirs: Set[py.path.local] = set()\n                for direntry in visit(str(argpath), self._recurse):\n                    if not direntry.is_file():\n                        continue\n\n                    path = py.path.local(direntry.path)\n                    dirpath = path.dirpath()\n\n                    if dirpath not in seen_dirs:\n                        # Collect packages first.\n                        seen_dirs.add(dirpath)\n                        pkginit = dirpath.join(\"__init__.py\")\n                        if pkginit.exists():\n                            for x in self._collectfile(pkginit):\n                                yield x\n                                if isinstance(x, Package):\n                                    pkg_roots[str(dirpath)] = x\n                    if str(dirpath) in pkg_roots:\n                        # Do not collect packages here.\n                        continue\n\n                    for x in self._collectfile(path):\n                        key = (type(x), x.fspath)\n                        if key in node_cache2:\n                            yield node_cache2[key]\n                        else:\n                            node_cache2[key] = x\n                            yield x\n            else:\n                assert argpath.check(file=1)\n\n                if argpath in node_cache1:\n                    col = node_cache1[argpath]\n                else:\n                    collect_root = pkg_roots.get(argpath.dirname, self)\n                    col = collect_root._collectfile(argpath, handle_dupes=False)\n                    if col:\n                        node_cache1[argpath] = col\n\n                matching = []\n                work: List[\n                    Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]\n                ] = [(col, names)]\n                while work:\n                    self.trace(\"matchnodes\", col, names)\n                    self.trace.root.indent += 1\n\n                    matchnodes, matchnames = work.pop()\n                    for node in matchnodes:\n                        if not matchnames:\n                            matching.append(node)\n                            continue\n                        if not isinstance(node, nodes.Collector):\n                            continue\n                        key = (type(node), node.nodeid)\n                        if key in matchnodes_cache:\n                            rep = matchnodes_cache[key]\n                        else:\n                            rep = collect_one_node(node)\n                            matchnodes_cache[key] = rep\n                        if rep.passed:\n                            submatchnodes = []\n                            for r in rep.result:\n                                # TODO: Remove parametrized workaround once collection structure contains\n                                # parametrization.\n                                if (\n                                    r.name == matchnames[0]\n                                    or r.name.split(\"[\")[0] == matchnames[0]\n                                ):\n                                    submatchnodes.append(r)\n                            if submatchnodes:\n                                work.append((submatchnodes, matchnames[1:]))\n                            # XXX Accept IDs that don't have \"()\" for class instances.\n                            elif len(rep.result) == 1 and rep.result[0].name == \"()\":\n                                work.append((rep.result, matchnames))\n                        else:\n                            # Report collection failures here to avoid failing to run some test\n                            # specified in the command line because the module could not be\n                            # imported (#134).\n                            node.ihook.pytest_collectreport(report=rep)\n\n                    self.trace(\"matchnodes finished -> \", len(matching), \"nodes\")\n                    self.trace.root.indent -= 1\n\n                if not matching:\n                    report_arg = \"::\".join((str(argpath), *names))\n                    self._notfound.append((report_arg, col))\n                    continue\n\n                # If __init__.py was the only file requested, then the matched node will be\n                # the corresponding Package, and the first yielded item will be the __init__\n                # Module itself, so just use that. If this special case isn't taken, then all\n                # the files in the package will be yielded.\n                if argpath.basename == \"__init__.py\":\n                    assert isinstance(matching[0], nodes.Collector)\n                    try:\n                        yield next(iter(matching[0].collect()))\n                    except StopIteration:\n                        # The package collects nothing with only an __init__.py\n                        # file in it, which gets ignored by the default\n                        # \"python_files\" option.\n                        pass\n                    continue\n\n                yield from matching\n\n            self.trace.root.indent -= 1",
            "start_line": 633,
            "start_column": 21316,
            "end_line": 4,
            "end_column": 28539,
            "start_byte": 21316,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "yle file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
            "start_line": 120,
            "start_column": 3292,
            "end_line": 0,
            "end_column": 3801,
            "start_byte": 3292,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "de.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python in",
            "start_line": 276,
            "start_column": 9742,
            "end_line": 0,
            "end_column": 10041,
            "start_byte": 9742,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module\n    return None",
            "start_line": 188,
            "start_column": 6518,
            "end_line": 0,
            "end_column": 7039,
            "start_byte": 6518,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 29525,
            "end_line": 4,
            "end_column": 29788,
            "start_byte": 29525,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 807,
            "start_column": 29794,
            "end_line": 4,
            "end_column": 34621,
            "start_byte": 29794,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 923,
            "start_column": 34627,
            "end_line": 4,
            "end_column": 35175,
            "start_byte": 34627,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 933,
            "start_column": 35181,
            "end_line": 4,
            "end_column": 36854,
            "start_byte": 35181,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 968,
            "start_column": 36860,
            "end_line": 4,
            "end_column": 37146,
            "start_byte": 36860,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 974,
            "start_column": 37152,
            "end_line": 4,
            "end_column": 37537,
            "start_byte": 37152,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 982,
            "start_column": 37543,
            "end_line": 4,
            "end_column": 38529,
            "start_byte": 37543,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1006,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38801,
            "start_byte": 38535,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1012,
            "start_column": 38807,
            "end_line": 4,
            "end_column": 39277,
            "start_byte": 38807,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1022,
            "start_column": 39283,
            "end_line": 4,
            "end_column": 41035,
            "start_byte": 39283,
            "end_byte": 4
          },
          {
            "name": "_pytest.pathlib.visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):\n            yield from visit(entry.path, recurse)",
            "start_line": 550,
            "start_column": 18105,
            "end_line": 0,
            "end_column": 18564,
            "start_byte": 18105,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:37.930826",
        "usage": "9614.835023880005 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        path = py.path.local(direntry.path)\n        ihook = self.gethookproxy(path.dirpath())\n        if ihook.pytest_ignore_collect(path=path, config=self.config):\n            return False\n        norecursepatterns = self.config.getini(\"norecursedirs\")\n        if any(path.check(fnmatch=pat) for pat in norecursepatterns):\n            return False\n        return True",
            "start_line": 518,
            "start_column": 16811,
            "end_line": 4,
            "end_column": 17305,
            "start_byte": 16811,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n        from _pytest.python import Package\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures.\n        node_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}\n        node_cache2: Dict[\n            Tuple[Type[nodes.Collector], py.path.local], nodes.Collector\n        ] = ({})\n\n        # Keep track of any collected collectors in matchnodes paths, so they\n        # are not collected more than once.\n        matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})\n\n        # Dirnames of pkgs with dunder-init files.\n        pkg_roots: Dict[str, Package] = {}\n\n        for argpath, names in self._initial_parts:\n            self.trace(\"processing argument\", (argpath, names))\n            self.trace.root.indent += 1\n\n            # Start with a Session root, and delve to argpath item (dir or file)\n            # and stack all Packages found on the way.\n            # No point in finding packages when collecting doctests.\n            if not self.config.getoption(\"doctestmodules\", False):\n                pm = self.config.pluginmanager\n                for parent in reversed(argpath.parts()):\n                    if pm._confcutdir and pm._confcutdir.relto(parent):\n                        break\n\n                    if parent.isdir():\n                        pkginit = parent.join(\"__init__.py\")\n                        if pkginit.isfile() and pkginit not in node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    pkg_roots[str(parent)] = col[0]\n                                node_cache1[col[0].fspath] = [col[0]]\n\n            # If it's a directory argument, recurse and look for any Subpackages.\n            # Let the Package collector deal with subnodes, don't collect here.\n            if argpath.check(dir=1):\n                assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n                seen_dirs: Set[py.path.local] = set()\n                for direntry in visit(str(argpath), self._recurse):\n                    if not direntry.is_file():\n                        continue\n\n                    path = py.path.local(direntry.path)\n                    dirpath = path.dirpath()\n\n                    if dirpath not in seen_dirs:\n                        # Collect packages first.\n                        seen_dirs.add(dirpath)\n                        pkginit = dirpath.join(\"__init__.py\")\n                        if pkginit.exists():\n                            for x in self._collectfile(pkginit):\n                                yield x\n                                if isinstance(x, Package):\n                                    pkg_roots[str(dirpath)] = x\n                    if str(dirpath) in pkg_roots:\n                        # Do not collect packages here.\n                        continue\n\n                    for x in self._collectfile(path):\n                        key = (type(x), x.fspath)\n                        if key in node_cache2:\n                            yield node_cache2[key]\n                        else:\n                            node_cache2[key] = x\n                            yield x\n            else:\n                assert argpath.check(file=1)\n\n                if argpath in node_cache1:\n                    col = node_cache1[argpath]\n                else:\n                    collect_root = pkg_roots.get(argpath.dirname, self)\n                    col = collect_root._collectfile(argpath, handle_dupes=False)\n                    if col:\n                        node_cache1[argpath] = col\n\n                matching = []\n                work: List[\n                    Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]\n                ] = [(col, names)]\n                while work:\n                    self.trace(\"matchnodes\", col, names)\n                    self.trace.root.indent += 1\n\n                    matchnodes, matchnames = work.pop()\n                    for node in matchnodes:\n                        if not matchnames:\n                            matching.append(node)\n                            continue\n                        if not isinstance(node, nodes.Collector):\n                            continue\n                        key = (type(node), node.nodeid)\n                        if key in matchnodes_cache:\n                            rep = matchnodes_cache[key]\n                        else:\n                            rep = collect_one_node(node)\n                            matchnodes_cache[key] = rep\n                        if rep.passed:\n                            submatchnodes = []\n                            for r in rep.result:\n                                # TODO: Remove parametrized workaround once collection structure contains\n                                # parametrization.\n                                if (\n                                    r.name == matchnames[0]\n                                    or r.name.split(\"[\")[0] == matchnames[0]\n                                ):\n                                    submatchnodes.append(r)\n                            if submatchnodes:\n                                work.append((submatchnodes, matchnames[1:]))\n                            # XXX Accept IDs that don't have \"()\" for class instances.\n                            elif len(rep.result) == 1 and rep.result[0].name == \"()\":\n                                work.append((rep.result, matchnames))\n                        else:\n                            # Report collection failures here to avoid failing to run some test\n                            # specified in the command line because the module could not be\n                            # imported (#134).\n                            node.ihook.pytest_collectreport(report=rep)\n\n                    self.trace(\"matchnodes finished -> \", len(matching), \"nodes\")\n                    self.trace.root.indent -= 1\n\n                if not matching:\n                    report_arg = \"::\".join((str(argpath), *names))\n                    self._notfound.append((report_arg, col))\n                    continue\n\n                # If __init__.py was the only file requested, then the matched node will be\n                # the corresponding Package, and the first yielded item will be the __init__\n                # Module itself, so just use that. If this special case isn't taken, then all\n                # the files in the package will be yielded.\n                if argpath.basename == \"__init__.py\":\n                    assert isinstance(matching[0], nodes.Collector)\n                    try:\n                        yield next(iter(matching[0].collect()))\n                    except StopIteration:\n                        # The package collects nothing with only an __init__.py\n                        # file in it, which gets ignored by the default\n                        # \"python_files\" option.\n                        pass\n                    continue\n\n                yield from matching\n\n            self.trace.root.indent -= 1",
            "start_line": 633,
            "start_column": 21316,
            "end_line": 4,
            "end_column": 28539,
            "start_byte": 21316,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "yle file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
            "start_line": 120,
            "start_column": 3292,
            "end_line": 0,
            "end_column": 3801,
            "start_byte": 3292,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "de.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python in",
            "start_line": 276,
            "start_column": 9742,
            "end_line": 0,
            "end_column": 10041,
            "start_byte": 9742,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module\n    return None",
            "start_line": 188,
            "start_column": 6518,
            "end_line": 0,
            "end_column": 7039,
            "start_byte": 6518,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 29525,
            "end_line": 4,
            "end_column": 29788,
            "start_byte": 29525,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 807,
            "start_column": 29794,
            "end_line": 4,
            "end_column": 34621,
            "start_byte": 29794,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 923,
            "start_column": 34627,
            "end_line": 4,
            "end_column": 35175,
            "start_byte": 34627,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 933,
            "start_column": 35181,
            "end_line": 4,
            "end_column": 36854,
            "start_byte": 35181,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 968,
            "start_column": 36860,
            "end_line": 4,
            "end_column": 37146,
            "start_byte": 36860,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 974,
            "start_column": 37152,
            "end_line": 4,
            "end_column": 37537,
            "start_byte": 37152,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 982,
            "start_column": 37543,
            "end_line": 4,
            "end_column": 38529,
            "start_byte": 37543,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1006,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38801,
            "start_byte": 38535,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1012,
            "start_column": 38807,
            "end_line": 4,
            "end_column": 39277,
            "start_byte": 38807,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1022,
            "start_column": 39283,
            "end_line": 4,
            "end_column": 41035,
            "start_byte": 39283,
            "end_byte": 4
          },
          {
            "name": "_pytest.pathlib.visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):\n            yield from visit(entry.path, recurse)",
            "start_line": 550,
            "start_column": 18105,
            "end_line": 0,
            "end_column": 18564,
            "start_byte": 18105,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1.1 The issue is that since pytest version 6.1.0, symlinked directories are not collected during tests. They are skipped, but previously, they were followed and collected.\n1.2 The issue was caused by a change in the code, where 'follow_symlinks=False' was added, which deviates from the previous behavior.\n1.3 The expected result is that pytest should follow symlinks and collect symlinked directories as it used to do before version 6.1.0.\n1.4 If not provided, the expectation is that symlinked directories should be included in the test collection process.\n1.5 The follow_symlinks argument should be set to True or removed to revert to the previous behavior.\n\n2.1-2.4 Analyzing the given symbols:\n\n- The primary suspect for the issue is the functionality related to the traversal and collection of directories.\n\n- The symbols `_pytest.pathlib.visit` and `_pytest.main.Session.collect` seem significant due to their involvement in directory traversal and collection processes.\n\n- `_pytest.pathlib.visit` directly deals with directory entries and has a `follow_symlinks=False` parameter for directories, which is a clue to the problem.\n",
        "symbols": [
          {
            "name": "_pytest.pathlib.visit",
            "file_path": "src/_pytest/pathlib.py",
            "reason": "This function includes a parameter 'follow_symlinks=False' when checking for directories, which is a direct clue related to the described issue. It needs to be altered to 'follow_symlinks=True' or removed to follow symlinks as expected."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The description of the issue does not immediately relate to assertion rewriting, but to collection behavior involving directory traversal with symlinks.",
          "Similarly to the prior symbol, this focuses on assertion rewriting and does not directly relate to the directory symlink collection problem.",
          "Also relates to assertion processing, which is unrelated to the symlink directory issue.",
          "Concerns boolean operations during assertion rewriting, not relevant to directory issues.",
          "Relates to unary operations during assertion rewriting, not connected to symlink traversal.",
          "Deals with binary operations, which don't relate to directory collection behavior.",
          "Handles calls within assertion rewriting. Also unrelated to directory symlink issues.",
          "Starred expressions in assertions, thus unrelated to symlink problems in directory handling.",
          "Deals with attribute access during assertion rewriting, not related to directory handling.",
          "Handles comparison expressions in assertions, not related to directory collection issues.",
          "`_pytest.pathlib.visit` is highly relevant because it involves directory traversal and the 'follow_symlinks=False' argument aligns with the described problem.",
          "This function deals with recursion in session collection demonstrating importance in the overall directory traversal process. It evaluates whether specific directories should be entered during collection, potentially implicating symlinks, but doesn't directly set 'follow_symlinks'.",
          "`_pytest.main.Session.collect` facilitates an overview of the root of collection processes during testing, including directory argument handling and traversal.",
          "The partition is closely tied to module and file collection patterns rather than directory navigation involving symlinks.",
          "Deals with setting up plugin collections, unrelated as it doesn't deal with directory traversal or symlinks.",
          "Involved in initiating module collection but without explicit impact on symlink following or directory traversal."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:47.545686",
        "usage": "1.8758773803710938 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.main.Session._recurse",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        path = py.path.local(direntry.path)\n        ihook = self.gethookproxy(path.dirpath())\n        if ihook.pytest_ignore_collect(path=path, config=self.config):\n            return False\n        norecursepatterns = self.config.getini(\"norecursedirs\")\n        if any(path.check(fnmatch=pat) for pat in norecursepatterns):\n            return False\n        return True",
              "start_line": 518,
              "start_column": 16811,
              "end_line": 4,
              "end_column": 17305,
              "start_byte": 16811,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n        from _pytest.python import Package\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures.\n        node_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}\n        node_cache2: Dict[\n            Tuple[Type[nodes.Collector], py.path.local], nodes.Collector\n        ] = ({})\n\n        # Keep track of any collected collectors in matchnodes paths, so they\n        # are not collected more than once.\n        matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})\n\n        # Dirnames of pkgs with dunder-init files.\n        pkg_roots: Dict[str, Package] = {}\n\n        for argpath, names in self._initial_parts:\n            self.trace(\"processing argument\", (argpath, names))\n            self.trace.root.indent += 1\n\n            # Start with a Session root, and delve to argpath item (dir or file)\n            # and stack all Packages found on the way.\n            # No point in finding packages when collecting doctests.\n            if not self.config.getoption(\"doctestmodules\", False):\n                pm = self.config.pluginmanager\n                for parent in reversed(argpath.parts()):\n                    if pm._confcutdir and pm._confcutdir.relto(parent):\n                        break\n\n                    if parent.isdir():\n                        pkginit = parent.join(\"__init__.py\")\n                        if pkginit.isfile() and pkginit not in node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    pkg_roots[str(parent)] = col[0]\n                                node_cache1[col[0].fspath] = [col[0]]\n\n            # If it's a directory argument, recurse and look for any Subpackages.\n            # Let the Package collector deal with subnodes, don't collect here.\n            if argpath.check(dir=1):\n                assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n                seen_dirs: Set[py.path.local] = set()\n                for direntry in visit(str(argpath), self._recurse):\n                    if not direntry.is_file():\n                        continue\n\n                    path = py.path.local(direntry.path)\n                    dirpath = path.dirpath()\n\n                    if dirpath not in seen_dirs:\n                        # Collect packages first.\n                        seen_dirs.add(dirpath)\n                        pkginit = dirpath.join(\"__init__.py\")\n                        if pkginit.exists():\n                            for x in self._collectfile(pkginit):\n                                yield x\n                                if isinstance(x, Package):\n                                    pkg_roots[str(dirpath)] = x\n                    if str(dirpath) in pkg_roots:\n                        # Do not collect packages here.\n                        continue\n\n                    for x in self._collectfile(path):\n                        key = (type(x), x.fspath)\n                        if key in node_cache2:\n                            yield node_cache2[key]\n                        else:\n                            node_cache2[key] = x\n                            yield x\n            else:\n                assert argpath.check(file=1)\n\n                if argpath in node_cache1:\n                    col = node_cache1[argpath]\n                else:\n                    collect_root = pkg_roots.get(argpath.dirname, self)\n                    col = collect_root._collectfile(argpath, handle_dupes=False)\n                    if col:\n                        node_cache1[argpath] = col\n\n                matching = []\n                work: List[\n                    Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]\n                ] = [(col, names)]\n                while work:\n                    self.trace(\"matchnodes\", col, names)\n                    self.trace.root.indent += 1\n\n                    matchnodes, matchnames = work.pop()\n                    for node in matchnodes:\n                        if not matchnames:\n                            matching.append(node)\n                            continue\n                        if not isinstance(node, nodes.Collector):\n                            continue\n                        key = (type(node), node.nodeid)\n                        if key in matchnodes_cache:\n                            rep = matchnodes_cache[key]\n                        else:\n                            rep = collect_one_node(node)\n                            matchnodes_cache[key] = rep\n                        if rep.passed:\n                            submatchnodes = []\n                            for r in rep.result:\n                                # TODO: Remove parametrized workaround once collection structure contains\n                                # parametrization.\n                                if (\n                                    r.name == matchnames[0]\n                                    or r.name.split(\"[\")[0] == matchnames[0]\n                                ):\n                                    submatchnodes.append(r)\n                            if submatchnodes:\n                                work.append((submatchnodes, matchnames[1:]))\n                            # XXX Accept IDs that don't have \"()\" for class instances.\n                            elif len(rep.result) == 1 and rep.result[0].name == \"()\":\n                                work.append((rep.result, matchnames))\n                        else:\n                            # Report collection failures here to avoid failing to run some test\n                            # specified in the command line because the module could not be\n                            # imported (#134).\n                            node.ihook.pytest_collectreport(report=rep)\n\n                    self.trace(\"matchnodes finished -> \", len(matching), \"nodes\")\n                    self.trace.root.indent -= 1\n\n                if not matching:\n                    report_arg = \"::\".join((str(argpath), *names))\n                    self._notfound.append((report_arg, col))\n                    continue\n\n                # If __init__.py was the only file requested, then the matched node will be\n                # the corresponding Package, and the first yielded item will be the __init__\n                # Module itself, so just use that. If this special case isn't taken, then all\n                # the files in the package will be yielded.\n                if argpath.basename == \"__init__.py\":\n                    assert isinstance(matching[0], nodes.Collector)\n                    try:\n                        yield next(iter(matching[0].collect()))\n                    except StopIteration:\n                        # The package collects nothing with only an __init__.py\n                        # file in it, which gets ignored by the default\n                        # \"python_files\" option.\n                        pass\n                    continue\n\n                yield from matching\n\n            self.trace.root.indent -= 1",
              "start_line": 633,
              "start_column": 21316,
              "end_line": 4,
              "end_column": 28539,
              "start_byte": 21316,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "yle file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
              "start_line": 120,
              "start_column": 3292,
              "end_line": 0,
              "end_column": 3801,
              "start_byte": 3292,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "de.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python in",
              "start_line": 276,
              "start_column": 9742,
              "end_line": 0,
              "end_column": 10041,
              "start_byte": 9742,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module\n    return None",
              "start_line": 188,
              "start_column": 6518,
              "end_line": 0,
              "end_column": 7039,
              "start_byte": 6518,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion.AssertionRewriter.generic_visit",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 801,
              "start_column": 29525,
              "end_line": 4,
              "end_column": 29788,
              "start_byte": 29525,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 807,
              "start_column": 29794,
              "end_line": 4,
              "end_column": 34621,
              "start_byte": 29794,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Name",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 923,
              "start_column": 34627,
              "end_line": 4,
              "end_column": 35175,
              "start_byte": 34627,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 933,
              "start_column": 35181,
              "end_line": 4,
              "end_column": 36854,
              "start_byte": 35181,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 968,
              "start_column": 36860,
              "end_line": 4,
              "end_column": 37146,
              "start_byte": 36860,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 974,
              "start_column": 37152,
              "end_line": 4,
              "end_column": 37537,
              "start_byte": 37152,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Call",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 982,
              "start_column": 37543,
              "end_line": 4,
              "end_column": 38529,
              "start_byte": 37543,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 1006,
              "start_column": 38535,
              "end_line": 4,
              "end_column": 38801,
              "start_byte": 38535,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 1012,
              "start_column": 38807,
              "end_line": 4,
              "end_column": 39277,
              "start_byte": 38807,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "",
              "start_line": 1022,
              "start_column": 39283,
              "end_line": 4,
              "end_column": 41035,
              "start_byte": 39283,
              "end_byte": 4
            },
            {
              "name": "_pytest.pathlib.visit",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):\n            yield from visit(entry.path, recurse)",
              "start_line": 550,
              "start_column": 18105,
              "end_line": 0,
              "end_column": 18564,
              "start_byte": 18105,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1.1 The issue is that since pytest version 6.1.0, symlinked directories are not collected during tests. They are skipped, but previously, they were followed and collected.\n1.2 The issue was caused by a change in the code, where 'follow_symlinks=False' was added, which deviates from the previous behavior.\n1.3 The expected result is that pytest should follow symlinks and collect symlinked directories as it used to do before version 6.1.0.\n1.4 If not provided, the expectation is that symlinked directories should be included in the test collection process.\n1.5 The follow_symlinks argument should be set to True or removed to revert to the previous behavior.\n\n2.1-2.4 Analyzing the given symbols:\n\n- The primary suspect for the issue is the functionality related to the traversal and collection of directories.\n\n- The symbols `_pytest.pathlib.visit` and `_pytest.main.Session.collect` seem significant due to their involvement in directory traversal and collection processes.\n\n- `_pytest.pathlib.visit` directly deals with directory entries and has a `follow_symlinks=False` parameter for directories, which is a clue to the problem.\n",
          "symbols": [
            {
              "name": "_pytest.pathlib.visit",
              "file_path": "src/_pytest/pathlib.py",
              "reason": "This function includes a parameter 'follow_symlinks=False' when checking for directories, which is a direct clue related to the described issue. It needs to be altered to 'follow_symlinks=True' or removed to follow symlinks as expected."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The description of the issue does not immediately relate to assertion rewriting, but to collection behavior involving directory traversal with symlinks.",
            "Similarly to the prior symbol, this focuses on assertion rewriting and does not directly relate to the directory symlink collection problem.",
            "Also relates to assertion processing, which is unrelated to the symlink directory issue.",
            "Concerns boolean operations during assertion rewriting, not relevant to directory issues.",
            "Relates to unary operations during assertion rewriting, not connected to symlink traversal.",
            "Deals with binary operations, which don't relate to directory collection behavior.",
            "Handles calls within assertion rewriting. Also unrelated to directory symlink issues.",
            "Starred expressions in assertions, thus unrelated to symlink problems in directory handling.",
            "Deals with attribute access during assertion rewriting, not related to directory handling.",
            "Handles comparison expressions in assertions, not related to directory collection issues.",
            "`_pytest.pathlib.visit` is highly relevant because it involves directory traversal and the 'follow_symlinks=False' argument aligns with the described problem.",
            "This function deals with recursion in session collection demonstrating importance in the overall directory traversal process. It evaluates whether specific directories should be entered during collection, potentially implicating symlinks, but doesn't directly set 'follow_symlinks'.",
            "`_pytest.main.Session.collect` facilitates an overview of the root of collection processes during testing, including directory argument handling and traversal.",
            "The partition is closely tied to module and file collection patterns rather than directory navigation involving symlinks.",
            "Deals with setting up plugin collections, unrelated as it doesn't deal with directory traversal or symlinks.",
            "Involved in initiating module collection but without explicit impact on symlink following or directory traversal."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/pathlib.py"
        ],
        "symbols": [
          "_pytest.pathlib.visit"
        ],
        "code_spans": {
          "_pytest.main.Session._recurse": {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _recurse(self, direntry: \"os.DirEntry[str]\") -> bool:\n        if direntry.name == \"__pycache__\":\n            return False\n        path = py.path.local(direntry.path)\n        ihook = self.gethookproxy(path.dirpath())\n        if ihook.pytest_ignore_collect(path=path, config=self.config):\n            return False\n        norecursepatterns = self.config.getini(\"norecursedirs\")\n        if any(path.check(fnmatch=pat) for pat in norecursepatterns):\n            return False\n        return True",
            "start_line": 518,
            "start_column": 16811,
            "end_line": 4,
            "end_column": 17305,
            "start_byte": 16811,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self) -> Iterator[Union[nodes.Item, nodes.Collector]]:\n        from _pytest.python import Package\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures.\n        node_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}\n        node_cache2: Dict[\n            Tuple[Type[nodes.Collector], py.path.local], nodes.Collector\n        ] = ({})\n\n        # Keep track of any collected collectors in matchnodes paths, so they\n        # are not collected more than once.\n        matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})\n\n        # Dirnames of pkgs with dunder-init files.\n        pkg_roots: Dict[str, Package] = {}\n\n        for argpath, names in self._initial_parts:\n            self.trace(\"processing argument\", (argpath, names))\n            self.trace.root.indent += 1\n\n            # Start with a Session root, and delve to argpath item (dir or file)\n            # and stack all Packages found on the way.\n            # No point in finding packages when collecting doctests.\n            if not self.config.getoption(\"doctestmodules\", False):\n                pm = self.config.pluginmanager\n                for parent in reversed(argpath.parts()):\n                    if pm._confcutdir and pm._confcutdir.relto(parent):\n                        break\n\n                    if parent.isdir():\n                        pkginit = parent.join(\"__init__.py\")\n                        if pkginit.isfile() and pkginit not in node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    pkg_roots[str(parent)] = col[0]\n                                node_cache1[col[0].fspath] = [col[0]]\n\n            # If it's a directory argument, recurse and look for any Subpackages.\n            # Let the Package collector deal with subnodes, don't collect here.\n            if argpath.check(dir=1):\n                assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n                seen_dirs: Set[py.path.local] = set()\n                for direntry in visit(str(argpath), self._recurse):\n                    if not direntry.is_file():\n                        continue\n\n                    path = py.path.local(direntry.path)\n                    dirpath = path.dirpath()\n\n                    if dirpath not in seen_dirs:\n                        # Collect packages first.\n                        seen_dirs.add(dirpath)\n                        pkginit = dirpath.join(\"__init__.py\")\n                        if pkginit.exists():\n                            for x in self._collectfile(pkginit):\n                                yield x\n                                if isinstance(x, Package):\n                                    pkg_roots[str(dirpath)] = x\n                    if str(dirpath) in pkg_roots:\n                        # Do not collect packages here.\n                        continue\n\n                    for x in self._collectfile(path):\n                        key = (type(x), x.fspath)\n                        if key in node_cache2:\n                            yield node_cache2[key]\n                        else:\n                            node_cache2[key] = x\n                            yield x\n            else:\n                assert argpath.check(file=1)\n\n                if argpath in node_cache1:\n                    col = node_cache1[argpath]\n                else:\n                    collect_root = pkg_roots.get(argpath.dirname, self)\n                    col = collect_root._collectfile(argpath, handle_dupes=False)\n                    if col:\n                        node_cache1[argpath] = col\n\n                matching = []\n                work: List[\n                    Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]\n                ] = [(col, names)]\n                while work:\n                    self.trace(\"matchnodes\", col, names)\n                    self.trace.root.indent += 1\n\n                    matchnodes, matchnames = work.pop()\n                    for node in matchnodes:\n                        if not matchnames:\n                            matching.append(node)\n                            continue\n                        if not isinstance(node, nodes.Collector):\n                            continue\n                        key = (type(node), node.nodeid)\n                        if key in matchnodes_cache:\n                            rep = matchnodes_cache[key]\n                        else:\n                            rep = collect_one_node(node)\n                            matchnodes_cache[key] = rep\n                        if rep.passed:\n                            submatchnodes = []\n                            for r in rep.result:\n                                # TODO: Remove parametrized workaround once collection structure contains\n                                # parametrization.\n                                if (\n                                    r.name == matchnames[0]\n                                    or r.name.split(\"[\")[0] == matchnames[0]\n                                ):\n                                    submatchnodes.append(r)\n                            if submatchnodes:\n                                work.append((submatchnodes, matchnames[1:]))\n                            # XXX Accept IDs that don't have \"()\" for class instances.\n                            elif len(rep.result) == 1 and rep.result[0].name == \"()\":\n                                work.append((rep.result, matchnames))\n                        else:\n                            # Report collection failures here to avoid failing to run some test\n                            # specified in the command line because the module could not be\n                            # imported (#134).\n                            node.ihook.pytest_collectreport(report=rep)\n\n                    self.trace(\"matchnodes finished -> \", len(matching), \"nodes\")\n                    self.trace.root.indent -= 1\n\n                if not matching:\n                    report_arg = \"::\".join((str(argpath), *names))\n                    self._notfound.append((report_arg, col))\n                    continue\n\n                # If __init__.py was the only file requested, then the matched node will be\n                # the corresponding Package, and the first yielded item will be the __init__\n                # Module itself, so just use that. If this special case isn't taken, then all\n                # the files in the package will be yielded.\n                if argpath.basename == \"__init__.py\":\n                    assert isinstance(matching[0], nodes.Collector)\n                    try:\n                        yield next(iter(matching[0].collect()))\n                    except StopIteration:\n                        # The package collects nothing with only an __init__.py\n                        # file in it, which gets ignored by the default\n                        # \"python_files\" option.\n                        pass\n                    continue\n\n                yield from matching\n\n            self.trace.root.indent -= 1",
            "start_line": 633,
            "start_column": 21316,
            "end_line": 4,
            "end_column": 28539,
            "start_byte": 21316,
            "end_byte": 4
          },
          "_pytest.doctest.pytest_collect_file": {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "yle file patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"],\n        help=\"prefixes or glob names for Python test function and method discovery\",\n    )\n    parser.addini(\n        \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
            "start_line": 120,
            "start_column": 3292,
            "end_line": 0,
            "end_column": 3801,
            "start_byte": 3292,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_file": {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "de.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python in",
            "start_line": 276,
            "start_column": 9742,
            "end_line": 0,
            "end_column": 10041,
            "start_byte": 9742,
            "end_byte": 0
          },
          "_pytest.python.pytest_collect_file": {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(\n    path: py.path.local, parent: nodes.Collector\n) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module: Module = ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n        return module\n    return None",
            "start_line": 188,
            "start_column": 6518,
            "end_line": 0,
            "end_column": 7039,
            "start_byte": 6518,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter.generic_visit": {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 801,
            "start_column": 29525,
            "end_line": 4,
            "end_column": 29788,
            "start_byte": 29525,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Assert": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 807,
            "start_column": 29794,
            "end_line": 4,
            "end_column": 34621,
            "start_byte": 29794,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Name": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 923,
            "start_column": 34627,
            "end_line": 4,
            "end_column": 35175,
            "start_byte": 34627,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_BoolOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 933,
            "start_column": 35181,
            "end_line": 4,
            "end_column": 36854,
            "start_byte": 35181,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_UnaryOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 968,
            "start_column": 36860,
            "end_line": 4,
            "end_column": 37146,
            "start_byte": 36860,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_BinOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 974,
            "start_column": 37152,
            "end_line": 4,
            "end_column": 37537,
            "start_byte": 37152,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Call": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 982,
            "start_column": 37543,
            "end_line": 4,
            "end_column": 38529,
            "start_byte": 37543,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Starred": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1006,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38801,
            "start_byte": 38535,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Attribute": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1012,
            "start_column": 38807,
            "end_line": 4,
            "end_column": 39277,
            "start_byte": 38807,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Compare": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "",
            "start_line": 1022,
            "start_column": 39283,
            "end_line": 4,
            "end_column": 41035,
            "start_byte": 39283,
            "end_byte": 4
          },
          "_pytest.pathlib.visit": {
            "name": "_pytest.pathlib.visit",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def visit(\n    path: str, recurse: Callable[[\"os.DirEntry[str]\"], bool]\n) -> Iterator[\"os.DirEntry[str]\"]:\n    \"\"\"Walk a directory recursively, in breadth-first order.\n\n    Entries at each directory level are sorted.\n    \"\"\"\n    entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n    yield from entries\n    for entry in entries:\n        if entry.is_dir(follow_symlinks=False) and recurse(entry):\n            yield from visit(entry.path, recurse)",
            "start_line": 550,
            "start_column": 18105,
            "end_line": 0,
            "end_column": 18564,
            "start_byte": 18105,
            "end_byte": 0
          }
        }
      }
    }
  ]
}