{
    "file_paths": [
        "src/_pytest/mark/expression.py"
    ],
    "symbols": [
        "_pytest.mark.Expression.compile"
    ],
    "code_spans": {
        "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )",
            "start_line": 23,
            "start_column": 602,
            "end_line": 0,
            "end_column": 1394,
            "start_byte": 602,
            "end_byte": 0
        },
        "_pytest.assertion.register_assert_rewrite": {
            "name": "_pytest.assertion.register_assert_rewrite",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)",
            "start_line": 48,
            "start_column": 1397,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1397,
            "end_byte": 0
        },
        "_pytest.assertion.install_importhook": {
            "name": "_pytest.assertion.install_importhook",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook",
            "start_line": 90,
            "start_column": 2868,
            "end_line": 0,
            "end_column": 3498,
            "start_byte": 2868,
            "end_byte": 0
        },
        "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14885,
            "end_line": 0,
            "end_column": 16668,
            "start_byte": 14885,
            "end_byte": 0
        },
        "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.",
            "start_line": 31,
            "start_column": 690,
            "end_line": 0,
            "end_column": 1171,
            "start_byte": 690,
            "end_byte": 0
        },
        "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "writes assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in yo",
            "start_line": 35,
            "start_column": 1034,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 1034,
            "end_byte": 0
        },
        "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "   actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.Ass",
            "start_line": 62,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3147,
            "start_byte": 1713,
            "end_byte": 0
        },
        "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "t util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nod",
            "start_line": 16,
            "start_column": 296,
            "end_line": 0,
            "end_column": 529,
            "start_byte": 296,
            "end_byte": 0
        },
        "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 1404,
            "start_column": 54010,
            "end_line": 0,
            "end_column": 54214,
            "start_byte": 54010,
            "end_byte": 0
        },
        "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = No",
            "start_line": 44,
            "start_column": 1360,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1360,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "write(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_",
            "start_line": 77,
            "start_column": 2424,
            "end_line": 0,
            "end_column": 4052,
            "start_byte": 2424,
            "end_byte": 0
        },
        "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 382,
            "start_column": 13364,
            "end_line": 0,
            "end_column": 14719,
            "start_byte": 13364,
            "end_byte": 0
        },
        "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 194,
            "start_column": 7008,
            "end_line": 0,
            "end_column": 9638,
            "start_byte": 7008,
            "end_byte": 0
        },
        "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == ",
            "start_line": 45,
            "start_column": 1160,
            "end_line": 0,
            "end_column": 5406,
            "start_byte": 1160,
            "end_byte": 0
        },
        "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "{0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collecte",
            "start_line": 63,
            "start_column": 1994,
            "end_line": 0,
            "end_column": 3613,
            "start_byte": 1994,
            "end_byte": 0
        },
        "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"asser",
            "start_line": 17,
            "start_column": 431,
            "end_line": 0,
            "end_column": 775,
            "start_byte": 431,
            "end_byte": 0
        },
        "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "r one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_pat",
            "start_line": 57,
            "start_column": 1461,
            "end_line": 0,
            "end_column": 2088,
            "start_byte": 1461,
            "end_byte": 0
        },
        "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "ook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Gen",
            "start_line": 72,
            "start_column": 2300,
            "end_line": 0,
            "end_column": 3991,
            "start_byte": 2300,
            "end_byte": 0
        },
        "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "pression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n",
            "start_line": 44,
            "start_column": 1120,
            "end_line": 0,
            "end_column": 1447,
            "start_byte": 1120,
            "end_byte": 0
        },
        "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "port assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"sto",
            "start_line": 13,
            "start_column": 336,
            "end_line": 0,
            "end_column": 751,
            "start_byte": 336,
            "end_byte": 0
        },
        "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "te\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECK",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 265,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.a",
            "start_line": 23,
            "start_column": 676,
            "end_line": 0,
            "end_column": 1172,
            "start_byte": 676,
            "end_byte": 0
        },
        "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--as",
            "start_line": 11,
            "start_column": 246,
            "end_line": 0,
            "end_column": 725,
            "start_byte": 246,
            "end_byte": 0
        },
        "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getva",
            "start_line": 107,
            "start_column": 2626,
            "end_line": 0,
            "end_column": 5385,
            "start_byte": 2626,
            "end_byte": 0
        },
        "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # ",
            "start_line": 57,
            "start_column": 1746,
            "end_line": 0,
            "end_column": 2220,
            "start_byte": 1746,
            "end_byte": 0
        },
        "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"",
            "start_line": 17,
            "start_column": 345,
            "end_line": 0,
            "end_column": 677,
            "start_byte": 345,
            "end_byte": 0
        },
        "_pytest.mark.Expression.compile": {
            "name": "_pytest.mark.Expression.compile",
            "file_path": "src/_pytest/mark/expression.py",
            "file_content": "@classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n        )  # type: types.CodeType\n        return Expression(code)",
            "start_line": 194,
            "start_column": 5342,
            "end_line": 4,
            "end_column": 5719,
            "start_byte": 5342,
            "end_byte": 4
        },
        "_pytest._code.Source": {
            "name": "_pytest._code.Source",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "class Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 26,
            "start_column": 499,
            "end_line": 0,
            "end_column": 7563,
            "start_byte": 499,
            "end_byte": 0
        },
        "_pytest._code.Source._compilecounter": {
            "name": "_pytest._code.Source._compilecounter",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "_compilecounter = 0",
            "start_line": 31,
            "start_column": 619,
            "end_line": 4,
            "end_column": 638,
            "start_byte": 619,
            "end_byte": 4
        },
        "_pytest._code.Source.__init__": {
            "name": "_pytest._code.Source.__init__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)",
            "start_line": 33,
            "start_column": 644,
            "end_line": 4,
            "end_column": 1344,
            "start_byte": 644,
            "end_byte": 4
        },
        "_pytest._code.Source.__eq__": {
            "name": "_pytest._code.Source.__eq__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False",
            "start_line": 51,
            "start_column": 1350,
            "end_line": 4,
            "end_column": 1569,
            "start_byte": 1350,
            "end_byte": 4
        },
        "_pytest._code.Source.__hash__": {
            "name": "_pytest._code.Source.__hash__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "__hash__ = None",
            "start_line": 60,
            "start_column": 1648,
            "end_line": 4,
            "end_column": 1663,
            "start_byte": 1648,
            "end_byte": 4
        },
        "_pytest._code.Source.__getitem__": {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource",
            "start_line": 70,
            "start_column": 1910,
            "end_line": 4,
            "end_column": 2313,
            "start_byte": 1910,
            "end_byte": 4
        },
        "_pytest._code.Source.__iter__": {
            "name": "_pytest._code.Source.__iter__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)",
            "start_line": 80,
            "start_column": 2319,
            "end_line": 4,
            "end_column": 2387,
            "start_byte": 2319,
            "end_byte": 4
        },
        "_pytest._code.Source.__len__": {
            "name": "_pytest._code.Source.__len__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __len__(self) -> int:\n        return len(self.lines)",
            "start_line": 83,
            "start_column": 2393,
            "end_line": 4,
            "end_column": 2449,
            "start_byte": 2393,
            "end_byte": 4
        },
        "_pytest._code.Source.strip": {
            "name": "_pytest._code.Source.strip",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source",
            "start_line": 86,
            "start_column": 2455,
            "end_line": 4,
            "end_column": 2889,
            "start_byte": 2455,
            "end_byte": 4
        },
        "_pytest._code.Source.putaround": {
            "name": "_pytest._code.Source.putaround",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource",
            "start_line": 99,
            "start_column": 2895,
            "end_line": 4,
            "end_column": 3373,
            "start_byte": 2895,
            "end_byte": 4
        },
        "_pytest._code.Source.indent": {
            "name": "_pytest._code.Source.indent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource",
            "start_line": 112,
            "start_column": 3379,
            "end_line": 4,
            "end_column": 3675,
            "start_byte": 3379,
            "end_byte": 4
        },
        "_pytest._code.Source.getstatement": {
            "name": "_pytest._code.Source.getstatement",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]",
            "start_line": 120,
            "start_column": 3681,
            "end_line": 4,
            "end_column": 3926,
            "start_byte": 3681,
            "end_byte": 4
        },
        "_pytest._code.Source.getstatementrange": {
            "name": "_pytest._code.Source.getstatementrange",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end",
            "start_line": 127,
            "start_column": 3932,
            "end_line": 4,
            "end_column": 4312,
            "start_byte": 3932,
            "end_byte": 4
        },
        "_pytest._code.Source.deindent": {
            "name": "_pytest._code.Source.deindent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource",
            "start_line": 136,
            "start_column": 4318,
            "end_line": 4,
            "end_column": 4506,
            "start_byte": 4318,
            "end_byte": 4
        },
        "_pytest._code.Source.isparseable": {
            "name": "_pytest._code.Source.isparseable",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True",
            "start_line": 142,
            "start_column": 4512,
            "end_line": 4,
            "end_column": 4945,
            "start_byte": 4512,
            "end_byte": 4
        },
        "_pytest._code.Source.__str__": {
            "name": "_pytest._code.Source.__str__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __str__(self) -> str:\n        return \"\\n\".join(self.lines)",
            "start_line": 157,
            "start_column": 4951,
            "end_line": 4,
            "end_column": 5013,
            "start_byte": 4951,
            "end_byte": 4
        },
        "_pytest._code.Source.compile": {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 182,
            "start_column": 5610,
            "end_line": 4,
            "end_column": 7563,
            "start_byte": 5610,
            "end_byte": 4
        },
        "_pytest._code.compile_": {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)",
            "start_line": 256,
            "start_column": 8115,
            "end_line": 0,
            "end_column": 8947,
            "start_byte": 8115,
            "end_byte": 0
        }
    }
}