{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7324",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:39.670961",
        "usage": "908.5979461669922 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "_CACHE_PREFIX_DIRS",
          "getfirstlinesource",
          "FaultHandlerHooks",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "T",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "pytest",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "_FixtureFunction",
          "rex_session_duration",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "MINUS_K_COLON",
          "accept",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "reprfileloc",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "RPAREN",
          "reprcrash",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "_color_for_type_default",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "pytest_warning_recorded",
          "tmpdir_factory",
          "__slots__",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "clear_cache",
          "_format_boolop",
          "PytestArg",
          "no_re_match_line",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "_WithException",
          "exec_module",
          "LFPluginCollSkipfiles",
          "category",
          "ParseError",
          "builtin_plugins",
          "evalxfail_key",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "handleError",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "Expression",
          "_getscopeitem",
          "SysCapture",
          "MINUS_K_DASH",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "_is_skipped",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "lineno",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "_PluggyPlugin",
          "writer",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Store",
          "Junit",
          "_W",
          "TestReport",
          "_find_spec",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "sections",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "_CACHE_PREFIX_VALUES",
          "showheader",
          "stream",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "_make_plural",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "extraline",
          "_compare_eq_verbose",
          "longrepr",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "_set_main_color",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "width_of_current_line",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "flush",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "finish_recording",
          "TerminalRepr",
          "duration",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "_get_multicapture",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "NODE_USE_FROM_PARENT",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "TERMINALWRITER_WRITER",
          "FakeCollectModule",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "_perform_collect",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "repr",
          "putaround",
          "_factorytraceback",
          "get_terminal_width",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "OR",
          "resolve_from_str",
          "report_collect",
          "_split_lines",
          "cacheshow",
          "_show_fixture_action",
          "_FixtureCachedResult",
          "resume_fixture",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "get_last_failed_paths",
          "exists",
          "write",
          "_write_content",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "_esctable",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "fullwidth",
          "_compare_eq_iterable",
          "COLLECT_DIRECTORY_HOOK",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_fail",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "pos",
          "catch_log_handler_key",
          "node",
          "_names",
          "HookRecorder",
          "_getentrysource",
          "should_do_markup",
          "Scanner",
          "head_line",
          "_FileHandler",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "maybe_wrap_pytest_function_for_tracing",
          "Class",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingNullHandler",
          "_LiveLoggingStreamHandler",
          "sep",
          "fault_handler_stderr_key",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "_get_teardown_reports",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "markup",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "Exception",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "TerminalWriter",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "WARNING_CAPTURED_HOOK",
          "setdefault",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "_validate_ids",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "from_parent",
          "_setupstate",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "CHECKER_CLASS",
          "find_spec",
          "get_statement_startend2",
          "try_makedirs",
          "old_mark_config_key",
          "_for_parametrize",
          "Token",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "from_config",
          "console_main",
          "lex",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "__attrs_post_init__",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "timing",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "JUNIT_XML_DEFAULT_FAMILY",
          "truncate_locals",
          "record_property",
          "reprlocals",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_validatekeys",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "__bool__",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "assertstate_key",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "_AnyPurePath",
          "LFPluginCollWrapper",
          "strip",
          "compile_",
          "pytest_runtestloop",
          "exitstatus",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "evalcache_key",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "_expecting_failure",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_add_stats",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "reprentries",
          "args",
          "_seen",
          "__module__",
          "_get_unknown_ini_keys",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "reject",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "pytest_sessionfinish",
          "fill_unfilled",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "D",
          "errisinstance",
          "_init_checker_class",
          "__exit__",
          "_assert_state",
          "make_properties_node",
          "result",
          "config",
          "_is_last_item",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "reprfuncargs",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "AND",
          "linecomp",
          "scope2index",
          "KNOWN_TYPES",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "__dir__",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "LPAREN",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "IDENT",
          "logging",
          "xml_key",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "invocation_dir",
          "not_expr",
          "get_fslocation_from_item",
          "listoutcomes",
          "EOF",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_FixtureFunc",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "KeywordMatcher",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_NodeType",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "_param_ids_from",
          "id",
          "_FixtureValue",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "_param_ids_generated",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "NotSetType",
          "freeze_includes",
          "unset_fixture",
          "ApproxDecimal",
          "_readline_workaround",
          "lines",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "_write_entry_lines",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "expression",
          "MatcherAdapter",
          "_is_setup_py",
          "pop",
          "TokenType",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "ensure_extended_length_path",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "_Markable",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "_write_pyc_fp",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "TeeCaptureIO",
          "add_property",
          "resultlog_key",
          "get_extended_length_path_str",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "cache_key",
          "TEST_OUTCOME",
          "NOT",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "_F",
          "activate_fixture",
          "catch_log_records_key",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "_has_param_ids",
          "NodeMeta",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_truncate_explanation",
          "_T",
          "get_cache_dir",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "_ensure_relative_to_basetemp",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_check_non_top_pytest_plugins",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_surrounding_parens_on_own_lines",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "ParameterSet",
          "listnames",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "_with_exception",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "_pformat_dispatch",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "and_expr",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "_format",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_color_for_type",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "async_warn_and_skip",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "evaluate",
          "_REPORTCHARS_DEFAULT",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "wcswidth",
          "fnmatch_ex",
          "_Key",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "skipped_by_mark_key",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "token",
          "_istrue",
          "popcall",
          "_no_match_line",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "_highlight",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "_get_auto_indent",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "get_timeout_config_value",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "_gethookproxy",
          "visit_Starred",
          "_ET",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "_HandlerType",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "_parse_filter",
          "ReprFuncArgs",
          "wcwidth",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_handle_teardown_sections",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "start",
          "_write_source",
          "LoggingPlugin",
          "_get_marks",
          "_determine_main_color",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_try_repr_or_str",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "_fixturemanager",
          "is_generator",
          "set_fixture",
          "get_common_ancestor",
          "PdbInvoke",
          "__contains__",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "MarkMatcher",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "_create",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "FILLFUNCARGS",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "store",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "_get_main_color",
          "no_fnmatch_line",
          "MarkGenerator",
          "_R",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "line",
          "StoreKey",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "is_async_function",
          "AlwaysDispatchingPrettyPrinter",
          "print_teardown_sections",
          "wrap_pytest_function_for_tracing",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "_S",
          "maybe_delete_a_numbered_dir",
          "_params_converter",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "pastebinfile_key",
          "getstatementrange",
          "makepyfile",
          "reprtraceback",
          "_is_doctest",
          "SetupState",
          "_prepare_content",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "AssertionRewritingHook",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "_in_suspended",
          "get_default_arg_names",
          "names_closure",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "expr",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "unexpectedsuccess_key",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "_eval_scope_callable",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "Expression",
          "compile_",
          "AssertionRewriter",
          "AssertionRewritingHook",
          "assertion"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:40.579571",
        "usage": "163.1331443786621 ms"
      },
      "request": {
        "tokens": [
          "Expression",
          "compile_",
          "AssertionRewriter",
          "AssertionRewritingHook",
          "assertion"
        ]
      },
      "response": {
        "results": {
          "assertion": [
            "src/_pytest/logging.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/pytest/__init__.py"
          ],
          "AssertionRewritingHook": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py"
          ],
          "Expression": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/mark/expression.py"
          ],
          "compile_": [
            "src/_pytest/_code/source.py",
            "src/_pytest/_code/__init__.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:40.742717",
        "usage": "5587.9669189453125 ms"
      },
      "request": {
        "keyword_search_results": {
          "assertion": [
            "src/_pytest/logging.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/pytest/__init__.py"
          ],
          "AssertionRewritingHook": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py"
          ],
          "Expression": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/mark/expression.py"
          ],
          "compile_": [
            "src/_pytest/_code/source.py",
            "src/_pytest/_code/__init__.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue reported is a Pytest crash related to the assertion failure in the Python interpreter when using Expression.compile(\"False\") method call. The issue particularly concerns the handling of expressions and the re-writing or interpreting of assertions in Pytest.\n\n1. Keywords to consider:\n   - `assertion`: This keyword is highly relevant because the error itself is about a failed assertion. The files related to assertion will likely contain logic which might involve the handling of code that could trigger assertions.\n   - `AssertionRewritingHook` and `AssertionRewriter`: These are highly relevant as they are directly linked with how assertions are processed and rewritten by Pytest. Since the problem involves a crash through expression compilation and assertion handling, these files could contain the crux of the issue.\n   - `Expression` and `compile_`: These keywords are closely related to the Expression.compile call in the bug. Files containing code handling expressions and compilation are potentially involved in the problem.\n\n2. Files to check:\n   - `src/_pytest/assertion/rewrite.py`: This file appears under both `AssertionRewritingHook` and `AssertionRewriter`, implying that it's involved in the assertion rewriting process, which is directly related to the issue.\n   - `src/_pytest/assertion/__init__.py`: This file is mentioned under `AssertionRewritingHook` and `assertion`. It might contain initial setup or crucial components affecting how assertions work.\n   - `src/_pytest/mark/expression.py`: Listed under `Expression`, potentially holds logic for expression handling which may interact with assertions leading to a crash.\n   - `src/_pytest/_code/source.py`: Appears under `compile_`, indicating it might interact with the compilation process that triggers the issue.\n\nFocusing on the most relevant files based on the keywords and their conceptual proximity to the problem seems appropriate.",
        "file_paths": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/__init__.py",
          "src/_pytest/mark/expression.py",
          "src/_pytest/_code/source.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:46.330728",
        "usage": "8790.961027145386 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n    - **Issue Description**: The user reports an issue where the Python debugger (pytest) crashes in a debug build when trying to compile a specific expression (`Expression.compile(\"False\")`). This results in an assertion failure within `Python/compile.c`.\n    - **Cause**: The assertion fails because there might be a direct compilation of prohibited values like the Python keywords \"None\", \"True\", or \"False\" without proper handling.\n    - **Expected Result**: The user might expect the expression to compile without triggering an assertion error, or for there to be more lenient or different handling of such expressions in debug builds.\n    - **How to fix**: The issue is deeply related to Python's compilation mechanics, so if `pytest` is triggering this, it could be due to improper assertion rewriting or module handling during compilation steps.\n\n2. **Review of Provided File (`rewrite.py`):**\n    - \n    - The file provided (rewrite.py) is responsible for rewriting ASTs to improve error messages for assertions. The AssertionRewritingHook is an import hook that rewrites assert statements into more descriptive failures and adds them into a custom format that pytest can handle.\n    - **Potentially Relevant Symbols (based on context and usage):**\n        - `AssertionRewriter` class: This class is responsible for traversing AST nodes and processing assertions in Python code.\n        - `AssertionRewritingHook` class: The whole class deals with finding and rewriting imports and assertions which might relate to the automatic compilation process that could lead to attempts of compiling reserved terms.\n        - `rewrite_asserts()` method: This function is a core part of the rewrite process which directly interacts with AST manipulation.\n        - `_rewrite_test()`: Specifically handles the reading and rewriting of test functions which might encounter the 'False', 'True', 'None' keywords during this process.\n    - **Relationship to Issue**: These parts interact heavily with the compilation and assertion mechanics in pytest.\n    - However, there is no explicit handling in this file for direct compilation of expressions like `Expression.compile()`, suggesting the issue could also be Python internal, or related to how pytest interacts with Python's compilation API.\n\n    Overall, while this file deals heavily with assertions and rewriting, the issue as described seems more fundamental to the compilation step in Python and less about the assertion rewriting process per se. The file likely doesn't directly cause the issue but might indirectly interface with Python's compilation during testing.\n\n3. **Determine File Relevance:**\n    - While this file handles aspects of code that might relate to assertion errors, the specific reported issue ties more closely to how Python handles these functions internally during compilation, not just rewriting for assertion messaging in pytest specifically.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/modes.py",
          "src/_pytest/assertion/truncate.py",
          "src/_pytest/assertion/util.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:55.121725",
        "usage": "6948.339939117432 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/__init__.py"
      },
      "response": {
        "scratch_pad": "### Analysis of the Issue:\n1. **Issue Description:**\n   - The user reported that Pytest crashes the interpreter on a debug build for Python version 3.8+ when executing an expression compilation with `Expression.compile(\"False\")`. The assertion failure happens in the Python core, specifically in the file `Python/compile.c`, and is related to checking that certain names (like \"None\", \"True\", \"False\") do not occur in certain contexts. \n   \n2. **Cause of the Issue:**\n   - The issue is caused by the assertion in the Python compiler checking for invalid usage of reserved keywords, which fails and leads to a crash.\n   - This occurs when using Pytest's assertion rewriting.\n\n3. **Expected Result:**\n   - It is expected that Pytest should not cause such an interpreter crash.\n\n4. **Possible Fix:**\n   - Ensuring that the rewriting process handled by Pytest correctly deals with keyword literals like \"False\", \"True\", and \"None\" perhaps by not rewriting them in situations where the compilation would consider them invalid.\n\n### Evaluation of the `src/_pytest/assertion/__init__.py` file:\n1. **Relevant Symbols and Code:**\n   - Looking at importing and setup of the assertion functionality like `install_importhook()`, `pytest_addoption()`, and `register_assert_rewrite()`, these are crucial for understanding how assertions are handled in Pytest.\n   - The `install_importhook()` function aims to install `AssertionRewritingHook` into `sys.meta_path`, which is relevant since assertion rewriting is a central part of the issue.\n   - `register_assert_rewrite()` is responsible for marking modules for rewriting, which is also crucial.\n   \n2. **Root Cause Positioning:**\n   - This file is related but might not be the direct cause since the assertion rewriting logic itself, possibly within `AssertionRewritingHook`, needs examining.\n\n3. **Connections to Other Components:**\n   - The real cause potentially lies somewhere within the `rewrite` module related to `AssertionRewritingHook`. This part of the codebase needs more investigation.\n",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py"
        ],
        "relevant_symbols": [
          "install_importhook",
          "register_assert_rewrite",
          "pytest_addoption"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:02.070106",
        "usage": "5139.296054840088 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/expression.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue described is a crash in the interpreter when using 'Expression.compile(\"False\")' with pytest, on Python 3.8+\n1.2 This is caused by using LLVM optimizations that may lead to the improper compilation of certain expressions with statically-defined boolean values, such as 'True', 'False', or 'None'.\n1.3 The expected result is that 'Expression.compile(\"False\")' should not crash the interpreter and should handle the expression properly.\n1.4 The expectation should be that 'Expression.compile()' validates and compiles input expressions without causing assertion failures.\n1.5 The issue might be fixed by ensuring that reserved boolean literals ('True', 'False', 'None') are handled properly, either by rejecting them with a clear error message or by adjusting the compile method to not trip the assertion.\n\n2. Make file evaluation:\n2.1 Analyze the content of the provided file.\n2.2 The file 'expression.py' defines a function 'Expression.compile' that compiles a match expression into a Python code object.\n2.3 This method might be related to the issue since the crash occurs during the compilation phase, which is what this method handles.\n2.4 Look for any expression handling of 'False', 'True', 'None' and check for their usage in this component. Additionally, consider how AST nodes are utilized since they could influence how the assertion fails.\n2.5 The lines involving 'compile(ast.expr...)', 'eval(...)', and 'ast.NameConstant(False)' may be of particular interest in diagnosing the cause of crashes.\n2.6 The 'Expression.compile' method likely directly correlates with the crash and is related to the root cause.\n\n3. Output Your Decision:",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Expression.compile"
        ],
        "root_cause_symbols": [
          "Expression.compile"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:07.209428",
        "usage": "5416.006088256836 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/source.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue where pytest crashes the Python interpreter in debug build for versions 3.8+.\n1.2 This issue is caused during the compilation of the expression 'False' where the compiler has an assertion failure.\n1.3 The expected result should be that pytest does not cause a crash in the interpreter when such an expression is compiled.\n1.4 The expectation is that the system should correctly handle the compilation request without assertion failures, possibly by either not passing the reserved keywords for compilation or handling them differently.\n1.5 The fix would likely involve modifying the code that compiles such expressions to prevent it from causing assertion failures with reserved keywords.\n\n2. Make file evaluation:\n2.1-2.2 In the file `src/_pytest/_code/source.py`, the class `Source` and the function `compile_` stand out with relevance to the issue because they involve compiling code snippets.\n2.3-2.4 The `Source.compile` method compiles a source fragment into a code object, which is directly relevant since the issue involves compiling an expression. The method `compile_` also performs compilation and caches the resulting code object, making it pertinent to analyze how expressions are handled during compilation.\n2.5 There are no direct references to other files or symbols in this file that appear explicitly relevant to the assertion failure with \"False\".\n2.6 Based on the provided file content, the root cause might be related to how expressions, specifically \"False\", are passed or handled during the compilation process in the `Source` class or how `compile_` manages the compilation.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Source",
          "Source.compile",
          "compile_"
        ],
        "root_cause_symbols": [
          "Source",
          "Source.compile",
          "compile_"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:12.625484",
        "usage": "169.88492012023926 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/__init__.py",
            "relevant_symbol_keys": [
              "install_importhook",
              "register_assert_rewrite",
              "pytest_addoption"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/mark/expression.py",
            "relevant_symbol_keys": [
              "Expression.compile"
            ],
            "root_cause_symbol_keys": [
              "Expression.compile"
            ]
          },
          {
            "file_path": "src/_pytest/_code/source.py",
            "relevant_symbol_keys": [
              "Source",
              "Source.compile",
              "compile_"
            ],
            "root_cause_symbol_keys": [
              "Source",
              "Source.compile",
              "compile_"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )",
            "start_line": 23,
            "start_column": 602,
            "end_line": 0,
            "end_column": 1394,
            "start_byte": 602,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.register_assert_rewrite",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)",
            "start_line": 48,
            "start_column": 1397,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1397,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.install_importhook",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook",
            "start_line": 90,
            "start_column": 2868,
            "end_line": 0,
            "end_column": 3498,
            "start_byte": 2868,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14885,
            "end_line": 0,
            "end_column": 16668,
            "start_byte": 14885,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.",
            "start_line": 31,
            "start_column": 690,
            "end_line": 0,
            "end_column": 1171,
            "start_byte": 690,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "writes assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in yo",
            "start_line": 35,
            "start_column": 1034,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 1034,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "   actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.Ass",
            "start_line": 62,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3147,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "t util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nod",
            "start_line": 16,
            "start_column": 296,
            "end_line": 0,
            "end_column": 529,
            "start_byte": 296,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 1404,
            "start_column": 54010,
            "end_line": 0,
            "end_column": 54214,
            "start_byte": 54010,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = No",
            "start_line": 44,
            "start_column": 1360,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1360,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "write(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_",
            "start_line": 77,
            "start_column": 2424,
            "end_line": 0,
            "end_column": 4052,
            "start_byte": 2424,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 382,
            "start_column": 13364,
            "end_line": 0,
            "end_column": 14719,
            "start_byte": 13364,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 194,
            "start_column": 7008,
            "end_line": 0,
            "end_column": 9638,
            "start_byte": 7008,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == ",
            "start_line": 45,
            "start_column": 1160,
            "end_line": 0,
            "end_column": 5406,
            "start_byte": 1160,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "{0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collecte",
            "start_line": 63,
            "start_column": 1994,
            "end_line": 0,
            "end_column": 3613,
            "start_byte": 1994,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"asser",
            "start_line": 17,
            "start_column": 431,
            "end_line": 0,
            "end_column": 775,
            "start_byte": 431,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "r one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_pat",
            "start_line": 57,
            "start_column": 1461,
            "end_line": 0,
            "end_column": 2088,
            "start_byte": 1461,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "ook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Gen",
            "start_line": 72,
            "start_column": 2300,
            "end_line": 0,
            "end_column": 3991,
            "start_byte": 2300,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "pression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n",
            "start_line": 44,
            "start_column": 1120,
            "end_line": 0,
            "end_column": 1447,
            "start_byte": 1120,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "port assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"sto",
            "start_line": 13,
            "start_column": 336,
            "end_line": 0,
            "end_column": 751,
            "start_byte": 336,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "te\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECK",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 265,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.a",
            "start_line": 23,
            "start_column": 676,
            "end_line": 0,
            "end_column": 1172,
            "start_byte": 676,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--as",
            "start_line": 11,
            "start_column": 246,
            "end_line": 0,
            "end_column": 725,
            "start_byte": 246,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getva",
            "start_line": 107,
            "start_column": 2626,
            "end_line": 0,
            "end_column": 5385,
            "start_byte": 2626,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # ",
            "start_line": 57,
            "start_column": 1746,
            "end_line": 0,
            "end_column": 2220,
            "start_byte": 1746,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"",
            "start_line": 17,
            "start_column": 345,
            "end_line": 0,
            "end_column": 677,
            "start_byte": 345,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.mark.Expression.compile",
            "file_path": "src/_pytest/mark/expression.py",
            "file_content": "@classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n        )  # type: types.CodeType\n        return Expression(code)",
            "start_line": 194,
            "start_column": 5342,
            "end_line": 4,
            "end_column": 5719,
            "start_byte": 5342,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "class Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 26,
            "start_column": 499,
            "end_line": 0,
            "end_column": 7563,
            "start_byte": 499,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.Source._compilecounter",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "_compilecounter = 0",
            "start_line": 31,
            "start_column": 619,
            "end_line": 4,
            "end_column": 638,
            "start_byte": 619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__init__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)",
            "start_line": 33,
            "start_column": 644,
            "end_line": 4,
            "end_column": 1344,
            "start_byte": 644,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__eq__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False",
            "start_line": 51,
            "start_column": 1350,
            "end_line": 4,
            "end_column": 1569,
            "start_byte": 1350,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__hash__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "__hash__ = None",
            "start_line": 60,
            "start_column": 1648,
            "end_line": 4,
            "end_column": 1663,
            "start_byte": 1648,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()",
            "start_line": 62,
            "start_column": 1685,
            "end_line": 4,
            "end_column": 1774,
            "start_byte": 1685,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()",
            "start_line": 66,
            "start_column": 1780,
            "end_line": 4,
            "end_column": 1904,
            "start_byte": 1780,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource",
            "start_line": 70,
            "start_column": 1910,
            "end_line": 4,
            "end_column": 2313,
            "start_byte": 1910,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__iter__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)",
            "start_line": 80,
            "start_column": 2319,
            "end_line": 4,
            "end_column": 2387,
            "start_byte": 2319,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__len__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __len__(self) -> int:\n        return len(self.lines)",
            "start_line": 83,
            "start_column": 2393,
            "end_line": 4,
            "end_column": 2449,
            "start_byte": 2393,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.strip",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source",
            "start_line": 86,
            "start_column": 2455,
            "end_line": 4,
            "end_column": 2889,
            "start_byte": 2455,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.putaround",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource",
            "start_line": 99,
            "start_column": 2895,
            "end_line": 4,
            "end_column": 3373,
            "start_byte": 2895,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.indent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource",
            "start_line": 112,
            "start_column": 3379,
            "end_line": 4,
            "end_column": 3675,
            "start_byte": 3379,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.getstatement",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]",
            "start_line": 120,
            "start_column": 3681,
            "end_line": 4,
            "end_column": 3926,
            "start_byte": 3681,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.getstatementrange",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end",
            "start_line": 127,
            "start_column": 3932,
            "end_line": 4,
            "end_column": 4312,
            "start_byte": 3932,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.deindent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource",
            "start_line": 136,
            "start_column": 4318,
            "end_line": 4,
            "end_column": 4506,
            "start_byte": 4318,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.isparseable",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True",
            "start_line": 142,
            "start_column": 4512,
            "end_line": 4,
            "end_column": 4945,
            "start_byte": 4512,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__str__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __str__(self) -> str:\n        return \"\\n\".join(self.lines)",
            "start_line": 157,
            "start_column": 4951,
            "end_line": 4,
            "end_column": 5013,
            "start_byte": 4951,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()",
            "start_line": 160,
            "start_column": 5019,
            "end_line": 4,
            "end_column": 5291,
            "start_byte": 5019,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()",
            "start_line": 171,
            "start_column": 5297,
            "end_line": 4,
            "end_column": 5604,
            "start_byte": 5297,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 182,
            "start_column": 5610,
            "end_line": 4,
            "end_column": 7563,
            "start_byte": 5610,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\ndef compile_(\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: \"Literal[0]\" = ...,\n    dont_inherit: int = ...,\n) -> CodeType:\n    raise NotImplementedError()",
            "start_line": 234,
            "start_column": 7604,
            "end_line": 0,
            "end_column": 7839,
            "start_byte": 7604,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\ndef compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: int = ...,\n    dont_inherit: int = ...,\n) -> Union[CodeType, ast.AST]:\n    raise NotImplementedError()",
            "start_line": 245,
            "start_column": 7842,
            "end_line": 0,
            "end_column": 8112,
            "start_byte": 7842,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)",
            "start_line": 256,
            "start_column": 8115,
            "end_line": 0,
            "end_column": 8947,
            "start_byte": 8115,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:12.795376",
        "usage": "6867.99693107605 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )",
            "start_line": 23,
            "start_column": 602,
            "end_line": 0,
            "end_column": 1394,
            "start_byte": 602,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.register_assert_rewrite",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)",
            "start_line": 48,
            "start_column": 1397,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1397,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.install_importhook",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook",
            "start_line": 90,
            "start_column": 2868,
            "end_line": 0,
            "end_column": 3498,
            "start_byte": 2868,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14885,
            "end_line": 0,
            "end_column": 16668,
            "start_byte": 14885,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.",
            "start_line": 31,
            "start_column": 690,
            "end_line": 0,
            "end_column": 1171,
            "start_byte": 690,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "writes assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in yo",
            "start_line": 35,
            "start_column": 1034,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 1034,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "   actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.Ass",
            "start_line": 62,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3147,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "t util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nod",
            "start_line": 16,
            "start_column": 296,
            "end_line": 0,
            "end_column": 529,
            "start_byte": 296,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 1404,
            "start_column": 54010,
            "end_line": 0,
            "end_column": 54214,
            "start_byte": 54010,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = No",
            "start_line": 44,
            "start_column": 1360,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1360,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "write(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_",
            "start_line": 77,
            "start_column": 2424,
            "end_line": 0,
            "end_column": 4052,
            "start_byte": 2424,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 382,
            "start_column": 13364,
            "end_line": 0,
            "end_column": 14719,
            "start_byte": 13364,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 194,
            "start_column": 7008,
            "end_line": 0,
            "end_column": 9638,
            "start_byte": 7008,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == ",
            "start_line": 45,
            "start_column": 1160,
            "end_line": 0,
            "end_column": 5406,
            "start_byte": 1160,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "{0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collecte",
            "start_line": 63,
            "start_column": 1994,
            "end_line": 0,
            "end_column": 3613,
            "start_byte": 1994,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"asser",
            "start_line": 17,
            "start_column": 431,
            "end_line": 0,
            "end_column": 775,
            "start_byte": 431,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "r one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_pat",
            "start_line": 57,
            "start_column": 1461,
            "end_line": 0,
            "end_column": 2088,
            "start_byte": 1461,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "ook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Gen",
            "start_line": 72,
            "start_column": 2300,
            "end_line": 0,
            "end_column": 3991,
            "start_byte": 2300,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "pression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n",
            "start_line": 44,
            "start_column": 1120,
            "end_line": 0,
            "end_column": 1447,
            "start_byte": 1120,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "port assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"sto",
            "start_line": 13,
            "start_column": 336,
            "end_line": 0,
            "end_column": 751,
            "start_byte": 336,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "te\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECK",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 265,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.a",
            "start_line": 23,
            "start_column": 676,
            "end_line": 0,
            "end_column": 1172,
            "start_byte": 676,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--as",
            "start_line": 11,
            "start_column": 246,
            "end_line": 0,
            "end_column": 725,
            "start_byte": 246,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getva",
            "start_line": 107,
            "start_column": 2626,
            "end_line": 0,
            "end_column": 5385,
            "start_byte": 2626,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # ",
            "start_line": 57,
            "start_column": 1746,
            "end_line": 0,
            "end_column": 2220,
            "start_byte": 1746,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"",
            "start_line": 17,
            "start_column": 345,
            "end_line": 0,
            "end_column": 677,
            "start_byte": 345,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.mark.Expression.compile",
            "file_path": "src/_pytest/mark/expression.py",
            "file_content": "@classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n        )  # type: types.CodeType\n        return Expression(code)",
            "start_line": 194,
            "start_column": 5342,
            "end_line": 4,
            "end_column": 5719,
            "start_byte": 5342,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "class Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 26,
            "start_column": 499,
            "end_line": 0,
            "end_column": 7563,
            "start_byte": 499,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.Source._compilecounter",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "_compilecounter = 0",
            "start_line": 31,
            "start_column": 619,
            "end_line": 4,
            "end_column": 638,
            "start_byte": 619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__init__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)",
            "start_line": 33,
            "start_column": 644,
            "end_line": 4,
            "end_column": 1344,
            "start_byte": 644,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__eq__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False",
            "start_line": 51,
            "start_column": 1350,
            "end_line": 4,
            "end_column": 1569,
            "start_byte": 1350,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__hash__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "__hash__ = None",
            "start_line": 60,
            "start_column": 1648,
            "end_line": 4,
            "end_column": 1663,
            "start_byte": 1648,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()",
            "start_line": 62,
            "start_column": 1685,
            "end_line": 4,
            "end_column": 1774,
            "start_byte": 1685,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()",
            "start_line": 66,
            "start_column": 1780,
            "end_line": 4,
            "end_column": 1904,
            "start_byte": 1780,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource",
            "start_line": 70,
            "start_column": 1910,
            "end_line": 4,
            "end_column": 2313,
            "start_byte": 1910,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__iter__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)",
            "start_line": 80,
            "start_column": 2319,
            "end_line": 4,
            "end_column": 2387,
            "start_byte": 2319,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__len__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __len__(self) -> int:\n        return len(self.lines)",
            "start_line": 83,
            "start_column": 2393,
            "end_line": 4,
            "end_column": 2449,
            "start_byte": 2393,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.strip",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source",
            "start_line": 86,
            "start_column": 2455,
            "end_line": 4,
            "end_column": 2889,
            "start_byte": 2455,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.putaround",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource",
            "start_line": 99,
            "start_column": 2895,
            "end_line": 4,
            "end_column": 3373,
            "start_byte": 2895,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.indent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource",
            "start_line": 112,
            "start_column": 3379,
            "end_line": 4,
            "end_column": 3675,
            "start_byte": 3379,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.getstatement",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]",
            "start_line": 120,
            "start_column": 3681,
            "end_line": 4,
            "end_column": 3926,
            "start_byte": 3681,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.getstatementrange",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end",
            "start_line": 127,
            "start_column": 3932,
            "end_line": 4,
            "end_column": 4312,
            "start_byte": 3932,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.deindent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource",
            "start_line": 136,
            "start_column": 4318,
            "end_line": 4,
            "end_column": 4506,
            "start_byte": 4318,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.isparseable",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True",
            "start_line": 142,
            "start_column": 4512,
            "end_line": 4,
            "end_column": 4945,
            "start_byte": 4512,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.__str__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __str__(self) -> str:\n        return \"\\n\".join(self.lines)",
            "start_line": 157,
            "start_column": 4951,
            "end_line": 4,
            "end_column": 5013,
            "start_byte": 4951,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()",
            "start_line": 160,
            "start_column": 5019,
            "end_line": 4,
            "end_column": 5291,
            "start_byte": 5019,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()",
            "start_line": 171,
            "start_column": 5297,
            "end_line": 4,
            "end_column": 5604,
            "start_byte": 5297,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 182,
            "start_column": 5610,
            "end_line": 4,
            "end_column": 7563,
            "start_byte": 5610,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload\ndef compile_(\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: \"Literal[0]\" = ...,\n    dont_inherit: int = ...,\n) -> CodeType:\n    raise NotImplementedError()",
            "start_line": 234,
            "start_column": 7604,
            "end_line": 0,
            "end_column": 7839,
            "start_byte": 7604,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "@overload  # noqa: F811\ndef compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: int = ...,\n    dont_inherit: int = ...,\n) -> Union[CodeType, ast.AST]:\n    raise NotImplementedError()",
            "start_line": 245,
            "start_column": 7842,
            "end_line": 0,
            "end_column": 8112,
            "start_byte": 7842,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)",
            "start_line": 256,
            "start_column": 8115,
            "end_line": 0,
            "end_column": 8947,
            "start_byte": 8115,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "Analyzing the issue...\n1. The issue described is related to Python crashing when using `Expression.compile(\"False\")`. This is due to an assertion in the Python compiler that certain names should not be present in expressions being compiled.\n2. The crash happens because this code path is being hit in a way that Python doesn't expect, possibly due to Pytest's handling of expressions/leverage of Python's built-in compile.\n3. The expected behavior is that the code should handle expressions like \"False\" without triggering an assertion error in the Python runtime.\n4. If not stated explicitly, the expectation is that the compile method should handle expressions in a way that respects Python's internal rules without crashing.\n5. The resolution involves ensuring that forbidden names like \"False\" are handled upfront before passing to Python's compile.\n\nEvaluating the symbols provided:\n- `_pytest.mark.Expression.compile`:\n  - The primary suspect for needing change, as it is the entry point where the incorrect compile invocation happens.\n  - Would need to inspect/check the input expression and reject or modify as appropriate before handing it off to compile.\n\nOther symbols provided seem to have less relevance as they deal with other aspects of pytest's functionality like assertion handling, logging, or helper utilities. The issue is specific to expression compilation, so they might not require changes directly related to this bug.",
        "symbols": [
          {
            "name": "_pytest.mark.Expression.compile",
            "file_path": "src/_pytest/mark/expression.py",
            "reason": "`Expression.compile` directly uses Python's compile, which triggers the assertion. This function needs to handle or sanitize the input expression to prevent forbidden names from reaching the raw compile call."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The `_pytest.mark.Expression.compile` method is critically related to the reported issue, as it is directly calling Python's `compile` with an input that triggers the assertion error about special constant names. It may need to filter or handle `input` to prevent invalid constants usage.",
          "The rest of the symbols appear to be unrelated to direct issue at hand, as they concern other utilities or functionalities in pytest unrelated to the `Expression.compile`. Their modification seems unnecessary unless found to specifically process expression strings given to `compile` in some indirect manner."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:19.663399",
        "usage": "2.8960704803466797 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )",
              "start_line": 23,
              "start_column": 602,
              "end_line": 0,
              "end_column": 1394,
              "start_byte": 602,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.register_assert_rewrite",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "def register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)",
              "start_line": 48,
              "start_column": 1397,
              "end_line": 0,
              "end_column": 2437,
              "start_byte": 1397,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.install_importhook",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook",
              "start_line": 90,
              "start_column": 2868,
              "end_line": 0,
              "end_column": 3498,
              "start_byte": 2868,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 398,
              "start_column": 14885,
              "end_line": 0,
              "end_column": 16668,
              "start_byte": 14885,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.",
              "start_line": 31,
              "start_column": 690,
              "end_line": 0,
              "end_column": 1171,
              "start_byte": 690,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "writes assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in yo",
              "start_line": 35,
              "start_column": 1034,
              "end_line": 0,
              "end_column": 1748,
              "start_byte": 1034,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "   actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.Ass",
              "start_line": 62,
              "start_column": 1713,
              "end_line": 0,
              "end_column": 3147,
              "start_byte": 1713,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "t util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nod",
              "start_line": 16,
              "start_column": 296,
              "end_line": 0,
              "end_column": 529,
              "start_byte": 296,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 1404,
              "start_column": 54010,
              "end_line": 0,
              "end_column": 54214,
              "start_byte": 54010,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = No",
              "start_line": 44,
              "start_column": 1360,
              "end_line": 0,
              "end_column": 2813,
              "start_byte": 1360,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "write(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_",
              "start_line": 77,
              "start_column": 2424,
              "end_line": 0,
              "end_column": 4052,
              "start_byte": 2424,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 382,
              "start_column": 13364,
              "end_line": 0,
              "end_column": 14719,
              "start_byte": 13364,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "",
              "start_line": 194,
              "start_column": 7008,
              "end_line": 0,
              "end_column": 9638,
              "start_byte": 7008,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == ",
              "start_line": 45,
              "start_column": 1160,
              "end_line": 0,
              "end_column": 5406,
              "start_byte": 1160,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "{0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collecte",
              "start_line": 63,
              "start_column": 1994,
              "end_line": 0,
              "end_column": 3613,
              "start_byte": 1994,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"asser",
              "start_line": 17,
              "start_column": 431,
              "end_line": 0,
              "end_column": 775,
              "start_byte": 431,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "r one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_pat",
              "start_line": 57,
              "start_column": 1461,
              "end_line": 0,
              "end_column": 2088,
              "start_byte": 1461,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "ook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Gen",
              "start_line": 72,
              "start_column": 2300,
              "end_line": 0,
              "end_column": 3991,
              "start_byte": 2300,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "pression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n",
              "start_line": 44,
              "start_column": 1120,
              "end_line": 0,
              "end_column": 1447,
              "start_byte": 1120,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "port assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"sto",
              "start_line": 13,
              "start_column": 336,
              "end_line": 0,
              "end_column": 751,
              "start_byte": 336,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "te\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECK",
              "start_line": 11,
              "start_column": 265,
              "end_line": 0,
              "end_column": 558,
              "start_byte": 265,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.a",
              "start_line": 23,
              "start_column": 676,
              "end_line": 0,
              "end_column": 1172,
              "start_byte": 676,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "rtion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--as",
              "start_line": 11,
              "start_column": 246,
              "end_line": 0,
              "end_column": 725,
              "start_byte": 246,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getva",
              "start_line": 107,
              "start_column": 2626,
              "end_line": 0,
              "end_column": 5385,
              "start_byte": 2626,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # ",
              "start_line": 57,
              "start_column": 1746,
              "end_line": 0,
              "end_column": 2220,
              "start_byte": 1746,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/assertion/__init__.py",
              "file_content": "rtstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"",
              "start_line": 17,
              "start_column": 345,
              "end_line": 0,
              "end_column": 677,
              "start_byte": 345,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.mark.Expression.compile",
              "file_path": "src/_pytest/mark/expression.py",
              "file_content": "@classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n        )  # type: types.CodeType\n        return Expression(code)",
              "start_line": 194,
              "start_column": 5342,
              "end_line": 4,
              "end_column": 5719,
              "start_byte": 5342,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "class Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
              "start_line": 26,
              "start_column": 499,
              "end_line": 0,
              "end_column": 7563,
              "start_byte": 499,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.Source._compilecounter",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "_compilecounter = 0",
              "start_line": 31,
              "start_column": 619,
              "end_line": 4,
              "end_column": 638,
              "start_byte": 619,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__init__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)",
              "start_line": 33,
              "start_column": 644,
              "end_line": 4,
              "end_column": 1344,
              "start_byte": 644,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__eq__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False",
              "start_line": 51,
              "start_column": 1350,
              "end_line": 4,
              "end_column": 1569,
              "start_byte": 1350,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__hash__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "__hash__ = None",
              "start_line": 60,
              "start_column": 1648,
              "end_line": 4,
              "end_column": 1663,
              "start_byte": 1648,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__getitem__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()",
              "start_line": 62,
              "start_column": 1685,
              "end_line": 4,
              "end_column": 1774,
              "start_byte": 1685,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__getitem__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()",
              "start_line": 66,
              "start_column": 1780,
              "end_line": 4,
              "end_column": 1904,
              "start_byte": 1780,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__getitem__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource",
              "start_line": 70,
              "start_column": 1910,
              "end_line": 4,
              "end_column": 2313,
              "start_byte": 1910,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__iter__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)",
              "start_line": 80,
              "start_column": 2319,
              "end_line": 4,
              "end_column": 2387,
              "start_byte": 2319,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__len__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __len__(self) -> int:\n        return len(self.lines)",
              "start_line": 83,
              "start_column": 2393,
              "end_line": 4,
              "end_column": 2449,
              "start_byte": 2393,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.strip",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source",
              "start_line": 86,
              "start_column": 2455,
              "end_line": 4,
              "end_column": 2889,
              "start_byte": 2455,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.putaround",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource",
              "start_line": 99,
              "start_column": 2895,
              "end_line": 4,
              "end_column": 3373,
              "start_byte": 2895,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.indent",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource",
              "start_line": 112,
              "start_column": 3379,
              "end_line": 4,
              "end_column": 3675,
              "start_byte": 3379,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.getstatement",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]",
              "start_line": 120,
              "start_column": 3681,
              "end_line": 4,
              "end_column": 3926,
              "start_byte": 3681,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.getstatementrange",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end",
              "start_line": 127,
              "start_column": 3932,
              "end_line": 4,
              "end_column": 4312,
              "start_byte": 3932,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.deindent",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource",
              "start_line": 136,
              "start_column": 4318,
              "end_line": 4,
              "end_column": 4506,
              "start_byte": 4318,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.isparseable",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True",
              "start_line": 142,
              "start_column": 4512,
              "end_line": 4,
              "end_column": 4945,
              "start_byte": 4512,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.__str__",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def __str__(self) -> str:\n        return \"\\n\".join(self.lines)",
              "start_line": 157,
              "start_column": 4951,
              "end_line": 4,
              "end_column": 5013,
              "start_byte": 4951,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.compile",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()",
              "start_line": 160,
              "start_column": 5019,
              "end_line": 4,
              "end_column": 5291,
              "start_byte": 5019,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.compile",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()",
              "start_line": 171,
              "start_column": 5297,
              "end_line": 4,
              "end_column": 5604,
              "start_byte": 5297,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.Source.compile",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
              "start_line": 182,
              "start_column": 5610,
              "end_line": 4,
              "end_column": 7563,
              "start_byte": 5610,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.compile_",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload\ndef compile_(\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: \"Literal[0]\" = ...,\n    dont_inherit: int = ...,\n) -> CodeType:\n    raise NotImplementedError()",
              "start_line": 234,
              "start_column": 7604,
              "end_line": 0,
              "end_column": 7839,
              "start_byte": 7604,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.compile_",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "@overload  # noqa: F811\ndef compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = ...,\n    mode: str = ...,\n    flags: int = ...,\n    dont_inherit: int = ...,\n) -> Union[CodeType, ast.AST]:\n    raise NotImplementedError()",
              "start_line": 245,
              "start_column": 7842,
              "end_line": 0,
              "end_column": 8112,
              "start_byte": 7842,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.compile_",
              "file_path": "src/_pytest/_code/source.py",
              "file_content": "def compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)",
              "start_line": 256,
              "start_column": 8115,
              "end_line": 0,
              "end_column": 8947,
              "start_byte": 8115,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Analyzing the issue...\n1. The issue described is related to Python crashing when using `Expression.compile(\"False\")`. This is due to an assertion in the Python compiler that certain names should not be present in expressions being compiled.\n2. The crash happens because this code path is being hit in a way that Python doesn't expect, possibly due to Pytest's handling of expressions/leverage of Python's built-in compile.\n3. The expected behavior is that the code should handle expressions like \"False\" without triggering an assertion error in the Python runtime.\n4. If not stated explicitly, the expectation is that the compile method should handle expressions in a way that respects Python's internal rules without crashing.\n5. The resolution involves ensuring that forbidden names like \"False\" are handled upfront before passing to Python's compile.\n\nEvaluating the symbols provided:\n- `_pytest.mark.Expression.compile`:\n  - The primary suspect for needing change, as it is the entry point where the incorrect compile invocation happens.\n  - Would need to inspect/check the input expression and reject or modify as appropriate before handing it off to compile.\n\nOther symbols provided seem to have less relevance as they deal with other aspects of pytest's functionality like assertion handling, logging, or helper utilities. The issue is specific to expression compilation, so they might not require changes directly related to this bug.",
          "symbols": [
            {
              "name": "_pytest.mark.Expression.compile",
              "file_path": "src/_pytest/mark/expression.py",
              "reason": "`Expression.compile` directly uses Python's compile, which triggers the assertion. This function needs to handle or sanitize the input expression to prevent forbidden names from reaching the raw compile call."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The `_pytest.mark.Expression.compile` method is critically related to the reported issue, as it is directly calling Python's `compile` with an input that triggers the assertion error about special constant names. It may need to filter or handle `input` to prevent invalid constants usage.",
            "The rest of the symbols appear to be unrelated to direct issue at hand, as they concern other utilities or functionalities in pytest unrelated to the `Expression.compile`. Their modification seems unnecessary unless found to specifically process expression strings given to `compile` in some indirect manner."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/mark/expression.py"
        ],
        "symbols": [
          "_pytest.mark.Expression.compile"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )",
            "start_line": 23,
            "start_column": 602,
            "end_line": 0,
            "end_column": 1394,
            "start_byte": 602,
            "end_byte": 0
          },
          "_pytest.assertion.register_assert_rewrite": {
            "name": "_pytest.assertion.register_assert_rewrite",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)",
            "start_line": 48,
            "start_column": 1397,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1397,
            "end_byte": 0
          },
          "_pytest.assertion.install_importhook": {
            "name": "_pytest.assertion.install_importhook",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "def install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook",
            "start_line": 90,
            "start_column": 2868,
            "end_line": 0,
            "end_column": 3498,
            "start_byte": 2868,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14885,
            "end_line": 0,
            "end_column": 16668,
            "start_byte": 14885,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.",
            "start_line": 31,
            "start_column": 690,
            "end_line": 0,
            "end_column": 1171,
            "start_byte": 690,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "writes assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in yo",
            "start_line": 35,
            "start_column": 1034,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 1034,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "   actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.Ass",
            "start_line": 62,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3147,
            "start_byte": 1713,
            "end_byte": 0
          },
          "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "t util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nod",
            "start_line": 16,
            "start_column": 296,
            "end_line": 0,
            "end_column": 529,
            "start_byte": 296,
            "end_byte": 0
          },
          "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 1404,
            "start_column": 54010,
            "end_line": 0,
            "end_column": 54214,
            "start_byte": 54010,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = No",
            "start_line": 44,
            "start_column": 1360,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1360,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "write(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_",
            "start_line": 77,
            "start_column": 2424,
            "end_line": 0,
            "end_column": 4052,
            "start_byte": 2424,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 382,
            "start_column": 13364,
            "end_line": 0,
            "end_column": 14719,
            "start_byte": 13364,
            "end_byte": 0
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "",
            "start_line": 194,
            "start_column": 7008,
            "end_line": 0,
            "end_column": 9638,
            "start_byte": 7008,
            "end_byte": 0
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n    \"\"\"Register one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getvalue(\"assertmode\") == ",
            "start_line": 45,
            "start_column": 1160,
            "end_line": 0,
            "end_column": 5406,
            "start_byte": 1160,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "{0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # TODO(typing): Add a protocol for mark_rewrite() and use it\n        # for importhook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collecte",
            "start_line": 63,
            "start_column": 1994,
            "end_line": 0,
            "end_column": 3613,
            "start_byte": 1994,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"asser",
            "start_line": 17,
            "start_column": 431,
            "end_line": 0,
            "end_column": 775,
            "start_byte": 431,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "r one or more module names to be rewritten on import.\n\n    This function will make sure that this module or all modules inside\n    the package will get their assert statements rewritten.\n    Thus you should make sure to call this before the module is\n    actually imported, usually in your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_pat",
            "start_line": 57,
            "start_column": 1461,
            "end_line": 0,
            "end_column": 2088,
            "start_byte": 1461,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "ook and for PytestPluginManager.rewrite_hook.\n        importhook = DummyRewriteHook()  # type: ignore\n    importhook.mark_rewrite(*names)\n\n\nclass DummyRewriteHook:\n    \"\"\"A no-op import hook for when rewriting is disabled.\"\"\"\n\n    def mark_rewrite(self, *names: str) -> None:\n        pass\n\n\nclass AssertionState:\n    \"\"\"State for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Gen",
            "start_line": 72,
            "start_column": 2300,
            "end_line": 0,
            "end_column": 3991,
            "start_byte": 2300,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "pression information.\"\n        ),\n    )\n    parser.addini(\n        \"enable_assertion_pass_hook\",\n        type=\"bool\",\n        default=False,\n        help=\"Enables the pytest_assertion_pass hook.\"\n        \"Make sure to delete any previously generated pyc cache files.\",\n    )\n\n\ndef register_assert_rewrite(*names: str) -> None:\n",
            "start_line": 44,
            "start_column": 1120,
            "end_line": 0,
            "end_column": 1447,
            "start_byte": 1120,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "port assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"sto",
            "start_line": 13,
            "start_column": 336,
            "end_line": 0,
            "end_column": 751,
            "start_byte": 336,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "te\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECK",
            "start_line": 11,
            "start_column": 265,
            "end_line": 0,
            "end_column": 558,
            "start_byte": 265,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "\"debugconfig\")\n    group.addoption(\n        \"--assert\",\n        action=\"store\",\n        dest=\"assertmode\",\n        choices=(\"rewrite\", \"plain\"),\n        default=\"rewrite\",\n        metavar=\"MODE\",\n        help=(\n            \"Control assertion debugging tools.\\n\"\n            \"'plain' performs no assertion debugging.\\n\"\n            \"'rewrite' (the default) rewrites assert statements in test modules\"\n            \" on import to provide assert expression information.\"\n        ),\n    )\n    parser.a",
            "start_line": 23,
            "start_column": 676,
            "end_line": 0,
            "end_column": 1172,
            "start_byte": 676,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtion import truncate\nfrom _pytest.assertion import util\nfrom _pytest.assertion.rewrite import assertstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"debugconfig\")\n    group.addoption(\n        \"--as",
            "start_line": 11,
            "start_column": 246,
            "end_line": 0,
            "end_column": 725,
            "start_byte": 246,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "for the assertion plugin.\"\"\"\n\n    def __init__(self, config: Config, mode) -> None:\n        self.mode = mode\n        self.trace = config.trace.root.get(\"assertion\")\n        self.hook = None  # type: Optional[rewrite.AssertionRewritingHook]\n\n\ndef install_importhook(config: Config) -> rewrite.AssertionRewritingHook:\n    \"\"\"Try to install the rewrite hook, raise SystemError if it fails.\"\"\"\n    config._store[assertstate_key] = AssertionState(config, \"rewrite\")\n    config._store[assertstate_key].hook = hook = rewrite.AssertionRewritingHook(config)\n    sys.meta_path.insert(0, hook)\n    config._store[assertstate_key].trace(\"installed rewrite import hook\")\n\n    def undo() -> None:\n        hook = config._store[assertstate_key].hook\n        if hook is not None and hook in sys.meta_path:\n            sys.meta_path.remove(hook)\n\n    config.add_cleanup(undo)\n    return hook\n\n\ndef pytest_collection(session: \"Session\") -> None:\n    # this hook is only called when test modules are collected\n    # so for example not in the master process of pytest-xdist\n    # (which does not collect test modules)\n    assertstate = session.config._store.get(assertstate_key, None)\n    if assertstate:\n        if assertstate.hook is not None:\n            assertstate.hook.set_session(session)\n\n\n@hookimpl(tryfirst=True, hookwrapper=True)\ndef pytest_runtest_protocol(item: Item) -> Generator[None, None, None]:\n    \"\"\"Setup the pytest_assertrepr_compare and pytest_assertion_pass hooks\n\n    The rewrite module will use util._reprcompare if\n    it exists to use custom reporting via the\n    pytest_assertrepr_compare hook.  This sets up this custom\n    comparison for the test.\n    \"\"\"\n\n    def callbinrepr(op, left: object, right: object) -> Optional[str]:\n        \"\"\"Call the pytest_assertrepr_compare hook and prepare the result\n\n        This uses the first result from the hook and then ensures the\n        following:\n        * Overly verbose explanations are truncated unless configured otherwise\n          (eg. if running in verbose mode).\n        * Embedded newlines are escaped to help util.format_explanation()\n          later.\n        * If the rewrite mode is used embedded %-characters are replaced\n          to protect later % formatting.\n\n        The result can be formatted by util.format_explanation() for\n        pretty printing.\n        \"\"\"\n        hook_result = item.ihook.pytest_assertrepr_compare(\n            config=item.config, op=op, left=left, right=right\n        )\n        for new_expl in hook_result:\n            if new_expl:\n                new_expl = truncate.truncate_if_required(new_expl, item)\n                new_expl = [line.replace(\"\\n\", \"\\\\n\") for line in new_expl]\n                res = \"\\n~\".join(new_expl)\n                if item.config.getva",
            "start_line": 107,
            "start_column": 2626,
            "end_line": 0,
            "end_column": 5385,
            "start_byte": 2626,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "your __init__.py if you are a plugin\n    using a package.\n\n    :raise TypeError: if the given module names are not strings.\n    \"\"\"\n    for name in names:\n        if not isinstance(name, str):\n            msg = \"expected module names as *args, got {0} instead\"\n            raise TypeError(msg.format(repr(names)))\n    for hook in sys.meta_path:\n        if isinstance(hook, rewrite.AssertionRewritingHook):\n            importhook = hook\n            break\n    else:\n        # ",
            "start_line": 57,
            "start_column": 1746,
            "end_line": 0,
            "end_column": 2220,
            "start_byte": 1746,
            "end_byte": 0
          },
          "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/assertion/__init__.py",
            "file_content": "rtstate_key\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import hookimpl\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.nodes import Item\n\nif TYPE_CHECKING:\n    from _pytest.main import Session\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"",
            "start_line": 17,
            "start_column": 345,
            "end_line": 0,
            "end_column": 677,
            "start_byte": 345,
            "end_byte": 0
          },
          "_pytest.mark.Expression.compile": {
            "name": "_pytest.mark.Expression.compile",
            "file_path": "src/_pytest/mark/expression.py",
            "file_content": "@classmethod\n    def compile(self, input: str) -> \"Expression\":\n        \"\"\"Compile a match expression.\n\n        :param input: The input expression - one line.\n        \"\"\"\n        astexpr = expression(Scanner(input))\n        code = compile(\n            astexpr, filename=\"<pytest match expression>\", mode=\"eval\",\n        )  # type: types.CodeType\n        return Expression(code)",
            "start_line": 194,
            "start_column": 5342,
            "end_line": 4,
            "end_column": 5719,
            "start_byte": 5342,
            "end_byte": 4
          },
          "_pytest._code.Source": {
            "name": "_pytest._code.Source",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "class Source:\n    \"\"\" an immutable object holding a source code fragment,\n        possibly deindenting it.\n    \"\"\"\n\n    _compilecounter = 0\n\n    def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)\n\n    def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False\n\n    # Ignore type because of https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    @overload\n    def __getitem__(self, key: int) -> str:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __getitem__(self, key: slice) -> \"Source\":  # noqa: F811\n        raise NotImplementedError()\n\n    def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)\n\n    def __len__(self) -> int:\n        return len(self.lines)\n\n    def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source\n\n    def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource\n\n    def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource\n\n    def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]\n\n    def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end\n\n    def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource\n\n    def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True\n\n    def __str__(self) -> str:\n        return \"\\n\".join(self.lines)\n\n    @overload\n    def compile(\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: \"Literal[0]\" = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> CodeType:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = ...,\n        mode: str = ...,\n        flag: int = ...,\n        dont_inherit: int = ...,\n        _genframe: Optional[FrameType] = ...,\n    ) -> Union[CodeType, ast.AST]:\n        raise NotImplementedError()\n\n    def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 26,
            "start_column": 499,
            "end_line": 0,
            "end_column": 7563,
            "start_byte": 499,
            "end_byte": 0
          },
          "_pytest._code.Source._compilecounter": {
            "name": "_pytest._code.Source._compilecounter",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "_compilecounter = 0",
            "start_line": 31,
            "start_column": 619,
            "end_line": 4,
            "end_column": 638,
            "start_byte": 619,
            "end_byte": 4
          },
          "_pytest._code.Source.__init__": {
            "name": "_pytest._code.Source.__init__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __init__(self, *parts, **kwargs) -> None:\n        self.lines = lines = []  # type: List[str]\n        de = kwargs.get(\"deindent\", True)\n        for part in parts:\n            if not part:\n                partlines = []  # type: List[str]\n            elif isinstance(part, Source):\n                partlines = part.lines\n            elif isinstance(part, (tuple, list)):\n                partlines = [x.rstrip(\"\\n\") for x in part]\n            elif isinstance(part, str):\n                partlines = part.split(\"\\n\")\n            else:\n                partlines = getsource(part, deindent=de).lines\n            if de:\n                partlines = deindent(partlines)\n            lines.extend(partlines)",
            "start_line": 33,
            "start_column": 644,
            "end_line": 4,
            "end_column": 1344,
            "start_byte": 644,
            "end_byte": 4
          },
          "_pytest._code.Source.__eq__": {
            "name": "_pytest._code.Source.__eq__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __eq__(self, other):\n        try:\n            return self.lines == other.lines\n        except AttributeError:\n            if isinstance(other, str):\n                return str(self) == other\n            return False",
            "start_line": 51,
            "start_column": 1350,
            "end_line": 4,
            "end_column": 1569,
            "start_byte": 1350,
            "end_byte": 4
          },
          "_pytest._code.Source.__hash__": {
            "name": "_pytest._code.Source.__hash__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "__hash__ = None",
            "start_line": 60,
            "start_column": 1648,
            "end_line": 4,
            "end_column": 1663,
            "start_byte": 1648,
            "end_byte": 4
          },
          "_pytest._code.Source.__getitem__": {
            "name": "_pytest._code.Source.__getitem__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __getitem__(self, key: Union[int, slice]) -> Union[str, \"Source\"]:  # noqa: F811\n        if isinstance(key, int):\n            return self.lines[key]\n        else:\n            if key.step not in (None, 1):\n                raise IndexError(\"cannot slice a Source with a step\")\n            newsource = Source()\n            newsource.lines = self.lines[key.start : key.stop]\n            return newsource",
            "start_line": 70,
            "start_column": 1910,
            "end_line": 4,
            "end_column": 2313,
            "start_byte": 1910,
            "end_byte": 4
          },
          "_pytest._code.Source.__iter__": {
            "name": "_pytest._code.Source.__iter__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __iter__(self) -> Iterator[str]:\n        return iter(self.lines)",
            "start_line": 80,
            "start_column": 2319,
            "end_line": 4,
            "end_column": 2387,
            "start_byte": 2319,
            "end_byte": 4
          },
          "_pytest._code.Source.__len__": {
            "name": "_pytest._code.Source.__len__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __len__(self) -> int:\n        return len(self.lines)",
            "start_line": 83,
            "start_column": 2393,
            "end_line": 4,
            "end_column": 2449,
            "start_byte": 2393,
            "end_byte": 4
          },
          "_pytest._code.Source.strip": {
            "name": "_pytest._code.Source.strip",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def strip(self) -> \"Source\":\n        \"\"\" return new source object with trailing\n            and leading blank lines removed.\n        \"\"\"\n        start, end = 0, len(self)\n        while start < end and not self.lines[start].strip():\n            start += 1\n        while end > start and not self.lines[end - 1].strip():\n            end -= 1\n        source = Source()\n        source.lines[:] = self.lines[start:end]\n        return source",
            "start_line": 86,
            "start_column": 2455,
            "end_line": 4,
            "end_column": 2889,
            "start_byte": 2455,
            "end_byte": 4
          },
          "_pytest._code.Source.putaround": {
            "name": "_pytest._code.Source.putaround",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def putaround(\n        self, before: str = \"\", after: str = \"\", indent: str = \" \" * 4\n    ) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            'before' and 'after' wrapped around it.\n        \"\"\"\n        beforesource = Source(before)\n        aftersource = Source(after)\n        newsource = Source()\n        lines = [(indent + line) for line in self.lines]\n        newsource.lines = beforesource.lines + lines + aftersource.lines\n        return newsource",
            "start_line": 99,
            "start_column": 2895,
            "end_line": 4,
            "end_column": 3373,
            "start_byte": 2895,
            "end_byte": 4
          },
          "_pytest._code.Source.indent": {
            "name": "_pytest._code.Source.indent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def indent(self, indent: str = \" \" * 4) -> \"Source\":\n        \"\"\" return a copy of the source object with\n            all lines indented by the given indent-string.\n        \"\"\"\n        newsource = Source()\n        newsource.lines = [(indent + line) for line in self.lines]\n        return newsource",
            "start_line": 112,
            "start_column": 3379,
            "end_line": 4,
            "end_column": 3675,
            "start_byte": 3379,
            "end_byte": 4
          },
          "_pytest._code.Source.getstatement": {
            "name": "_pytest._code.Source.getstatement",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatement(self, lineno: int) -> \"Source\":\n        \"\"\" return Source statement which contains the\n            given linenumber (counted from 0).\n        \"\"\"\n        start, end = self.getstatementrange(lineno)\n        return self[start:end]",
            "start_line": 120,
            "start_column": 3681,
            "end_line": 4,
            "end_column": 3926,
            "start_byte": 3681,
            "end_byte": 4
          },
          "_pytest._code.Source.getstatementrange": {
            "name": "_pytest._code.Source.getstatementrange",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def getstatementrange(self, lineno: int) -> Tuple[int, int]:\n        \"\"\" return (start, end) tuple which spans the minimal\n            statement region which containing the given lineno.\n        \"\"\"\n        if not (0 <= lineno < len(self)):\n            raise IndexError(\"lineno out of range\")\n        ast, start, end = getstatementrange_ast(lineno, self)\n        return start, end",
            "start_line": 127,
            "start_column": 3932,
            "end_line": 4,
            "end_column": 4312,
            "start_byte": 3932,
            "end_byte": 4
          },
          "_pytest._code.Source.deindent": {
            "name": "_pytest._code.Source.deindent",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def deindent(self) -> \"Source\":\n        \"\"\"return a new source object deindented.\"\"\"\n        newsource = Source()\n        newsource.lines[:] = deindent(self.lines)\n        return newsource",
            "start_line": 136,
            "start_column": 4318,
            "end_line": 4,
            "end_column": 4506,
            "start_byte": 4318,
            "end_byte": 4
          },
          "_pytest._code.Source.isparseable": {
            "name": "_pytest._code.Source.isparseable",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def isparseable(self, deindent: bool = True) -> bool:\n        \"\"\" return True if source is parseable, heuristically\n            deindenting it by default.\n        \"\"\"\n        if deindent:\n            source = str(self.deindent())\n        else:\n            source = str(self)\n        try:\n            ast.parse(source)\n        except (SyntaxError, ValueError, TypeError):\n            return False\n        else:\n            return True",
            "start_line": 142,
            "start_column": 4512,
            "end_line": 4,
            "end_column": 4945,
            "start_byte": 4512,
            "end_byte": 4
          },
          "_pytest._code.Source.__str__": {
            "name": "_pytest._code.Source.__str__",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def __str__(self) -> str:\n        return \"\\n\".join(self.lines)",
            "start_line": 157,
            "start_column": 4951,
            "end_line": 4,
            "end_column": 5013,
            "start_byte": 4951,
            "end_byte": 4
          },
          "_pytest._code.Source.compile": {
            "name": "_pytest._code.Source.compile",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile(  # noqa: F811\n        self,\n        filename: Optional[str] = None,\n        mode: str = \"exec\",\n        flag: int = 0,\n        dont_inherit: int = 0,\n        _genframe: Optional[FrameType] = None,\n    ) -> Union[CodeType, ast.AST]:\n        \"\"\" return compiled code object. if filename is None\n            invent an artificial filename which displays\n            the source/line position of the caller frame.\n        \"\"\"\n        if not filename or py.path.local(filename).check(file=0):\n            if _genframe is None:\n                _genframe = sys._getframe(1)  # the caller\n            fn, lineno = _genframe.f_code.co_filename, _genframe.f_lineno\n            base = \"<%d-codegen \" % self._compilecounter\n            self.__class__._compilecounter += 1\n            if not filename:\n                filename = base + \"%s:%d>\" % (fn, lineno)\n            else:\n                filename = base + \"%r %s:%d>\" % (filename, fn, lineno)\n        source = \"\\n\".join(self.lines) + \"\\n\"\n        try:\n            co = compile(source, filename, mode, flag)\n        except SyntaxError as ex:\n            # re-represent syntax errors from parsing python strings\n            msglines = self.lines[: ex.lineno]\n            if ex.offset:\n                msglines.append(\" \" * ex.offset + \"^\")\n            msglines.append(\"(code was compiled probably from here: %s)\" % filename)\n            newex = SyntaxError(\"\\n\".join(msglines))\n            newex.offset = ex.offset\n            newex.lineno = ex.lineno\n            newex.text = ex.text\n            raise newex\n        else:\n            if flag & ast.PyCF_ONLY_AST:\n                assert isinstance(co, ast.AST)\n                return co\n            assert isinstance(co, CodeType)\n            lines = [(x + \"\\n\") for x in self.lines]\n            # Type ignored because linecache.cache is private.\n            linecache.cache[filename] = (1, None, lines, filename)  # type: ignore\n            return co",
            "start_line": 182,
            "start_column": 5610,
            "end_line": 4,
            "end_column": 7563,
            "start_byte": 5610,
            "end_byte": 4
          },
          "_pytest._code.compile_": {
            "name": "_pytest._code.compile_",
            "file_path": "src/_pytest/_code/source.py",
            "file_content": "def compile_(  # noqa: F811\n    source: Union[str, bytes, ast.mod, ast.AST],\n    filename: Optional[str] = None,\n    mode: str = \"exec\",\n    flags: int = 0,\n    dont_inherit: int = 0,\n) -> Union[CodeType, ast.AST]:\n    \"\"\" compile the given source to a raw code object,\n        and maintain an internal cache which allows later\n        retrieval of the source code for the code object\n        and any recursively created code objects.\n    \"\"\"\n    if isinstance(source, ast.AST):\n        # XXX should Source support having AST?\n        assert filename is not None\n        co = compile(source, filename, mode, flags, dont_inherit)\n        assert isinstance(co, (CodeType, ast.AST))\n        return co\n    _genframe = sys._getframe(1)  # the caller\n    s = Source(source)\n    return s.compile(filename, mode, flags, _genframe=_genframe)",
            "start_line": 256,
            "start_column": 8115,
            "end_line": 0,
            "end_column": 8947,
            "start_byte": 8115,
            "end_byte": 0
          }
        }
      }
    }
  ]
}