{
    "file_paths": [
        "src/_pytest/reports.py",
        "src/_pytest/_code/code.py"
    ],
    "symbols": [
        "_pytest.reports.BaseReport._to_json",
        "_pytest.reports.BaseReport._from_json",
        "_pytest._code.ExceptionInfo.getrepr"
    ],
    "code_spans": {
        "_pytest._code.ExceptionInfo": {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
        },
        "_pytest._code.ExceptionInfo._assert_start_repr": {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo._excinfo": {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo._striptext": {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(type=str, default=\"\")",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo._traceback": {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(type=Optional[Traceback], default=None)",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.from_exc_info": {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.from_current": {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.for_later": {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.fill_unfilled": {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.type": {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.value": {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.tb": {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.typename": {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.traceback": {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.__repr__": {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.exconly": {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.errisinstance": {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo._getreprcrash": {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
        },
        "_pytest._code.ExceptionInfo.match": {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
        },
        "_pytest._code.ReprExceptionInfo": {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
        },
        "_pytest._code.ReprExceptionInfo.__init__": {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
        },
        "_pytest._code.ReprExceptionInfo.toterminal": {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
        },
        "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(item, when, log=True, **kwds):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 165,
            "start_column": 4915,
            "end_line": 0,
            "end_column": 5311,
            "start_byte": 4915,
            "end_byte": 0
        },
        "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 176,
            "start_column": 5314,
            "end_line": 0,
            "end_column": 5534,
            "start_byte": 5314,
            "end_byte": 0
        },
        "_pytest.hookspec.pytest_report_to_serializable": {
            "name": "_pytest.hookspec.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": " item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )\n\n\nclass CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n      ",
            "start_line": 380,
            "start_column": 12325,
            "end_line": 0,
            "end_column": 12939,
            "start_byte": 12325,
            "end_byte": 0
        },
        "_pytest.reports.BaseReport._to_json": {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n\n        def disassembled_report(rep):\n            reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n            reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n\n            new_entries = []\n            for entry in reprtraceback[\"reprentries\"]:\n                entry_data = {\n                    \"type\": type(entry).__name__,\n                    \"data\": entry.__dict__.copy(),\n                }\n                for key, value in entry_data[\"data\"].items():\n                    if hasattr(value, \"__dict__\"):\n                        entry_data[\"data\"][key] = value.__dict__.copy()\n                new_entries.append(entry_data)\n\n            reprtraceback[\"reprentries\"] = new_entries\n\n            return {\n                \"reprcrash\": reprcrash,\n                \"reprtraceback\": reprtraceback,\n                \"sections\": rep.longrepr.sections,\n            }\n\n        d = self.__dict__.copy()\n        if hasattr(self.longrepr, \"toterminal\"):\n            if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n                self.longrepr, \"reprcrash\"\n            ):\n                d[\"longrepr\"] = disassembled_report(self)\n            else:\n                d[\"longrepr\"] = str(self.longrepr)\n        else:\n            d[\"longrepr\"] = self.longrepr\n        for name in d:\n            if isinstance(d[name], (py.path.local, Path)):\n                d[name] = str(d[name])\n            elif name == \"result\":\n                d[name] = None  # for now\n        return d",
            "start_line": 153,
            "start_column": 4241,
            "end_line": 4,
            "end_column": 5985,
            "start_byte": 4241,
            "end_byte": 4
        },
        "_pytest.reports.BaseReport._from_json": {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        if reportdict[\"longrepr\"]:\n            if (\n                \"reprcrash\" in reportdict[\"longrepr\"]\n                and \"reprtraceback\" in reportdict[\"longrepr\"]\n            ):\n\n                reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n                reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n\n                unserialized_entries = []\n                reprentry = None\n                for entry_data in reprtraceback[\"reprentries\"]:\n                    data = entry_data[\"data\"]\n                    entry_type = entry_data[\"type\"]\n                    if entry_type == \"ReprEntry\":\n                        reprfuncargs = None\n                        reprfileloc = None\n                        reprlocals = None\n                        if data[\"reprfuncargs\"]:\n                            reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n                        if data[\"reprfileloc\"]:\n                            reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n                        if data[\"reprlocals\"]:\n                            reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n                        reprentry = ReprEntry(\n                            lines=data[\"lines\"],\n                            reprfuncargs=reprfuncargs,\n                            reprlocals=reprlocals,\n                            filelocrepr=reprfileloc,\n                            style=data[\"style\"],\n                        )\n                    elif entry_type == \"ReprEntryNative\":\n                        reprentry = ReprEntryNative(data[\"lines\"])\n                    else:\n                        _report_unserialization_failure(entry_type, cls, reportdict)\n                    unserialized_entries.append(reprentry)\n                reprtraceback[\"reprentries\"] = unserialized_entries\n\n                exception_info = ReprExceptionInfo(\n                    reprtraceback=ReprTraceback(**reprtraceback),\n                    reprcrash=ReprFileLocation(**reprcrash),\n                )\n\n                for section in reportdict[\"longrepr\"][\"sections\"]:\n                    exception_info.addsection(*section)\n                reportdict[\"longrepr\"] = exception_info\n\n        return cls(**reportdict)",
            "start_line": 203,
            "start_column": 5991,
            "end_line": 4,
            "end_column": 8587,
            "start_byte": 5991,
            "end_byte": 4
        },
        "_pytest.reports.TestReport": {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 276,
            "start_column": 9116,
            "end_line": 0,
            "end_column": 12552,
            "start_byte": 9116,
            "end_byte": 0
        },
        "_pytest.reports.TestReport.__test__": {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 281,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 9251,
            "end_byte": 4
        },
        "_pytest.reports.TestReport.__init__": {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 283,
            "start_column": 9273,
            "end_line": 4,
            "end_column": 10859,
            "start_byte": 9273,
            "end_byte": 4
        },
        "_pytest.reports.TestReport.__repr__": {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 332,
            "start_column": 10865,
            "end_line": 4,
            "end_column": 11026,
            "start_byte": 10865,
            "end_byte": 4
        },
        "_pytest.reports.TestReport.from_item_and_call": {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 337,
            "start_column": 11032,
            "end_line": 4,
            "end_column": 12552,
            "start_byte": 11032,
            "end_byte": 4
        },
        "_pytest.reports.pytest_report_to_serializable": {
            "name": "_pytest.reports.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"_report_type\"] = report.__class__.__name__\n        return data",
            "start_line": 410,
            "start_column": 13317,
            "end_line": 0,
            "end_column": 13525,
            "start_byte": 13317,
            "end_byte": 0
        },
        "_pytest.terminal.TerminalReporter": {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content, **markup):\n        self._tw.write(content, **markup)\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n\n    def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n\n    def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)\n\n    def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line\n\n    def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)\n\n    def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n\n    def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)\n\n    def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 217,
            "start_column": 6374,
            "end_line": 0,
            "end_column": 34081,
            "start_byte": 6374,
            "end_byte": 0
        },
        "_pytest.terminal.TerminalReporter.__init__": {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None",
            "start_line": 218,
            "start_column": 6402,
            "end_line": 4,
            "end_column": 7252,
            "start_byte": 6402,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._determine_show_progress_info": {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 242,
            "start_column": 7258,
            "end_line": 4,
            "end_column": 7841,
            "start_byte": 7258,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.verbosity": {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 255,
            "start_column": 7847,
            "end_line": 4,
            "end_column": 7923,
            "start_byte": 7847,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showheader": {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 259,
            "start_column": 7929,
            "end_line": 4,
            "end_column": 7999,
            "start_byte": 7929,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showfspath": {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 269,
            "start_column": 8154,
            "end_line": 4,
            "end_column": 8238,
            "start_byte": 8154,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.showlongtestinfo": {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 273,
            "start_column": 8244,
            "end_line": 4,
            "end_column": 8319,
            "start_byte": 8244,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.hasopt": {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 277,
            "start_column": 8325,
            "end_line": 4,
            "end_column": 8452,
            "start_byte": 8325,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_fspath_result": {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)",
            "start_line": 281,
            "start_column": 8458,
            "end_line": 4,
            "end_column": 9143,
            "start_byte": 8458,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_ensure_prefix": {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 294,
            "start_column": 9149,
            "end_line": 4,
            "end_column": 9449,
            "start_byte": 9149,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.ensure_newline": {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 303,
            "start_column": 9455,
            "end_line": 4,
            "end_column": 9577,
            "start_byte": 9455,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write": {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content, **markup):\n        self._tw.write(content, **markup)",
            "start_line": 308,
            "start_column": 9583,
            "end_line": 4,
            "end_column": 9660,
            "start_byte": 9583,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_line": {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 311,
            "start_column": 9666,
            "end_line": 4,
            "end_column": 9856,
            "start_byte": 9666,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.rewrite": {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 317,
            "start_column": 9862,
            "end_line": 4,
            "end_column": 10480,
            "start_byte": 9862,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.write_sep": {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 335,
            "start_column": 10486,
            "end_line": 4,
            "end_column": 10606,
            "start_byte": 10486,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.section": {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 339,
            "start_column": 10612,
            "end_line": 4,
            "end_column": 10691,
            "start_byte": 10612,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.line": {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 342,
            "start_column": 10697,
            "end_line": 4,
            "end_column": 10756,
            "start_byte": 10697,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_internalerror": {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 345,
            "start_column": 10762,
            "end_line": 4,
            "end_column": 10919,
            "start_byte": 10762,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_warning_captured": {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)",
            "start_line": 350,
            "start_column": 10925,
            "end_line": 4,
            "end_column": 11501,
            "start_byte": 10925,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_plugin_registered": {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 364,
            "start_column": 11507,
            "end_line": 4,
            "end_column": 11882,
            "start_byte": 11507,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_deselected": {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)",
            "start_line": 372,
            "start_column": 11888,
            "end_line": 4,
            "end_column": 11985,
            "start_byte": 11888,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")",
            "start_line": 375,
            "start_column": 11991,
            "end_line": 4,
            "end_column": 12398,
            "start_byte": 11991,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2",
            "start_line": 385,
            "start_column": 12404,
            "end_line": 4,
            "end_column": 14437,
            "start_byte": 12404,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)",
            "start_line": 436,
            "start_column": 14443,
            "end_line": 4,
            "end_column": 15386,
            "start_byte": 14443,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._get_progress_information_message": {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"",
            "start_line": 457,
            "start_column": 15392,
            "end_line": 4,
            "end_column": 16095,
            "start_byte": 15392,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._write_progress_information_filling_space": {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)",
            "start_line": 472,
            "start_column": 16101,
            "end_line": 4,
            "end_column": 16337,
            "start_byte": 16101,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._width_of_current_line": {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line",
            "start_line": 478,
            "start_column": 16343,
            "end_line": 4,
            "end_column": 16666,
            "start_byte": 16343,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collectreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 495,
            "start_column": 16996,
            "end_line": 4,
            "end_column": 17388,
            "start_byte": 16996,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.report_collect": {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 505,
            "start_column": 17394,
            "end_line": 4,
            "end_column": 18778,
            "start_byte": 17394,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_sessionstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 545,
            "start_column": 18784,
            "end_line": 4,
            "end_column": 19889,
            "start_byte": 18784,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks": {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 572,
            "start_column": 19895,
            "end_line": 4,
            "end_column": 20038,
            "start_byte": 19895,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_report_header": {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 577,
            "start_column": 20044,
            "end_line": 4,
            "end_column": 20699,
            "start_byte": 20044,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._printcollecteditems": {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))",
            "start_line": 611,
            "start_column": 21341,
            "end_line": 4,
            "end_column": 22905,
            "start_byte": 21341,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_sessionfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()",
            "start_line": 646,
            "start_column": 22911,
            "end_line": 4,
            "end_column": 23642,
            "start_byte": 22911,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_terminal_summary": {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 667,
            "start_column": 23648,
            "end_line": 4,
            "end_column": 23991,
            "start_byte": 23648,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt": {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 678,
            "start_column": 23997,
            "end_line": 4,
            "end_column": 24112,
            "start_byte": 23997,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.pytest_unconfigure": {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 681,
            "start_column": 24118,
            "end_line": 4,
            "end_column": 24245,
            "start_byte": 24118,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._report_keyboardinterrupt": {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 685,
            "start_column": 24251,
            "end_line": 4,
            "end_column": 24779,
            "start_byte": 24251,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._locationline": {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 699,
            "start_column": 24785,
            "end_line": 4,
            "end_column": 25607,
            "start_byte": 24785,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._getfailureheadline": {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 721,
            "start_column": 25613,
            "end_line": 4,
            "end_column": 25771,
            "start_byte": 25613,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._getcrashline": {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 727,
            "start_column": 25777,
            "end_line": 4,
            "end_column": 26021,
            "start_byte": 25777,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.getreports": {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 739,
            "start_column": 26073,
            "end_line": 4,
            "end_column": 26262,
            "start_byte": 26073,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_warnings": {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 746,
            "start_column": 26268,
            "end_line": 4,
            "end_column": 27912,
            "start_byte": 26268,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_passes": {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)",
            "start_line": 784,
            "start_column": 27918,
            "end_line": 4,
            "end_column": 28435,
            "start_byte": 27918,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.print_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 797,
            "start_column": 28441,
            "end_line": 4,
            "end_column": 28927,
            "start_byte": 28441,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_failures": {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)",
            "start_line": 810,
            "start_column": 28933,
            "end_line": 4,
            "end_column": 29916,
            "start_byte": 28933,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_errors": {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 833,
            "start_column": 29922,
            "end_line": 4,
            "end_column": 30518,
            "start_byte": 29922,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter._outrep_summary": {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 848,
            "start_column": 30524,
            "end_line": 4,
            "end_column": 30981,
            "start_byte": 30524,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.summary_stats": {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)",
            "start_line": 861,
            "start_column": 30987,
            "end_line": 4,
            "end_column": 31418,
            "start_byte": 30987,
            "end_byte": 4
        },
        "_pytest.terminal.TerminalReporter.short_test_summary": {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 872,
            "start_column": 31424,
            "end_line": 4,
            "end_column": 34081,
            "start_byte": 31424,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo": {
            "name": "_pytest._code.FormattedExcinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(default=False)\n    style = attr.ib(default=\"long\")\n    abspath = attr.ib(default=True)\n    tbfilter = attr.ib(default=True)\n    funcargs = attr.ib(default=False)\n    truncate_locals = attr.ib(default=True)\n    chain = attr.ib(default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n\n    def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines\n\n    def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n\n    def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)\n\n    def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline\n\n    def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 607,
            "start_column": 19506,
            "end_line": 0,
            "end_column": 29052,
            "start_byte": 19506,
            "end_byte": 0
        },
        "_pytest._code.FormattedExcinfo.flow_marker": {
            "name": "_pytest._code.FormattedExcinfo.flow_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "flow_marker = \">\"",
            "start_line": 612,
            "start_column": 19646,
            "end_line": 4,
            "end_column": 19663,
            "start_byte": 19646,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.fail_marker": {
            "name": "_pytest._code.FormattedExcinfo.fail_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "fail_marker = \"E\"",
            "start_line": 613,
            "start_column": 19668,
            "end_line": 4,
            "end_column": 19685,
            "start_byte": 19668,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.showlocals": {
            "name": "_pytest._code.FormattedExcinfo.showlocals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "showlocals = attr.ib(default=False)",
            "start_line": 615,
            "start_column": 19691,
            "end_line": 4,
            "end_column": 19726,
            "start_byte": 19691,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.style": {
            "name": "_pytest._code.FormattedExcinfo.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = attr.ib(default=\"long\")",
            "start_line": 616,
            "start_column": 19731,
            "end_line": 4,
            "end_column": 19762,
            "start_byte": 19731,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.abspath": {
            "name": "_pytest._code.FormattedExcinfo.abspath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "abspath = attr.ib(default=True)",
            "start_line": 617,
            "start_column": 19767,
            "end_line": 4,
            "end_column": 19798,
            "start_byte": 19767,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.tbfilter": {
            "name": "_pytest._code.FormattedExcinfo.tbfilter",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "tbfilter = attr.ib(default=True)",
            "start_line": 618,
            "start_column": 19803,
            "end_line": 4,
            "end_column": 19835,
            "start_byte": 19803,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.funcargs": {
            "name": "_pytest._code.FormattedExcinfo.funcargs",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "funcargs = attr.ib(default=False)",
            "start_line": 619,
            "start_column": 19840,
            "end_line": 4,
            "end_column": 19873,
            "start_byte": 19840,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.truncate_locals": {
            "name": "_pytest._code.FormattedExcinfo.truncate_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "truncate_locals = attr.ib(default=True)",
            "start_line": 620,
            "start_column": 19878,
            "end_line": 4,
            "end_column": 19917,
            "start_byte": 19878,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.chain": {
            "name": "_pytest._code.FormattedExcinfo.chain",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "chain = attr.ib(default=True)",
            "start_line": 621,
            "start_column": 19922,
            "end_line": 4,
            "end_column": 19951,
            "start_byte": 19922,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.astcache": {
            "name": "_pytest._code.FormattedExcinfo.astcache",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)",
            "start_line": 622,
            "start_column": 19956,
            "end_line": 4,
            "end_column": 20026,
            "start_byte": 19956,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo._getindent": {
            "name": "_pytest._code.FormattedExcinfo._getindent",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))",
            "start_line": 624,
            "start_column": 20032,
            "end_line": 4,
            "end_column": 20465,
            "start_byte": 20032,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo._getentrysource": {
            "name": "_pytest._code.FormattedExcinfo._getentrysource",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source",
            "start_line": 639,
            "start_column": 20471,
            "end_line": 4,
            "end_column": 20644,
            "start_byte": 20471,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.repr_args": {
            "name": "_pytest._code.FormattedExcinfo.repr_args",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)",
            "start_line": 645,
            "start_column": 20650,
            "end_line": 4,
            "end_column": 20890,
            "start_byte": 20650,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.get_source": {
            "name": "_pytest._code.FormattedExcinfo.get_source",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines",
            "start_line": 652,
            "start_column": 20896,
            "end_line": 4,
            "end_column": 21896,
            "start_byte": 20896,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.get_exconly": {
            "name": "_pytest._code.FormattedExcinfo.get_exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines",
            "start_line": 676,
            "start_column": 21902,
            "end_line": 4,
            "end_column": 22326,
            "start_byte": 21902,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.repr_locals": {
            "name": "_pytest._code.FormattedExcinfo.repr_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)",
            "start_line": 688,
            "start_column": 22332,
            "end_line": 4,
            "end_column": 23498,
            "start_byte": 22332,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.repr_traceback_entry": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 714,
            "start_column": 23504,
            "end_line": 4,
            "end_column": 24777,
            "start_byte": 23504,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo._makepath": {
            "name": "_pytest._code.FormattedExcinfo._makepath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path",
            "start_line": 747,
            "start_column": 24783,
            "end_line": 4,
            "end_column": 25053,
            "start_byte": 24783,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.repr_traceback": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 757,
            "start_column": 25059,
            "end_line": 4,
            "end_column": 25701,
            "start_byte": 25059,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo._truncate_recursive_traceback": {
            "name": "_pytest._code.FormattedExcinfo._truncate_recursive_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline",
            "start_line": 775,
            "start_column": 25707,
            "end_line": 4,
            "end_column": 27387,
            "start_byte": 25707,
            "end_byte": 4
        },
        "_pytest._code.FormattedExcinfo.repr_excinfo": {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 812,
            "start_column": 27393,
            "end_line": 4,
            "end_column": 29052,
            "start_byte": 27393,
            "end_byte": 4
        },
        "_pytest._code.ExceptionChainRepr": {
            "name": "_pytest._code.ExceptionChainRepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ExceptionChainRepr(ExceptionRepr):\n    def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]\n\n    def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 882,
            "start_column": 29762,
            "end_line": 0,
            "end_column": 30319,
            "start_byte": 29762,
            "end_byte": 0
        },
        "_pytest._code.ExceptionChainRepr.__init__": {
            "name": "_pytest._code.ExceptionChainRepr.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]",
            "start_line": 883,
            "start_column": 29807,
            "end_line": 4,
            "end_column": 30068,
            "start_byte": 29807,
            "end_byte": 4
        },
        "_pytest._code.ExceptionChainRepr.toterminal": {
            "name": "_pytest._code.ExceptionChainRepr.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 891,
            "start_column": 30074,
            "end_line": 4,
            "end_column": 30319,
            "start_byte": 30074,
            "end_byte": 4
        },
        "_pytest._code.ReprTraceback": {
            "name": "_pytest._code.ReprTraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTraceback(TerminalRepr):\n    entrysep = \"_ \"\n\n    def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style\n\n    def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 911,
            "start_column": 30623,
            "end_line": 0,
            "end_column": 31451,
            "start_byte": 30623,
            "end_byte": 0
        },
        "_pytest._code.ReprTraceback.entrysep": {
            "name": "_pytest._code.ReprTraceback.entrysep",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "entrysep = \"_ \"",
            "start_line": 912,
            "start_column": 30662,
            "end_line": 4,
            "end_column": 30677,
            "start_byte": 30662,
            "end_byte": 4
        },
        "_pytest._code.ReprTraceback.__init__": {
            "name": "_pytest._code.ReprTraceback.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style",
            "start_line": 914,
            "start_column": 30683,
            "end_line": 4,
            "end_column": 30834,
            "start_byte": 30683,
            "end_byte": 4
        },
        "_pytest._code.ReprTraceback.toterminal": {
            "name": "_pytest._code.ReprTraceback.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 919,
            "start_column": 30840,
            "end_line": 4,
            "end_column": 31451,
            "start_byte": 30840,
            "end_byte": 4
        },
        "_pytest._code.ReprTracebackNative": {
            "name": "_pytest._code.ReprTracebackNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 938,
            "start_column": 31454,
            "end_line": 0,
            "end_column": 31642,
            "start_byte": 31454,
            "end_byte": 0
        },
        "_pytest._code.ReprTracebackNative.__init__": {
            "name": "_pytest._code.ReprTracebackNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 939,
            "start_column": 31500,
            "end_line": 4,
            "end_column": 31642,
            "start_byte": 31500,
            "end_byte": 4
        },
        "_pytest._code.ReprEntryNative": {
            "name": "_pytest._code.ReprEntryNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntryNative(TerminalRepr):\n    style = \"native\"\n\n    def __init__(self, tblines):\n        self.lines = tblines\n\n    def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 945,
            "start_column": 31645,
            "end_line": 0,
            "end_column": 31834,
            "start_byte": 31645,
            "end_byte": 0
        },
        "_pytest._code.ReprEntryNative.style": {
            "name": "_pytest._code.ReprEntryNative.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = \"native\"",
            "start_line": 946,
            "start_column": 31686,
            "end_line": 4,
            "end_column": 31702,
            "start_byte": 31686,
            "end_byte": 4
        },
        "_pytest._code.ReprEntryNative.__init__": {
            "name": "_pytest._code.ReprEntryNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.lines = tblines",
            "start_line": 948,
            "start_column": 31708,
            "end_line": 4,
            "end_column": 31765,
            "start_byte": 31708,
            "end_byte": 4
        },
        "_pytest._code.ReprEntryNative.toterminal": {
            "name": "_pytest._code.ReprEntryNative.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 951,
            "start_column": 31771,
            "end_line": 4,
            "end_column": 31834,
            "start_byte": 31771,
            "end_byte": 4
        },
        "_pytest._code.ReprEntry": {
            "name": "_pytest._code.ReprEntry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntry(TerminalRepr):\n    def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style\n\n    def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 955,
            "start_column": 31837,
            "end_line": 0,
            "end_column": 32932,
            "start_byte": 31837,
            "end_byte": 0
        },
        "_pytest._code.ReprEntry.__init__": {
            "name": "_pytest._code.ReprEntry.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style",
            "start_line": 956,
            "start_column": 31872,
            "end_line": 4,
            "end_column": 32115,
            "start_byte": 31872,
            "end_byte": 4
        },
        "_pytest._code.ReprEntry.toterminal": {
            "name": "_pytest._code.ReprEntry.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)",
            "start_line": 963,
            "start_column": 32121,
            "end_line": 4,
            "end_column": 32793,
            "start_byte": 32121,
            "end_byte": 4
        },
        "_pytest._code.ReprEntry.__str__": {
            "name": "_pytest._code.ReprEntry.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 983,
            "start_column": 32799,
            "end_line": 4,
            "end_column": 32932,
            "start_byte": 32799,
            "end_byte": 4
        }
    }
}