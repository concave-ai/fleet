{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5787",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:38.416159",
        "usage": "1530.0791263580322 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "getfirstlinesource",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "writelines",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "rex_session_duration",
          "capture_fixtures",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "tmpdir_factory",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "_format_boolop",
          "PytestArg",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "exec_module",
          "category",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "_getscopeitem",
          "SysCapture",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "_setup_cli_logging",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Junit",
          "TestReport",
          "_find_spec",
          "_done",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "showheader",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "FuncargnamesCompatAttr",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "_compare_eq_verbose",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "finish_recording",
          "TerminalRepr",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_getcapture",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_perform_collect",
          "repr",
          "putaround",
          "_factorytraceback",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "resolve_from_str",
          "Entry",
          "report_collect",
          "cacheshow",
          "_show_fixture_action",
          "resume_fixture",
          "unique_path",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "exists",
          "write",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "defaultfuncargprefixmarker",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "node",
          "HookRecorder",
          "_getentrysource",
          "head_line",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "Class",
          "find",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingStreamHandler",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "find_spec",
          "_ensure_only_one_capture_fixture",
          "get_statement_startend2",
          "_for_parametrize",
          "get_actual_log_level",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "NodeMarkers",
          "from_config",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "truncate_locals",
          "record_property",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "KeywordMapping",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "_handle_skip",
          "__bool__",
          "_fail_on_non_top_pytest_plugins",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "strip",
          "compile_",
          "python_keywords_allowed_list",
          "pytest_runtestloop",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_setup_collect_fakemodule",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "args",
          "__module__",
          "_seen",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "_runtest_for_main",
          "pytest_sessionfinish",
          "fill_unfilled",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "errisinstance",
          "__exit__",
          "make_properties_node",
          "result",
          "config",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "linecomp",
          "scope2index",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "logging",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "safe_text_dupfile",
          "invocation_dir",
          "get_fslocation_from_item",
          "listoutcomes",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "matchmark",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "matchkeyword",
          "id",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "try_mkdir",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "freeze_includes",
          "ApproxDecimal",
          "_readline_workaround",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "PyobjContext",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "_is_setup_py",
          "pop",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "add_property",
          "update",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "last_failed_paths",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "TEST_OUTCOME",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "activate_fixture",
          "alias",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_test_pytest_function",
          "_truncate_explanation",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_write_pyc",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "ParameterSet",
          "listnames",
          "plugins",
          "create_cleanup_lock",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "_setoption",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "own_markers",
          "setns",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "fnmatch_ex",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "_istrue",
          "popcall",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "warn_about_none_ast",
          "visit_Starred",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "FunctionMixin",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "__nonzero__",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "start",
          "LoggingPlugin",
          "_get_marks",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "is_generator",
          "get_common_ancestor",
          "PdbInvoke",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "MarkMapping",
          "errors",
          "MarkGenerator",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "line",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "print_teardown_sections",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "maybe_delete_a_numbered_dir",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "getdecoded",
          "getstatementrange",
          "pyobj_property",
          "makepyfile",
          "SetupState",
          "_is_doctest",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "pytest_itemstart",
          "AssertionRewritingHook",
          "_install_capture_fixture_on_item",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "get_default_arg_names",
          "names_closure",
          "out",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "TestReport",
          "test",
          "ExceptionInfo",
          "pytest_make_collect_report",
          "raiseerror",
          "excinfo",
          "write_log_entry",
          "pytest_exception_interact",
          "runtestprotocol"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:39.946249",
        "usage": "190.92917442321777 ms"
      },
      "request": {
        "tokens": [
          "TestReport",
          "test",
          "ExceptionInfo",
          "pytest_make_collect_report",
          "raiseerror",
          "excinfo",
          "write_log_entry",
          "pytest_exception_interact",
          "runtestprotocol"
        ]
      },
      "response": {
        "results": {
          "test": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/nose.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pytester.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python_api.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/main.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python.py"
          ],
          "excinfo": [
            "src/_pytest/python_api.py",
            "src/_pytest/skipping.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/debugging.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/python_api.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "write_log_entry": [
            "src/_pytest/resultlog.py"
          ],
          "TestReport": [
            "src/_pytest/reports.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "runtestprotocol": [
            "src/_pytest/pytester.py",
            "src/_pytest/runner.py"
          ],
          "pytest_exception_interact": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py"
          ],
          "pytest_make_collect_report": [
            "src/_pytest/hookspec.py",
            "src/_pytest/capture.py",
            "src/_pytest/runner.py"
          ],
          "raiseerror": [
            "src/_pytest/fixtures.py",
            "src/_pytest/capture.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:40.137187",
        "usage": "5697.340965270996 ms"
      },
      "request": {
        "keyword_search_results": {
          "test": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/nose.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pytester.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python_api.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/main.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python.py"
          ],
          "excinfo": [
            "src/_pytest/python_api.py",
            "src/_pytest/skipping.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/debugging.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/python_api.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py",
            "src/_pytest/python.py"
          ],
          "write_log_entry": [
            "src/_pytest/resultlog.py"
          ],
          "TestReport": [
            "src/_pytest/reports.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "runtestprotocol": [
            "src/_pytest/pytester.py",
            "src/_pytest/runner.py"
          ],
          "pytest_exception_interact": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py"
          ],
          "pytest_make_collect_report": [
            "src/_pytest/hookspec.py",
            "src/_pytest/capture.py",
            "src/_pytest/runner.py"
          ],
          "raiseerror": [
            "src/_pytest/fixtures.py",
            "src/_pytest/capture.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "To address the issue of exception serialization including chained exceptions, especially in the context of using `xdist`, we need to focus on files that likely manage how exceptions are caught, displayed, or logged during testing. The keywords most relevant to this problem are:\n\n1. **excinfo**: This seems to be related to exception information and could be crucial for understanding how exceptions are serialized or processed.\n2. **ExceptionInfo**: Likely strongly related to how exceptions, particularly chained exceptions, are represented and managed.\n3. **pytest_exception_interact**: This would be involved in the interaction with exceptions during pytest executions, potentially including the xdist-related behavior.\n4. **TestReport**: As this corresponds to how test results, including failures and exceptions, are reported, it might influence the serialization of exceptions in reports.\n\nGiven the issue, I'll prioritize files that intersect with these concepts and seem to relate to how exceptions are reported or handled, especially under `xdist`:\n\n1. **src/_pytest/runner.py**: Appears multiple times across relevant keywords, likely dealing with the test run lifecycle and could impact exception handling.\n2. **src/_pytest/reports.py**: Includes keywords related to reporting and exceptions, so likely influential in how exceptions are serialized in the test reports.\n3. **src/_pytest/terminal.py**: Might handle display outputs directly to the terminal, including exception info.\n4. **src/_pytest/python_api.py**: Cited under both `excinfo` and `ExceptionInfo`, suggesting it may handle exception-related APIs.\n5. **src/_pytest/_code/code.py**: The presence of keywords suggests it might deal with underlying exception handling mechanisms, especially for `ExceptionInfo`.\n6. **src/_pytest/debugging.py**: Involved with exception interactions, might provide insights into exception chaining, especially under debug/test scenarios.",
        "file_paths": [
          "src/_pytest/runner.py",
          "src/_pytest/reports.py",
          "src/_pytest/terminal.py",
          "src/_pytest/python_api.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/debugging.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:45.834556",
        "usage": "8036.143064498901 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is describing an issue with the serialization of chained exceptions when running tests with pytest and xdist. The full exception traceback is not being displayed as expected when using xdist with multiple processes.\n\n1.2 How was this issue caused?\n- This issue could be due to how exceptions are collected and reported in pytest, especially when using xdist, which distributes tests across multiple processes. There might be a problem in capturing and serializing the complete traceback of chained exceptions.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result is for the entire chained exception trace to be displayed, not just the last exception in the chain, even when running tests with xdist.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- N/A (The user provided the expected result)\n\n1.5 How should the issue be fixed to meet the expectation?\n- Ensure that the full traceback of chained exceptions is captured and serialized correctly, even when running in parallel with xdist.\n\n2. Make file evaluation:\n2.1 Analyze <file_content> tag for relevance:\n- The file contains functions and classes related to running tests and reporting their results.\n- The potential root of the issue could be in how the exceptions are captured and reported in pytest when xdist is involved.\n\n2.2 Match with the issue:\n- The 'call_and_report', 'check_interactive_exception', and 'ExceptionInfo.from_current()' are potentially involved in exception handling and reporting.\n\n2.3 Evaluate relevance:\n- The handling and reporting of exceptions are critical to this issue. Functions associated with gathering and reporting test results, especially when handling exceptions, are more relevant.\n- 'call_and_report' function seems highly relevant as it deals with reporting test call results.\n\n2.4 Review complete code sections:\n- Thoroughly reviewed functions that deal with exception handling and reporting.\n\n2.5 Verify references to other parts:\n- May require looking into other parts like reports or ExceptionInfo.\n\n2.6 Determine relevance:\n- Code seems to be relevant as handling and logging of exception traces is a key component here. Need a closer look at serialization specifically when xdist is involved.\n\nConclusion:\n- This file seems to be related to the issue, with particular relevance to exception handling and reporting.\n\nRecommended Symbols:\n- These relate to exception handling which might be causing loss of detail when using xdist.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/reports.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/xdist.py"
        ],
        "relevant_symbols": [
          "call_and_report",
          "check_interactive_exception",
          "ExceptionInfo"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:53.870728",
        "usage": "7191.000938415527 ms"
      },
      "request": {
        "file_path": "src/_pytest/reports.py"
      },
      "response": {
        "scratch_pad": "### Analyzing the Issue:\n\n1. **Description:**\n   - The issue describes a problem where exception serialization doesn't include chained exceptions explicitly when using `pytest-xdist`, which runs tests in parallel.\n\n2. **Cause:**\n   - The cause seems to be in how exceptions, specifically chained exceptions, are serialized and reported when tests are executed in parallel using the `xdist` plugin.\n\n3. **Expected Result:**\n   - The expected result would be for the serialized exception report to include the entire chain of exceptions as it does when xdist is not used.\n\n4. **How it could be fixed:**\n   - The fix would involve ensuring that when exceptions are serialized, especially in cases involving xdist, all chained exceptions are captured and included in the serialized report.\n\n### Analyzing the Provided File:\n\n- The file 'src/_pytest/reports.py' appears to handle the generation of test reports, potentially including exception serialization.\n\n#### Relevant Symbols:\n\n1. **BaseReport._to_json():**\n   - Contains logic for serializing exception information.\n   - Currently processes `reprtraceback` and `reprcrash`, which would be relevant for ensuring chained exceptions are properly serialized.\n\n2. **BaseReport._from_json(cls, reportdict):**\n   - Handles the deserialization of exception reports. This is relevant to ensure that the serialized chained exceptions can be reconstructed accurately.\n\n3. **disassembled_report(rep):**\n   - A helper function within `_to_json()` to break down the report's exception tracebacks for serialization.\n\n4. **TestReport:**\n   - Involved in creating test report objects. Its `longrepr` property would need to store chained exception details.\n   \n5. **pytest_report_to_serializable(report):**\n   - Converts report to a serializable format; must include chained exceptions.\n\n- The file is likely a root cause as it contains the serialization logic for exception reports, which aligns with the problem described in serializing chained exceptions.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "BaseReport._to_json",
          "BaseReport._from_json",
          "disassembled_report",
          "TestReport",
          "pytest_report_to_serializable"
        ],
        "root_cause_symbols": [
          "BaseReport._to_json",
          "BaseReport._from_json",
          "disassembled_report",
          "TestReport",
          "pytest_report_to_serializable"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:01.061753",
        "usage": "10729.674100875854 ms"
      },
      "request": {
        "file_path": "src/_pytest/terminal.py"
      },
      "response": {
        "scratch_pad": "The issue at hand pertains to the serialization of chained exceptions when running tests with pytest's xdist mode, parallel execution, versus without it. When running without xdist, the full chain of exceptions is visible in test reports, but with xdist, only the last exception in the chain is shown.\n\nIn examining the source file `src/_pytest/terminal.py`, we notice this file is heavily involved in the terminal reporting of pytest; it contains extensive logic related to capturing and reporting the state of test executions.\n\n1. **Root Cause Exploration:**\n\n   - The discrepancy between the `xdist` behavior and non-`xdist` behavior suggests that the issue could lie in how exception information is gathered and reported once it's distributed across multiple processes by `xdist`, versus single-process (standard) pytest runs.\n   \n   - The handling of test output and reporting in different configurations could play a role: If the test failures and outputs are processed differently with `xdist`, the chain of exceptions might be lost somewhere in this chain.\n\n2. **Relevant Fragment of Code in `terminal.py`:**\n\n   - `pytest_runtest_logreport(self, report)`: this method handles logging each test report which is likely where the issue can manifest, especially if connection to chain exceptions and capturing stdout/stderr is different under xdist.\n   - There are control flows for running 'xdist' using `running_xdist = hasattr(rep, \"node\")`. If the logging/reporting skips certain types of exceptions or only considers the last point (in the presence of xdist), that could explain the issue.  This is a strong lead supporting the notion that the file is possibly the root cause of the problem.\n\n3. **Symbols Consideration:**\n\n   - Given the problem described, looking into how exceptions are caught and handled will be insightful. \n   - \"TerminalReporter\" class - since it's responsible for gathering and output of test results.\n   - Methods in TerminalReporter like `pytest_runtest_logreport()` since they process each report that could potentially misrepresent error chaining.\n\nIn conclusion, based on these points, I determine that this file is quite relevant and possibly root cause of the issue based on the discovered methods and classes. \n",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "TerminalReporter.pytest_runtest_logreport",
          "TerminalReporter"
        ],
        "root_cause_symbols": [
          "TerminalReporter.pytest_runtest_logreport",
          "TerminalReporter"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:11.791460",
        "usage": "5139.269828796387 ms"
      },
      "request": {
        "file_path": "src/_pytest/python_api.py"
      },
      "response": {
        "scratch_pad": "**Analysis of the Issue:**\n1. The user is describing an issue where exception serialization is not properly displaying chained exceptions when running tests with xdist. Normally, running without xdist, the full exception trace is shown.\n2. This issue is likely caused by the serialization or printing mechanism not correctly handling chained exceptions when using xdist.\n3. The expected behavior would be for both individual exceptions and the chain of exceptions to be printed properly, even when xdist is used for parallel test execution. All the exception traces, just as they are without xdist, should appear.\n\n**File Content Analysis:**\n1. The file `src/_pytest/python_api.py` contains utilities and helper functions and classes for pytest, including error approximation and the custom raises function.\n2. Potentially relevant areas might be the handling of exceptions and contexts related to pytest's `raises` function. However, this `python_api.py` specifically implements the `raises` context manager for assertion purposes in tests.\n3. There is no direct code related to exception serialization or error traceback formatting within this file's content. This file contains implementations primarily for approximations and exception catching assertions (using `pytest.raises`).\n4. No code in the file directly affects how exceptions are formatted and reported. The functions like `raises` facilitate verifying exceptions occur but not how they are serialized or reported when they do.\n\n**Conclusion:**\n- The file does not directly handle exception printing/serialization relevant to the issue.\n- The issue likely originates from other parts of pytest dealing with result formatting or possibly xdist's result handling and reporting.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/terminal.py",
          "src/_pytest/config.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:16.930765",
        "usage": "5524.217844009399 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is experiencing an issue where exception traces are not fully serialized when using pytest with xdist. The exceptions should show the full chain of causes and contexts, but under xdist, only the final exception in the chain is displayed.\n1.2 The issue is caused by the pytest-xdist plugin not capturing or displaying the full exception chain properly when tests are run in parallel.\n1.3 The user expects the full chain of exceptions, including the causes and contexts, to be serialized and displayed when running tests with xdist just like when running without it.\n1.4 The expectation should be that the exception traces include the full chain of causes and contexts.\n1.5 To fix the issue, exception serialization should specifically include the chained exceptions ('__cause__' and '__context__').\n\n2. Make file evaluation:\n2.1 After reviewing the provided file, the `ExceptionInfo` and `FormattedExcinfo` classes are relevant as they handle the capture and representation of exception information.\n2.2 The `ExceptionInfo.getrepr` and `FormattedExcinfo.repr_excinfo` methods mention handling for chained exceptions with the `chain` parameter.\n2.3 Specifically, `FormattedExcinfo.repr_excinfo` method constructs the representation of exceptions by going through the exception chain.\n2.4 Also, the classes `ExceptionChainRepr`, `ReprExceptionInfo`, `ReprTraceback`, and `ReprEntry` seem to deal with formatting exception representations, which are crucial for ensuring that the full exception chain is displayed.\n2.5 Note that additional investigation may be needed to confirm how these methods interact and modify serialization behavior under xdist.\n2.6 Given the presence of the `chain` parameter and handling in the serialization logic, it is likely that aspects of this file do contribute to the root cause or part of a related solution for this issue.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.getrepr",
          "FormattedExcinfo",
          "FormattedExcinfo.repr_excinfo",
          "ExceptionChainRepr",
          "ReprExceptionInfo",
          "ReprTraceback",
          "ReprEntry"
        ],
        "root_cause_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.getrepr",
          "FormattedExcinfo",
          "FormattedExcinfo.repr_excinfo",
          "ExceptionChainRepr",
          "ReprExceptionInfo",
          "ReprTraceback",
          "ReprEntry"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:22.455023",
        "usage": "7305.595874786377 ms"
      },
      "request": {
        "file_path": "src/_pytest/debugging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue described is that with pytest-xdist, chained exceptions do not produce the complete traceback output as they do when not using xdist.\n1.2 The issue is caused by pytest-xdist not serializing the complete exception chain between distributed test nodes and the main process.\n1.3 The expected result should be that the full exception traceback, including chained exceptions, is displayed even when running tests with pytest-xdist.\n1.4 If the description did not provide an expected result, it should be displaying all parts of the exception chain regardless of the test configuration.\n1.5 To fix the issue, the exception serialization logic in pytest-xdist needs to be modified to include chained exception information.\n\n2. Make file evaluation:\n2.1 The file 'src/_pytest/debugging.py' relates to debugging with PDB. It contains classes like 'pytestPDB', which implement debugging mechanisms and commands.\n2.2 There are no symbols directly related to exception serialization or pytest-xdist in this file.\n2.3 Evaluating parts like '_enter_pdb', 'post_mortem', and 'pytest_exception_interact' shows they are focused on interacting with exceptions at the point of running a debugger but not serializing exceptions for distributed test output.\n2.4 There are no references in this file to parts of the codebase that handle serialization of exceptions or integration with pytest-xdist functionality.\n2.5 Given the content of the file, it is more about enabling debugging and not serializing exceptions. Thus, this is not the root cause of the reported issue. The root cause likely resides in the pytest-xdist code dealing with how exceptions are gathered and reported back from different nodes.\n\n3. Output Your Decision:\nThe file is not relevant to exception serialization in pytest-xdist, thus not related to the root cause nor potentially fixing the issue. Debugging logic here does not impact chained exception traceback outputs.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/xdist.py",
          "src/_pytest/terminal.py",
          "src/_pytest/reporting.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:29.760684",
        "usage": "208.2691192626953 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "call_and_report",
              "check_interactive_exception",
              "ExceptionInfo"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/reports.py",
            "relevant_symbol_keys": [
              "BaseReport._to_json",
              "BaseReport._from_json",
              "disassembled_report",
              "TestReport",
              "pytest_report_to_serializable"
            ],
            "root_cause_symbol_keys": [
              "BaseReport._to_json",
              "BaseReport._from_json",
              "disassembled_report",
              "TestReport",
              "pytest_report_to_serializable"
            ]
          },
          {
            "file_path": "src/_pytest/terminal.py",
            "relevant_symbol_keys": [
              "TerminalReporter.pytest_runtest_logreport",
              "TerminalReporter"
            ],
            "root_cause_symbol_keys": [
              "TerminalReporter.pytest_runtest_logreport",
              "TerminalReporter"
            ]
          },
          {
            "file_path": "src/_pytest/python_api.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.getrepr",
              "FormattedExcinfo",
              "FormattedExcinfo.repr_excinfo",
              "ExceptionChainRepr",
              "ReprExceptionInfo",
              "ReprTraceback",
              "ReprEntry"
            ],
            "root_cause_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.getrepr",
              "FormattedExcinfo",
              "FormattedExcinfo.repr_excinfo",
              "ExceptionChainRepr",
              "ReprExceptionInfo",
              "ReprTraceback",
              "ReprEntry"
            ]
          },
          {
            "file_path": "src/_pytest/debugging.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 490,
            "start_column": 15426,
            "end_line": 4,
            "end_column": 15636,
            "start_byte": 15426,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(item, when, log=True, **kwds):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 165,
            "start_column": 4915,
            "end_line": 0,
            "end_column": 5311,
            "start_byte": 4915,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 176,
            "start_column": 5314,
            "end_line": 0,
            "end_column": 5534,
            "start_byte": 5314,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.hookspec.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": " item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )\n\n\nclass CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n      ",
            "start_line": 380,
            "start_column": 12325,
            "end_line": 0,
            "end_column": 12939,
            "start_byte": 12325,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n\n        def disassembled_report(rep):\n            reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n            reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n\n            new_entries = []\n            for entry in reprtraceback[\"reprentries\"]:\n                entry_data = {\n                    \"type\": type(entry).__name__,\n                    \"data\": entry.__dict__.copy(),\n                }\n                for key, value in entry_data[\"data\"].items():\n                    if hasattr(value, \"__dict__\"):\n                        entry_data[\"data\"][key] = value.__dict__.copy()\n                new_entries.append(entry_data)\n\n            reprtraceback[\"reprentries\"] = new_entries\n\n            return {\n                \"reprcrash\": reprcrash,\n                \"reprtraceback\": reprtraceback,\n                \"sections\": rep.longrepr.sections,\n            }\n\n        d = self.__dict__.copy()\n        if hasattr(self.longrepr, \"toterminal\"):\n            if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n                self.longrepr, \"reprcrash\"\n            ):\n                d[\"longrepr\"] = disassembled_report(self)\n            else:\n                d[\"longrepr\"] = str(self.longrepr)\n        else:\n            d[\"longrepr\"] = self.longrepr\n        for name in d:\n            if isinstance(d[name], (py.path.local, Path)):\n                d[name] = str(d[name])\n            elif name == \"result\":\n                d[name] = None  # for now\n        return d",
            "start_line": 153,
            "start_column": 4241,
            "end_line": 4,
            "end_column": 5985,
            "start_byte": 4241,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        if reportdict[\"longrepr\"]:\n            if (\n                \"reprcrash\" in reportdict[\"longrepr\"]\n                and \"reprtraceback\" in reportdict[\"longrepr\"]\n            ):\n\n                reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n                reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n\n                unserialized_entries = []\n                reprentry = None\n                for entry_data in reprtraceback[\"reprentries\"]:\n                    data = entry_data[\"data\"]\n                    entry_type = entry_data[\"type\"]\n                    if entry_type == \"ReprEntry\":\n                        reprfuncargs = None\n                        reprfileloc = None\n                        reprlocals = None\n                        if data[\"reprfuncargs\"]:\n                            reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n                        if data[\"reprfileloc\"]:\n                            reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n                        if data[\"reprlocals\"]:\n                            reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n                        reprentry = ReprEntry(\n                            lines=data[\"lines\"],\n                            reprfuncargs=reprfuncargs,\n                            reprlocals=reprlocals,\n                            filelocrepr=reprfileloc,\n                            style=data[\"style\"],\n                        )\n                    elif entry_type == \"ReprEntryNative\":\n                        reprentry = ReprEntryNative(data[\"lines\"])\n                    else:\n                        _report_unserialization_failure(entry_type, cls, reportdict)\n                    unserialized_entries.append(reprentry)\n                reprtraceback[\"reprentries\"] = unserialized_entries\n\n                exception_info = ReprExceptionInfo(\n                    reprtraceback=ReprTraceback(**reprtraceback),\n                    reprcrash=ReprFileLocation(**reprcrash),\n                )\n\n                for section in reportdict[\"longrepr\"][\"sections\"]:\n                    exception_info.addsection(*section)\n                reportdict[\"longrepr\"] = exception_info\n\n        return cls(**reportdict)",
            "start_line": 203,
            "start_column": 5991,
            "end_line": 4,
            "end_column": 8587,
            "start_byte": 5991,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 276,
            "start_column": 9116,
            "end_line": 0,
            "end_column": 12552,
            "start_byte": 9116,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 281,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 9251,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 283,
            "start_column": 9273,
            "end_line": 4,
            "end_column": 10859,
            "start_byte": 9273,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 332,
            "start_column": 10865,
            "end_line": 4,
            "end_column": 11026,
            "start_byte": 10865,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 337,
            "start_column": 11032,
            "end_line": 4,
            "end_column": 12552,
            "start_byte": 11032,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"_report_type\"] = report.__class__.__name__\n        return data",
            "start_line": 410,
            "start_column": 13317,
            "end_line": 0,
            "end_column": 13525,
            "start_byte": 13317,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content, **markup):\n        self._tw.write(content, **markup)\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n\n    def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n\n    def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)\n\n    def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line\n\n    def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)\n\n    def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n\n    def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)\n\n    def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 217,
            "start_column": 6374,
            "end_line": 0,
            "end_column": 34081,
            "start_byte": 6374,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None",
            "start_line": 218,
            "start_column": 6402,
            "end_line": 4,
            "end_column": 7252,
            "start_byte": 6402,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 242,
            "start_column": 7258,
            "end_line": 4,
            "end_column": 7841,
            "start_byte": 7258,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 255,
            "start_column": 7847,
            "end_line": 4,
            "end_column": 7923,
            "start_byte": 7847,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 259,
            "start_column": 7929,
            "end_line": 4,
            "end_column": 7999,
            "start_byte": 7929,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
            "start_line": 263,
            "start_column": 8005,
            "end_line": 4,
            "end_column": 8148,
            "start_byte": 8005,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 269,
            "start_column": 8154,
            "end_line": 4,
            "end_column": 8238,
            "start_byte": 8154,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 273,
            "start_column": 8244,
            "end_line": 4,
            "end_column": 8319,
            "start_byte": 8244,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 277,
            "start_column": 8325,
            "end_line": 4,
            "end_column": 8452,
            "start_byte": 8325,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)",
            "start_line": 281,
            "start_column": 8458,
            "end_line": 4,
            "end_column": 9143,
            "start_byte": 8458,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 294,
            "start_column": 9149,
            "end_line": 4,
            "end_column": 9449,
            "start_byte": 9149,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 303,
            "start_column": 9455,
            "end_line": 4,
            "end_column": 9577,
            "start_byte": 9455,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content, **markup):\n        self._tw.write(content, **markup)",
            "start_line": 308,
            "start_column": 9583,
            "end_line": 4,
            "end_column": 9660,
            "start_byte": 9583,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 311,
            "start_column": 9666,
            "end_line": 4,
            "end_column": 9856,
            "start_byte": 9666,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 317,
            "start_column": 9862,
            "end_line": 4,
            "end_column": 10480,
            "start_byte": 9862,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 335,
            "start_column": 10486,
            "end_line": 4,
            "end_column": 10606,
            "start_byte": 10486,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 339,
            "start_column": 10612,
            "end_line": 4,
            "end_column": 10691,
            "start_byte": 10612,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 342,
            "start_column": 10697,
            "end_line": 4,
            "end_column": 10756,
            "start_byte": 10697,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 345,
            "start_column": 10762,
            "end_line": 4,
            "end_column": 10919,
            "start_byte": 10762,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)",
            "start_line": 350,
            "start_column": 10925,
            "end_line": 4,
            "end_column": 11501,
            "start_byte": 10925,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 364,
            "start_column": 11507,
            "end_line": 4,
            "end_column": 11882,
            "start_byte": 11507,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)",
            "start_line": 372,
            "start_column": 11888,
            "end_line": 4,
            "end_column": 11985,
            "start_byte": 11888,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")",
            "start_line": 375,
            "start_column": 11991,
            "end_line": 4,
            "end_column": 12398,
            "start_byte": 11991,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2",
            "start_line": 385,
            "start_column": 12404,
            "end_line": 4,
            "end_column": 14437,
            "start_byte": 12404,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)",
            "start_line": 436,
            "start_column": 14443,
            "end_line": 4,
            "end_column": 15386,
            "start_byte": 14443,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"",
            "start_line": 457,
            "start_column": 15392,
            "end_line": 4,
            "end_column": 16095,
            "start_byte": 15392,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)",
            "start_line": 472,
            "start_column": 16101,
            "end_line": 4,
            "end_column": 16337,
            "start_byte": 16101,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line",
            "start_line": 478,
            "start_column": 16343,
            "end_line": 4,
            "end_column": 16666,
            "start_byte": 16343,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 495,
            "start_column": 16996,
            "end_line": 4,
            "end_column": 17388,
            "start_byte": 16996,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 505,
            "start_column": 17394,
            "end_line": 4,
            "end_column": 18778,
            "start_byte": 17394,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 545,
            "start_column": 18784,
            "end_line": 4,
            "end_column": 19889,
            "start_byte": 18784,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 572,
            "start_column": 19895,
            "end_line": 4,
            "end_column": 20038,
            "start_byte": 19895,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 577,
            "start_column": 20044,
            "end_line": 4,
            "end_column": 20699,
            "start_byte": 20044,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))",
            "start_line": 611,
            "start_column": 21341,
            "end_line": 4,
            "end_column": 22905,
            "start_byte": 21341,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()",
            "start_line": 646,
            "start_column": 22911,
            "end_line": 4,
            "end_column": 23642,
            "start_byte": 22911,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 667,
            "start_column": 23648,
            "end_line": 4,
            "end_column": 23991,
            "start_byte": 23648,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 678,
            "start_column": 23997,
            "end_line": 4,
            "end_column": 24112,
            "start_byte": 23997,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 681,
            "start_column": 24118,
            "end_line": 4,
            "end_column": 24245,
            "start_byte": 24118,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 685,
            "start_column": 24251,
            "end_line": 4,
            "end_column": 24779,
            "start_byte": 24251,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 699,
            "start_column": 24785,
            "end_line": 4,
            "end_column": 25607,
            "start_byte": 24785,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 721,
            "start_column": 25613,
            "end_line": 4,
            "end_column": 25771,
            "start_byte": 25613,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 727,
            "start_column": 25777,
            "end_line": 4,
            "end_column": 26021,
            "start_byte": 25777,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 739,
            "start_column": 26073,
            "end_line": 4,
            "end_column": 26262,
            "start_byte": 26073,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 746,
            "start_column": 26268,
            "end_line": 4,
            "end_column": 27912,
            "start_byte": 26268,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)",
            "start_line": 784,
            "start_column": 27918,
            "end_line": 4,
            "end_column": 28435,
            "start_byte": 27918,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 797,
            "start_column": 28441,
            "end_line": 4,
            "end_column": 28927,
            "start_byte": 28441,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)",
            "start_line": 810,
            "start_column": 28933,
            "end_line": 4,
            "end_column": 29916,
            "start_byte": 28933,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 833,
            "start_column": 29922,
            "end_line": 4,
            "end_column": 30518,
            "start_byte": 29922,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 848,
            "start_column": 30524,
            "end_line": 4,
            "end_column": 30981,
            "start_byte": 30524,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)",
            "start_line": 861,
            "start_column": 30987,
            "end_line": 4,
            "end_column": 31418,
            "start_byte": 30987,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 872,
            "start_column": 31424,
            "end_line": 4,
            "end_column": 34081,
            "start_byte": 31424,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(type=str, default=\"\")",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(type=Optional[Traceback], default=None)",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 490,
            "start_column": 15426,
            "end_line": 4,
            "end_column": 15636,
            "start_byte": 15426,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(default=False)\n    style = attr.ib(default=\"long\")\n    abspath = attr.ib(default=True)\n    tbfilter = attr.ib(default=True)\n    funcargs = attr.ib(default=False)\n    truncate_locals = attr.ib(default=True)\n    chain = attr.ib(default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n\n    def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines\n\n    def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n\n    def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)\n\n    def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline\n\n    def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 607,
            "start_column": 19506,
            "end_line": 0,
            "end_column": 29052,
            "start_byte": 19506,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.FormattedExcinfo.flow_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "flow_marker = \">\"",
            "start_line": 612,
            "start_column": 19646,
            "end_line": 4,
            "end_column": 19663,
            "start_byte": 19646,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.fail_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "fail_marker = \"E\"",
            "start_line": 613,
            "start_column": 19668,
            "end_line": 4,
            "end_column": 19685,
            "start_byte": 19668,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.showlocals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "showlocals = attr.ib(default=False)",
            "start_line": 615,
            "start_column": 19691,
            "end_line": 4,
            "end_column": 19726,
            "start_byte": 19691,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = attr.ib(default=\"long\")",
            "start_line": 616,
            "start_column": 19731,
            "end_line": 4,
            "end_column": 19762,
            "start_byte": 19731,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.abspath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "abspath = attr.ib(default=True)",
            "start_line": 617,
            "start_column": 19767,
            "end_line": 4,
            "end_column": 19798,
            "start_byte": 19767,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.tbfilter",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "tbfilter = attr.ib(default=True)",
            "start_line": 618,
            "start_column": 19803,
            "end_line": 4,
            "end_column": 19835,
            "start_byte": 19803,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.funcargs",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "funcargs = attr.ib(default=False)",
            "start_line": 619,
            "start_column": 19840,
            "end_line": 4,
            "end_column": 19873,
            "start_byte": 19840,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.truncate_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "truncate_locals = attr.ib(default=True)",
            "start_line": 620,
            "start_column": 19878,
            "end_line": 4,
            "end_column": 19917,
            "start_byte": 19878,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.chain",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "chain = attr.ib(default=True)",
            "start_line": 621,
            "start_column": 19922,
            "end_line": 4,
            "end_column": 19951,
            "start_byte": 19922,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.astcache",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)",
            "start_line": 622,
            "start_column": 19956,
            "end_line": 4,
            "end_column": 20026,
            "start_byte": 19956,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._getindent",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))",
            "start_line": 624,
            "start_column": 20032,
            "end_line": 4,
            "end_column": 20465,
            "start_byte": 20032,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._getentrysource",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source",
            "start_line": 639,
            "start_column": 20471,
            "end_line": 4,
            "end_column": 20644,
            "start_byte": 20471,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_args",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)",
            "start_line": 645,
            "start_column": 20650,
            "end_line": 4,
            "end_column": 20890,
            "start_byte": 20650,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.get_source",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines",
            "start_line": 652,
            "start_column": 20896,
            "end_line": 4,
            "end_column": 21896,
            "start_byte": 20896,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.get_exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines",
            "start_line": 676,
            "start_column": 21902,
            "end_line": 4,
            "end_column": 22326,
            "start_byte": 21902,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)",
            "start_line": 688,
            "start_column": 22332,
            "end_line": 4,
            "end_column": 23498,
            "start_byte": 22332,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 714,
            "start_column": 23504,
            "end_line": 4,
            "end_column": 24777,
            "start_byte": 23504,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._makepath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path",
            "start_line": 747,
            "start_column": 24783,
            "end_line": 4,
            "end_column": 25053,
            "start_byte": 24783,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 757,
            "start_column": 25059,
            "end_line": 4,
            "end_column": 25701,
            "start_byte": 25059,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._truncate_recursive_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline",
            "start_line": 775,
            "start_column": 25707,
            "end_line": 4,
            "end_column": 27387,
            "start_byte": 25707,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 812,
            "start_column": 27393,
            "end_line": 4,
            "end_column": 29052,
            "start_byte": 27393,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionChainRepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ExceptionChainRepr(ExceptionRepr):\n    def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]\n\n    def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 882,
            "start_column": 29762,
            "end_line": 0,
            "end_column": 30319,
            "start_byte": 29762,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionChainRepr.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]",
            "start_line": 883,
            "start_column": 29807,
            "end_line": 4,
            "end_column": 30068,
            "start_byte": 29807,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionChainRepr.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 891,
            "start_column": 30074,
            "end_line": 4,
            "end_column": 30319,
            "start_byte": 30074,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTraceback(TerminalRepr):\n    entrysep = \"_ \"\n\n    def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style\n\n    def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 911,
            "start_column": 30623,
            "end_line": 0,
            "end_column": 31451,
            "start_byte": 30623,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprTraceback.entrysep",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "entrysep = \"_ \"",
            "start_line": 912,
            "start_column": 30662,
            "end_line": 4,
            "end_column": 30677,
            "start_byte": 30662,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style",
            "start_line": 914,
            "start_column": 30683,
            "end_line": 4,
            "end_column": 30834,
            "start_byte": 30683,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 919,
            "start_column": 30840,
            "end_line": 4,
            "end_column": 31451,
            "start_byte": 30840,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTracebackNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 938,
            "start_column": 31454,
            "end_line": 0,
            "end_column": 31642,
            "start_byte": 31454,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprTracebackNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 939,
            "start_column": 31500,
            "end_line": 4,
            "end_column": 31642,
            "start_byte": 31500,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntryNative(TerminalRepr):\n    style = \"native\"\n\n    def __init__(self, tblines):\n        self.lines = tblines\n\n    def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 945,
            "start_column": 31645,
            "end_line": 0,
            "end_column": 31834,
            "start_byte": 31645,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprEntryNative.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = \"native\"",
            "start_line": 946,
            "start_column": 31686,
            "end_line": 4,
            "end_column": 31702,
            "start_byte": 31686,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.lines = tblines",
            "start_line": 948,
            "start_column": 31708,
            "end_line": 4,
            "end_column": 31765,
            "start_byte": 31708,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 951,
            "start_column": 31771,
            "end_line": 4,
            "end_column": 31834,
            "start_byte": 31771,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntry(TerminalRepr):\n    def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style\n\n    def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 955,
            "start_column": 31837,
            "end_line": 0,
            "end_column": 32932,
            "start_byte": 31837,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprEntry.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style",
            "start_line": 956,
            "start_column": 31872,
            "end_line": 4,
            "end_column": 32115,
            "start_byte": 31872,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)",
            "start_line": 963,
            "start_column": 32121,
            "end_line": 4,
            "end_column": 32793,
            "start_byte": 32121,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 983,
            "start_column": 32799,
            "end_line": 4,
            "end_column": 32932,
            "start_byte": 32799,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:29.968960",
        "usage": "12670.281887054443 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 490,
            "start_column": 15426,
            "end_line": 4,
            "end_column": 15636,
            "start_byte": 15426,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(item, when, log=True, **kwds):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 165,
            "start_column": 4915,
            "end_line": 0,
            "end_column": 5311,
            "start_byte": 4915,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 176,
            "start_column": 5314,
            "end_line": 0,
            "end_column": 5534,
            "start_byte": 5314,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.hookspec.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": " item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )\n\n\nclass CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n      ",
            "start_line": 380,
            "start_column": 12325,
            "end_line": 0,
            "end_column": 12939,
            "start_byte": 12325,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n\n        def disassembled_report(rep):\n            reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n            reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n\n            new_entries = []\n            for entry in reprtraceback[\"reprentries\"]:\n                entry_data = {\n                    \"type\": type(entry).__name__,\n                    \"data\": entry.__dict__.copy(),\n                }\n                for key, value in entry_data[\"data\"].items():\n                    if hasattr(value, \"__dict__\"):\n                        entry_data[\"data\"][key] = value.__dict__.copy()\n                new_entries.append(entry_data)\n\n            reprtraceback[\"reprentries\"] = new_entries\n\n            return {\n                \"reprcrash\": reprcrash,\n                \"reprtraceback\": reprtraceback,\n                \"sections\": rep.longrepr.sections,\n            }\n\n        d = self.__dict__.copy()\n        if hasattr(self.longrepr, \"toterminal\"):\n            if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n                self.longrepr, \"reprcrash\"\n            ):\n                d[\"longrepr\"] = disassembled_report(self)\n            else:\n                d[\"longrepr\"] = str(self.longrepr)\n        else:\n            d[\"longrepr\"] = self.longrepr\n        for name in d:\n            if isinstance(d[name], (py.path.local, Path)):\n                d[name] = str(d[name])\n            elif name == \"result\":\n                d[name] = None  # for now\n        return d",
            "start_line": 153,
            "start_column": 4241,
            "end_line": 4,
            "end_column": 5985,
            "start_byte": 4241,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        if reportdict[\"longrepr\"]:\n            if (\n                \"reprcrash\" in reportdict[\"longrepr\"]\n                and \"reprtraceback\" in reportdict[\"longrepr\"]\n            ):\n\n                reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n                reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n\n                unserialized_entries = []\n                reprentry = None\n                for entry_data in reprtraceback[\"reprentries\"]:\n                    data = entry_data[\"data\"]\n                    entry_type = entry_data[\"type\"]\n                    if entry_type == \"ReprEntry\":\n                        reprfuncargs = None\n                        reprfileloc = None\n                        reprlocals = None\n                        if data[\"reprfuncargs\"]:\n                            reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n                        if data[\"reprfileloc\"]:\n                            reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n                        if data[\"reprlocals\"]:\n                            reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n                        reprentry = ReprEntry(\n                            lines=data[\"lines\"],\n                            reprfuncargs=reprfuncargs,\n                            reprlocals=reprlocals,\n                            filelocrepr=reprfileloc,\n                            style=data[\"style\"],\n                        )\n                    elif entry_type == \"ReprEntryNative\":\n                        reprentry = ReprEntryNative(data[\"lines\"])\n                    else:\n                        _report_unserialization_failure(entry_type, cls, reportdict)\n                    unserialized_entries.append(reprentry)\n                reprtraceback[\"reprentries\"] = unserialized_entries\n\n                exception_info = ReprExceptionInfo(\n                    reprtraceback=ReprTraceback(**reprtraceback),\n                    reprcrash=ReprFileLocation(**reprcrash),\n                )\n\n                for section in reportdict[\"longrepr\"][\"sections\"]:\n                    exception_info.addsection(*section)\n                reportdict[\"longrepr\"] = exception_info\n\n        return cls(**reportdict)",
            "start_line": 203,
            "start_column": 5991,
            "end_line": 4,
            "end_column": 8587,
            "start_byte": 5991,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 276,
            "start_column": 9116,
            "end_line": 0,
            "end_column": 12552,
            "start_byte": 9116,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 281,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 9251,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 283,
            "start_column": 9273,
            "end_line": 4,
            "end_column": 10859,
            "start_byte": 9273,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 332,
            "start_column": 10865,
            "end_line": 4,
            "end_column": 11026,
            "start_byte": 10865,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 337,
            "start_column": 11032,
            "end_line": 4,
            "end_column": 12552,
            "start_byte": 11032,
            "end_byte": 4
          },
          {
            "name": "_pytest.reports.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"_report_type\"] = report.__class__.__name__\n        return data",
            "start_line": 410,
            "start_column": 13317,
            "end_line": 0,
            "end_column": 13525,
            "start_byte": 13317,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content, **markup):\n        self._tw.write(content, **markup)\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n\n    def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n\n    def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)\n\n    def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line\n\n    def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)\n\n    def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n\n    def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)\n\n    def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 217,
            "start_column": 6374,
            "end_line": 0,
            "end_column": 34081,
            "start_byte": 6374,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None",
            "start_line": 218,
            "start_column": 6402,
            "end_line": 4,
            "end_column": 7252,
            "start_byte": 6402,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 242,
            "start_column": 7258,
            "end_line": 4,
            "end_column": 7841,
            "start_byte": 7258,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 255,
            "start_column": 7847,
            "end_line": 4,
            "end_column": 7923,
            "start_byte": 7847,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 259,
            "start_column": 7929,
            "end_line": 4,
            "end_column": 7999,
            "start_byte": 7929,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
            "start_line": 263,
            "start_column": 8005,
            "end_line": 4,
            "end_column": 8148,
            "start_byte": 8005,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 269,
            "start_column": 8154,
            "end_line": 4,
            "end_column": 8238,
            "start_byte": 8154,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 273,
            "start_column": 8244,
            "end_line": 4,
            "end_column": 8319,
            "start_byte": 8244,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 277,
            "start_column": 8325,
            "end_line": 4,
            "end_column": 8452,
            "start_byte": 8325,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)",
            "start_line": 281,
            "start_column": 8458,
            "end_line": 4,
            "end_column": 9143,
            "start_byte": 8458,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 294,
            "start_column": 9149,
            "end_line": 4,
            "end_column": 9449,
            "start_byte": 9149,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 303,
            "start_column": 9455,
            "end_line": 4,
            "end_column": 9577,
            "start_byte": 9455,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content, **markup):\n        self._tw.write(content, **markup)",
            "start_line": 308,
            "start_column": 9583,
            "end_line": 4,
            "end_column": 9660,
            "start_byte": 9583,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 311,
            "start_column": 9666,
            "end_line": 4,
            "end_column": 9856,
            "start_byte": 9666,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 317,
            "start_column": 9862,
            "end_line": 4,
            "end_column": 10480,
            "start_byte": 9862,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 335,
            "start_column": 10486,
            "end_line": 4,
            "end_column": 10606,
            "start_byte": 10486,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 339,
            "start_column": 10612,
            "end_line": 4,
            "end_column": 10691,
            "start_byte": 10612,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 342,
            "start_column": 10697,
            "end_line": 4,
            "end_column": 10756,
            "start_byte": 10697,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 345,
            "start_column": 10762,
            "end_line": 4,
            "end_column": 10919,
            "start_byte": 10762,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)",
            "start_line": 350,
            "start_column": 10925,
            "end_line": 4,
            "end_column": 11501,
            "start_byte": 10925,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 364,
            "start_column": 11507,
            "end_line": 4,
            "end_column": 11882,
            "start_byte": 11507,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)",
            "start_line": 372,
            "start_column": 11888,
            "end_line": 4,
            "end_column": 11985,
            "start_byte": 11888,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")",
            "start_line": 375,
            "start_column": 11991,
            "end_line": 4,
            "end_column": 12398,
            "start_byte": 11991,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2",
            "start_line": 385,
            "start_column": 12404,
            "end_line": 4,
            "end_column": 14437,
            "start_byte": 12404,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)",
            "start_line": 436,
            "start_column": 14443,
            "end_line": 4,
            "end_column": 15386,
            "start_byte": 14443,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"",
            "start_line": 457,
            "start_column": 15392,
            "end_line": 4,
            "end_column": 16095,
            "start_byte": 15392,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)",
            "start_line": 472,
            "start_column": 16101,
            "end_line": 4,
            "end_column": 16337,
            "start_byte": 16101,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line",
            "start_line": 478,
            "start_column": 16343,
            "end_line": 4,
            "end_column": 16666,
            "start_byte": 16343,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 495,
            "start_column": 16996,
            "end_line": 4,
            "end_column": 17388,
            "start_byte": 16996,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 505,
            "start_column": 17394,
            "end_line": 4,
            "end_column": 18778,
            "start_byte": 17394,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 545,
            "start_column": 18784,
            "end_line": 4,
            "end_column": 19889,
            "start_byte": 18784,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 572,
            "start_column": 19895,
            "end_line": 4,
            "end_column": 20038,
            "start_byte": 19895,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 577,
            "start_column": 20044,
            "end_line": 4,
            "end_column": 20699,
            "start_byte": 20044,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))",
            "start_line": 611,
            "start_column": 21341,
            "end_line": 4,
            "end_column": 22905,
            "start_byte": 21341,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()",
            "start_line": 646,
            "start_column": 22911,
            "end_line": 4,
            "end_column": 23642,
            "start_byte": 22911,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 667,
            "start_column": 23648,
            "end_line": 4,
            "end_column": 23991,
            "start_byte": 23648,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 678,
            "start_column": 23997,
            "end_line": 4,
            "end_column": 24112,
            "start_byte": 23997,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 681,
            "start_column": 24118,
            "end_line": 4,
            "end_column": 24245,
            "start_byte": 24118,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 685,
            "start_column": 24251,
            "end_line": 4,
            "end_column": 24779,
            "start_byte": 24251,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 699,
            "start_column": 24785,
            "end_line": 4,
            "end_column": 25607,
            "start_byte": 24785,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 721,
            "start_column": 25613,
            "end_line": 4,
            "end_column": 25771,
            "start_byte": 25613,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 727,
            "start_column": 25777,
            "end_line": 4,
            "end_column": 26021,
            "start_byte": 25777,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 739,
            "start_column": 26073,
            "end_line": 4,
            "end_column": 26262,
            "start_byte": 26073,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 746,
            "start_column": 26268,
            "end_line": 4,
            "end_column": 27912,
            "start_byte": 26268,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)",
            "start_line": 784,
            "start_column": 27918,
            "end_line": 4,
            "end_column": 28435,
            "start_byte": 27918,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 797,
            "start_column": 28441,
            "end_line": 4,
            "end_column": 28927,
            "start_byte": 28441,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)",
            "start_line": 810,
            "start_column": 28933,
            "end_line": 4,
            "end_column": 29916,
            "start_byte": 28933,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 833,
            "start_column": 29922,
            "end_line": 4,
            "end_column": 30518,
            "start_byte": 29922,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 848,
            "start_column": 30524,
            "end_line": 4,
            "end_column": 30981,
            "start_byte": 30524,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)",
            "start_line": 861,
            "start_column": 30987,
            "end_line": 4,
            "end_column": 31418,
            "start_byte": 30987,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 872,
            "start_column": 31424,
            "end_line": 4,
            "end_column": 34081,
            "start_byte": 31424,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(type=str, default=\"\")",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(type=Optional[Traceback], default=None)",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 490,
            "start_column": 15426,
            "end_line": 4,
            "end_column": 15636,
            "start_byte": 15426,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(default=False)\n    style = attr.ib(default=\"long\")\n    abspath = attr.ib(default=True)\n    tbfilter = attr.ib(default=True)\n    funcargs = attr.ib(default=False)\n    truncate_locals = attr.ib(default=True)\n    chain = attr.ib(default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n\n    def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines\n\n    def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n\n    def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)\n\n    def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline\n\n    def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 607,
            "start_column": 19506,
            "end_line": 0,
            "end_column": 29052,
            "start_byte": 19506,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.FormattedExcinfo.flow_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "flow_marker = \">\"",
            "start_line": 612,
            "start_column": 19646,
            "end_line": 4,
            "end_column": 19663,
            "start_byte": 19646,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.fail_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "fail_marker = \"E\"",
            "start_line": 613,
            "start_column": 19668,
            "end_line": 4,
            "end_column": 19685,
            "start_byte": 19668,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.showlocals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "showlocals = attr.ib(default=False)",
            "start_line": 615,
            "start_column": 19691,
            "end_line": 4,
            "end_column": 19726,
            "start_byte": 19691,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = attr.ib(default=\"long\")",
            "start_line": 616,
            "start_column": 19731,
            "end_line": 4,
            "end_column": 19762,
            "start_byte": 19731,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.abspath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "abspath = attr.ib(default=True)",
            "start_line": 617,
            "start_column": 19767,
            "end_line": 4,
            "end_column": 19798,
            "start_byte": 19767,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.tbfilter",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "tbfilter = attr.ib(default=True)",
            "start_line": 618,
            "start_column": 19803,
            "end_line": 4,
            "end_column": 19835,
            "start_byte": 19803,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.funcargs",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "funcargs = attr.ib(default=False)",
            "start_line": 619,
            "start_column": 19840,
            "end_line": 4,
            "end_column": 19873,
            "start_byte": 19840,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.truncate_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "truncate_locals = attr.ib(default=True)",
            "start_line": 620,
            "start_column": 19878,
            "end_line": 4,
            "end_column": 19917,
            "start_byte": 19878,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.chain",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "chain = attr.ib(default=True)",
            "start_line": 621,
            "start_column": 19922,
            "end_line": 4,
            "end_column": 19951,
            "start_byte": 19922,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.astcache",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)",
            "start_line": 622,
            "start_column": 19956,
            "end_line": 4,
            "end_column": 20026,
            "start_byte": 19956,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._getindent",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))",
            "start_line": 624,
            "start_column": 20032,
            "end_line": 4,
            "end_column": 20465,
            "start_byte": 20032,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._getentrysource",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source",
            "start_line": 639,
            "start_column": 20471,
            "end_line": 4,
            "end_column": 20644,
            "start_byte": 20471,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_args",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)",
            "start_line": 645,
            "start_column": 20650,
            "end_line": 4,
            "end_column": 20890,
            "start_byte": 20650,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.get_source",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines",
            "start_line": 652,
            "start_column": 20896,
            "end_line": 4,
            "end_column": 21896,
            "start_byte": 20896,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.get_exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines",
            "start_line": 676,
            "start_column": 21902,
            "end_line": 4,
            "end_column": 22326,
            "start_byte": 21902,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)",
            "start_line": 688,
            "start_column": 22332,
            "end_line": 4,
            "end_column": 23498,
            "start_byte": 22332,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 714,
            "start_column": 23504,
            "end_line": 4,
            "end_column": 24777,
            "start_byte": 23504,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._makepath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path",
            "start_line": 747,
            "start_column": 24783,
            "end_line": 4,
            "end_column": 25053,
            "start_byte": 24783,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 757,
            "start_column": 25059,
            "end_line": 4,
            "end_column": 25701,
            "start_byte": 25059,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo._truncate_recursive_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline",
            "start_line": 775,
            "start_column": 25707,
            "end_line": 4,
            "end_column": 27387,
            "start_byte": 25707,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 812,
            "start_column": 27393,
            "end_line": 4,
            "end_column": 29052,
            "start_byte": 27393,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionChainRepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ExceptionChainRepr(ExceptionRepr):\n    def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]\n\n    def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 882,
            "start_column": 29762,
            "end_line": 0,
            "end_column": 30319,
            "start_byte": 29762,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionChainRepr.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]",
            "start_line": 883,
            "start_column": 29807,
            "end_line": 4,
            "end_column": 30068,
            "start_byte": 29807,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionChainRepr.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 891,
            "start_column": 30074,
            "end_line": 4,
            "end_column": 30319,
            "start_byte": 30074,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTraceback(TerminalRepr):\n    entrysep = \"_ \"\n\n    def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style\n\n    def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 911,
            "start_column": 30623,
            "end_line": 0,
            "end_column": 31451,
            "start_byte": 30623,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprTraceback.entrysep",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "entrysep = \"_ \"",
            "start_line": 912,
            "start_column": 30662,
            "end_line": 4,
            "end_column": 30677,
            "start_byte": 30662,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style",
            "start_line": 914,
            "start_column": 30683,
            "end_line": 4,
            "end_column": 30834,
            "start_byte": 30683,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTraceback.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 919,
            "start_column": 30840,
            "end_line": 4,
            "end_column": 31451,
            "start_byte": 30840,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprTracebackNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 938,
            "start_column": 31454,
            "end_line": 0,
            "end_column": 31642,
            "start_byte": 31454,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprTracebackNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 939,
            "start_column": 31500,
            "end_line": 4,
            "end_column": 31642,
            "start_byte": 31500,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntryNative(TerminalRepr):\n    style = \"native\"\n\n    def __init__(self, tblines):\n        self.lines = tblines\n\n    def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 945,
            "start_column": 31645,
            "end_line": 0,
            "end_column": 31834,
            "start_byte": 31645,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprEntryNative.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = \"native\"",
            "start_line": 946,
            "start_column": 31686,
            "end_line": 4,
            "end_column": 31702,
            "start_byte": 31686,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.lines = tblines",
            "start_line": 948,
            "start_column": 31708,
            "end_line": 4,
            "end_column": 31765,
            "start_byte": 31708,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntryNative.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 951,
            "start_column": 31771,
            "end_line": 4,
            "end_column": 31834,
            "start_byte": 31771,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntry(TerminalRepr):\n    def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style\n\n    def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 955,
            "start_column": 31837,
            "end_line": 0,
            "end_column": 32932,
            "start_byte": 31837,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprEntry.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style",
            "start_line": 956,
            "start_column": 31872,
            "end_line": 4,
            "end_column": 32115,
            "start_byte": 31872,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)",
            "start_line": 963,
            "start_column": 32121,
            "end_line": 4,
            "end_column": 32793,
            "start_byte": 32121,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprEntry.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 983,
            "start_column": 32799,
            "end_line": 4,
            "end_column": 32932,
            "start_byte": 32799,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "Analyzing the user-reported issue:\n1.1 The issue is about exception serialization, specifically for chained exceptions, when using pytest with xdist.\n1.2 It is caused because current xdist serialization doesn't support chained exceptions, hence only the last exception is displayed.\n1.3 The expected result should include all exceptions in the chain, similar to running without xdist.\n1.4 The expected outcome would be that when a test fails, the entire chain of exceptions should be visible across different nodes in distributed testing.\n1.5 The issue could be resolved by updating the exception serialization/deserialization mechanism to support chained exceptions.\n\nEvaluating symbols:\n2.1 Through 2.4 \u2013 Assess symbols for relevance to this problem.\n2.5 If necessary, request more info.\n2.6 Determine number of symbols to change to resolve issue.",
        "symbols": [
          {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "reason": "The `_to_json` method must be updated to properly serialize chained exceptions within `longrepr`."
          },
          {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "reason": "The `_from_json` method must be updated to properly deserialize chained exceptions within `longrepr`."
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "reason": "This method includes parameters specifically for handling chained exceptions, and might need adjustments to fully support serialization for pytest-xdist."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The `pytest_report_to_serializable` method transforms a report into a serializable format, but does not seem directly responsible for handling exceptions.",
          "The `_to_json` method in `BaseReport` is tasked with serializing the report, involving `longrepr` for exceptions, which means it might need adjustments to serialize chains of exceptions.\n\nThe `disassembled_report` closure function within this method might need enhancement to ensure traceback and exception information not currently accounted for in chained exceptions is serialized correctly.",
          "The `_from_json` method handles deserialization of reports, which includes handling `longrepr`, potentially requiring changes to manage chained exceptions.",
          "`TestReport` class mainly holds data, and its serialization/deserialization is handled by the `BaseReport` methods.",
          "The TerminalReporter comments and code seem to generally deal with display aspects and don't impact the serialization of exceptions themselves in pytest-xdist.",
          "ExceptionInfo is a key element in handling exceptions, and the `getrepr` method in `_code.ExceptionInfo` is particularly important as it directly supports chained exceptions with a `chain` parameter. It may require addressing potential serialization gaps for chained exceptions."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:42.639309",
        "usage": "7.786989212036133 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest._code.ExceptionInfo",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 386,
              "start_column": 11961,
              "end_line": 0,
              "end_column": 19503,
              "start_byte": 11961,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo._assert_start_repr",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 392,
              "start_column": 12119,
              "end_line": 4,
              "end_column": 12165,
              "start_byte": 12119,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._excinfo",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 394,
              "start_column": 12171,
              "end_line": 4,
              "end_column": 12244,
              "start_byte": 12171,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._striptext",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 395,
              "start_column": 12249,
              "end_line": 4,
              "end_column": 12291,
              "start_byte": 12249,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._traceback",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 396,
              "start_column": 12296,
              "end_line": 4,
              "end_column": 12356,
              "start_byte": 12296,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_exc_info",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 398,
              "start_column": 12362,
              "end_line": 4,
              "end_column": 13284,
              "start_byte": 12362,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_current",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 425,
              "start_column": 13290,
              "end_line": 4,
              "end_column": 14045,
              "start_byte": 13290,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.for_later",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 447,
              "start_column": 14051,
              "end_line": 4,
              "end_column": 14191,
              "start_byte": 14051,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.fill_unfilled",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 453,
              "start_column": 14197,
              "end_line": 4,
              "end_column": 14453,
              "start_byte": 14197,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.type",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 458,
              "start_column": 14459,
              "end_line": 4,
              "end_column": 14691,
              "start_byte": 14459,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.value",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 466,
              "start_column": 14697,
              "end_line": 4,
              "end_column": 14923,
              "start_byte": 14697,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.tb",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 474,
              "start_column": 14929,
              "end_line": 4,
              "end_column": 15168,
              "start_byte": 14929,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.typename",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 482,
              "start_column": 15174,
              "end_line": 4,
              "end_column": 15420,
              "start_byte": 15174,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 490,
              "start_column": 15426,
              "end_line": 4,
              "end_column": 15636,
              "start_byte": 15426,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 497,
              "start_column": 15642,
              "end_line": 4,
              "end_column": 15742,
              "start_byte": 15642,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__repr__",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 501,
              "start_column": 15748,
              "end_line": 4,
              "end_column": 15955,
              "start_byte": 15748,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.exconly",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 506,
              "start_column": 15961,
              "end_line": 4,
              "end_column": 16595,
              "start_byte": 15961,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.errisinstance",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 522,
              "start_column": 16601,
              "end_line": 4,
              "end_column": 16827,
              "start_byte": 16601,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._getreprcrash",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 528,
              "start_column": 16833,
              "end_line": 4,
              "end_column": 17101,
              "start_byte": 16833,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 534,
              "start_column": 17107,
              "end_line": 4,
              "end_column": 18918,
              "start_byte": 17107,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.match",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 593,
              "start_column": 18924,
              "end_line": 4,
              "end_column": 19503,
              "start_byte": 18924,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 900,
              "start_column": 30322,
              "end_line": 0,
              "end_column": 30620,
              "start_byte": 30322,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.__init__",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 901,
              "start_column": 30366,
              "end_line": 4,
              "end_column": 30516,
              "start_byte": 30366,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.toterminal",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 906,
              "start_column": 30522,
              "end_line": 4,
              "end_column": 30620,
              "start_byte": 30522,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(item, when, log=True, **kwds):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 165,
              "start_column": 4915,
              "end_line": 0,
              "end_column": 5311,
              "start_byte": 4915,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.check_interactive_exception",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
              "start_line": 176,
              "start_column": 5314,
              "end_line": 0,
              "end_column": 5534,
              "start_byte": 5314,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.hookspec.pytest_report_to_serializable",
              "file_path": "src/_pytest/reports.py",
              "file_content": " item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )\n\n\nclass CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n      ",
              "start_line": 380,
              "start_column": 12325,
              "end_line": 0,
              "end_column": 12939,
              "start_byte": 12325,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.BaseReport._to_json",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n\n        def disassembled_report(rep):\n            reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n            reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n\n            new_entries = []\n            for entry in reprtraceback[\"reprentries\"]:\n                entry_data = {\n                    \"type\": type(entry).__name__,\n                    \"data\": entry.__dict__.copy(),\n                }\n                for key, value in entry_data[\"data\"].items():\n                    if hasattr(value, \"__dict__\"):\n                        entry_data[\"data\"][key] = value.__dict__.copy()\n                new_entries.append(entry_data)\n\n            reprtraceback[\"reprentries\"] = new_entries\n\n            return {\n                \"reprcrash\": reprcrash,\n                \"reprtraceback\": reprtraceback,\n                \"sections\": rep.longrepr.sections,\n            }\n\n        d = self.__dict__.copy()\n        if hasattr(self.longrepr, \"toterminal\"):\n            if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n                self.longrepr, \"reprcrash\"\n            ):\n                d[\"longrepr\"] = disassembled_report(self)\n            else:\n                d[\"longrepr\"] = str(self.longrepr)\n        else:\n            d[\"longrepr\"] = self.longrepr\n        for name in d:\n            if isinstance(d[name], (py.path.local, Path)):\n                d[name] = str(d[name])\n            elif name == \"result\":\n                d[name] = None  # for now\n        return d",
              "start_line": 153,
              "start_column": 4241,
              "end_line": 4,
              "end_column": 5985,
              "start_byte": 4241,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.BaseReport._from_json",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        if reportdict[\"longrepr\"]:\n            if (\n                \"reprcrash\" in reportdict[\"longrepr\"]\n                and \"reprtraceback\" in reportdict[\"longrepr\"]\n            ):\n\n                reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n                reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n\n                unserialized_entries = []\n                reprentry = None\n                for entry_data in reprtraceback[\"reprentries\"]:\n                    data = entry_data[\"data\"]\n                    entry_type = entry_data[\"type\"]\n                    if entry_type == \"ReprEntry\":\n                        reprfuncargs = None\n                        reprfileloc = None\n                        reprlocals = None\n                        if data[\"reprfuncargs\"]:\n                            reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n                        if data[\"reprfileloc\"]:\n                            reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n                        if data[\"reprlocals\"]:\n                            reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n                        reprentry = ReprEntry(\n                            lines=data[\"lines\"],\n                            reprfuncargs=reprfuncargs,\n                            reprlocals=reprlocals,\n                            filelocrepr=reprfileloc,\n                            style=data[\"style\"],\n                        )\n                    elif entry_type == \"ReprEntryNative\":\n                        reprentry = ReprEntryNative(data[\"lines\"])\n                    else:\n                        _report_unserialization_failure(entry_type, cls, reportdict)\n                    unserialized_entries.append(reprentry)\n                reprtraceback[\"reprentries\"] = unserialized_entries\n\n                exception_info = ReprExceptionInfo(\n                    reprtraceback=ReprTraceback(**reprtraceback),\n                    reprcrash=ReprFileLocation(**reprcrash),\n                )\n\n                for section in reportdict[\"longrepr\"][\"sections\"]:\n                    exception_info.addsection(*section)\n                reportdict[\"longrepr\"] = exception_info\n\n        return cls(**reportdict)",
              "start_line": 203,
              "start_column": 5991,
              "end_line": 4,
              "end_column": 8587,
              "start_byte": 5991,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport",
              "file_path": "src/_pytest/reports.py",
              "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
              "start_line": 276,
              "start_column": 9116,
              "end_line": 0,
              "end_column": 12552,
              "start_byte": 9116,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.TestReport.__test__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "__test__ = False",
              "start_line": 281,
              "start_column": 9251,
              "end_line": 4,
              "end_column": 9267,
              "start_byte": 9251,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.__init__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
              "start_line": 283,
              "start_column": 9273,
              "end_line": 4,
              "end_column": 10859,
              "start_byte": 9273,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.__repr__",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
              "start_line": 332,
              "start_column": 10865,
              "end_line": 4,
              "end_column": 11026,
              "start_byte": 10865,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.TestReport.from_item_and_call",
              "file_path": "src/_pytest/reports.py",
              "file_content": "@classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
              "start_line": 337,
              "start_column": 11032,
              "end_line": 4,
              "end_column": 12552,
              "start_byte": 11032,
              "end_byte": 4
            },
            {
              "name": "_pytest.reports.pytest_report_to_serializable",
              "file_path": "src/_pytest/reports.py",
              "file_content": "def pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"_report_type\"] = report.__class__.__name__\n        return data",
              "start_line": 410,
              "start_column": 13317,
              "end_line": 0,
              "end_column": 13525,
              "start_byte": 13317,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.TerminalReporter",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "class TerminalReporter:\n    def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content, **markup):\n        self._tw.write(content, **markup)\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n\n    def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n\n    def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)\n\n    def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line\n\n    def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)\n\n    def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n\n    def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)\n\n    def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
              "start_line": 217,
              "start_column": 6374,
              "end_line": 0,
              "end_column": 34081,
              "start_byte": 6374,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.TerminalReporter.__init__",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None",
              "start_line": 218,
              "start_column": 6402,
              "end_line": 4,
              "end_column": 7252,
              "start_byte": 6402,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
              "start_line": 242,
              "start_column": 7258,
              "end_line": 4,
              "end_column": 7841,
              "start_byte": 7258,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.verbosity",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
              "start_line": 255,
              "start_column": 7847,
              "end_line": 4,
              "end_column": 7923,
              "start_byte": 7847,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showheader",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
              "start_line": 259,
              "start_column": 7929,
              "end_line": 4,
              "end_column": 7999,
              "start_byte": 7929,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showfspath",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath",
              "start_line": 263,
              "start_column": 8005,
              "end_line": 4,
              "end_column": 8148,
              "start_byte": 8005,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showfspath",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
              "start_line": 269,
              "start_column": 8154,
              "end_line": 4,
              "end_column": 8238,
              "start_byte": 8154,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
              "start_line": 273,
              "start_column": 8244,
              "end_line": 4,
              "end_column": 8319,
              "start_byte": 8244,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.hasopt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
              "start_line": 277,
              "start_column": 8325,
              "end_line": 4,
              "end_column": 8452,
              "start_byte": 8325,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)",
              "start_line": 281,
              "start_column": 8458,
              "end_line": 4,
              "end_column": 9143,
              "start_byte": 8458,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
              "start_line": 294,
              "start_column": 9149,
              "end_line": 4,
              "end_column": 9449,
              "start_byte": 9149,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.ensure_newline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
              "start_line": 303,
              "start_column": 9455,
              "end_line": 4,
              "end_column": 9577,
              "start_byte": 9455,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write(self, content, **markup):\n        self._tw.write(content, **markup)",
              "start_line": 308,
              "start_column": 9583,
              "end_line": 4,
              "end_column": 9660,
              "start_byte": 9583,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
              "start_line": 311,
              "start_column": 9666,
              "end_line": 4,
              "end_column": 9856,
              "start_byte": 9666,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.rewrite",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
              "start_line": 317,
              "start_column": 9862,
              "end_line": 4,
              "end_column": 10480,
              "start_byte": 9862,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.write_sep",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
              "start_line": 335,
              "start_column": 10486,
              "end_line": 4,
              "end_column": 10606,
              "start_byte": 10486,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.section",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
              "start_line": 339,
              "start_column": 10612,
              "end_line": 4,
              "end_column": 10691,
              "start_byte": 10612,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
              "start_line": 342,
              "start_column": 10697,
              "end_line": 4,
              "end_column": 10756,
              "start_byte": 10697,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
              "start_line": 345,
              "start_column": 10762,
              "end_line": 4,
              "end_column": 10919,
              "start_byte": 10762,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)",
              "start_line": 350,
              "start_column": 10925,
              "end_line": 4,
              "end_column": 11501,
              "start_byte": 10925,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
              "start_line": 364,
              "start_column": 11507,
              "end_line": 4,
              "end_column": 11882,
              "start_byte": 11507,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)",
              "start_line": 372,
              "start_column": 11888,
              "end_line": 4,
              "end_column": 11985,
              "start_byte": 11888,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")",
              "start_line": 375,
              "start_column": 11991,
              "end_line": 4,
              "end_column": 12398,
              "start_byte": 11991,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2",
              "start_line": 385,
              "start_column": 12404,
              "end_line": 4,
              "end_column": 14437,
              "start_byte": 12404,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)",
              "start_line": 436,
              "start_column": 14443,
              "end_line": 4,
              "end_column": 15386,
              "start_byte": 14443,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"",
              "start_line": 457,
              "start_column": 15392,
              "end_line": 4,
              "end_column": 16095,
              "start_byte": 15392,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)",
              "start_line": 472,
              "start_column": 16101,
              "end_line": 4,
              "end_column": 16337,
              "start_byte": 16101,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line",
              "start_line": 478,
              "start_column": 16343,
              "end_line": 4,
              "end_column": 16666,
              "start_byte": 16343,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)",
              "start_line": 487,
              "start_column": 16672,
              "end_line": 4,
              "end_column": 16990,
              "start_byte": 16672,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
              "start_line": 495,
              "start_column": 16996,
              "end_line": 4,
              "end_column": 17388,
              "start_byte": 16996,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.report_collect",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
              "start_line": 505,
              "start_column": 17394,
              "end_line": 4,
              "end_column": 18778,
              "start_byte": 17394,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
              "start_line": 545,
              "start_column": 18784,
              "end_line": 4,
              "end_column": 19889,
              "start_byte": 18784,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
              "start_line": 572,
              "start_column": 19895,
              "end_line": 4,
              "end_column": 20038,
              "start_byte": 19895,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
              "start_line": 577,
              "start_column": 20044,
              "end_line": 4,
              "end_column": 20699,
              "start_byte": 20044,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)",
              "start_line": 594,
              "start_column": 20705,
              "end_line": 4,
              "end_column": 21335,
              "start_byte": 20705,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))",
              "start_line": 611,
              "start_column": 21341,
              "end_line": 4,
              "end_column": 22905,
              "start_byte": 21341,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()",
              "start_line": 646,
              "start_column": 22911,
              "end_line": 4,
              "end_column": 23642,
              "start_byte": 22911,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
              "start_line": 667,
              "start_column": 23648,
              "end_line": 4,
              "end_column": 23991,
              "start_byte": 23648,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
              "start_line": 678,
              "start_column": 23997,
              "end_line": 4,
              "end_column": 24112,
              "start_byte": 23997,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
              "start_line": 681,
              "start_column": 24118,
              "end_line": 4,
              "end_column": 24245,
              "start_byte": 24118,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
              "start_line": 685,
              "start_column": 24251,
              "end_line": 4,
              "end_column": 24779,
              "start_byte": 24251,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._locationline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
              "start_line": 699,
              "start_column": 24785,
              "end_line": 4,
              "end_column": 25607,
              "start_byte": 24785,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
              "start_line": 721,
              "start_column": 25613,
              "end_line": 4,
              "end_column": 25771,
              "start_byte": 25613,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._getcrashline",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
              "start_line": 727,
              "start_column": 25777,
              "end_line": 4,
              "end_column": 26021,
              "start_byte": 25777,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.getreports",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
              "start_line": 739,
              "start_column": 26073,
              "end_line": 4,
              "end_column": 26262,
              "start_byte": 26073,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_warnings",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
              "start_line": 746,
              "start_column": 26268,
              "end_line": 4,
              "end_column": 27912,
              "start_byte": 26268,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_passes",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)",
              "start_line": 784,
              "start_column": 27918,
              "end_line": 4,
              "end_column": 28435,
              "start_byte": 27918,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
              "start_line": 797,
              "start_column": 28441,
              "end_line": 4,
              "end_column": 28927,
              "start_byte": 28441,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_failures",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)",
              "start_line": 810,
              "start_column": 28933,
              "end_line": 4,
              "end_column": 29916,
              "start_byte": 28933,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_errors",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
              "start_line": 833,
              "start_column": 29922,
              "end_line": 4,
              "end_column": 30518,
              "start_byte": 29922,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._outrep_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
              "start_line": 848,
              "start_column": 30524,
              "end_line": 4,
              "end_column": 30981,
              "start_byte": 30524,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.summary_stats",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)",
              "start_line": 861,
              "start_column": 30987,
              "end_line": 4,
              "end_column": 31418,
              "start_byte": 30987,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.short_test_summary",
              "file_path": "src/_pytest/terminal.py",
              "file_content": "def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
              "start_line": 872,
              "start_column": 31424,
              "end_line": 4,
              "end_column": 34081,
              "start_byte": 31424,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
              "start_line": 386,
              "start_column": 11961,
              "end_line": 0,
              "end_column": 19503,
              "start_byte": 11961,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo._assert_start_repr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_assert_start_repr = \"AssertionError('assert \"",
              "start_line": 392,
              "start_column": 12119,
              "end_line": 4,
              "end_column": 12165,
              "start_byte": 12119,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])",
              "start_line": 394,
              "start_column": 12171,
              "end_line": 4,
              "end_column": 12244,
              "start_byte": 12171,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._striptext",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_striptext = attr.ib(type=str, default=\"\")",
              "start_line": 395,
              "start_column": 12249,
              "end_line": 4,
              "end_column": 12291,
              "start_byte": 12249,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_traceback = attr.ib(type=Optional[Traceback], default=None)",
              "start_line": 396,
              "start_column": 12296,
              "end_line": 4,
              "end_column": 12356,
              "start_byte": 12296,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_exc_info",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)",
              "start_line": 398,
              "start_column": 12362,
              "end_line": 4,
              "end_column": 13284,
              "start_byte": 12362,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_current",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)",
              "start_line": 425,
              "start_column": 13290,
              "end_line": 4,
              "end_column": 14045,
              "start_byte": 13290,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.for_later",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
              "start_line": 447,
              "start_column": 14051,
              "end_line": 4,
              "end_column": 14191,
              "start_byte": 14051,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.fill_unfilled",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info",
              "start_line": 453,
              "start_column": 14197,
              "end_line": 4,
              "end_column": 14453,
              "start_byte": 14197,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.type",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]",
              "start_line": 458,
              "start_column": 14459,
              "end_line": 4,
              "end_column": 14691,
              "start_byte": 14459,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.value",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]",
              "start_line": 466,
              "start_column": 14697,
              "end_line": 4,
              "end_column": 14923,
              "start_byte": 14697,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.tb",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]",
              "start_line": 474,
              "start_column": 14929,
              "end_line": 4,
              "end_column": 15168,
              "start_byte": 14929,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.typename",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__",
              "start_line": 482,
              "start_column": 15174,
              "end_line": 4,
              "end_column": 15420,
              "start_byte": 15174,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
              "start_line": 490,
              "start_column": 15426,
              "end_line": 4,
              "end_column": 15636,
              "start_byte": 15426,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value",
              "start_line": 497,
              "start_column": 15642,
              "end_line": 4,
              "end_column": 15742,
              "start_byte": 15642,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__repr__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
              "start_line": 501,
              "start_column": 15748,
              "end_line": 4,
              "end_column": 15955,
              "start_byte": 15748,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.exconly",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
              "start_line": 506,
              "start_column": 15961,
              "end_line": 4,
              "end_column": 16595,
              "start_byte": 15961,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.errisinstance",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
              "start_line": 522,
              "start_column": 16601,
              "end_line": 4,
              "end_column": 16827,
              "start_byte": 16601,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._getreprcrash",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
              "start_line": 528,
              "start_column": 16833,
              "end_line": 4,
              "end_column": 17101,
              "start_byte": 16833,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 534,
              "start_column": 17107,
              "end_line": 4,
              "end_column": 18918,
              "start_byte": 17107,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.match",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
              "start_line": 593,
              "start_column": 18924,
              "end_line": 4,
              "end_column": 19503,
              "start_byte": 18924,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(default=False)\n    style = attr.ib(default=\"long\")\n    abspath = attr.ib(default=True)\n    tbfilter = attr.ib(default=True)\n    funcargs = attr.ib(default=False)\n    truncate_locals = attr.ib(default=True)\n    chain = attr.ib(default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n\n    def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines\n\n    def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n\n    def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)\n\n    def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline\n\n    def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
              "start_line": 607,
              "start_column": 19506,
              "end_line": 0,
              "end_column": 29052,
              "start_byte": 19506,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.FormattedExcinfo.flow_marker",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "flow_marker = \">\"",
              "start_line": 612,
              "start_column": 19646,
              "end_line": 4,
              "end_column": 19663,
              "start_byte": 19646,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.fail_marker",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "fail_marker = \"E\"",
              "start_line": 613,
              "start_column": 19668,
              "end_line": 4,
              "end_column": 19685,
              "start_byte": 19668,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.showlocals",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "showlocals = attr.ib(default=False)",
              "start_line": 615,
              "start_column": 19691,
              "end_line": 4,
              "end_column": 19726,
              "start_byte": 19691,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.style",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "style = attr.ib(default=\"long\")",
              "start_line": 616,
              "start_column": 19731,
              "end_line": 4,
              "end_column": 19762,
              "start_byte": 19731,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.abspath",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "abspath = attr.ib(default=True)",
              "start_line": 617,
              "start_column": 19767,
              "end_line": 4,
              "end_column": 19798,
              "start_byte": 19767,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.tbfilter",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "tbfilter = attr.ib(default=True)",
              "start_line": 618,
              "start_column": 19803,
              "end_line": 4,
              "end_column": 19835,
              "start_byte": 19803,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.funcargs",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "funcargs = attr.ib(default=False)",
              "start_line": 619,
              "start_column": 19840,
              "end_line": 4,
              "end_column": 19873,
              "start_byte": 19840,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.truncate_locals",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "truncate_locals = attr.ib(default=True)",
              "start_line": 620,
              "start_column": 19878,
              "end_line": 4,
              "end_column": 19917,
              "start_byte": 19878,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.chain",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "chain = attr.ib(default=True)",
              "start_line": 621,
              "start_column": 19922,
              "end_line": 4,
              "end_column": 19951,
              "start_byte": 19922,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.astcache",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)",
              "start_line": 622,
              "start_column": 19956,
              "end_line": 4,
              "end_column": 20026,
              "start_byte": 19956,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo._getindent",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))",
              "start_line": 624,
              "start_column": 20032,
              "end_line": 4,
              "end_column": 20465,
              "start_byte": 20032,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo._getentrysource",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source",
              "start_line": 639,
              "start_column": 20471,
              "end_line": 4,
              "end_column": 20644,
              "start_byte": 20471,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_args",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)",
              "start_line": 645,
              "start_column": 20650,
              "end_line": 4,
              "end_column": 20890,
              "start_byte": 20650,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.get_source",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines",
              "start_line": 652,
              "start_column": 20896,
              "end_line": 4,
              "end_column": 21896,
              "start_byte": 20896,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.get_exconly",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines",
              "start_line": 676,
              "start_column": 21902,
              "end_line": 4,
              "end_column": 22326,
              "start_byte": 21902,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_locals",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)",
              "start_line": 688,
              "start_column": 22332,
              "end_line": 4,
              "end_column": 23498,
              "start_byte": 22332,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
              "start_line": 714,
              "start_column": 23504,
              "end_line": 4,
              "end_column": 24777,
              "start_byte": 23504,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo._makepath",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path",
              "start_line": 747,
              "start_column": 24783,
              "end_line": 4,
              "end_column": 25053,
              "start_byte": 24783,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
              "start_line": 757,
              "start_column": 25059,
              "end_line": 4,
              "end_column": 25701,
              "start_byte": 25059,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo._truncate_recursive_traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline",
              "start_line": 775,
              "start_column": 25707,
              "end_line": 4,
              "end_column": 27387,
              "start_byte": 25707,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
              "start_line": 812,
              "start_column": 27393,
              "end_line": 4,
              "end_column": 29052,
              "start_byte": 27393,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionChainRepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ExceptionChainRepr(ExceptionRepr):\n    def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]\n\n    def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
              "start_line": 882,
              "start_column": 29762,
              "end_line": 0,
              "end_column": 30319,
              "start_byte": 29762,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionChainRepr.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]",
              "start_line": 883,
              "start_column": 29807,
              "end_line": 4,
              "end_column": 30068,
              "start_byte": 29807,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionChainRepr.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
              "start_line": 891,
              "start_column": 30074,
              "end_line": 4,
              "end_column": 30319,
              "start_byte": 30074,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 900,
              "start_column": 30322,
              "end_line": 0,
              "end_column": 30620,
              "start_byte": 30322,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
              "start_line": 901,
              "start_column": 30366,
              "end_line": 4,
              "end_column": 30516,
              "start_byte": 30366,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 906,
              "start_column": 30522,
              "end_line": 4,
              "end_column": 30620,
              "start_byte": 30522,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprTraceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprTraceback(TerminalRepr):\n    entrysep = \"_ \"\n\n    def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style\n\n    def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
              "start_line": 911,
              "start_column": 30623,
              "end_line": 0,
              "end_column": 31451,
              "start_byte": 30623,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprTraceback.entrysep",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "entrysep = \"_ \"",
              "start_line": 912,
              "start_column": 30662,
              "end_line": 4,
              "end_column": 30677,
              "start_byte": 30662,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprTraceback.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style",
              "start_line": 914,
              "start_column": 30683,
              "end_line": 4,
              "end_column": 30834,
              "start_byte": 30683,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprTraceback.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
              "start_line": 919,
              "start_column": 30840,
              "end_line": 4,
              "end_column": 31451,
              "start_byte": 30840,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprTracebackNative",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
              "start_line": 938,
              "start_column": 31454,
              "end_line": 0,
              "end_column": 31642,
              "start_byte": 31454,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprTracebackNative.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
              "start_line": 939,
              "start_column": 31500,
              "end_line": 4,
              "end_column": 31642,
              "start_byte": 31500,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntryNative",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprEntryNative(TerminalRepr):\n    style = \"native\"\n\n    def __init__(self, tblines):\n        self.lines = tblines\n\n    def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
              "start_line": 945,
              "start_column": 31645,
              "end_line": 0,
              "end_column": 31834,
              "start_byte": 31645,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprEntryNative.style",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "style = \"native\"",
              "start_line": 946,
              "start_column": 31686,
              "end_line": 4,
              "end_column": 31702,
              "start_byte": 31686,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntryNative.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, tblines):\n        self.lines = tblines",
              "start_line": 948,
              "start_column": 31708,
              "end_line": 4,
              "end_column": 31765,
              "start_byte": 31708,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntryNative.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
              "start_line": 951,
              "start_column": 31771,
              "end_line": 4,
              "end_column": 31834,
              "start_byte": 31771,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntry",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprEntry(TerminalRepr):\n    def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style\n\n    def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
              "start_line": 955,
              "start_column": 31837,
              "end_line": 0,
              "end_column": 32932,
              "start_byte": 31837,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprEntry.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style",
              "start_line": 956,
              "start_column": 31872,
              "end_line": 4,
              "end_column": 32115,
              "start_byte": 31872,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntry.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)",
              "start_line": 963,
              "start_column": 32121,
              "end_line": 4,
              "end_column": 32793,
              "start_byte": 32121,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprEntry.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
              "start_line": 983,
              "start_column": 32799,
              "end_line": 4,
              "end_column": 32932,
              "start_byte": 32799,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Analyzing the user-reported issue:\n1.1 The issue is about exception serialization, specifically for chained exceptions, when using pytest with xdist.\n1.2 It is caused because current xdist serialization doesn't support chained exceptions, hence only the last exception is displayed.\n1.3 The expected result should include all exceptions in the chain, similar to running without xdist.\n1.4 The expected outcome would be that when a test fails, the entire chain of exceptions should be visible across different nodes in distributed testing.\n1.5 The issue could be resolved by updating the exception serialization/deserialization mechanism to support chained exceptions.\n\nEvaluating symbols:\n2.1 Through 2.4 \u2013 Assess symbols for relevance to this problem.\n2.5 If necessary, request more info.\n2.6 Determine number of symbols to change to resolve issue.",
          "symbols": [
            {
              "name": "_pytest.reports.BaseReport._to_json",
              "file_path": "src/_pytest/reports.py",
              "reason": "The `_to_json` method must be updated to properly serialize chained exceptions within `longrepr`."
            },
            {
              "name": "_pytest.reports.BaseReport._from_json",
              "file_path": "src/_pytest/reports.py",
              "reason": "The `_from_json` method must be updated to properly deserialize chained exceptions within `longrepr`."
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "reason": "This method includes parameters specifically for handling chained exceptions, and might need adjustments to fully support serialization for pytest-xdist."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The `pytest_report_to_serializable` method transforms a report into a serializable format, but does not seem directly responsible for handling exceptions.",
            "The `_to_json` method in `BaseReport` is tasked with serializing the report, involving `longrepr` for exceptions, which means it might need adjustments to serialize chains of exceptions.\n\nThe `disassembled_report` closure function within this method might need enhancement to ensure traceback and exception information not currently accounted for in chained exceptions is serialized correctly.",
            "The `_from_json` method handles deserialization of reports, which includes handling `longrepr`, potentially requiring changes to manage chained exceptions.",
            "`TestReport` class mainly holds data, and its serialization/deserialization is handled by the `BaseReport` methods.",
            "The TerminalReporter comments and code seem to generally deal with display aspects and don't impact the serialization of exceptions themselves in pytest-xdist.",
            "ExceptionInfo is a key element in handling exceptions, and the `getrepr` method in `_code.ExceptionInfo` is particularly important as it directly supports chained exceptions with a `chain` parameter. It may require addressing potential serialization gaps for chained exceptions."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/reports.py",
          "src/_pytest/_code/code.py"
        ],
        "symbols": [
          "_pytest.reports.BaseReport._to_json",
          "_pytest.reports.BaseReport._from_json",
          "_pytest._code.ExceptionInfo.getrepr"
        ],
        "code_spans": {
          "_pytest._code.ExceptionInfo": {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, default=\"\")\n    _traceback = attr.ib(type=Optional[Traceback], default=None)\n\n    @classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)\n\n    @classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)\n\n    @classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info\n\n    @property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]\n\n    @property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__\n\n    @property\n    def traceback(self) -> Traceback:\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value\n\n    def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 386,
            "start_column": 11961,
            "end_line": 0,
            "end_column": 19503,
            "start_byte": 11961,
            "end_byte": 0
          },
          "_pytest._code.ExceptionInfo._assert_start_repr": {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 392,
            "start_column": 12119,
            "end_line": 4,
            "end_column": 12165,
            "start_byte": 12119,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._excinfo": {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])",
            "start_line": 394,
            "start_column": 12171,
            "end_line": 4,
            "end_column": 12244,
            "start_byte": 12171,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._striptext": {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(type=str, default=\"\")",
            "start_line": 395,
            "start_column": 12249,
            "end_line": 4,
            "end_column": 12291,
            "start_byte": 12249,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._traceback": {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(type=Optional[Traceback], default=None)",
            "start_line": 396,
            "start_column": 12296,
            "end_line": 4,
            "end_column": 12356,
            "start_byte": 12296,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.from_exc_info": {
            "name": "_pytest._code.ExceptionInfo.from_exc_info",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_exc_info(\n        cls,\n        exc_info: Tuple[\"Type[_E]\", \"_E\", TracebackType],\n        exprinfo: Optional[str] = None,\n    ) -> \"ExceptionInfo[_E]\":\n        \"\"\"returns an ExceptionInfo for an existing exc_info tuple.\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(exc_info[1], AssertionError):\n            exprinfo = getattr(exc_info[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(exc_info[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(exc_info, _striptext)",
            "start_line": 398,
            "start_column": 12362,
            "end_line": 4,
            "end_column": 13284,
            "start_byte": 12362,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.from_current": {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(\n        cls, exprinfo: Optional[str] = None\n    ) -> \"ExceptionInfo[BaseException]\":\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        assert tup[1] is not None, \"no current exception\"\n        assert tup[2] is not None, \"no current exception\"\n        exc_info = (tup[0], tup[1], tup[2])\n        return cls.from_exc_info(exc_info)",
            "start_line": 425,
            "start_column": 13290,
            "end_line": 4,
            "end_column": 14045,
            "start_byte": 13290,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.for_later": {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls) -> \"ExceptionInfo[_E]\":\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 447,
            "start_column": 14051,
            "end_line": 4,
            "end_column": 14191,
            "start_byte": 14051,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.fill_unfilled": {
            "name": "_pytest._code.ExceptionInfo.fill_unfilled",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def fill_unfilled(self, exc_info: Tuple[\"Type[_E]\", _E, TracebackType]) -> None:\n        \"\"\"fill an unfilled ExceptionInfo created with for_later()\"\"\"\n        assert self._excinfo is None, \"ExceptionInfo was already filled\"\n        self._excinfo = exc_info",
            "start_line": 453,
            "start_column": 14197,
            "end_line": 4,
            "end_column": 14453,
            "start_byte": 14197,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.type": {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self) -> \"Type[_E]\":\n        \"\"\"the exception class\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".type can only be used after the context manager exits\"\n        return self._excinfo[0]",
            "start_line": 458,
            "start_column": 14459,
            "end_line": 4,
            "end_column": 14691,
            "start_byte": 14459,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.value": {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self) -> _E:\n        \"\"\"the exception value\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".value can only be used after the context manager exits\"\n        return self._excinfo[1]",
            "start_line": 466,
            "start_column": 14697,
            "end_line": 4,
            "end_column": 14923,
            "start_byte": 14697,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.tb": {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self) -> TracebackType:\n        \"\"\"the exception raw traceback\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".tb can only be used after the context manager exits\"\n        return self._excinfo[2]",
            "start_line": 474,
            "start_column": 14929,
            "end_line": 4,
            "end_column": 15168,
            "start_byte": 14929,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.typename": {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self) -> str:\n        \"\"\"the type name of the exception\"\"\"\n        assert (\n            self._excinfo is not None\n        ), \".typename can only be used after the context manager exits\"\n        return self.type.__name__",
            "start_line": 482,
            "start_column": 15174,
            "end_line": 4,
            "end_column": 15420,
            "start_byte": 15174,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.traceback": {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value: Traceback) -> None:\n        self._traceback = value",
            "start_line": 497,
            "start_column": 15642,
            "end_line": 4,
            "end_column": 15742,
            "start_byte": 15642,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__repr__": {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 501,
            "start_column": 15748,
            "end_line": 4,
            "end_column": 15955,
            "start_byte": 15748,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.exconly": {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort: bool = False) -> str:\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 506,
            "start_column": 15961,
            "end_line": 4,
            "end_column": 16595,
            "start_byte": 15961,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.errisinstance": {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(\n        self, exc: Union[\"Type[BaseException]\", Tuple[\"Type[BaseException]\", ...]]\n    ) -> bool:\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 522,
            "start_column": 16601,
            "end_line": 4,
            "end_column": 16827,
            "start_byte": 16601,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._getreprcrash": {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self) -> \"ReprFileLocation\":\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 528,
            "start_column": 16833,
            "end_line": 4,
            "end_column": 17101,
            "start_byte": 16833,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: str = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 534,
            "start_column": 17107,
            "end_line": 4,
            "end_column": 18918,
            "start_byte": 17107,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.match": {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp: \"Union[str, Pattern]\") -> bool:\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern {!r} not found in {!r}\".format(regexp, str(self.value))\n        return True",
            "start_line": 593,
            "start_column": 18924,
            "end_line": 4,
            "end_column": 19503,
            "start_byte": 18924,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo": {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 900,
            "start_column": 30322,
            "end_line": 0,
            "end_column": 30620,
            "start_byte": 30322,
            "end_byte": 0
          },
          "_pytest._code.ReprExceptionInfo.__init__": {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 901,
            "start_column": 30366,
            "end_line": 4,
            "end_column": 30516,
            "start_byte": 30366,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.toterminal": {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 906,
            "start_column": 30522,
            "end_line": 4,
            "end_column": 30620,
            "start_byte": 30522,
            "end_byte": 4
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(item, when, log=True, **kwds):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 165,
            "start_column": 4915,
            "end_line": 0,
            "end_column": 5311,
            "start_byte": 4915,
            "end_byte": 0
          },
          "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call, report):\n    return call.excinfo and not (\n        hasattr(report, \"wasxfail\")\n        or call.excinfo.errisinstance(Skipped)\n        or call.excinfo.errisinstance(bdb.BdbQuit)\n    )",
            "start_line": 176,
            "start_column": 5314,
            "end_line": 0,
            "end_column": 5534,
            "start_byte": 5314,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_report_to_serializable": {
            "name": "_pytest.hookspec.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": " item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )\n\n\nclass CollectReport(BaseReport):\n    when = \"collect\"\n\n    def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):\n        self.nodeid = nodeid\n        self.outcome = outcome\n        self.longrepr = longrepr\n        self.result = result or []\n        self.sections = list(sections)\n        self.__dict__.update(extra)\n\n    @property\n    def location(self):\n      ",
            "start_line": 380,
            "start_column": 12325,
            "end_line": 0,
            "end_column": 12939,
            "start_byte": 12325,
            "end_byte": 0
          },
          "_pytest.reports.BaseReport._to_json": {
            "name": "_pytest.reports.BaseReport._to_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def _to_json(self):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Returns the contents of this report as a dict of builtin entries, suitable for\n        serialization.\n\n        Experimental method.\n        \"\"\"\n\n        def disassembled_report(rep):\n            reprtraceback = rep.longrepr.reprtraceback.__dict__.copy()\n            reprcrash = rep.longrepr.reprcrash.__dict__.copy()\n\n            new_entries = []\n            for entry in reprtraceback[\"reprentries\"]:\n                entry_data = {\n                    \"type\": type(entry).__name__,\n                    \"data\": entry.__dict__.copy(),\n                }\n                for key, value in entry_data[\"data\"].items():\n                    if hasattr(value, \"__dict__\"):\n                        entry_data[\"data\"][key] = value.__dict__.copy()\n                new_entries.append(entry_data)\n\n            reprtraceback[\"reprentries\"] = new_entries\n\n            return {\n                \"reprcrash\": reprcrash,\n                \"reprtraceback\": reprtraceback,\n                \"sections\": rep.longrepr.sections,\n            }\n\n        d = self.__dict__.copy()\n        if hasattr(self.longrepr, \"toterminal\"):\n            if hasattr(self.longrepr, \"reprtraceback\") and hasattr(\n                self.longrepr, \"reprcrash\"\n            ):\n                d[\"longrepr\"] = disassembled_report(self)\n            else:\n                d[\"longrepr\"] = str(self.longrepr)\n        else:\n            d[\"longrepr\"] = self.longrepr\n        for name in d:\n            if isinstance(d[name], (py.path.local, Path)):\n                d[name] = str(d[name])\n            elif name == \"result\":\n                d[name] = None  # for now\n        return d",
            "start_line": 153,
            "start_column": 4241,
            "end_line": 4,
            "end_column": 5985,
            "start_byte": 4241,
            "end_byte": 4
          },
          "_pytest.reports.BaseReport._from_json": {
            "name": "_pytest.reports.BaseReport._from_json",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def _from_json(cls, reportdict):\n        \"\"\"\n        This was originally the serialize_report() function from xdist (ca03269).\n\n        Factory method that returns either a TestReport or CollectReport, depending on the calling\n        class. It's the callers responsibility to know which class to pass here.\n\n        Experimental method.\n        \"\"\"\n        if reportdict[\"longrepr\"]:\n            if (\n                \"reprcrash\" in reportdict[\"longrepr\"]\n                and \"reprtraceback\" in reportdict[\"longrepr\"]\n            ):\n\n                reprtraceback = reportdict[\"longrepr\"][\"reprtraceback\"]\n                reprcrash = reportdict[\"longrepr\"][\"reprcrash\"]\n\n                unserialized_entries = []\n                reprentry = None\n                for entry_data in reprtraceback[\"reprentries\"]:\n                    data = entry_data[\"data\"]\n                    entry_type = entry_data[\"type\"]\n                    if entry_type == \"ReprEntry\":\n                        reprfuncargs = None\n                        reprfileloc = None\n                        reprlocals = None\n                        if data[\"reprfuncargs\"]:\n                            reprfuncargs = ReprFuncArgs(**data[\"reprfuncargs\"])\n                        if data[\"reprfileloc\"]:\n                            reprfileloc = ReprFileLocation(**data[\"reprfileloc\"])\n                        if data[\"reprlocals\"]:\n                            reprlocals = ReprLocals(data[\"reprlocals\"][\"lines\"])\n\n                        reprentry = ReprEntry(\n                            lines=data[\"lines\"],\n                            reprfuncargs=reprfuncargs,\n                            reprlocals=reprlocals,\n                            filelocrepr=reprfileloc,\n                            style=data[\"style\"],\n                        )\n                    elif entry_type == \"ReprEntryNative\":\n                        reprentry = ReprEntryNative(data[\"lines\"])\n                    else:\n                        _report_unserialization_failure(entry_type, cls, reportdict)\n                    unserialized_entries.append(reprentry)\n                reprtraceback[\"reprentries\"] = unserialized_entries\n\n                exception_info = ReprExceptionInfo(\n                    reprtraceback=ReprTraceback(**reprtraceback),\n                    reprcrash=ReprFileLocation(**reprcrash),\n                )\n\n                for section in reportdict[\"longrepr\"][\"sections\"]:\n                    exception_info.addsection(*section)\n                reportdict[\"longrepr\"] = exception_info\n\n        return cls(**reportdict)",
            "start_line": 203,
            "start_column": 5991,
            "end_line": 4,
            "end_column": 8587,
            "start_byte": 5991,
            "end_byte": 4
          },
          "_pytest.reports.TestReport": {
            "name": "_pytest.reports.TestReport",
            "file_path": "src/_pytest/reports.py",
            "file_content": "class TestReport(BaseReport):\n    \"\"\" Basic test report object (also used for setup and teardown calls if\n    they fail).\n    \"\"\"\n\n    __test__ = False\n\n    def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)\n\n    def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )\n\n    @classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 276,
            "start_column": 9116,
            "end_line": 0,
            "end_column": 12552,
            "start_byte": 9116,
            "end_byte": 0
          },
          "_pytest.reports.TestReport.__test__": {
            "name": "_pytest.reports.TestReport.__test__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "__test__ = False",
            "start_line": 281,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 9251,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.__init__": {
            "name": "_pytest.reports.TestReport.__init__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __init__(\n        self,\n        nodeid,\n        location,\n        keywords,\n        outcome,\n        longrepr,\n        when,\n        sections=(),\n        duration=0,\n        user_properties=None,\n        **extra\n    ):\n        #: normalized collection node id\n        self.nodeid = nodeid\n\n        #: a (filesystempath, lineno, domaininfo) tuple indicating the\n        #: actual location of a test item - it might be different from the\n        #: collected one e.g. if a method is inherited from a different module.\n        self.location = location\n\n        #: a name -> value dictionary containing all keywords and\n        #: markers associated with a test invocation.\n        self.keywords = keywords\n\n        #: test outcome, always one of \"passed\", \"failed\", \"skipped\".\n        self.outcome = outcome\n\n        #: None or a failure representation.\n        self.longrepr = longrepr\n\n        #: one of 'setup', 'call', 'teardown' to indicate runtest phase.\n        self.when = when\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties of the test\n        self.user_properties = list(user_properties or [])\n\n        #: list of pairs ``(str, str)`` of extra information which needs to\n        #: marshallable. Used by pytest to add captured text\n        #: from ``stdout`` and ``stderr``, but may be used by other plugins\n        #: to add arbitrary information to reports.\n        self.sections = list(sections)\n\n        #: time it took to run just the test\n        self.duration = duration\n\n        self.__dict__.update(extra)",
            "start_line": 283,
            "start_column": 9273,
            "end_line": 4,
            "end_column": 10859,
            "start_byte": 9273,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.__repr__": {
            "name": "_pytest.reports.TestReport.__repr__",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def __repr__(self):\n        return \"<{} {!r} when={!r} outcome={!r}>\".format(\n            self.__class__.__name__, self.nodeid, self.when, self.outcome\n        )",
            "start_line": 332,
            "start_column": 10865,
            "end_line": 4,
            "end_column": 11026,
            "start_byte": 10865,
            "end_byte": 4
          },
          "_pytest.reports.TestReport.from_item_and_call": {
            "name": "_pytest.reports.TestReport.from_item_and_call",
            "file_path": "src/_pytest/reports.py",
            "file_content": "@classmethod\n    def from_item_and_call(cls, item, call):\n        \"\"\"\n        Factory method to create and fill a TestReport with standard item and call info.\n        \"\"\"\n        when = call.when\n        duration = call.stop - call.start\n        keywords = {x: 1 for x in item.keywords}\n        excinfo = call.excinfo\n        sections = []\n        if not call.excinfo:\n            outcome = \"passed\"\n            longrepr = None\n        else:\n            if not isinstance(excinfo, ExceptionInfo):\n                outcome = \"failed\"\n                longrepr = excinfo\n            elif excinfo.errisinstance(skip.Exception):\n                outcome = \"skipped\"\n                r = excinfo._getreprcrash()\n                longrepr = (str(r.path), r.lineno, r.message)\n            else:\n                outcome = \"failed\"\n                if call.when == \"call\":\n                    longrepr = item.repr_failure(excinfo)\n                else:  # exception in setup or teardown\n                    longrepr = item._repr_failure_py(\n                        excinfo, style=item.config.getoption(\"tbstyle\", \"auto\")\n                    )\n        for rwhen, key, content in item._report_sections:\n            sections.append((\"Captured {} {}\".format(key, rwhen), content))\n        return cls(\n            item.nodeid,\n            item.location,\n            keywords,\n            outcome,\n            longrepr,\n            when,\n            sections,\n            duration,\n            user_properties=item.user_properties,\n        )",
            "start_line": 337,
            "start_column": 11032,
            "end_line": 4,
            "end_column": 12552,
            "start_byte": 11032,
            "end_byte": 4
          },
          "_pytest.reports.pytest_report_to_serializable": {
            "name": "_pytest.reports.pytest_report_to_serializable",
            "file_path": "src/_pytest/reports.py",
            "file_content": "def pytest_report_to_serializable(report):\n    if isinstance(report, (TestReport, CollectReport)):\n        data = report._to_json()\n        data[\"_report_type\"] = report.__class__.__name__\n        return data",
            "start_line": 410,
            "start_column": 13317,
            "end_line": 0,
            "end_column": 13525,
            "start_byte": 13317,
            "end_byte": 0
          },
          "_pytest.terminal.TerminalReporter": {
            "name": "_pytest.terminal.TerminalReporter",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "class TerminalReporter:\n    def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None\n\n    def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False\n\n    @property\n    def verbosity(self):\n        return self.config.option.verbose\n\n    @property\n    def showheader(self):\n        return self.verbosity >= 0\n\n    @property\n    def showfspath(self):\n        if self._showfspath is None:\n            return self.verbosity >= 0\n        return self._showfspath\n\n    @showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value\n\n    @property\n    def showlongtestinfo(self):\n        return self.verbosity > 0\n\n    def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars\n\n    def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)\n\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2\n\n    def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None\n\n    def write(self, content, **markup):\n        self._tw.write(content, **markup)\n\n    def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)\n\n    def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)\n\n    def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)\n\n    def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)\n\n    def line(self, msg, **kw):\n        self._tw.line(msg, **kw)\n\n    def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1\n\n    def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)\n\n    def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)\n\n    def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)\n\n    def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")\n\n    def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2\n\n    def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)\n\n    def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"\n\n    def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)\n\n    @property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line\n\n    def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)\n\n    def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()\n\n    def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)\n\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)\n\n    def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)\n\n    def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result\n\n    def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)\n\n    def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()\n\n    def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n\n    def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()\n\n    def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )\n\n    def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"\n\n    def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?\n\n    def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"\n\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values\n\n    def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n\n    def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)\n\n    def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)\n\n    def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)\n\n    def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)\n\n    def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)\n\n    def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)\n\n    def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 217,
            "start_column": 6374,
            "end_line": 0,
            "end_column": 34081,
            "start_byte": 6374,
            "end_byte": 0
          },
          "_pytest.terminal.TerminalReporter.__init__": {
            "name": "_pytest.terminal.TerminalReporter.__init__",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def __init__(self, config, file=None):\n        import _pytest.config\n\n        self.config = config\n        self._numcollected = 0\n        self._session = None\n        self._showfspath = None\n\n        self.stats = {}\n        self.startdir = config.invocation_dir\n        if file is None:\n            file = sys.stdout\n        self._tw = _pytest.config.create_terminal_writer(config, file)\n        # self.writer will be deprecated in pytest-3.4\n        self.writer = self._tw\n        self._screen_width = self._tw.fullwidth\n        self.currentfspath = None\n        self.reportchars = getreportopt(config)\n        self.hasmarkup = self._tw.hasmarkup\n        self.isatty = file.isatty()\n        self._progress_nodeids_reported = set()\n        self._show_progress_info = self._determine_show_progress_info()\n        self._collect_report_last_write = None",
            "start_line": 218,
            "start_column": 6402,
            "end_line": 4,
            "end_column": 7252,
            "start_byte": 6402,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._determine_show_progress_info": {
            "name": "_pytest.terminal.TerminalReporter._determine_show_progress_info",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _determine_show_progress_info(self):\n        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n        # do not show progress if we are not capturing output (#3038)\n        if self.config.getoption(\"capture\", \"no\") == \"no\":\n            return False\n        # do not show progress if we are showing fixture setup/teardown\n        if self.config.getoption(\"setupshow\", False):\n            return False\n        cfg = self.config.getini(\"console_output_style\")\n        if cfg in (\"progress\", \"count\"):\n            return cfg\n        return False",
            "start_line": 242,
            "start_column": 7258,
            "end_line": 4,
            "end_column": 7841,
            "start_byte": 7258,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.verbosity": {
            "name": "_pytest.terminal.TerminalReporter.verbosity",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def verbosity(self):\n        return self.config.option.verbose",
            "start_line": 255,
            "start_column": 7847,
            "end_line": 4,
            "end_column": 7923,
            "start_byte": 7847,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showheader": {
            "name": "_pytest.terminal.TerminalReporter.showheader",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showheader(self):\n        return self.verbosity >= 0",
            "start_line": 259,
            "start_column": 7929,
            "end_line": 4,
            "end_column": 7999,
            "start_byte": 7929,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showfspath": {
            "name": "_pytest.terminal.TerminalReporter.showfspath",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@showfspath.setter\n    def showfspath(self, value):\n        self._showfspath = value",
            "start_line": 269,
            "start_column": 8154,
            "end_line": 4,
            "end_column": 8238,
            "start_byte": 8154,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.showlongtestinfo": {
            "name": "_pytest.terminal.TerminalReporter.showlongtestinfo",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def showlongtestinfo(self):\n        return self.verbosity > 0",
            "start_line": 273,
            "start_column": 8244,
            "end_line": 4,
            "end_column": 8319,
            "start_byte": 8244,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.hasopt": {
            "name": "_pytest.terminal.TerminalReporter.hasopt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def hasopt(self, char):\n        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n        return char in self.reportchars",
            "start_line": 277,
            "start_column": 8325,
            "end_line": 4,
            "end_column": 8452,
            "start_byte": 8325,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_fspath_result": {
            "name": "_pytest.terminal.TerminalReporter.write_fspath_result",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_fspath_result(self, nodeid, res, **markup):\n        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n        # NOTE: explicitly check for None to work around py bug, and for less\n        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n        if self.currentfspath is None or fspath != self.currentfspath:\n            if self.currentfspath is not None and self._show_progress_info:\n                self._write_progress_information_filling_space()\n            self.currentfspath = fspath\n            fspath = self.startdir.bestrelpath(fspath)\n            self._tw.line()\n            self._tw.write(fspath + \" \")\n        self._tw.write(res, **markup)",
            "start_line": 281,
            "start_column": 8458,
            "end_line": 4,
            "end_column": 9143,
            "start_byte": 8458,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_ensure_prefix": {
            "name": "_pytest.terminal.TerminalReporter.write_ensure_prefix",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n        if self.currentfspath != prefix:\n            self._tw.line()\n            self.currentfspath = prefix\n            self._tw.write(prefix)\n        if extra:\n            self._tw.write(extra, **kwargs)\n            self.currentfspath = -2",
            "start_line": 294,
            "start_column": 9149,
            "end_line": 4,
            "end_column": 9449,
            "start_byte": 9149,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.ensure_newline": {
            "name": "_pytest.terminal.TerminalReporter.ensure_newline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def ensure_newline(self):\n        if self.currentfspath:\n            self._tw.line()\n            self.currentfspath = None",
            "start_line": 303,
            "start_column": 9455,
            "end_line": 4,
            "end_column": 9577,
            "start_byte": 9455,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write": {
            "name": "_pytest.terminal.TerminalReporter.write",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write(self, content, **markup):\n        self._tw.write(content, **markup)",
            "start_line": 308,
            "start_column": 9583,
            "end_line": 4,
            "end_column": 9660,
            "start_byte": 9583,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_line": {
            "name": "_pytest.terminal.TerminalReporter.write_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_line(self, line, **markup):\n        if not isinstance(line, str):\n            line = str(line, errors=\"replace\")\n        self.ensure_newline()\n        self._tw.line(line, **markup)",
            "start_line": 311,
            "start_column": 9666,
            "end_line": 4,
            "end_column": 9856,
            "start_byte": 9666,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.rewrite": {
            "name": "_pytest.terminal.TerminalReporter.rewrite",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def rewrite(self, line, **markup):\n        \"\"\"\n        Rewinds the terminal cursor to the beginning and writes the given line.\n\n        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n            previous lines are properly erased.\n\n        The rest of the keyword arguments are markup instructions.\n        \"\"\"\n        erase = markup.pop(\"erase\", False)\n        if erase:\n            fill_count = self._tw.fullwidth - len(line) - 1\n            fill = \" \" * fill_count\n        else:\n            fill = \"\"\n        line = str(line)\n        self._tw.write(\"\\r\" + line + fill, **markup)",
            "start_line": 317,
            "start_column": 9862,
            "end_line": 4,
            "end_column": 10480,
            "start_byte": 9862,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.write_sep": {
            "name": "_pytest.terminal.TerminalReporter.write_sep",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def write_sep(self, sep, title=None, **markup):\n        self.ensure_newline()\n        self._tw.sep(sep, title, **markup)",
            "start_line": 335,
            "start_column": 10486,
            "end_line": 4,
            "end_column": 10606,
            "start_byte": 10486,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.section": {
            "name": "_pytest.terminal.TerminalReporter.section",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def section(self, title, sep=\"=\", **kw):\n        self._tw.sep(sep, title, **kw)",
            "start_line": 339,
            "start_column": 10612,
            "end_line": 4,
            "end_column": 10691,
            "start_byte": 10612,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.line": {
            "name": "_pytest.terminal.TerminalReporter.line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def line(self, msg, **kw):\n        self._tw.line(msg, **kw)",
            "start_line": 342,
            "start_column": 10697,
            "end_line": 4,
            "end_column": 10756,
            "start_byte": 10697,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_internalerror": {
            "name": "_pytest.terminal.TerminalReporter.pytest_internalerror",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        for line in str(excrepr).split(\"\\n\"):\n            self.write_line(\"INTERNALERROR> \" + line)\n        return 1",
            "start_line": 345,
            "start_column": 10762,
            "end_line": 4,
            "end_column": 10919,
            "start_byte": 10762,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_warning_captured": {
            "name": "_pytest.terminal.TerminalReporter.pytest_warning_captured",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_warning_captured(self, warning_message, item):\n        # from _pytest.nodes import get_fslocation_from_item\n        from _pytest.warnings import warning_record_to_str\n\n        warnings = self.stats.setdefault(\"warnings\", [])\n        fslocation = warning_message.filename, warning_message.lineno\n        message = warning_record_to_str(warning_message)\n\n        nodeid = item.nodeid if item is not None else \"\"\n        warning_report = WarningReport(\n            fslocation=fslocation, message=message, nodeid=nodeid\n        )\n        warnings.append(warning_report)",
            "start_line": 350,
            "start_column": 10925,
            "end_line": 4,
            "end_column": 11501,
            "start_byte": 10925,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_plugin_registered": {
            "name": "_pytest.terminal.TerminalReporter.pytest_plugin_registered",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        if self.config.option.traceconfig:\n            msg = \"PLUGIN registered: {}\".format(plugin)\n            # XXX this event may happen during setup/teardown time\n            #     which unfortunately captures our output here\n            #     which garbles our output if we use self.write_line\n            self.write_line(msg)",
            "start_line": 364,
            "start_column": 11507,
            "end_line": 4,
            "end_column": 11882,
            "start_byte": 11507,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_deselected": {
            "name": "_pytest.terminal.TerminalReporter.pytest_deselected",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_deselected(self, items):\n        self.stats.setdefault(\"deselected\", []).extend(items)",
            "start_line": 372,
            "start_column": 11888,
            "end_line": 4,
            "end_column": 11985,
            "start_byte": 11888,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logstart(self, nodeid, location):\n        # ensure that the path is printed before the\n        # 1st test of a module starts running\n        if self.showlongtestinfo:\n            line = self._locationline(nodeid, *location)\n            self.write_ensure_prefix(line, \"\")\n        elif self.showfspath:\n            fsid = nodeid.split(\"::\")[0]\n            self.write_fspath_result(fsid, \"\")",
            "start_line": 375,
            "start_column": 11991,
            "end_line": 4,
            "end_column": 12398,
            "start_byte": 11991,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        self._tests_ran = True\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n        category, letter, word = res\n        if isinstance(word, tuple):\n            word, markup = word\n        else:\n            markup = None\n        self.stats.setdefault(category, []).append(rep)\n        if not letter and not word:\n            # probably passed setup/teardown\n            return\n        running_xdist = hasattr(rep, \"node\")\n        if markup is None:\n            was_xfail = hasattr(report, \"wasxfail\")\n            if rep.passed and not was_xfail:\n                markup = {\"green\": True}\n            elif rep.passed and was_xfail:\n                markup = {\"yellow\": True}\n            elif rep.failed:\n                markup = {\"red\": True}\n            elif rep.skipped:\n                markup = {\"yellow\": True}\n            else:\n                markup = {}\n        if self.verbosity <= 0:\n            if not running_xdist and self.showfspath:\n                self.write_fspath_result(rep.nodeid, letter, **markup)\n            else:\n                self._tw.write(letter, **markup)\n        else:\n            self._progress_nodeids_reported.add(rep.nodeid)\n            line = self._locationline(rep.nodeid, *rep.location)\n            if not running_xdist:\n                self.write_ensure_prefix(line, word, **markup)\n                if self._show_progress_info:\n                    self._write_progress_information_filling_space()\n            else:\n                self.ensure_newline()\n                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n                if self._show_progress_info:\n                    self._tw.write(\n                        self._get_progress_information_message() + \" \", cyan=True\n                    )\n                else:\n                    self._tw.write(\" \")\n                self._tw.write(word, **markup)\n                self._tw.write(\" \" + line)\n                self.currentfspath = -2",
            "start_line": 385,
            "start_column": 12404,
            "end_line": 4,
            "end_column": 14437,
            "start_byte": 12404,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_runtest_logfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_runtest_logfinish(self, nodeid):\n        if self.verbosity <= 0 and self._show_progress_info:\n            if self._show_progress_info == \"count\":\n                num_tests = self._session.testscollected\n                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n            else:\n                progress_length = len(\" [100%]\")\n\n            self._progress_nodeids_reported.add(nodeid)\n            is_last_item = (\n                len(self._progress_nodeids_reported) == self._session.testscollected\n            )\n            if is_last_item:\n                self._write_progress_information_filling_space()\n            else:\n                w = self._width_of_current_line\n                past_edge = w + progress_length + 1 >= self._screen_width\n                if past_edge:\n                    msg = self._get_progress_information_message()\n                    self._tw.write(msg + \"\\n\", cyan=True)",
            "start_line": 436,
            "start_column": 14443,
            "end_line": 4,
            "end_column": 15386,
            "start_byte": 14443,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._get_progress_information_message": {
            "name": "_pytest.terminal.TerminalReporter._get_progress_information_message",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _get_progress_information_message(self):\n        collected = self._session.testscollected\n        if self._show_progress_info == \"count\":\n            if collected:\n                progress = self._progress_nodeids_reported\n                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n                format_string = \" [{}/{{}}]\".format(counter_format)\n                return format_string.format(len(progress), collected)\n            return \" [ {} / {} ]\".format(collected, collected)\n        else:\n            if collected:\n                progress = len(self._progress_nodeids_reported) * 100 // collected\n                return \" [{:3d}%]\".format(progress)\n            return \" [100%]\"",
            "start_line": 457,
            "start_column": 15392,
            "end_line": 4,
            "end_column": 16095,
            "start_byte": 15392,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._write_progress_information_filling_space": {
            "name": "_pytest.terminal.TerminalReporter._write_progress_information_filling_space",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_progress_information_filling_space(self):\n        msg = self._get_progress_information_message()\n        w = self._width_of_current_line\n        fill = self._tw.fullwidth - w - 1\n        self.write(msg.rjust(fill), cyan=True)",
            "start_line": 472,
            "start_column": 16101,
            "end_line": 4,
            "end_column": 16337,
            "start_byte": 16101,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._width_of_current_line": {
            "name": "_pytest.terminal.TerminalReporter._width_of_current_line",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@property\n    def _width_of_current_line(self):\n        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n        try:\n            return self._tw.width_of_current_line\n        except AttributeError:\n            # py < 1.6.0\n            return self._tw.chars_on_current_line",
            "start_line": 478,
            "start_column": 16343,
            "end_line": 4,
            "end_column": 16666,
            "start_byte": 16343,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection(self):\n        if self.isatty:\n            if self.config.option.verbose >= 0:\n                self.write(\"collecting ... \", bold=True)\n                self._collect_report_last_write = time.time()\n        elif self.config.option.verbose >= 1:\n            self.write(\"collecting ... \", bold=True)",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collectreport": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collectreport",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collectreport(self, report):\n        if report.failed:\n            self.stats.setdefault(\"error\", []).append(report)\n        elif report.skipped:\n            self.stats.setdefault(\"skipped\", []).append(report)\n        items = [x for x in report.result if isinstance(x, pytest.Item)]\n        self._numcollected += len(items)\n        if self.isatty:\n            self.report_collect()",
            "start_line": 495,
            "start_column": 16996,
            "end_line": 4,
            "end_column": 17388,
            "start_byte": 16996,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.report_collect": {
            "name": "_pytest.terminal.TerminalReporter.report_collect",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def report_collect(self, final=False):\n        if self.config.option.verbose < 0:\n            return\n\n        if not final:\n            # Only write \"collecting\" report every 0.5s.\n            t = time.time()\n            if (\n                self._collect_report_last_write is not None\n                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n            ):\n                return\n            self._collect_report_last_write = t\n\n        errors = len(self.stats.get(\"error\", []))\n        skipped = len(self.stats.get(\"skipped\", []))\n        deselected = len(self.stats.get(\"deselected\", []))\n        selected = self._numcollected - errors - skipped - deselected\n        if final:\n            line = \"collected \"\n        else:\n            line = \"collecting \"\n        line += (\n            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n        )\n        if errors:\n            line += \" / %d errors\" % errors\n        if deselected:\n            line += \" / %d deselected\" % deselected\n        if skipped:\n            line += \" / %d skipped\" % skipped\n        if self._numcollected > selected > 0:\n            line += \" / %d selected\" % selected\n        if self.isatty:\n            self.rewrite(line, bold=True, erase=True)\n            if final:\n                self.write(\"\\n\")\n        else:\n            self.write_line(line)",
            "start_line": 505,
            "start_column": 17394,
            "end_line": 4,
            "end_column": 18778,
            "start_byte": 17394,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_sessionstart": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionstart",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n        self._session = session\n        self._sessionstarttime = time.time()\n        if not self.showheader:\n            return\n        self.write_sep(\"=\", \"test session starts\", bold=True)\n        verinfo = platform.python_version()\n        msg = \"platform {} -- Python {}\".format(sys.platform, verinfo)\n        if hasattr(sys, \"pypy_version_info\"):\n            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n            msg += \"[pypy-{}-{}]\".format(verinfo, sys.pypy_version_info[3])\n        msg += \", pytest-{}, py-{}, pluggy-{}\".format(\n            pytest.__version__, py.__version__, pluggy.__version__\n        )\n        if (\n            self.verbosity > 0\n            or self.config.option.debug\n            or getattr(self.config.option, \"pastebin\", None)\n        ):\n            msg += \" -- \" + str(sys.executable)\n        self.write_line(msg)\n        lines = self.config.hook.pytest_report_header(\n            config=self.config, startdir=self.startdir\n        )\n        self._write_report_lines_from_hooks(lines)",
            "start_line": 545,
            "start_column": 18784,
            "end_line": 4,
            "end_column": 19889,
            "start_byte": 18784,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks": {
            "name": "_pytest.terminal.TerminalReporter._write_report_lines_from_hooks",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _write_report_lines_from_hooks(self, lines):\n        lines.reverse()\n        for line in collapse(lines):\n            self.write_line(line)",
            "start_line": 572,
            "start_column": 19895,
            "end_line": 4,
            "end_column": 20038,
            "start_byte": 19895,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_report_header": {
            "name": "_pytest.terminal.TerminalReporter.pytest_report_header",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_report_header(self, config):\n        line = \"rootdir: %s\" % config.rootdir\n\n        if config.inifile:\n            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n\n        testpaths = config.getini(\"testpaths\")\n        if testpaths and config.args == testpaths:\n            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n        result = [line]\n\n        plugininfo = config.pluginmanager.list_plugin_distinfo()\n        if plugininfo:\n            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n        return result",
            "start_line": 577,
            "start_column": 20044,
            "end_line": 4,
            "end_column": 20699,
            "start_byte": 20044,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_collection_finish(self, session):\n        self.report_collect(True)\n\n        if self.config.getoption(\"collectonly\"):\n            self._printcollecteditems(session.items)\n\n        lines = self.config.hook.pytest_report_collectionfinish(\n            config=self.config, startdir=self.startdir, items=session.items\n        )\n        self._write_report_lines_from_hooks(lines)\n\n        if self.config.getoption(\"collectonly\"):\n            if self.stats.get(\"failed\"):\n                self._tw.sep(\"!\", \"collection failures\")\n                for rep in self.stats.get(\"failed\"):\n                    rep.toterminal(self._tw)",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._printcollecteditems": {
            "name": "_pytest.terminal.TerminalReporter._printcollecteditems",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _printcollecteditems(self, items):\n        # to print out items and their parent collectors\n        # we take care to leave out Instances aka ()\n        # because later versions are going to get rid of them anyway\n        if self.config.option.verbose < 0:\n            if self.config.option.verbose < -1:\n                counts = {}\n                for item in items:\n                    name = item.nodeid.split(\"::\", 1)[0]\n                    counts[name] = counts.get(name, 0) + 1\n                for name, count in sorted(counts.items()):\n                    self._tw.line(\"%s: %d\" % (name, count))\n            else:\n                for item in items:\n                    self._tw.line(item.nodeid)\n            return\n        stack = []\n        indent = \"\"\n        for item in items:\n            needed_collectors = item.listchain()[1:]  # strip root node\n            while stack:\n                if stack == needed_collectors[: len(stack)]:\n                    break\n                stack.pop()\n            for col in needed_collectors[len(stack) :]:\n                stack.append(col)\n                if col.name == \"()\":  # Skip Instances.\n                    continue\n                indent = (len(stack) - 1) * \"  \"\n                self._tw.line(\"{}{}\".format(indent, col))\n                if self.config.option.verbose >= 1:\n                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n                        for line in col._obj.__doc__.strip().splitlines():\n                            self._tw.line(\"{}{}\".format(indent + \"  \", line.strip()))",
            "start_line": 611,
            "start_column": 21341,
            "end_line": 4,
            "end_column": 22905,
            "start_byte": 21341,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_sessionfinish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_sessionfinish",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n        outcome = yield\n        outcome.get_result()\n        self._tw.line(\"\")\n        summary_exit_codes = (\n            ExitCode.OK,\n            ExitCode.TESTS_FAILED,\n            ExitCode.INTERRUPTED,\n            ExitCode.USAGE_ERROR,\n            ExitCode.NO_TESTS_COLLECTED,\n        )\n        if exitstatus in summary_exit_codes:\n            self.config.hook.pytest_terminal_summary(\n                terminalreporter=self, exitstatus=exitstatus, config=self.config\n            )\n        if exitstatus == ExitCode.INTERRUPTED:\n            self._report_keyboardinterrupt()\n            del self._keyboardinterrupt_memo\n        self.summary_stats()",
            "start_line": 646,
            "start_column": 22911,
            "end_line": 4,
            "end_column": 23642,
            "start_byte": 22911,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_terminal_summary": {
            "name": "_pytest.terminal.TerminalReporter.pytest_terminal_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n        self.summary_errors()\n        self.summary_failures()\n        self.summary_warnings()\n        self.summary_passes()\n        yield\n        self.short_test_summary()\n        # Display any extra warnings from teardown here (if any).\n        self.summary_warnings()",
            "start_line": 667,
            "start_column": 23648,
            "end_line": 4,
            "end_column": 23991,
            "start_byte": 23648,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt": {
            "name": "_pytest.terminal.TerminalReporter.pytest_keyboard_interrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_keyboard_interrupt(self, excinfo):\n        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)",
            "start_line": 678,
            "start_column": 23997,
            "end_line": 4,
            "end_column": 24112,
            "start_byte": 23997,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_unconfigure": {
            "name": "_pytest.terminal.TerminalReporter.pytest_unconfigure",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def pytest_unconfigure(self):\n        if hasattr(self, \"_keyboardinterrupt_memo\"):\n            self._report_keyboardinterrupt()",
            "start_line": 681,
            "start_column": 24118,
            "end_line": 4,
            "end_column": 24245,
            "start_byte": 24118,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._report_keyboardinterrupt": {
            "name": "_pytest.terminal.TerminalReporter._report_keyboardinterrupt",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _report_keyboardinterrupt(self):\n        excrepr = self._keyboardinterrupt_memo\n        msg = excrepr.reprcrash.message\n        self.write_sep(\"!\", msg)\n        if \"KeyboardInterrupt\" in msg:\n            if self.config.option.fulltrace:\n                excrepr.toterminal(self._tw)\n            else:\n                excrepr.reprcrash.toterminal(self._tw)\n                self._tw.line(\n                    \"(to show a full traceback on KeyboardInterrupt use --full-trace)\",\n                    yellow=True,\n                )",
            "start_line": 685,
            "start_column": 24251,
            "end_line": 4,
            "end_column": 24779,
            "start_byte": 24251,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._locationline": {
            "name": "_pytest.terminal.TerminalReporter._locationline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _locationline(self, nodeid, fspath, lineno, domain):\n        def mkrel(nodeid):\n            line = self.config.cwd_relative_nodeid(nodeid)\n            if domain and line.endswith(domain):\n                line = line[: -len(domain)]\n                values = domain.split(\"[\")\n                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n                line += \"[\".join(values)\n            return line\n\n        # collect_fspath comes from testid which has a \"/\"-normalized path\n\n        if fspath:\n            res = mkrel(nodeid)\n            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n                \"\\\\\", nodes.SEP\n            ):\n                res += \" <- \" + self.startdir.bestrelpath(fspath)\n        else:\n            res = \"[location]\"\n        return res + \" \"",
            "start_line": 699,
            "start_column": 24785,
            "end_line": 4,
            "end_column": 25607,
            "start_byte": 24785,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._getfailureheadline": {
            "name": "_pytest.terminal.TerminalReporter._getfailureheadline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getfailureheadline(self, rep):\n        head_line = rep.head_line\n        if head_line:\n            return head_line\n        return \"test session\"  # XXX?",
            "start_line": 721,
            "start_column": 25613,
            "end_line": 4,
            "end_column": 25771,
            "start_byte": 25613,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._getcrashline": {
            "name": "_pytest.terminal.TerminalReporter._getcrashline",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _getcrashline(self, rep):\n        try:\n            return str(rep.longrepr.reprcrash)\n        except AttributeError:\n            try:\n                return str(rep.longrepr)[:50]\n            except AttributeError:\n                return \"\"",
            "start_line": 727,
            "start_column": 25777,
            "end_line": 4,
            "end_column": 26021,
            "start_byte": 25777,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.getreports": {
            "name": "_pytest.terminal.TerminalReporter.getreports",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def getreports(self, name):\n        values = []\n        for x in self.stats.get(name, []):\n            if not hasattr(x, \"_pdbshown\"):\n                values.append(x)\n        return values",
            "start_line": 739,
            "start_column": 26073,
            "end_line": 4,
            "end_column": 26262,
            "start_byte": 26073,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_warnings": {
            "name": "_pytest.terminal.TerminalReporter.summary_warnings",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_warnings(self):\n        if self.hasopt(\"w\"):\n            all_warnings = self.stats.get(\"warnings\")\n            if not all_warnings:\n                return\n\n            final = hasattr(self, \"_already_displayed_warnings\")\n            if final:\n                warning_reports = all_warnings[self._already_displayed_warnings :]\n            else:\n                warning_reports = all_warnings\n            self._already_displayed_warnings = len(warning_reports)\n            if not warning_reports:\n                return\n\n            reports_grouped_by_message = collections.OrderedDict()\n            for wr in warning_reports:\n                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n\n            title = \"warnings summary (final)\" if final else \"warnings summary\"\n            self.write_sep(\"=\", title, yellow=True, bold=False)\n            for message, warning_reports in reports_grouped_by_message.items():\n                has_any_location = False\n                for w in warning_reports:\n                    location = w.get_location(self.config)\n                    if location:\n                        self._tw.line(str(location))\n                        has_any_location = True\n                if has_any_location:\n                    lines = message.splitlines()\n                    indented = \"\\n\".join(\"  \" + x for x in lines)\n                    message = indented.rstrip()\n                else:\n                    message = message.rstrip()\n                self._tw.line(message)\n                self._tw.line()\n            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")",
            "start_line": 746,
            "start_column": 26268,
            "end_line": 4,
            "end_column": 27912,
            "start_byte": 26268,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_passes": {
            "name": "_pytest.terminal.TerminalReporter.summary_passes",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_passes(self):\n        if self.config.option.tbstyle != \"no\":\n            if self.hasopt(\"P\"):\n                reports = self.getreports(\"passed\")\n                if not reports:\n                    return\n                self.write_sep(\"=\", \"PASSES\")\n                for rep in reports:\n                    if rep.sections:\n                        msg = self._getfailureheadline(rep)\n                        self.write_sep(\"_\", msg, green=True, bold=True)\n                        self._outrep_summary(rep)",
            "start_line": 784,
            "start_column": 27918,
            "end_line": 4,
            "end_column": 28435,
            "start_byte": 27918,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.print_teardown_sections": {
            "name": "_pytest.terminal.TerminalReporter.print_teardown_sections",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def print_teardown_sections(self, rep):\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            if \"teardown\" in secname:\n                self._tw.sep(\"-\", secname)\n                if content[-1:] == \"\\n\":\n                    content = content[:-1]\n                self._tw.line(content)",
            "start_line": 797,
            "start_column": 28441,
            "end_line": 4,
            "end_column": 28927,
            "start_byte": 28441,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_failures": {
            "name": "_pytest.terminal.TerminalReporter.summary_failures",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_failures(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"failed\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"FAILURES\")\n            if self.config.option.tbstyle == \"line\":\n                for rep in reports:\n                    line = self._getcrashline(rep)\n                    self.write_line(line)\n            else:\n                teardown_sections = {}\n                for report in self.getreports(\"\"):\n                    if report.when == \"teardown\":\n                        teardown_sections.setdefault(report.nodeid, []).append(report)\n\n                for rep in reports:\n                    msg = self._getfailureheadline(rep)\n                    self.write_sep(\"_\", msg, red=True, bold=True)\n                    self._outrep_summary(rep)\n                    for report in teardown_sections.get(rep.nodeid, []):\n                        self.print_teardown_sections(report)",
            "start_line": 810,
            "start_column": 28933,
            "end_line": 4,
            "end_column": 29916,
            "start_byte": 28933,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_errors": {
            "name": "_pytest.terminal.TerminalReporter.summary_errors",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_errors(self):\n        if self.config.option.tbstyle != \"no\":\n            reports = self.getreports(\"error\")\n            if not reports:\n                return\n            self.write_sep(\"=\", \"ERRORS\")\n            for rep in self.stats[\"error\"]:\n                msg = self._getfailureheadline(rep)\n                if rep.when == \"collect\":\n                    msg = \"ERROR collecting \" + msg\n                else:\n                    msg = \"ERROR at {} of {}\".format(rep.when, msg)\n                self.write_sep(\"_\", msg, red=True, bold=True)\n                self._outrep_summary(rep)",
            "start_line": 833,
            "start_column": 29922,
            "end_line": 4,
            "end_column": 30518,
            "start_byte": 29922,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._outrep_summary": {
            "name": "_pytest.terminal.TerminalReporter._outrep_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def _outrep_summary(self, rep):\n        rep.toterminal(self._tw)\n        showcapture = self.config.option.showcapture\n        if showcapture == \"no\":\n            return\n        for secname, content in rep.sections:\n            if showcapture != \"all\" and showcapture not in secname:\n                continue\n            self._tw.sep(\"-\", secname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            self._tw.line(content)",
            "start_line": 848,
            "start_column": 30524,
            "end_line": 4,
            "end_column": 30981,
            "start_byte": 30524,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.summary_stats": {
            "name": "_pytest.terminal.TerminalReporter.summary_stats",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def summary_stats(self):\n        session_duration = time.time() - self._sessionstarttime\n        (line, color) = build_summary_stats_line(self.stats)\n        msg = \"{} in {}\".format(line, format_session_duration(session_duration))\n        markup = {color: True, \"bold\": True}\n\n        if self.verbosity >= 0:\n            self.write_sep(\"=\", msg, **markup)\n        if self.verbosity == -1:\n            self.write_line(msg, **markup)",
            "start_line": 861,
            "start_column": 30987,
            "end_line": 4,
            "end_column": 31418,
            "start_byte": 30987,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.short_test_summary": {
            "name": "_pytest.terminal.TerminalReporter.short_test_summary",
            "file_path": "src/_pytest/terminal.py",
            "file_content": "def short_test_summary(self):\n        if not self.reportchars:\n            return\n\n        def show_simple(stat, lines):\n            failed = self.stats.get(stat, [])\n            if not failed:\n                return\n            termwidth = self.writer.fullwidth\n            config = self.config\n            for rep in failed:\n                line = _get_line_with_reprcrash_message(config, rep, termwidth)\n                lines.append(line)\n\n        def show_xfailed(lines):\n            xfailed = self.stats.get(\"xfailed\", [])\n            for rep in xfailed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                lines.append(\"{} {}\".format(verbose_word, pos))\n                reason = rep.wasxfail\n                if reason:\n                    lines.append(\"  \" + str(reason))\n\n        def show_xpassed(lines):\n            xpassed = self.stats.get(\"xpassed\", [])\n            for rep in xpassed:\n                verbose_word = rep._get_verbose_word(self.config)\n                pos = _get_pos(self.config, rep)\n                reason = rep.wasxfail\n                lines.append(\"{} {} {}\".format(verbose_word, pos, reason))\n\n        def show_skipped(lines):\n            skipped = self.stats.get(\"skipped\", [])\n            fskips = _folded_skips(skipped) if skipped else []\n            if not fskips:\n                return\n            verbose_word = skipped[0]._get_verbose_word(self.config)\n            for num, fspath, lineno, reason in fskips:\n                if reason.startswith(\"Skipped: \"):\n                    reason = reason[9:]\n                if lineno is not None:\n                    lines.append(\n                        \"%s [%d] %s:%d: %s\"\n                        % (verbose_word, num, fspath, lineno + 1, reason)\n                    )\n                else:\n                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n\n        REPORTCHAR_ACTIONS = {\n            \"x\": show_xfailed,\n            \"X\": show_xpassed,\n            \"f\": partial(show_simple, \"failed\"),\n            \"F\": partial(show_simple, \"failed\"),\n            \"s\": show_skipped,\n            \"S\": show_skipped,\n            \"p\": partial(show_simple, \"passed\"),\n            \"E\": partial(show_simple, \"error\"),\n        }\n\n        lines = []\n        for char in self.reportchars:\n            action = REPORTCHAR_ACTIONS.get(char)\n            if action:  # skipping e.g. \"P\" (passed with output) here.\n                action(lines)\n\n        if lines:\n            self.write_sep(\"=\", \"short test summary info\")\n            for line in lines:\n                self.write_line(line)",
            "start_line": 872,
            "start_column": 31424,
            "end_line": 4,
            "end_column": 34081,
            "start_byte": 31424,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo": {
            "name": "_pytest._code.FormattedExcinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s\nclass FormattedExcinfo:\n    \"\"\" presenting information about failing Functions and Generators. \"\"\"\n\n    # for traceback entries\n    flow_marker = \">\"\n    fail_marker = \"E\"\n\n    showlocals = attr.ib(default=False)\n    style = attr.ib(default=\"long\")\n    abspath = attr.ib(default=True)\n    tbfilter = attr.ib(default=True)\n    funcargs = attr.ib(default=False)\n    truncate_locals = attr.ib(default=True)\n    chain = attr.ib(default=True)\n    astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)\n\n    def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))\n\n    def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source\n\n    def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)\n\n    def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines\n\n    def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines\n\n    def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)\n\n    def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)\n\n    def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path\n\n    def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)\n\n    def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline\n\n    def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 607,
            "start_column": 19506,
            "end_line": 0,
            "end_column": 29052,
            "start_byte": 19506,
            "end_byte": 0
          },
          "_pytest._code.FormattedExcinfo.flow_marker": {
            "name": "_pytest._code.FormattedExcinfo.flow_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "flow_marker = \">\"",
            "start_line": 612,
            "start_column": 19646,
            "end_line": 4,
            "end_column": 19663,
            "start_byte": 19646,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.fail_marker": {
            "name": "_pytest._code.FormattedExcinfo.fail_marker",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "fail_marker = \"E\"",
            "start_line": 613,
            "start_column": 19668,
            "end_line": 4,
            "end_column": 19685,
            "start_byte": 19668,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.showlocals": {
            "name": "_pytest._code.FormattedExcinfo.showlocals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "showlocals = attr.ib(default=False)",
            "start_line": 615,
            "start_column": 19691,
            "end_line": 4,
            "end_column": 19726,
            "start_byte": 19691,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.style": {
            "name": "_pytest._code.FormattedExcinfo.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = attr.ib(default=\"long\")",
            "start_line": 616,
            "start_column": 19731,
            "end_line": 4,
            "end_column": 19762,
            "start_byte": 19731,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.abspath": {
            "name": "_pytest._code.FormattedExcinfo.abspath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "abspath = attr.ib(default=True)",
            "start_line": 617,
            "start_column": 19767,
            "end_line": 4,
            "end_column": 19798,
            "start_byte": 19767,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.tbfilter": {
            "name": "_pytest._code.FormattedExcinfo.tbfilter",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "tbfilter = attr.ib(default=True)",
            "start_line": 618,
            "start_column": 19803,
            "end_line": 4,
            "end_column": 19835,
            "start_byte": 19803,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.funcargs": {
            "name": "_pytest._code.FormattedExcinfo.funcargs",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "funcargs = attr.ib(default=False)",
            "start_line": 619,
            "start_column": 19840,
            "end_line": 4,
            "end_column": 19873,
            "start_byte": 19840,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.truncate_locals": {
            "name": "_pytest._code.FormattedExcinfo.truncate_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "truncate_locals = attr.ib(default=True)",
            "start_line": 620,
            "start_column": 19878,
            "end_line": 4,
            "end_column": 19917,
            "start_byte": 19878,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.chain": {
            "name": "_pytest._code.FormattedExcinfo.chain",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "chain = attr.ib(default=True)",
            "start_line": 621,
            "start_column": 19922,
            "end_line": 4,
            "end_column": 19951,
            "start_byte": 19922,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.astcache": {
            "name": "_pytest._code.FormattedExcinfo.astcache",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "astcache = attr.ib(default=attr.Factory(dict), init=False, repr=False)",
            "start_line": 622,
            "start_column": 19956,
            "end_line": 4,
            "end_column": 20026,
            "start_byte": 19956,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo._getindent": {
            "name": "_pytest._code.FormattedExcinfo._getindent",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getindent(self, source):\n        # figure out indent for given source\n        try:\n            s = str(source.getstatement(len(source) - 1))\n        except KeyboardInterrupt:\n            raise\n        except:  # noqa\n            try:\n                s = str(source[-1])\n            except KeyboardInterrupt:\n                raise\n            except:  # noqa\n                return 0\n        return 4 + (len(s) - len(s.lstrip()))",
            "start_line": 624,
            "start_column": 20032,
            "end_line": 4,
            "end_column": 20465,
            "start_byte": 20032,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo._getentrysource": {
            "name": "_pytest._code.FormattedExcinfo._getentrysource",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getentrysource(self, entry):\n        source = entry.getsource(self.astcache)\n        if source is not None:\n            source = source.deindent()\n        return source",
            "start_line": 639,
            "start_column": 20471,
            "end_line": 4,
            "end_column": 20644,
            "start_byte": 20471,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_args": {
            "name": "_pytest._code.FormattedExcinfo.repr_args",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_args(self, entry):\n        if self.funcargs:\n            args = []\n            for argname, argvalue in entry.frame.getargs(var=True):\n                args.append((argname, saferepr(argvalue)))\n            return ReprFuncArgs(args)",
            "start_line": 645,
            "start_column": 20650,
            "end_line": 4,
            "end_column": 20890,
            "start_byte": 20650,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.get_source": {
            "name": "_pytest._code.FormattedExcinfo.get_source",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_source(self, source, line_index=-1, excinfo=None, short=False):\n        \"\"\" return formatted and marked up source lines. \"\"\"\n        import _pytest._code\n\n        lines = []\n        if source is None or line_index >= len(source.lines):\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        if line_index < 0:\n            line_index += len(source)\n        space_prefix = \"    \"\n        if short:\n            lines.append(space_prefix + source.lines[line_index].strip())\n        else:\n            for line in source.lines[:line_index]:\n                lines.append(space_prefix + line)\n            lines.append(self.flow_marker + \"   \" + source.lines[line_index])\n            for line in source.lines[line_index + 1 :]:\n                lines.append(space_prefix + line)\n        if excinfo is not None:\n            indent = 4 if short else self._getindent(source)\n            lines.extend(self.get_exconly(excinfo, indent=indent, markall=True))\n        return lines",
            "start_line": 652,
            "start_column": 20896,
            "end_line": 4,
            "end_column": 21896,
            "start_byte": 20896,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.get_exconly": {
            "name": "_pytest._code.FormattedExcinfo.get_exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def get_exconly(self, excinfo, indent=4, markall=False):\n        lines = []\n        indent = \" \" * indent\n        # get the real exception information out\n        exlines = excinfo.exconly(tryshort=True).split(\"\\n\")\n        failindent = self.fail_marker + indent[1:]\n        for line in exlines:\n            lines.append(failindent + line)\n            if not markall:\n                failindent = indent\n        return lines",
            "start_line": 676,
            "start_column": 21902,
            "end_line": 4,
            "end_column": 22326,
            "start_byte": 21902,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_locals": {
            "name": "_pytest._code.FormattedExcinfo.repr_locals",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_locals(self, locals):\n        if self.showlocals:\n            lines = []\n            keys = [loc for loc in locals if loc[0] != \"@\"]\n            keys.sort()\n            for name in keys:\n                value = locals[name]\n                if name == \"__builtins__\":\n                    lines.append(\"__builtins__ = <builtins>\")\n                else:\n                    # This formatting could all be handled by the\n                    # _repr() function, which is only reprlib.Repr in\n                    # disguise, so is very configurable.\n                    if self.truncate_locals:\n                        str_repr = saferepr(value)\n                    else:\n                        str_repr = safeformat(value)\n                    # if len(str_repr) < 70 or not isinstance(value,\n                    #                            (list, tuple, dict)):\n                    lines.append(\"{:<10} = {}\".format(name, str_repr))\n                    # else:\n                    #    self._line(\"%-10s =\\\\\" % (name,))\n                    #    # XXX\n                    #    pprint.pprint(value, stream=self.excinfowriter)\n            return ReprLocals(lines)",
            "start_line": 688,
            "start_column": 22332,
            "end_line": 4,
            "end_column": 23498,
            "start_byte": 22332,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_traceback_entry": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback_entry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback_entry(self, entry, excinfo=None):\n        import _pytest._code\n\n        source = self._getentrysource(entry)\n        if source is None:\n            source = _pytest._code.Source(\"???\")\n            line_index = 0\n        else:\n            line_index = entry.lineno - entry.getfirstlinesource()\n\n        lines = []\n        style = entry._repr_style\n        if style is None:\n            style = self.style\n        if style in (\"short\", \"long\"):\n            short = style == \"short\"\n            reprargs = self.repr_args(entry) if not short else None\n            s = self.get_source(source, line_index, excinfo, short=short)\n            lines.extend(s)\n            if short:\n                message = \"in %s\" % (entry.name)\n            else:\n                message = excinfo and excinfo.typename or \"\"\n            path = self._makepath(entry.path)\n            filelocrepr = ReprFileLocation(path, entry.lineno + 1, message)\n            localsrepr = None\n            if not short:\n                localsrepr = self.repr_locals(entry.locals)\n            return ReprEntry(lines, reprargs, localsrepr, filelocrepr, style)\n        if excinfo:\n            lines.extend(self.get_exconly(excinfo, indent=4))\n        return ReprEntry(lines, None, None, None, style)",
            "start_line": 714,
            "start_column": 23504,
            "end_line": 4,
            "end_column": 24777,
            "start_byte": 23504,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo._makepath": {
            "name": "_pytest._code.FormattedExcinfo._makepath",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _makepath(self, path):\n        if not self.abspath:\n            try:\n                np = py.path.local().bestrelpath(path)\n            except OSError:\n                return path\n            if len(np) < len(str(path)):\n                path = np\n        return path",
            "start_line": 747,
            "start_column": 24783,
            "end_line": 4,
            "end_column": 25053,
            "start_byte": 24783,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_traceback": {
            "name": "_pytest._code.FormattedExcinfo.repr_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_traceback(self, excinfo):\n        traceback = excinfo.traceback\n        if self.tbfilter:\n            traceback = traceback.filter()\n\n        if excinfo.errisinstance(RecursionError):\n            traceback, extraline = self._truncate_recursive_traceback(traceback)\n        else:\n            extraline = None\n\n        last = traceback[-1]\n        entries = []\n        for index, entry in enumerate(traceback):\n            einfo = (last == entry) and excinfo or None\n            reprentry = self.repr_traceback_entry(entry, einfo)\n            entries.append(reprentry)\n        return ReprTraceback(entries, extraline, style=self.style)",
            "start_line": 757,
            "start_column": 25059,
            "end_line": 4,
            "end_column": 25701,
            "start_byte": 25059,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo._truncate_recursive_traceback": {
            "name": "_pytest._code.FormattedExcinfo._truncate_recursive_traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _truncate_recursive_traceback(self, traceback):\n        \"\"\"\n        Truncate the given recursive traceback trying to find the starting point\n        of the recursion.\n\n        The detection is done by going through each traceback entry and finding the\n        point in which the locals of the frame are equal to the locals of a previous frame (see ``recursionindex()``.\n\n        Handle the situation where the recursion process might raise an exception (for example\n        comparing numpy arrays using equality raises a TypeError), in which case we do our best to\n        warn the user of the error and show a limited traceback.\n        \"\"\"\n        try:\n            recursionindex = traceback.recursionindex()\n        except Exception as e:\n            max_frames = 10\n            extraline = (\n                \"!!! Recursion error detected, but an error occurred locating the origin of recursion.\\n\"\n                \"  The following exception happened when comparing locals in the stack frame:\\n\"\n                \"    {exc_type}: {exc_msg}\\n\"\n                \"  Displaying first and last {max_frames} stack frames out of {total}.\"\n            ).format(\n                exc_type=type(e).__name__,\n                exc_msg=str(e),\n                max_frames=max_frames,\n                total=len(traceback),\n            )\n            traceback = traceback[:max_frames] + traceback[-max_frames:]\n        else:\n            if recursionindex is not None:\n                extraline = \"!!! Recursion detected (same locals & position)\"\n                traceback = traceback[: recursionindex + 1]\n            else:\n                extraline = None\n\n        return traceback, extraline",
            "start_line": 775,
            "start_column": 25707,
            "end_line": 4,
            "end_column": 27387,
            "start_byte": 25707,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_excinfo": {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo):\n\n        repr_chain = []\n        e = excinfo.value\n        descr = None\n        seen = set()\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo:\n                reprtraceback = self.repr_traceback(excinfo)\n                reprcrash = excinfo._getreprcrash()\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 812,
            "start_column": 27393,
            "end_line": 4,
            "end_column": 29052,
            "start_byte": 27393,
            "end_byte": 4
          },
          "_pytest._code.ExceptionChainRepr": {
            "name": "_pytest._code.ExceptionChainRepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ExceptionChainRepr(ExceptionRepr):\n    def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]\n\n    def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 882,
            "start_column": 29762,
            "end_line": 0,
            "end_column": 30319,
            "start_byte": 29762,
            "end_byte": 0
          },
          "_pytest._code.ExceptionChainRepr.__init__": {
            "name": "_pytest._code.ExceptionChainRepr.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, chain):\n        super().__init__()\n        self.chain = chain\n        # reprcrash and reprtraceback of the outermost (the newest) exception\n        # in the chain\n        self.reprtraceback = chain[-1][0]\n        self.reprcrash = chain[-1][1]",
            "start_line": 883,
            "start_column": 29807,
            "end_line": 4,
            "end_column": 30068,
            "start_byte": 29807,
            "end_byte": 4
          },
          "_pytest._code.ExceptionChainRepr.toterminal": {
            "name": "_pytest._code.ExceptionChainRepr.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        for element in self.chain:\n            element[0].toterminal(tw)\n            if element[2] is not None:\n                tw.line(\"\")\n                tw.line(element[2], yellow=True)\n        super().toterminal(tw)",
            "start_line": 891,
            "start_column": 30074,
            "end_line": 4,
            "end_column": 30319,
            "start_byte": 30074,
            "end_byte": 4
          },
          "_pytest._code.ReprTraceback": {
            "name": "_pytest._code.ReprTraceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTraceback(TerminalRepr):\n    entrysep = \"_ \"\n\n    def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style\n\n    def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 911,
            "start_column": 30623,
            "end_line": 0,
            "end_column": 31451,
            "start_byte": 30623,
            "end_byte": 0
          },
          "_pytest._code.ReprTraceback.entrysep": {
            "name": "_pytest._code.ReprTraceback.entrysep",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "entrysep = \"_ \"",
            "start_line": 912,
            "start_column": 30662,
            "end_line": 4,
            "end_column": 30677,
            "start_byte": 30662,
            "end_byte": 4
          },
          "_pytest._code.ReprTraceback.__init__": {
            "name": "_pytest._code.ReprTraceback.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprentries, extraline, style):\n        self.reprentries = reprentries\n        self.extraline = extraline\n        self.style = style",
            "start_line": 914,
            "start_column": 30683,
            "end_line": 4,
            "end_column": 30834,
            "start_byte": 30683,
            "end_byte": 4
          },
          "_pytest._code.ReprTraceback.toterminal": {
            "name": "_pytest._code.ReprTraceback.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        # the entries might have different styles\n        for i, entry in enumerate(self.reprentries):\n            if entry.style == \"long\":\n                tw.line(\"\")\n            entry.toterminal(tw)\n            if i < len(self.reprentries) - 1:\n                next_entry = self.reprentries[i + 1]\n                if (\n                    entry.style == \"long\"\n                    or entry.style == \"short\"\n                    and next_entry.style == \"long\"\n                ):\n                    tw.sep(self.entrysep)\n\n        if self.extraline:\n            tw.line(self.extraline)",
            "start_line": 919,
            "start_column": 30840,
            "end_line": 4,
            "end_column": 31451,
            "start_byte": 30840,
            "end_byte": 4
          },
          "_pytest._code.ReprTracebackNative": {
            "name": "_pytest._code.ReprTracebackNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprTracebackNative(ReprTraceback):\n    def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 938,
            "start_column": 31454,
            "end_line": 0,
            "end_column": 31642,
            "start_byte": 31454,
            "end_byte": 0
          },
          "_pytest._code.ReprTracebackNative.__init__": {
            "name": "_pytest._code.ReprTracebackNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.style = \"native\"\n        self.reprentries = [ReprEntryNative(tblines)]\n        self.extraline = None",
            "start_line": 939,
            "start_column": 31500,
            "end_line": 4,
            "end_column": 31642,
            "start_byte": 31500,
            "end_byte": 4
          },
          "_pytest._code.ReprEntryNative": {
            "name": "_pytest._code.ReprEntryNative",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntryNative(TerminalRepr):\n    style = \"native\"\n\n    def __init__(self, tblines):\n        self.lines = tblines\n\n    def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 945,
            "start_column": 31645,
            "end_line": 0,
            "end_column": 31834,
            "start_byte": 31645,
            "end_byte": 0
          },
          "_pytest._code.ReprEntryNative.style": {
            "name": "_pytest._code.ReprEntryNative.style",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "style = \"native\"",
            "start_line": 946,
            "start_column": 31686,
            "end_line": 4,
            "end_column": 31702,
            "start_byte": 31686,
            "end_byte": 4
          },
          "_pytest._code.ReprEntryNative.__init__": {
            "name": "_pytest._code.ReprEntryNative.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, tblines):\n        self.lines = tblines",
            "start_line": 948,
            "start_column": 31708,
            "end_line": 4,
            "end_column": 31765,
            "start_byte": 31708,
            "end_byte": 4
          },
          "_pytest._code.ReprEntryNative.toterminal": {
            "name": "_pytest._code.ReprEntryNative.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        tw.write(\"\".join(self.lines))",
            "start_line": 951,
            "start_column": 31771,
            "end_line": 4,
            "end_column": 31834,
            "start_byte": 31771,
            "end_byte": 4
          },
          "_pytest._code.ReprEntry": {
            "name": "_pytest._code.ReprEntry",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprEntry(TerminalRepr):\n    def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style\n\n    def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)\n\n    def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 955,
            "start_column": 31837,
            "end_line": 0,
            "end_column": 32932,
            "start_byte": 31837,
            "end_byte": 0
          },
          "_pytest._code.ReprEntry.__init__": {
            "name": "_pytest._code.ReprEntry.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, lines, reprfuncargs, reprlocals, filelocrepr, style):\n        self.lines = lines\n        self.reprfuncargs = reprfuncargs\n        self.reprlocals = reprlocals\n        self.reprfileloc = filelocrepr\n        self.style = style",
            "start_line": 956,
            "start_column": 31872,
            "end_line": 4,
            "end_column": 32115,
            "start_byte": 31872,
            "end_byte": 4
          },
          "_pytest._code.ReprEntry.toterminal": {
            "name": "_pytest._code.ReprEntry.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        if self.style == \"short\":\n            self.reprfileloc.toterminal(tw)\n            for line in self.lines:\n                red = line.startswith(\"E   \")\n                tw.line(line, bold=True, red=red)\n            return\n        if self.reprfuncargs:\n            self.reprfuncargs.toterminal(tw)\n        for line in self.lines:\n            red = line.startswith(\"E   \")\n            tw.line(line, bold=True, red=red)\n        if self.reprlocals:\n            tw.line(\"\")\n            self.reprlocals.toterminal(tw)\n        if self.reprfileloc:\n            if self.lines:\n                tw.line(\"\")\n            self.reprfileloc.toterminal(tw)",
            "start_line": 963,
            "start_column": 32121,
            "end_line": 4,
            "end_column": 32793,
            "start_byte": 32121,
            "end_byte": 4
          },
          "_pytest._code.ReprEntry.__str__": {
            "name": "_pytest._code.ReprEntry.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        return \"{}\\n{}\\n{}\".format(\n            \"\\n\".join(self.lines), self.reprlocals, self.reprfileloc\n        )",
            "start_line": 983,
            "start_column": 32799,
            "end_line": 4,
            "end_column": 32932,
            "start_byte": 32799,
            "end_byte": 4
          }
        }
      }
    }
  ]
}