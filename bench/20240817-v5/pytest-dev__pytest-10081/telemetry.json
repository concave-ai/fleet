{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-10081",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:37.584445",
        "usage": "1445.1329708099365 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "outcome",
          "__getitem__",
          "_resolve_ids",
          "_CACHE_PREFIX_DIRS",
          "ARGUMENT_TYPE_STR",
          "getfirstlinesource",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "test_tmproot",
          "T",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "evaluate_xfail_marks",
          "add_report_section",
          "getfixturedefs",
          "PytestUnhandledThreadExceptionWarning",
          "MoreQuietAction",
          "Node_fspath",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "pytest",
          "fullsource",
          "rex_session_duration",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "cacheprovider",
          "TResult",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "_parse_expression",
          "list",
          "append_collect_error",
          "ImportPathMismatchError",
          "get_scope_node",
          "evaluate_condition",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "SEP",
          "accept",
          "_resolve_warning_category",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "symlink_or_skip",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getfailedcollections",
          "reprfileloc",
          "startpath",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "RPAREN",
          "reprcrash",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "_color_for_type_default",
          "node_reporter",
          "write_line",
          "f_locals",
          "_getindent",
          "pytest_warning_recorded",
          "tmpdir_factory",
          "__slots__",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "is_started",
          "WarningsRecorder",
          "clear_cache",
          "_format_boolop",
          "PytestArg",
          "no_re_match_line",
          "INSTANCE_COLLECTOR",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "Config_rootdir",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "_WithException",
          "exec_module",
          "unraisableexception",
          "LFPluginCollSkipfiles",
          "category",
          "ParseError",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "__str__",
          "from_current",
          "_initrequest",
          "handleError",
          "reorder_items_atscope",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "Expression",
          "_getscopeitem",
          "SysCapture",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "_is_skipped",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "Cache_makedir",
          "lineno",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "OK",
          "Item",
          "firstlineno",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "_PluggyPlugin",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "request",
          "USAGE_ERROR",
          "_W",
          "TestReport",
          "_find_spec",
          "fix_cache_order",
          "__getattr__",
          "File",
          "idfn",
          "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
          "sections",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "__lt__",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "_CACHE_PREFIX_VALUES",
          "showheader",
          "_IGNORED_ERRORS",
          "stream",
          "commonpath",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "no_summary",
          "name",
          "add_global_property",
          "append",
          "PRIVATE",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "extraline",
          "longrepr",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "_set_main_color",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "_scope",
          "global_and_fixture_disabled",
          "pytester_assertions",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "Config_inifile",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "LEGACY_PATH",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "width_of_current_line",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "flush",
          "get_direct_param_fixture_func",
          "PytestRemovedIn8Warning",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "reason",
          "finish_recording",
          "TerminalRepr",
          "duration",
          "__enter__",
          "_repr_failure_py",
          "caplog_records_key",
          "pytest_runtest_logstart",
          "_format_action_invocation",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "insert_missing_modules",
          "E",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "_get_multicapture",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "Scope",
          "_check_path",
          "TerminalReporter_startdir",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "STEPWISE_CACHE_DIR",
          "helper",
          "check_ispytest",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "repr",
          "_factorytraceback",
          "get_terminal_width",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "PathAwareHookProxy",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "Testdir",
          "threadexception",
          "OR",
          "resolve_from_str",
          "assert_never",
          "report_collect",
          "_split_lines",
          "cacheshow",
          "_show_fixture_action",
          "_FixtureCachedResult",
          "resume_fixture",
          "inline_run",
          "saferepr_unlimited",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "_resolve_msg_to_reason",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "get_last_failed_paths",
          "write",
          "_write_content",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "makepyprojecttoml",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "ARGUMENT_TYPE_STR_CHOICE",
          "_esctable",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "filter_traceback_for_conftest_import_failure",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "fullwidth",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "copytree",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_fail",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "pos",
          "node",
          "_names",
          "InstanceDummy",
          "Node_fspath_set",
          "HookRecorder",
          "_getentrysource",
          "should_do_markup",
          "Scanner",
          "resolve_package_path",
          "head_line",
          "marks",
          "_FileHandler",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "ARGUMENT_PERCENT_DEFAULT",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "IGNORED_ATTRIBUTES",
          "_do_configure",
          "families",
          "search_pypath",
          "repr_failure",
          "resolve",
          "format_session_duration",
          "traverse_node",
          "messages",
          "IDENT_PREFIX",
          "_check_all_skipped",
          "get_terminal_writer",
          "maybe_wrap_pytest_function_for_tracing",
          "Class",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_warn_about_skipped_plugins",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingNullHandler",
          "_LiveLoggingStreamHandler",
          "sep",
          "fault_handler_stderr_key",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "_compare_approx",
          "_get_teardown_reports",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "markup",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "PytestReturnNotNoneWarning",
          "Config",
          "_getini",
          "Exception",
          "reports",
          "_ensure_basetemp",
          "_compare_eq_any",
          "_collectfile",
          "_check_initialpaths_for_relpath",
          "type",
          "TerminalWriter",
          "pytest_runtest_setup",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "make_unique_parameterset_ids",
          "setdefault",
          "DoctestModule",
          "legacy_path",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "xfailed_key",
          "StashKey",
          "_validate_ids",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "from_parent",
          "_setupstate",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "IdMaker",
          "CHECKER_CLASS",
          "find_spec",
          "get_statement_startend2",
          "try_makedirs",
          "old_mark_config_key",
          "_resolve_parameter_set_ids",
          "_for_parametrize",
          "Token",
          "from_exc_info",
          "extract_from",
          "_ALL_SCOPES",
          "cut",
          "setupplan",
          "parse_setoption",
          "imply_paths_hooks",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "PytestUnraisableExceptionWarning",
          "findsource",
          "HIGH_SCOPES",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "from_config",
          "console_main",
          "resolve_collection_argument",
          "lex",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "__attrs_post_init__",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "timing",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "next_higher",
          "truncate_locals",
          "record_property",
          "visit",
          "reprlocals",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "__iter__",
          "no_header",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "__bool__",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "assertstate_key",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "_AnyPurePath",
          "LFPluginCollWrapper",
          "strip",
          "pytest_runtestloop",
          "_recursive_sequence_map",
          "exitstatus",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "_format_trimmed",
          "frame",
          "makeini",
          "RE_IMPORT_ERROR_NAME",
          "deselect_by_mark",
          "from_function",
          "append_skipped",
          "listchain",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "_hook",
          "name2fixturedefs",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "strict",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "_as_numpy_array",
          "pytest_ignore_collect",
          "stash",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_add_stats",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "NODE_CTOR_FSPATH_ARG",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "_check_item_and_collector_diamond_inheritance",
          "reprentries",
          "args",
          "__module__",
          "_get_unknown_ini_keys",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "count",
          "show_fixtures_per_test",
          "running_on_ci",
          "_build_collect_only_summary_stats_line",
          "isinitpath",
          "thread_exception_runtest_hook",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "reject",
          "cache_dir_from_config",
          "ApproxSequenceLike",
          "tracebackcutdir",
          "ApproxBase",
          "TYPE_CHECKING",
          "isnamedtuple",
          "_excinfo",
          "DontReadFromInput",
          "_idval_from_hook",
          "pytest_sessionfinish",
          "fill_unfilled",
          "_PYTEST_DIR",
          "visit_Call",
          "ImportMode",
          "D",
          "errisinstance",
          "pluralize",
          "_init_checker_class",
          "__exit__",
          "_assert_state",
          "make_properties_node",
          "result",
          "config",
          "_is_last_item",
          "parse_warning_filter",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "catch_unraisable_exception",
          "_check_scope",
          "reprfuncargs",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "next_lower",
          "keywords",
          "AND",
          "indices",
          "linecomp",
          "_parse_ini_config",
          "KNOWN_TYPES",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "__dir__",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "record_testsuite_property",
          "_update_current_test_var",
          "LPAREN",
          "_ANSI_ESCAPE_SEQ",
          "parse_known_and_unknown_args",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "mkpydir",
          "_argcomplete",
          "IDENT",
          "logging",
          "xml_key",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "LegacyTmpdirPlugin",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "not_expr",
          "get_fslocation_from_item",
          "listoutcomes",
          "EOF",
          "get",
          "pytest_unconfigure",
          "_start",
          "_mk_tmp",
          "_build_normal_summary_stats_line",
          "_FixtureFunc",
          "_initini",
          "consider_conftest",
          "apply_warning_filters",
          "addinivalue_line",
          "KeywordMatcher",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_NodeType",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "parse_summary_nouns",
          "index",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_param_ids_from",
          "inipath",
          "id",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "consider_pluginarg",
          "CollectErrorRepr",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "_param_ids_generated",
          "display",
          "template",
          "_get_continue_on_failure",
          "K",
          "prog",
          "get_stderr_fileno",
          "setuponly",
          "_resume",
          "NotSetType",
          "freeze_includes",
          "unset_fixture",
          "ApproxDecimal",
          "lines",
          "record_xml_attribute",
          "ReprEntry",
          "_get_directory",
          "make_numbered_dir",
          "_write_entry_lines",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "_validate_config_options",
          "relline",
          "_ignore_error",
          "WarningsChecker",
          "fail_marker",
          "getitems",
          "Skip",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_idval_from_function",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "DEFAULT_REPR_MAX_SIZE",
          "showhelp",
          "expression",
          "MatcherAdapter",
          "getworkerinfoline",
          "_is_setup_py",
          "pop",
          "TokenType",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_replace",
          "Parser",
          "_find_parametrized_scope",
          "ensure_extended_length_path",
          "nodes",
          "YIELD_FIXTURE",
          "MyOptionParser",
          "inline_genitems",
          "catch_warnings_for_item",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "_write_pyc_fp",
          "delitem",
          "V",
          "get_lines_after",
          "assert_contains",
          "_arg2scope",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "WARNING_CMDLINE_PREPARSE_HOOK",
          "TeeCaptureIO",
          "add_property",
          "update",
          "get_extended_length_path_str",
          "prepend",
          "compile",
          "__version__",
          "from_user",
          "USAGE_MSG",
          "_is_numpy_array",
          "_args_converter",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_is_main_py",
          "_get_progress_information_message",
          "fault_handler_originally_enabled_key",
          "Config_invocation_dir",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "parametersets",
          "cache_key",
          "TEST_OUTCOME",
          "NOT",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "rootpath",
          "_F",
          "unraisable_exception_runtest_hook",
          "activate_fixture",
          "evaluate_skip_marks",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "_has_param_ids",
          "NodeMeta",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_truncate_explanation",
          "_T",
          "get_cache_dir",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "code",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "_IGNORED_WINERRORS",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "Config__getini_unknown_type",
          "_importconftest",
          "FixtureLookupError",
          "_ensure_relative_to_basetemp",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_check_non_top_pytest_plugins",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_surrounding_parens_on_own_lines",
          "ReprTracebackNative",
          "ParameterSet",
          "locate_config",
          "listnames",
          "caplog_handler_key",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "_with_exception",
          "assertrepr_compare",
          "pytest_markeval_namespace",
          "param",
          "pytest_collectreport",
          "_pformat_dispatch",
          "assertion",
          "_idval_from_value_required",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "and_expr",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "_idval_from_argname",
          "FastFilesCompleter",
          "_format",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_color_for_type",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "async_warn_and_skip",
          "_truncate_by_char_count",
          "own_mark_names",
          "_imply_path",
          "__take_sys_modules_snapshot",
          "getcall",
          "_getini_unknown_type",
          "_should_rewrite",
          "fail_fixturefunc",
          "Markable",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "Stash",
          "_is_in_confcutdir",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "has_default_eq",
          "set_trace",
          "_teardown_yield_fixture",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "_is_started",
          "module_name_from_path",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "showlongtestinfo",
          "append_failure",
          "importlib",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "_get_raw_skip_reason",
          "HOOK_LEGACY_PATH_ARG",
          "SysPathsSnapshot",
          "NodeKeywords",
          "evaluate",
          "_REPORTCHARS_DEFAULT",
          "Skipped",
          "STRICT_OPTION",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "python",
          "_tmppath_factory",
          "issue_config_time_warning",
          "wcswidth",
          "fnmatch_ex",
          "name2pseudofixturedef_key",
          "_Key",
          "absolutepath",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "_idlist",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "cache",
          "validate_basetemp",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "match",
          "token",
          "popcall",
          "_no_match_line",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "_highlight",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "gethookproxy",
          "_genfunctions",
          "_get_auto_indent",
          "pytest_plugins",
          "addoption",
          "Session_stardir",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "_windowsconsoleio_workaround",
          "explanation_param",
          "get_timeout_config_value",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "legacypath",
          "pytest_pycollect_makeitem",
          "FixtureRequest_fspath",
          "visit_Starred",
          "_repr_compare",
          "_ET",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "_HandlerType",
          "_get_reports_to_display",
          "setmulti",
          "assert_contains_lines",
          "_get_maxsize_for_saferepr",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "wcwidth",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "Xfail",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "Pytester",
          "ids",
          "_handle_teardown_sections",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "values",
          "start",
          "_write_source",
          "LoggingPlugin",
          "_determine_main_color",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_try_repr_or_str",
          "_folded_skips",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "load_config_dict_from_file",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "_fixturemanager",
          "func_name",
          "is_generator",
          "ARGS",
          "set_fixture",
          "get_common_ancestor",
          "PdbInvoke",
          "__contains__",
          "_pretty_fixture_path",
          "deactivate_fixture",
          "PercentStyleMultiline",
          "MarkMatcher",
          "f_globals",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "_create",
          "longreprtext",
          "runner",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "FixtureValue",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getbasetemp",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "FDCaptureBinary",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "KEYWORD_MSG_ARG",
          "_get_main_color",
          "no_fnmatch_line",
          "MarkGenerator",
          "ArgsSource",
          "_R",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "_EmptyClass",
          "line",
          "__test__",
          "_result",
          "_getlines",
          "_get_node_id_with_markup",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "add_color_level",
          "iterparentnodeids",
          "_get_number_flag",
          "python_path",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "is_async_function",
          "AlwaysDispatchingPrettyPrinter",
          "print_teardown_sections",
          "wrap_pytest_function_for_tracing",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "maybe_delete_a_numbered_dir",
          "_S",
          "_params_converter",
          "import_path",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "LegacyTestdirPlugin",
          "passed",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "bestrelpath",
          "pastebinfile_key",
          "getstatementrange",
          "INCOVATION_DIR",
          "makepyfile",
          "reprtraceback",
          "_is_doctest",
          "SetupState",
          "RecordedHookCall",
          "_prepare_content",
          "pathlib",
          "_addoption_instance",
          "notset",
          "catch_threading_exception",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "WARNS_NONE_ARG",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "AssertionRewritingHook",
          "bin_xml_escape",
          "FixtureFunction",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "_validate_plugins",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "TESTPATHS",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "_in_suspended",
          "get_default_arg_names",
          "names_closure",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "expr",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "parametrize",
          "_SCOPE_INDICES",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "_warn_or_fail_if_strict",
          "PytestDeprecationWarning",
          "genitems",
          "_eval_scope_callable",
          "clear",
          "_idval_from_value"
        ]
      },
      "response": {
        "keywords": [
          "pytest",
          "unittest",
          "pytest_enter_pdb",
          "PytestPDB",
          "tearDown",
          "skip",
          "unittest.skip",
          "testcase",
          "teardown",
          "debugging"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:39.029592",
        "usage": "196.24996185302734 ms"
      },
      "request": {
        "tokens": [
          "pytest",
          "unittest",
          "pytest_enter_pdb",
          "PytestPDB",
          "tearDown",
          "skip",
          "unittest.skip",
          "testcase",
          "teardown",
          "debugging"
        ]
      },
      "response": {
        "results": {
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "teardown": [
            "src/_pytest/outcomes.py",
            "src/_pytest/logging.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/nose.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/warnings.py",
            "src/pytest/__main__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pytester.py",
            "src/pytest/__init__.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/python_path.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/timing.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/scope.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/stash.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python.py"
          ],
          "debugging": [
            "src/_pytest/legacypath.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py"
          ],
          "skip": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/doctest.py",
            "src/pytest/__init__.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/pytester.py"
          ],
          "testcase": [
            "src/_pytest/unittest.py",
            "src/_pytest/junitxml.py"
          ],
          "tearDown": [
            "src/_pytest/unittest.py"
          ],
          "pytest_enter_pdb": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:39.225855",
        "usage": "5785.813093185425 ms"
      },
      "request": {
        "keyword_search_results": {
          "unittest": [
            "src/_pytest/python_api.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/unittest.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "teardown": [
            "src/_pytest/outcomes.py",
            "src/_pytest/logging.py",
            "src/_pytest/runner.py",
            "src/_pytest/nodes.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/nose.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/capture.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest": [
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/logging.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/warnings.py",
            "src/pytest/__main__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pytester.py",
            "src/pytest/__init__.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/python_path.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/timing.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/scope.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/stash.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python.py"
          ],
          "debugging": [
            "src/_pytest/legacypath.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/debugging.py",
            "src/pytest/__init__.py"
          ],
          "skip": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/doctest.py",
            "src/pytest/__init__.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/pytester.py"
          ],
          "testcase": [
            "src/_pytest/unittest.py",
            "src/_pytest/junitxml.py"
          ],
          "tearDown": [
            "src/_pytest/unittest.py"
          ],
          "pytest_enter_pdb": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue relates to the handling of skipped `unittest.TestCase` classes with the `--pdb` option in pytest. The expected behavior is that when a class is marked with `unittest.skip`, its `tearDown()` method should not be called. However, it appears that when running with `--pdb`, this method is still executed, leading to an error.\n\nThe key elements of this problem are:\n1. `unittest` \u2014 involves handling `unittest.TestCase`, which should link to related pytest code that deals with unittest integration.\n2. `tearDown` \u2014 the specific method that's being executed inappropriately.\n3. `--pdb` \u2014 debugging flag within pytest that is possibly influencing this behavior.\n4. `skip` \u2014 the decorator causing skipping that seems to not be functioning correctly with `--pdb`.\n\nRelevant files based on the keywords:\n1. `src/_pytest/unittest.py`: This file appears multiple times in relation to `unittest`, `tearDown`, `skip`, and `testcase`. It's very likely this file contains logic for running unittest tests, possibly including setting up and tearing down tests.\n2. `src/_pytest/debugging.py`: Contains `pytest_enter_pdb`, which might affect behavior when `--pdb` is used, although it's less directly related to the skipping issue itself.\n3. `src/_pytest/skipping.py`: Directly related to skip logic in pytest, which could be relevant for understanding why the class-level skip is not behaving as expected.\n4. `src/_pytest/runner.py`: Contains mentions of `unittest`, likely relevant to the actual running of tests and executing teardown operations.\n\nOther results seem less relevant to this specific problem. Based on the provided paths, it seems like `src/_pytest/unittest.py` is the most likely location to check for issues, followed by the skipping logic and interaction with debugging options.",
        "file_paths": [
          "src/_pytest/unittest.py",
          "src/_pytest/skipping.py",
          "src/_pytest/runner.py",
          "src/_pytest/debugging.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:45.011684",
        "usage": "5209.1028690338135 ms"
      },
      "request": {
        "file_path": "src/_pytest/unittest.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue where the `tearDown()` method of `unittest.TestCase` is being executed even for classes that are marked with `unittest.skip` when using the `--pdb` option in pytest.\n1.2 This issue is caused because when `--pdb` is used, the setup or teardown behavior might be inherently different, potentially causing skipped tests to still run some of their methods like tearDown().\n1.5 The issue should be addressed by ensuring that `tearDown()` and other similar methods don't get executed or altered during the setup/teardown process for a skipped class, even when `--pdb` is used.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/unittest.py` is responsible for integrating pytest with unittest-style test cases.\n2.2 The file content is primarily about the setup and teardown process for such test cases.\n2.3 The method `runtest()` in `TestCaseFunction` class is directly relevant as it mentions conditionally delaying tear down when `--pdb` is used.\n2.4 The `_is_skipped()` utility function checks if a test was marked to be skipped.\n2.5 The `_make_xunit_fixture` method handles setting up fixtures that call setup and teardown found in the class, which would include `tearDown()`.\n2.6 Based on these reviews, the root issue is that `tearDown()` is not properly handled for skipped tests when `--pdb` is used within `runtest()`.\n3. Output Your Decision:",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "_make_xunit_fixture",
          "TestCaseFunction.runtest",
          "_is_skipped"
        ],
        "root_cause_symbols": [
          "TestCaseFunction.runtest",
          "_make_xunit_fixture"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:50.220825",
        "usage": "4303.984880447388 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "1. User describes an issue where the `tearDown()` method in `unittest.TestCase` classes, marked with `unittest.skip`, execute during `--pdb` runs, even though they should be skipped.\n2. The file `src/_pytest/skipping.py` appears related, as it deals with skip and xfail marker evaluation in pytest.\n\nThis file defines how skip and xfail markers are used, setting configurations and evaluating conditions. It doesn't directly handle `unittest.skip` behavior but instead manages pytest's own skip logic.\n\nRelevance:\n- The file does not define unittest behavior. Instead, it defines mechanisms for pytest's skipping functionality. Given that the issue occurs when \"`pytest --pdb` is run\", this file might influence how unittest skips are understood within pytest's domain.\n- `evaluate_skip_marks` checks for \"skip\" and \"skipif\" markers but doesn't alter `unittest.skip` behavior.\n\nConclusion:\n- Although not directly responsible for the behavior of `unittest.skip`, this file does connect to how test skipping is defined in pytest. It could indirectly relate if pytest-initiated configurations and states affect `unittest` tests when running with `--pdb`. However, the root cause likely lies in how pytest interfaces with unittest tests overall and is not confined to this specific file.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/unittest.py",
          "src/_pytest/debugging.py",
          "src/_pytest/hookspec.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:54.524835",
        "usage": "9871.10686302185 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is experiencing an issue where the `tearDown()` method of `unittest.TestCase` classes, which are marked with `unittest.skip` on the class level, is executed when running `pytest` with the `--pdb` option.\n1.2 This issue is caused because the `tearDown()` method should not be called for skipped tests, but it seems to be called when the `--pdb` option is used.\n1.3 The expected result is that `tearDown()` should not be executed for tests skipped with `unittest.skip`.\n1.4 If the user did not specify the expected behavior more, the expectation should be that skipped tests do not execute any setup or teardown unless explicitly specified.\n1.5 The issue should be fixed by ensuring that the `--pdb` option does not alter the skipping behavior for the test suite, especially in the context of setup or teardown execution.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/runner.py` contains numerous functions related to test execution, and ties closely to how pytest manages test runs including setup and teardown.\n2.2 Key functions like `runtestprotocol()`, `pytest_runtest_teardown()` and `call_and_report()` can play a critical role in deciding when setup/teardown activities are carried out. Particularly, `runtestprotocol()` initiates setup, call (test execution), and teardown for each test item.\n2.3 `check_interactive_exception()`, and its association with exceptions and interactive debugging, is particularly relevant due to its control over behavior when exceptions like `Skipped` are faced.\n2.4 A call to `pytest_runtest_teardown` is placed within the sequence of hooks, possibly indicating the teardown step being executed erroneously even when tests are marked to skip.\n2.5 No direct handling within this scope to manage `--pdb` related behavioral exceptions was found but the interaction of `check_interactive_exception` with the invocation of `pytest_exception_interact` suggests pivotal control over postmortem handling.\n2.6 Based on the setup state and teardown control dynamics explored here, the core area is `runtestprotocol`'s method and its correlation with `pytest_runtest_teardown` and `check_interactive_exception`.\n\nThe diagnosis is tentative since auxiliary files may invoke substantial logic tweaks. However, the symbols identified could play root roles or at the least denote faulty interactions when `--pdb` applies.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "runtestprotocol",
          "call_and_report",
          "check_interactive_exception",
          "pytest_runtest_teardown"
        ],
        "root_cause_symbols": [
          "runtestprotocol",
          "check_interactive_exception",
          "pytest_runtest_teardown"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:04.395990",
        "usage": "7483.296871185303 ms"
      },
      "request": {
        "file_path": "src/_pytest/debugging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is that when running `pytest --pdb`, the `tearDown()` method of `unittest.TestCase` classes, which are decorated with `unittest.skip`, is being executed.\n1.2 This issue occurs when using the `--pdb` option, which interacts with the skipped tests in an unexpected way, potentially due to how pytest integrates with pdb for test debugging.\n1.3 The expected result should be that `tearDown()` or any other methods do not execute when the class is marked with `unittest.skip`, even when `--pdb` is used.\n1.4 The expectation, when fixed, should be that if a class is marked with `unittest.skip`, no part of the test (including `tearDown()`) should execute, maintaining skip behavior consistently irrespective of the `--pdb` option.\n1.5 The issue might be fixed by altering how pytest handles test lifecycle when integrated with the `pdb` debugger and especially how it respects the skip decorators.\n\n2. Make File Evaluation:\n2.1 Analyze the file, checking for how `--pdb` options are handled and if any hooks or lifecycle methods might involve `tearDown` indirectly.\n2.2 The class `pytestPDB` and method `PdbInvoke.pytest_exception_interact` relate to pdb handling during test exceptions, which would be involved in `--pdb` behaviors.\n2.3 In terms of symbols relevant to this problem, we should consider `_init_pdb`, `pytest_exception_interact`, and `_enter_pdb` as they manage the setup for pdb interactions which could influence `tearDown()` execution.\n2.4 Given these potential entry points, the issue might be due to how pdb is initialized or interacts with exceptions, possibly making skipped statuses not fully respected in the context where pdb wants to break.\n2.5 The function that registers pdb-related hooks, such as `pytest_addoption` and `pytest_configure`, may also contribute to why pdb doesn't respect the `unittest.skip` as expected when the `--pdb` flag is provided.\n2.6 The file is related to the issue since it orchestrates pdb setups, but whether it exactly triggers `tearDown()` unintentionally would require additional context cross-referencing other lifecycle affecting components in pytest.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/unittest.py",
          "src/_pytest/hooks.py"
        ],
        "relevant_symbols": [
          "pytestPDB._init_pdb",
          "PdbInvoke.pytest_exception_interact",
          "_enter_pdb"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:11.879309",
        "usage": "112.56003379821777 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/unittest.py",
            "relevant_symbol_keys": [
              "_make_xunit_fixture",
              "TestCaseFunction.runtest",
              "_is_skipped"
            ],
            "root_cause_symbol_keys": [
              "TestCaseFunction.runtest",
              "_make_xunit_fixture"
            ]
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "runtestprotocol",
              "call_and_report",
              "check_interactive_exception",
              "pytest_runtest_teardown"
            ],
            "root_cause_symbol_keys": [
              "runtestprotocol",
              "check_interactive_exception",
              "pytest_runtest_teardown"
            ]
          },
          {
            "file_path": "src/_pytest/debugging.py",
            "relevant_symbol_keys": [
              "pytestPDB._init_pdb",
              "PdbInvoke.pytest_exception_interact",
              "_enter_pdb"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.unittest._is_skipped",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _is_skipped(obj) -> bool:\n    \"\"\"Return True if the given object has been marked with @unittest.skip.\"\"\"\n    return bool(getattr(obj, \"__unittest_skip__\", False))",
            "start_line": 411,
            "start_column": 14289,
            "end_line": 0,
            "end_column": 14455,
            "start_byte": 14289,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 216,
            "start_column": 6784,
            "end_line": 0,
            "end_column": 7266,
            "start_byte": 6784,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\"Initialize PDB debugging, dropping any IO capturing.\"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is None:\n            capman: Optional[CaptureManager] = None\n        else:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", f\"PDB {method} (IO-capturing turned off)\")\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", f\"PDB {method}\")\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 236,
            "start_column": 7946,
            "end_line": 4,
            "end_column": 9411,
            "start_byte": 7946,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_exception_interact(\n        self, node: Node, call: \"CallInfo[Any]\", report: BaseReport\n    ) -> None:\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        assert call.excinfo is not None\n        _enter_pdb(node, call.excinfo, report)",
            "start_line": 285,
            "start_column": 9711,
            "end_line": 4,
            "end_column": 10173,
            "start_byte": 9711,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(\n    node: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport\n) -> BaseReport:\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True  # type: ignore[attr-defined]\n    post_mortem(tb)\n    return rep",
            "start_line": 335,
            "start_column": 11583,
            "end_line": 0,
            "end_column": 12554,
            "start_byte": 11583,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "config.add_cleanup(fin)\n\n\nclass pytestPDB:\n    \"\"\"Pseudo PDB that defers to the real pdb.\"\"\"\n\n    _pluginmanager: Optional[PytestPluginManager] = None\n    _config: Optional[Config] = None\n    _saved: List[\n    ",
            "start_line": 82,
            "start_column": 2739,
            "end_line": 0,
            "end_column": 2949,
            "start_byte": 2739,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 872,
            "start_column": 30367,
            "end_line": 0,
            "end_column": 30688,
            "start_byte": 30367,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: Scope,\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope.value,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"_unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n\n    return fixture",
            "start_line": 121,
            "start_column": 3946,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 3946,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self) -> None:\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        assert self._testcase is not None\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # Let the unittest framework handle async functions.\n        if is_async_function(self.obj):\n            # Type ignored because self acts as the TestResult, but is not actually one.\n            self._testcase(result=self)  # type: ignore[arg-type]\n        else:\n            # When --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug.\n            # Arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed.\n            if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # We need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)  # type: ignore[arg-type]\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 300,
            "start_column": 10108,
            "end_line": 4,
            "end_column": 11636,
            "start_byte": 10108,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 787,
            "start_column": 25291,
            "end_line": 4,
            "end_column": 25468,
            "start_byte": 25291,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "item is None:\n            assert not self.stack\n\n\ndef collect_one_node(collector: Collector) -> CollectReport:\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 504,
            "start_column": 17597,
            "end_line": 0,
            "end_column": 18272,
            "start_byte": 17597,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 720,
            "start_column": 26288,
            "end_line": 4,
            "end_column": 26595,
            "start_byte": 26288,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # After all teardown hooks have been called\n    # want funcargs and request info to go away.\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 116,
            "start_column": 3503,
            "end_line": 0,
            "end_column": 4506,
            "start_byte": 3503,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(nextitem)\n    _update_current_test_var(item, None)",
            "start_line": 177,
            "start_column": 5576,
            "end_line": 0,
            "end_column": 5792,
            "start_byte": 5576,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo[object]\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 229,
            "start_column": 7269,
            "end_line": 0,
            "end_column": 7759,
            "start_byte": 7269,
            "end_byte": 0
          },
          {
            "name": "_pytest.threadexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "          \"(%s durations < %gs hidden.  Use -vv to show these durations.)\"\n                % (len(dlist) - i, durations_min)\n            )\n            break\n ",
            "start_line": 85,
            "start_column": 2756,
            "end_line": 0,
            "end_column": 2914,
            "start_byte": 2756,
            "end_byte": 0
          },
          {
            "name": "_pytest.unraisableexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ion\") -> None:\n    session._setupstate = SetupState()\n\n\ndef pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\n\n\ndef p",
            "start_line": 90,
            "start_column": 3028,
            "end_line": 0,
            "end_column": 3190,
            "start_byte": 3028,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:11.991882",
        "usage": "10163.892984390259 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.unittest._is_skipped",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _is_skipped(obj) -> bool:\n    \"\"\"Return True if the given object has been marked with @unittest.skip.\"\"\"\n    return bool(getattr(obj, \"__unittest_skip__\", False))",
            "start_line": 411,
            "start_column": 14289,
            "end_line": 0,
            "end_column": 14455,
            "start_byte": 14289,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 216,
            "start_column": 6784,
            "end_line": 0,
            "end_column": 7266,
            "start_byte": 6784,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\"Initialize PDB debugging, dropping any IO capturing.\"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is None:\n            capman: Optional[CaptureManager] = None\n        else:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", f\"PDB {method} (IO-capturing turned off)\")\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", f\"PDB {method}\")\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 236,
            "start_column": 7946,
            "end_line": 4,
            "end_column": 9411,
            "start_byte": 7946,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_exception_interact(\n        self, node: Node, call: \"CallInfo[Any]\", report: BaseReport\n    ) -> None:\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        assert call.excinfo is not None\n        _enter_pdb(node, call.excinfo, report)",
            "start_line": 285,
            "start_column": 9711,
            "end_line": 4,
            "end_column": 10173,
            "start_byte": 9711,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(\n    node: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport\n) -> BaseReport:\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True  # type: ignore[attr-defined]\n    post_mortem(tb)\n    return rep",
            "start_line": 335,
            "start_column": 11583,
            "end_line": 0,
            "end_column": 12554,
            "start_byte": 11583,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "config.add_cleanup(fin)\n\n\nclass pytestPDB:\n    \"\"\"Pseudo PDB that defers to the real pdb.\"\"\"\n\n    _pluginmanager: Optional[PytestPluginManager] = None\n    _config: Optional[Config] = None\n    _saved: List[\n    ",
            "start_line": 82,
            "start_column": 2739,
            "end_line": 0,
            "end_column": 2949,
            "start_byte": 2739,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 872,
            "start_column": 30367,
            "end_line": 0,
            "end_column": 30688,
            "start_byte": 30367,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: Scope,\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope.value,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"_unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n\n    return fixture",
            "start_line": 121,
            "start_column": 3946,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 3946,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self) -> None:\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        assert self._testcase is not None\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # Let the unittest framework handle async functions.\n        if is_async_function(self.obj):\n            # Type ignored because self acts as the TestResult, but is not actually one.\n            self._testcase(result=self)  # type: ignore[arg-type]\n        else:\n            # When --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug.\n            # Arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed.\n            if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # We need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)  # type: ignore[arg-type]\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 300,
            "start_column": 10108,
            "end_line": 4,
            "end_column": 11636,
            "start_byte": 10108,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 787,
            "start_column": 25291,
            "end_line": 4,
            "end_column": 25468,
            "start_byte": 25291,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "item is None:\n            assert not self.stack\n\n\ndef collect_one_node(collector: Collector) -> CollectReport:\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 504,
            "start_column": 17597,
            "end_line": 0,
            "end_column": 18272,
            "start_byte": 17597,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 720,
            "start_column": 26288,
            "end_line": 4,
            "end_column": 26595,
            "start_byte": 26288,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # After all teardown hooks have been called\n    # want funcargs and request info to go away.\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 116,
            "start_column": 3503,
            "end_line": 0,
            "end_column": 4506,
            "start_byte": 3503,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(nextitem)\n    _update_current_test_var(item, None)",
            "start_line": 177,
            "start_column": 5576,
            "end_line": 0,
            "end_column": 5792,
            "start_byte": 5576,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo[object]\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 229,
            "start_column": 7269,
            "end_line": 0,
            "end_column": 7759,
            "start_byte": 7269,
            "end_byte": 0
          },
          {
            "name": "_pytest.threadexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "          \"(%s durations < %gs hidden.  Use -vv to show these durations.)\"\n                % (len(dlist) - i, durations_min)\n            )\n            break\n ",
            "start_line": 85,
            "start_column": 2756,
            "end_line": 0,
            "end_column": 2914,
            "start_byte": 2756,
            "end_byte": 0
          },
          {
            "name": "_pytest.unraisableexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ion\") -> None:\n    session._setupstate = SetupState()\n\n\ndef pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\n\n\ndef p",
            "start_line": 90,
            "start_column": 3028,
            "end_line": 0,
            "end_column": 3190,
            "start_byte": 3028,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue where the `tearDown()` method of a `unittest.TestCase` is being executed even when the entire class is marked with `unittest.skip` and tests are run with `pytest --pdb`.\n1.2 This might be caused by a bug in pytest handling of skipped classes when the --pdb flag is involved.\n1.3 The expected result would be for `tearDown()` not to be executed if the class is skipped.\n1.4 If not explicitly mentioned, a reasonable expectation is that methods of a skipped class (including `tearDown`) should not execute regardless of other options like --pdb.\n1.5 The issue can be fixed by ensuring that if a class is marked as skipped, none of its methods including the `tearDown` are run.\n\n2. Make the evaluation:\n2.1 The function `_make_xunit_fixture` has a check for `_is_skipped`. It prevents the execution of setup in case of skip.\n2.2 The `TestCaseFunction.runtest` temporarily modifies `tearDown` if it's not marked as skipped.\n2.3 The `_is_skipped` utility helps in identifying skipped tests.\n2.4 All these symbols interact with the test running and skipping mechanism.\n\nDeciding which symbols would need changes:\n- `_pytest.unittest.TestCaseFunction.runtest` has a direct interaction with the `tearDown` method and skipping logic.\n- `_pytest.unittest._is_skipped` utility can be reviewed for any enhancement needed.",
        "symbols": [
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "reason": "This function directly handles calling the tearDown method. Modifications are required to ensure that tearDown is not set to None in the first place if the class is marked with unittest.skip in the context of --pdb."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "This function handles the execution of `tearDown`. It checks for `usepdb` and `_is_skipped`. It modifies `tearDown` when the test isn't skipped and pdb is used. Needs adjustment to ensure skipped test classes don't execute `tearDown`.",
          "Handles both setup and teardown logic for xunit-style tests. Contains logic to skip the execution if `_is_skipped()` returns true, which is relevant to skipping behavior.",
          "No behavior given but could be related to capturing issues during the teardown process for pdb.",
          "Doesn't appear to offer direct changes or hooks related to skipping or pdb.",
          "Handles the logging during teardown which has no direct link to skipping logic or --pdb.",
          "Executes the teardown in the standard pytest lifecycle, handles logging and setup procedures.",
          "Actual function handling the teardown process for test items, interacts with the session's state to manage teardowns.",
          "Possibly checks for exceptions during execution which does relate to test failures rather than skipping directly.",
          "Content is related to threading and duration hiding rather than skipping tests in pdb context.",
          "Handles session teardown but logic seems more related to teardown at the session level, not test case skipping.",
          "Checks if an object is marked for skipping, critical point to ensure the correct behavior is achieved.",
          "Runs hooks and creates reports, less likely candidate but relates to how session runs hooks.",
          "Initialization and handling of PDB which isn't directly related to skipping logic but sets up debugging environment.",
          "Manages interaction hook when exceptions occur which could be important if pdb & skip interacts unexpectedly.",
          "Involved with entering pdb, debug and post-mortem context but not directly related with skip or teardown logic.",
          "Class related to PDB debugging, indirect influence on pdb activity, no skip logic noted.",
          "No content provided but could relate to pdb entering hooks which might impact overall pdb behavior."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:22.155814",
        "usage": "2.1500587463378906 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.unittest._is_skipped",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def _is_skipped(obj) -> bool:\n    \"\"\"Return True if the given object has been marked with @unittest.skip.\"\"\"\n    return bool(getattr(obj, \"__unittest_skip__\", False))",
              "start_line": 411,
              "start_column": 14289,
              "end_line": 0,
              "end_column": 14455,
              "start_byte": 14289,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 216,
              "start_column": 6784,
              "end_line": 0,
              "end_column": 7266,
              "start_byte": 6784,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytestPDB._init_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\"Initialize PDB debugging, dropping any IO capturing.\"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is None:\n            capman: Optional[CaptureManager] = None\n        else:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", f\"PDB {method} (IO-capturing turned off)\")\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", f\"PDB {method}\")\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
              "start_line": 236,
              "start_column": 7946,
              "end_line": 4,
              "end_column": 9411,
              "start_byte": 7946,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "def pytest_exception_interact(\n        self, node: Node, call: \"CallInfo[Any]\", report: BaseReport\n    ) -> None:\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        assert call.excinfo is not None\n        _enter_pdb(node, call.excinfo, report)",
              "start_line": 285,
              "start_column": 9711,
              "end_line": 4,
              "end_column": 10173,
              "start_byte": 9711,
              "end_byte": 4
            },
            {
              "name": "_pytest.debugging._enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "def _enter_pdb(\n    node: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport\n) -> BaseReport:\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True  # type: ignore[attr-defined]\n    post_mortem(tb)\n    return rep",
              "start_line": 335,
              "start_column": 11583,
              "end_line": 0,
              "end_column": 12554,
              "start_byte": 11583,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "config.add_cleanup(fin)\n\n\nclass pytestPDB:\n    \"\"\"Pseudo PDB that defers to the real pdb.\"\"\"\n\n    _pluginmanager: Optional[PytestPluginManager] = None\n    _config: Optional[Config] = None\n    _saved: List[\n    ",
              "start_line": 82,
              "start_column": 2739,
              "end_line": 0,
              "end_column": 2949,
              "start_byte": 2739,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_enter_pdb",
              "file_path": "src/_pytest/debugging.py",
              "file_content": "",
              "start_line": 872,
              "start_column": 30367,
              "end_line": 0,
              "end_column": 30688,
              "start_byte": 30367,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.unittest._make_xunit_fixture",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: Scope,\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope.value,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"_unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n\n    return fixture",
              "start_line": 121,
              "start_column": 3946,
              "end_line": 0,
              "end_column": 5629,
              "start_byte": 3946,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/unittest.py",
              "file_content": "def runtest(self) -> None:\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        assert self._testcase is not None\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # Let the unittest framework handle async functions.\n        if is_async_function(self.obj):\n            # Type ignored because self acts as the TestResult, but is not actually one.\n            self._testcase(result=self)  # type: ignore[arg-type]\n        else:\n            # When --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug.\n            # Arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed.\n            if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # We need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)  # type: ignore[arg-type]\n            finally:\n                delattr(self._testcase, self.name)",
              "start_line": 300,
              "start_column": 10108,
              "end_line": 4,
              "end_column": 11636,
              "start_byte": 10108,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 787,
              "start_column": 25291,
              "end_line": 4,
              "end_column": 25468,
              "start_byte": 25291,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "item is None:\n            assert not self.stack\n\n\ndef collect_one_node(collector: Collector) -> CollectReport:\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
              "start_line": 504,
              "start_column": 17597,
              "end_line": 0,
              "end_column": 18272,
              "start_byte": 17597,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "",
              "start_line": 720,
              "start_column": 26288,
              "end_line": 4,
              "end_column": 26595,
              "start_byte": 26288,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.runtestprotocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # After all teardown hooks have been called\n    # want funcargs and request info to go away.\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
              "start_line": 116,
              "start_column": 3503,
              "end_line": 0,
              "end_column": 4506,
              "start_byte": 3503,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(nextitem)\n    _update_current_test_var(item, None)",
              "start_line": 177,
              "start_column": 5576,
              "end_line": 0,
              "end_column": 5792,
              "start_byte": 5576,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.check_interactive_exception",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def check_interactive_exception(call: \"CallInfo[object]\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
              "start_line": 229,
              "start_column": 7269,
              "end_line": 0,
              "end_column": 7759,
              "start_byte": 7269,
              "end_byte": 0
            },
            {
              "name": "_pytest.threadexception.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "          \"(%s durations < %gs hidden.  Use -vv to show these durations.)\"\n                % (len(dlist) - i, durations_min)\n            )\n            break\n ",
              "start_line": 85,
              "start_column": 2756,
              "end_line": 0,
              "end_column": 2914,
              "start_byte": 2756,
              "end_byte": 0
            },
            {
              "name": "_pytest.unraisableexception.pytest_runtest_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "ion\") -> None:\n    session._setupstate = SetupState()\n\n\ndef pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\n\n\ndef p",
              "start_line": 90,
              "start_column": 3028,
              "end_line": 0,
              "end_column": 3190,
              "start_byte": 3028,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue where the `tearDown()` method of a `unittest.TestCase` is being executed even when the entire class is marked with `unittest.skip` and tests are run with `pytest --pdb`.\n1.2 This might be caused by a bug in pytest handling of skipped classes when the --pdb flag is involved.\n1.3 The expected result would be for `tearDown()` not to be executed if the class is skipped.\n1.4 If not explicitly mentioned, a reasonable expectation is that methods of a skipped class (including `tearDown`) should not execute regardless of other options like --pdb.\n1.5 The issue can be fixed by ensuring that if a class is marked as skipped, none of its methods including the `tearDown` are run.\n\n2. Make the evaluation:\n2.1 The function `_make_xunit_fixture` has a check for `_is_skipped`. It prevents the execution of setup in case of skip.\n2.2 The `TestCaseFunction.runtest` temporarily modifies `tearDown` if it's not marked as skipped.\n2.3 The `_is_skipped` utility helps in identifying skipped tests.\n2.4 All these symbols interact with the test running and skipping mechanism.\n\nDeciding which symbols would need changes:\n- `_pytest.unittest.TestCaseFunction.runtest` has a direct interaction with the `tearDown` method and skipping logic.\n- `_pytest.unittest._is_skipped` utility can be reviewed for any enhancement needed.",
          "symbols": [
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/unittest.py",
              "reason": "This function directly handles calling the tearDown method. Modifications are required to ensure that tearDown is not set to None in the first place if the class is marked with unittest.skip in the context of --pdb."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "This function handles the execution of `tearDown`. It checks for `usepdb` and `_is_skipped`. It modifies `tearDown` when the test isn't skipped and pdb is used. Needs adjustment to ensure skipped test classes don't execute `tearDown`.",
            "Handles both setup and teardown logic for xunit-style tests. Contains logic to skip the execution if `_is_skipped()` returns true, which is relevant to skipping behavior.",
            "No behavior given but could be related to capturing issues during the teardown process for pdb.",
            "Doesn't appear to offer direct changes or hooks related to skipping or pdb.",
            "Handles the logging during teardown which has no direct link to skipping logic or --pdb.",
            "Executes the teardown in the standard pytest lifecycle, handles logging and setup procedures.",
            "Actual function handling the teardown process for test items, interacts with the session's state to manage teardowns.",
            "Possibly checks for exceptions during execution which does relate to test failures rather than skipping directly.",
            "Content is related to threading and duration hiding rather than skipping tests in pdb context.",
            "Handles session teardown but logic seems more related to teardown at the session level, not test case skipping.",
            "Checks if an object is marked for skipping, critical point to ensure the correct behavior is achieved.",
            "Runs hooks and creates reports, less likely candidate but relates to how session runs hooks.",
            "Initialization and handling of PDB which isn't directly related to skipping logic but sets up debugging environment.",
            "Manages interaction hook when exceptions occur which could be important if pdb & skip interacts unexpectedly.",
            "Involved with entering pdb, debug and post-mortem context but not directly related with skip or teardown logic.",
            "Class related to PDB debugging, indirect influence on pdb activity, no skip logic noted.",
            "No content provided but could relate to pdb entering hooks which might impact overall pdb behavior."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/unittest.py"
        ],
        "symbols": [
          "_pytest.unittest.TestCaseFunction.runtest"
        ],
        "code_spans": {
          "_pytest.unittest._is_skipped": {
            "name": "_pytest.unittest._is_skipped",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _is_skipped(obj) -> bool:\n    \"\"\"Return True if the given object has been marked with @unittest.skip.\"\"\"\n    return bool(getattr(obj, \"__unittest_skip__\", False))",
            "start_line": 411,
            "start_column": 14289,
            "end_line": 0,
            "end_column": 14455,
            "start_byte": 14289,
            "end_byte": 0
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 216,
            "start_column": 6784,
            "end_line": 0,
            "end_column": 7266,
            "start_byte": 6784,
            "end_byte": 0
          },
          "_pytest.debugging.pytestPDB._init_pdb": {
            "name": "_pytest.debugging.pytestPDB._init_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "@classmethod\n    def _init_pdb(cls, method, *args, **kwargs):\n        \"\"\"Initialize PDB debugging, dropping any IO capturing.\"\"\"\n        import _pytest.config\n\n        if cls._pluginmanager is None:\n            capman: Optional[CaptureManager] = None\n        else:\n            capman = cls._pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend(in_=True)\n\n        if cls._config:\n            tw = _pytest.config.create_terminal_writer(cls._config)\n            tw.line()\n\n            if cls._recursive_debug == 0:\n                # Handle header similar to pdb.set_trace in py37+.\n                header = kwargs.pop(\"header\", None)\n                if header is not None:\n                    tw.sep(\">\", header)\n                else:\n                    capturing = cls._is_capturing(capman)\n                    if capturing == \"global\":\n                        tw.sep(\">\", f\"PDB {method} (IO-capturing turned off)\")\n                    elif capturing:\n                        tw.sep(\n                            \">\",\n                            \"PDB %s (IO-capturing turned off for %s)\"\n                            % (method, capturing),\n                        )\n                    else:\n                        tw.sep(\">\", f\"PDB {method}\")\n\n        _pdb = cls._import_pdb_cls(capman)(**kwargs)\n\n        if cls._pluginmanager:\n            cls._pluginmanager.hook.pytest_enter_pdb(config=cls._config, pdb=_pdb)\n        return _pdb",
            "start_line": 236,
            "start_column": 7946,
            "end_line": 4,
            "end_column": 9411,
            "start_byte": 7946,
            "end_byte": 4
          },
          "_pytest.debugging.PdbInvoke.pytest_exception_interact": {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def pytest_exception_interact(\n        self, node: Node, call: \"CallInfo[Any]\", report: BaseReport\n    ) -> None:\n        capman = node.config.pluginmanager.getplugin(\"capturemanager\")\n        if capman:\n            capman.suspend_global_capture(in_=True)\n            out, err = capman.read_global_capture()\n            sys.stdout.write(out)\n            sys.stdout.write(err)\n        assert call.excinfo is not None\n        _enter_pdb(node, call.excinfo, report)",
            "start_line": 285,
            "start_column": 9711,
            "end_line": 4,
            "end_column": 10173,
            "start_byte": 9711,
            "end_byte": 4
          },
          "_pytest.debugging._enter_pdb": {
            "name": "_pytest.debugging._enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "def _enter_pdb(\n    node: Node, excinfo: ExceptionInfo[BaseException], rep: BaseReport\n) -> BaseReport:\n    # XXX we re-use the TerminalReporter's terminalwriter\n    # because this seems to avoid some encoding related troubles\n    # for not completely clear reasons.\n    tw = node.config.pluginmanager.getplugin(\"terminalreporter\")._tw\n    tw.line()\n\n    showcapture = node.config.option.showcapture\n\n    for sectionname, content in (\n        (\"stdout\", rep.capstdout),\n        (\"stderr\", rep.capstderr),\n        (\"log\", rep.caplog),\n    ):\n        if showcapture in (sectionname, \"all\") and content:\n            tw.sep(\">\", \"captured \" + sectionname)\n            if content[-1:] == \"\\n\":\n                content = content[:-1]\n            tw.line(content)\n\n    tw.sep(\">\", \"traceback\")\n    rep.toterminal(tw)\n    tw.sep(\">\", \"entering PDB\")\n    tb = _postmortem_traceback(excinfo)\n    rep._pdbshown = True  # type: ignore[attr-defined]\n    post_mortem(tb)\n    return rep",
            "start_line": 335,
            "start_column": 11583,
            "end_line": 0,
            "end_column": 12554,
            "start_byte": 11583,
            "end_byte": 0
          },
          "_pytest.faulthandler.pytest_enter_pdb": {
            "name": "_pytest.faulthandler.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "config.add_cleanup(fin)\n\n\nclass pytestPDB:\n    \"\"\"Pseudo PDB that defers to the real pdb.\"\"\"\n\n    _pluginmanager: Optional[PytestPluginManager] = None\n    _config: Optional[Config] = None\n    _saved: List[\n    ",
            "start_line": 82,
            "start_column": 2739,
            "end_line": 0,
            "end_column": 2949,
            "start_byte": 2739,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_enter_pdb": {
            "name": "_pytest.hookspec.pytest_enter_pdb",
            "file_path": "src/_pytest/debugging.py",
            "file_content": "",
            "start_line": 872,
            "start_column": 30367,
            "end_line": 0,
            "end_column": 30688,
            "start_byte": 30367,
            "end_byte": 0
          },
          "_pytest.unittest._make_xunit_fixture": {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def _make_xunit_fixture(\n    obj: type,\n    setup_name: str,\n    teardown_name: str,\n    cleanup_name: Optional[str],\n    scope: Scope,\n    pass_self: bool,\n):\n    setup = getattr(obj, setup_name, None)\n    teardown = getattr(obj, teardown_name, None)\n    if setup is None and teardown is None:\n        return None\n\n    if cleanup_name:\n        cleanup = getattr(obj, cleanup_name, lambda *args: None)\n    else:\n\n        def cleanup(*args):\n            pass\n\n    @pytest.fixture(\n        scope=scope.value,\n        autouse=True,\n        # Use a unique name to speed up lookup.\n        name=f\"_unittest_{setup_name}_fixture_{obj.__qualname__}\",\n    )\n    def fixture(self, request: FixtureRequest) -> Generator[None, None, None]:\n        if _is_skipped(self):\n            reason = self.__unittest_skip_why__\n            raise pytest.skip.Exception(reason, _use_item_location=True)\n        if setup is not None:\n            try:\n                if pass_self:\n                    setup(self, request.function)\n                else:\n                    setup()\n            # unittest does not call the cleanup function for every BaseException, so we\n            # follow this here.\n            except Exception:\n                if pass_self:\n                    cleanup(self)\n                else:\n                    cleanup()\n\n                raise\n        yield\n        try:\n            if teardown is not None:\n                if pass_self:\n                    teardown(self, request.function)\n                else:\n                    teardown()\n        finally:\n            if pass_self:\n                cleanup(self)\n            else:\n                cleanup()\n\n    return fixture",
            "start_line": 121,
            "start_column": 3946,
            "end_line": 0,
            "end_column": 5629,
            "start_byte": 3946,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/unittest.py",
            "file_content": "def runtest(self) -> None:\n        from _pytest.debugging import maybe_wrap_pytest_function_for_tracing\n\n        assert self._testcase is not None\n\n        maybe_wrap_pytest_function_for_tracing(self)\n\n        # Let the unittest framework handle async functions.\n        if is_async_function(self.obj):\n            # Type ignored because self acts as the TestResult, but is not actually one.\n            self._testcase(result=self)  # type: ignore[arg-type]\n        else:\n            # When --pdb is given, we want to postpone calling tearDown() otherwise\n            # when entering the pdb prompt, tearDown() would have probably cleaned up\n            # instance variables, which makes it difficult to debug.\n            # Arguably we could always postpone tearDown(), but this changes the moment where the\n            # TestCase instance interacts with the results object, so better to only do it\n            # when absolutely needed.\n            if self.config.getoption(\"usepdb\") and not _is_skipped(self.obj):\n                self._explicit_tearDown = self._testcase.tearDown\n                setattr(self._testcase, \"tearDown\", lambda *args: None)\n\n            # We need to update the actual bound method with self.obj, because\n            # wrap_pytest_function_for_tracing replaces self.obj by a wrapper.\n            setattr(self._testcase, self.name, self.obj)\n            try:\n                self._testcase(result=self)  # type: ignore[arg-type]\n            finally:\n                delattr(self._testcase, self.name)",
            "start_line": 300,
            "start_column": 10108,
            "end_line": 4,
            "end_column": 11636,
            "start_byte": 10108,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.pytest_runtest_teardown": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 787,
            "start_column": 25291,
            "end_line": 4,
            "end_column": 25468,
            "start_byte": 25291,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_teardown": {
            "name": "_pytest.hookspec.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "item is None:\n            assert not self.stack\n\n\ndef collect_one_node(collector: Collector) -> CollectReport:\n    ihook = collector.ihook\n    ihook.pytest_collectstart(collector=collector)\n    rep: CollectReport = ihook.pytest_make_collect_report(collector=collector)\n    call = rep.__dict__.pop(\"call\", None)\n    if call and check_interactive_exception(call, rep):\n        ihook.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 504,
            "start_column": 17597,
            "end_line": 0,
            "end_column": 18272,
            "start_byte": 17597,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_teardown": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "",
            "start_line": 720,
            "start_column": 26288,
            "end_line": 4,
            "end_column": 26595,
            "start_byte": 26288,
            "end_byte": 4
          },
          "_pytest.runner.runtestprotocol": {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        # This only happens if the item is re-run, as is done by\n        # pytest-rerunfailures.\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # After all teardown hooks have been called\n    # want funcargs and request info to go away.\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 116,
            "start_column": 3503,
            "end_line": 0,
            "end_column": 4506,
            "start_byte": 3503,
            "end_byte": 0
          },
          "_pytest.runner.pytest_runtest_teardown": {
            "name": "_pytest.runner.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_teardown(item: Item, nextitem: Optional[Item]) -> None:\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(nextitem)\n    _update_current_test_var(item, None)",
            "start_line": 177,
            "start_column": 5576,
            "end_line": 0,
            "end_column": 5792,
            "start_byte": 5576,
            "end_byte": 0
          },
          "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo[object]\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 229,
            "start_column": 7269,
            "end_line": 0,
            "end_column": 7759,
            "start_byte": 7269,
            "end_byte": 0
          },
          "_pytest.threadexception.pytest_runtest_teardown": {
            "name": "_pytest.threadexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "          \"(%s durations < %gs hidden.  Use -vv to show these durations.)\"\n                % (len(dlist) - i, durations_min)\n            )\n            break\n ",
            "start_line": 85,
            "start_column": 2756,
            "end_line": 0,
            "end_column": 2914,
            "start_byte": 2756,
            "end_byte": 0
          },
          "_pytest.unraisableexception.pytest_runtest_teardown": {
            "name": "_pytest.unraisableexception.pytest_runtest_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ion\") -> None:\n    session._setupstate = SetupState()\n\n\ndef pytest_sessionfinish(session: \"Session\") -> None:\n    session._setupstate.teardown_exact(None)\n\n\ndef p",
            "start_line": 90,
            "start_column": 3028,
            "end_line": 0,
            "end_column": 3190,
            "start_byte": 3028,
            "end_byte": 0
          }
        }
      }
    }
  ]
}