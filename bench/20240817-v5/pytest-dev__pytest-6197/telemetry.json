{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-6197",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:38.903971",
        "usage": "1041.9201850891113 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "getfirstlinesource",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "writelines",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "rex_session_duration",
          "capture_fixtures",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "tmpdir_factory",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "_format_boolop",
          "PytestArg",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "exec_module",
          "category",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "_getscopeitem",
          "SysCapture",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "_setup_cli_logging",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Junit",
          "TestReport",
          "_find_spec",
          "_done",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "showheader",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "FuncargnamesCompatAttr",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "_compare_eq_verbose",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "finish_recording",
          "TerminalRepr",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_getcapture",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_perform_collect",
          "repr",
          "putaround",
          "_factorytraceback",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "_mount_obj_if_needed",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "resolve_from_str",
          "Entry",
          "report_collect",
          "cacheshow",
          "_show_fixture_action",
          "resume_fixture",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "exists",
          "write",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "defaultfuncargprefixmarker",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "node",
          "HookRecorder",
          "_getentrysource",
          "head_line",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "Class",
          "find",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingStreamHandler",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "find_spec",
          "_ensure_only_one_capture_fixture",
          "get_statement_startend2",
          "_for_parametrize",
          "get_actual_log_level",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "NodeMarkers",
          "from_config",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "truncate_locals",
          "record_property",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "KeywordMapping",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "_handle_skip",
          "__bool__",
          "_fail_on_non_top_pytest_plugins",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "strip",
          "compile_",
          "python_keywords_allowed_list",
          "pytest_runtestloop",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_setup_collect_fakemodule",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "args",
          "__module__",
          "_seen",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "_runtest_for_main",
          "pytest_sessionfinish",
          "fill_unfilled",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "errisinstance",
          "__exit__",
          "make_properties_node",
          "result",
          "config",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "linecomp",
          "scope2index",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "logging",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "safe_text_dupfile",
          "invocation_dir",
          "get_fslocation_from_item",
          "listoutcomes",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "matchmark",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "matchkeyword",
          "id",
          "OutcomeException",
          "getparam",
          "FIXTURE_ARGS_ORDER",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "try_mkdir",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "freeze_includes",
          "ApproxDecimal",
          "_readline_workaround",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "PyobjContext",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "_is_setup_py",
          "pop",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "add_property",
          "update",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "last_failed_paths",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "cache_key",
          "TEST_OUTCOME",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "activate_fixture",
          "alias",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_test_pytest_function",
          "_truncate_explanation",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_write_pyc",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "ParameterSet",
          "listnames",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "_setoption",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "own_markers",
          "setns",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "fnmatch_ex",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "_istrue",
          "popcall",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "warn_about_none_ast",
          "visit_Starred",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "FunctionMixin",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "__nonzero__",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "start",
          "LoggingPlugin",
          "_get_marks",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "is_generator",
          "get_common_ancestor",
          "PdbInvoke",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "MarkMapping",
          "errors",
          "MarkGenerator",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "_parse_fixture_args",
          "pytest_report_teststatus",
          "line",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "print_teardown_sections",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "maybe_delete_a_numbered_dir",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "getdecoded",
          "getstatementrange",
          "pyobj_property",
          "makepyfile",
          "SetupState",
          "_is_doctest",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "pytest_itemstart",
          "AssertionRewritingHook",
          "_install_capture_fixture_on_item",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "get_default_arg_names",
          "names_closure",
          "out",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "_eval_scope_callable",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "pytest_collection",
          "pytest_collectstart",
          "pytest_collect_file",
          "collect",
          "Collection",
          "collect_one_node",
          "pytest_collection_modifyitems",
          "pytest_ignore_collect",
          "pytest_make_collect_report",
          "Node"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:39.945904",
        "usage": "171.04077339172363 ms"
      },
      "request": {
        "tokens": [
          "pytest_collection",
          "pytest_collectstart",
          "pytest_collect_file",
          "collect",
          "Collection",
          "collect_one_node",
          "pytest_collection_modifyitems",
          "pytest_ignore_collect",
          "pytest_make_collect_report",
          "Node"
        ]
      },
      "response": {
        "results": {
          "collect": [
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/warnings.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/terminal.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "Node": [
            "src/_pytest/nodes.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "collect_one_node": [
            "src/_pytest/runner.py",
            "src/_pytest/main.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_collectstart": [
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/main.py"
          ],
          "pytest_make_collect_report": [
            "src/_pytest/hookspec.py",
            "src/_pytest/capture.py",
            "src/_pytest/runner.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:40.116955",
        "usage": "4253.6780834198 ms"
      },
      "request": {
        "keyword_search_results": {
          "collect": [
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/doctest.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/warnings.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/terminal.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "Node": [
            "src/_pytest/nodes.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "collect_one_node": [
            "src/_pytest/runner.py",
            "src/_pytest/main.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_collectstart": [
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/main.py"
          ],
          "pytest_make_collect_report": [
            "src/_pytest/hookspec.py",
            "src/_pytest/capture.py",
            "src/_pytest/runner.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue reported is related to pytest erroneously trying to collect `__init__.py` files, specifically a regression observed in the difference between versions 5.2.2 and 5.2.3. The key areas of concern are pytest's collection mechanism, especially changes between these versions that could have altered how files are collected.\n\nLet's examine the keywords and their respective files:\n\n1. **collect**:\n   - This is directly related to test collection, which is where the issue is happening.\n   - Files like `src/_pytest/nodes.py`, `src/_pytest/main.py`, and `src/_pytest/python.py` seem relevant due to their roles in node and test management, including collection.\n\n2. **pytest_collection**:\n   - Similarly, this keyword seems directly tied to the test collection process.\n   - However, the files under this keyword didn't add new insights as they overlapped with what we have.\n\n3. **pytest_collect_file**:\n   - This is likely related to how pytest determines which files to collect as test files.\n   - `src/_pytest/main.py` and `src/_pytest/python.py` again are relevant as these are central to the collection logic.\n\n4. **pytest_ignore_collect**:\n   - This directly suggests logic about ignoring files during collection, which might be wrongly bypassed in 5.2.3.\n   - Again, `src/_pytest/main.py` is relevant here.\n\nPrioritizing `src/_pytest/main.py` and `src/_pytest/python.py` makes sense since they seem to be involved in the mechanics of collection and potentially the regression involved. `src/_pytest/nodes.py` could also be involved in node management, which influences file collection decisions.",
        "file_paths": [
          "src/_pytest/main.py",
          "src/_pytest/python.py",
          "src/_pytest/nodes.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:44.370655",
        "usage": "5527.431964874268 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user reports a regression in pytest 5.2.3 where it tries to collect and import `__init__.py` files, causing issues when such a file contains code that can't be executed on the current platform (e.g., Windows-specific code running on Linux).\n1.2 This issue is likely caused by the change in pytest's test collection strategy.\n1.3 The expected result is that pytest should only collect test-related code, not random `__init__.py` files unless explicitly stated.\n1.4 Pytest should not attempt to import or collect from such `__init__.py` files unless configured to do so, thus avoiding failures from platform-specific code.\n1.5 The issue might be fixed by adding an option or extending the ignore logic to skip `__init__.py` files if not asked to be included explicitly.\n\n2. Make file evaluation:\n2.1 Begin evaluation of `src/_pytest/main.py` to understand the test collection logic.\n2.2 `pytest_ignore_collect` method is of interest as it dictates what gets ignored during collection. The method supports ignoring files based on config.\n2.3 The `_perform_collect` method is involved in the test collection process, including managing collected nodes.\n2.4 The `perform_collect` method calls `_collectfile` which may be involved in deciding which files to collect.\n2.5 `_collect` method indicates that `__init__.py` leads to creation of Packages which pytest seems to automatically collect.\n2.6 `isinitpath`, `_tryconvertpyarg`, and `_parsearg` are methods related to path interpretation and validation.\n2.7 `Session.collect` and `_collectfile` directly manage which files should be collected and may be directly related to the reported issue.\n2.8 There is no explicit check to exclude `__init__.py` in `_collectfile`, suggesting that logic to avoid non-test files here might be missing, thus relating to the described issue.\n\nConclusion:\nThe file seems to be a fundamental part of pytest's test collection and, given the missing logic for `__init__.py` exclusion, it seems to be a root cause for the inclusion of these files in test collections.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "pytest_collection",
          "Session._collectfile",
          "Session.collect"
        ],
        "root_cause_symbols": [
          "Session._collectfile",
          "Session.collect",
          "pytest_collection"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:49.898119",
        "usage": "5860.291004180908 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "1. **Analyzing User Instructions**\n   - **Issue Description**: The issue involves `pytest` package, specifically version 5.2.3, attempting to import all `__init__.py` files in a directory when running tests. This behavior did not occur in version 5.2.2.\n   - **Cause**: The `pytest_collect_file` function in `src/_pytest/python.py` seems to be incorrectly identifying `__init__.py` files as test modules due to path pattern matching.\n   - **Expected Result**: `pytest` should not try to collect or execute assertions in `__init__.py` files during its test discovery process.\n   - **Suggested Fix**: Modify the pattern matching system to exclude `__init__.py` from being collected or executed as test files unless explicitly configured to do so.\n\n2. **File Evaluation**\n  - **Relevant Sections**: \n    - The `pytest_collect_file` function is crucial as it contains logic for collecting test items based on file extensions and patterns, specifically concerning the inclusion of `__init__.py` through `path_matches_patterns` function.\n    - The `parser.addini` options for `python_files` provide the patterns that pytest uses to identify test files. Important as it implicitly includes `__init__.py` which appears to be the root issue.\n    - The `path_matches_patterns` function evaluates whether a file path matches test file patterns.\n\n  - **Potential Root Cause**: The inclusion of `__init__.py` in the `pytest_collect_file` function's pattern matching means `pytest` treats it like a potential test file.\n\n  - **References**: The parts of the code involved directly in test file pattern handling, and collection are located entirely within this file and neither depend on nor affect code outside `python.py`.\n\n3. **Output Decision**\n   3.1 The file `src/_pytest/python.py` is indeed the root cause of the issue due to the functionality of `pytest_collect_file` and related pattern handling,\n   3.2 Adjustments are necessary to ensure `__init__.py` files are not mistakenly processed as test files.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "pytest_collect_file",
          "path_matches_patterns"
        ],
        "root_cause_symbols": [
          "pytest_collect_file",
          "path_matches_patterns"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:55.758444",
        "usage": "7688.287973403931 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the user instructions:\n   1.1 The issue is that pytest version 5.2.3 tries to import any `__init__.py` file under the current directory, leading to an error if `__init__.py` contains non-importable code (e.g., code that asserts False).\n   1.2 This issue seems to be caused by a change in the collection mechanism of pytest between versions 5.2.2 and 5.2.3.\n   1.3 The expected result is that `__init__.py` files that are not meant to be collected or executed as tests would not be collected by pytest.\n   1.4 The expectation should be that pytest should avoid collecting arbitrary `__init__.py` files unless they are specifically test files with testable content.\n   1.5 The issue could be fixed by changing the file collection mechanism to exclude or properly handle `__init__.py` files.\n\n2. Evaluating the file `src/_pytest/nodes.py`:\n   - The file `src/_pytest/nodes.py` defines the core structures related to nodes in the pytest collection tree, including classes `Node`, `Collector`, and `FSCollector` among others.\n   - The `FSCollector` class is relevant as it directly deals with collecting file system paths (`fspath`) as nodes in the test collection process.\n   - The `File` class is a subclass of `FSCollector` and is also relevant as it is used for collecting tests from a file, which might be related to the collection of `__init__.py`.\n   - `_check_initialpaths_for_relpath()` is a helper function used for resolving relative paths during the collection process. While it aids in collection, it doesn\u2019t directly influence which files to collect.\n\n3. Conclusion:\n   - This file implements `FSCollector`, which is directly related to the issue because it deals with file collection, hinting at how the new mechanism might include `__init__.py`.\n   - The issue is therefore likely to be rooted within these collection classes, especially `FSCollector` and `Collector`, which manage file system-based collections.\n\n",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/python.py",
          "src/_pytest/mark.py"
        ],
        "relevant_symbols": [
          "Node",
          "Collector",
          "FSCollector",
          "File"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:03.446779",
        "usage": "150.05922317504883 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "pytest_collection",
              "Session._collectfile",
              "Session.collect"
            ],
            "root_cause_symbol_keys": [
              "Session._collectfile",
              "Session.collect",
              "pytest_collection"
            ]
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "pytest_collect_file",
              "path_matches_patterns"
            ],
            "root_cause_symbol_keys": [
              "pytest_collect_file",
              "path_matches_patterns"
            ]
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node",
              "Collector",
              "FSCollector",
              "File"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "s, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glo",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\"%d errors during collection\" % session.testsfailed)\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates for fname in bindir.listdir()])\n\n\ndef pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "elected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\nclass FSHookProxy:\n    def __init__(self, fspath, pm, remove_mods):\n        self.fspath = fspath\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass NoMatch(Exception):\n    \"\"\" raised if matching cannot locate a matching names. \"\"\"\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\" signals an interrupted test run. \"\"\"\n\n    __module__ = \"builtins\"  # for py3\n\n\nclass Failed(Exception):\n    \"\"\" signals a stop as failed test run. \"\"\"\n\n\n@attr.s\nclass _bestrel",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "    initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            ",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "se\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "                 exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.ty",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": ".py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._c",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection(session):\n    return session.perform_collect()",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection_modifyitems(items, config):\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for initialpart in self._initialparts:\n            arg = \"::\".join(map(str, initialpart))\n            self.trace(\"processing argument\", arg)\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(arg)\n            except NoMatch:\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((arg, sys.exc_info()[1]))\n\n            self.trace.root.indent -= 1",
            "start_line": 480,
            "start_column": 15068,
            "end_line": 4,
            "end_column": 15589,
            "start_byte": 15068,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debug",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        typ",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "st in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            asse",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "d_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n ",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:03.596844",
        "usage": "11598.839044570923 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "s, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glo",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\"%d errors during collection\" % session.testsfailed)\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates for fname in bindir.listdir()])\n\n\ndef pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "elected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\nclass FSHookProxy:\n    def __init__(self, fspath, pm, remove_mods):\n        self.fspath = fspath\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass NoMatch(Exception):\n    \"\"\" raised if matching cannot locate a matching names. \"\"\"\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\" signals an interrupted test run. \"\"\"\n\n    __module__ = \"builtins\"  # for py3\n\n\nclass Failed(Exception):\n    \"\"\" signals a stop as failed test run. \"\"\"\n\n\n@attr.s\nclass _bestrel",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "    initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            ",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "se\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "                 exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.ty",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": ".py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._c",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection(session):\n    return session.perform_collect()",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection_modifyitems(items, config):\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for initialpart in self._initialparts:\n            arg = \"::\".join(map(str, initialpart))\n            self.trace(\"processing argument\", arg)\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(arg)\n            except NoMatch:\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((arg, sys.exc_info()[1]))\n\n            self.trace.root.indent -= 1",
            "start_line": 480,
            "start_column": 15068,
            "end_line": 4,
            "end_column": 15589,
            "start_byte": 15068,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debug",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        typ",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "st in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            asse",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "d_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n ",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is that with pytest version 5.2.3, the tool attempts to import any `__init__.py` files in the current directory, causing errors if these files are not meant to be imported on the current operating system, like Linux.\n1.2 The issue was caused by a change or regression introduced in pytest 5.2.3, which results in it trying to collect `__init__.py` files.\n1.3 The expected result is that pytest should not attempt to collect `__init__.py` files as test modules unless specifically configured to do so.\n1.4 If no expected result was provided, the expectation should be that pytest behaves like version 5.2.2 and only collects files configured as test files.\n1.5 To fix this, pytest's collection logic should be adjusted so that it excludes `__init__.py` files unless explicitly included by user configuration.\n\n2. Evaluate the symbols provided:\n2.1 The symbol '_pytest.assertion.pytest_collection' in `src/_pytest/main.py` appears to deal with the collection options related to ignoring paths but not specifically '__init__.py' files.\n2.2 The symbol '_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems' suggests dealing with session and item modification but may not directly affect file collection.\n2.3 The symbol '_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems' deals with item collection modification, potentially impacting which items are collected during pytest runs.\n2.4 The symbol '_pytest.fixtures.FixtureManager.pytest_collection_modifyitems' was not available for review.\n2.5 The symbol '_pytest.hookspec.pytest_collection' mentions `pytest_collection` in the main.py, indicating its role in starting the collection process.\n2.6 '_pytest.hookspec.pytest_collection_finish' possibly ends the collection process but lacks relevant content provided.\n2.7 The symbols related to `encoded file`, `Node`, `NodeKeywords`, their methods, etc., in `_pytest/nodes.py, `_pytest/python.py`, or others, such as Node, NodeKeywords, Collector, FSCollector, might affect nodes but not directly '__init__.py' collection.\n\nTest strategies might involve ensuring pytest excludes '__init__.py' through its file patterns or configuration unless specified otherwise.\nUltimately, the adjustment to the `pytest_collect_file` method might be needed to ensure '__init__.py' files are filtered out appropriately.",
        "symbols": [
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "reason": "This function handles which files are considered test modules during collection. Modifying its logic to exclude `__init__.py` unless specified otherwise may resolve the issue."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "This symbol seems to deal with pytest collection options but doesn't provide enough insight to see if it's responsible for collecting '__init__.py' files.",
          "This symbol deals with pytest collection in terms of sessions and items, rather than files, so it seems less relevant to the '__init__.py' collection issue.",
          "This selection is relevant because it includes collection logic for file exclusion, which could influence which files are collected as tests.",
          "The symbol description was empty, unable to evaluate relevance.",
          "This symbol represents a central point in collection, might need adjusting to handle '__init__.py' exclusion.",
          "Description is not enough to determine relevance to '__init__.py' collection issue.",
          "This is not directly visible in the content provided, so its role is unclear without further details.",
          "Logs which metadata might be influencing collection decisions.",
          "Indicates the beginning of a collection session, possible check-point for when exclusions need to occur.",
          "Potentially looks like more directly links to pytest collection logic important for '__init__.py' issue.",
          "Description is not sufficient to determine influence on collection or '__init__.py' loading.",
          "This textual content doesn't aid in evaluating its connection to '__init__.py' collection."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:15.195763",
        "usage": "6.067991256713867 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest._argcomplete.FastFilesCompleter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
              "start_line": 61,
              "start_column": 2341,
              "end_line": 0,
              "end_column": 3274,
              "start_byte": 2341,
              "end_byte": 0
            },
            {
              "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
              "start_line": 64,
              "start_column": 2404,
              "end_line": 4,
              "end_column": 2480,
              "start_byte": 2404,
              "end_byte": 4
            },
            {
              "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
              "start_line": 67,
              "start_column": 2486,
              "end_line": 4,
              "end_column": 3274,
              "start_byte": 2486,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprFileLocation",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 997,
              "start_column": 33380,
              "end_line": 0,
              "end_column": 33901,
              "start_byte": 33380,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprFileLocation.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 998,
              "start_column": 33422,
              "end_line": 4,
              "end_column": 33554,
              "start_byte": 33422,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprFileLocation.toterminal",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 1003,
              "start_column": 33560,
              "end_line": 4,
              "end_column": 33901,
              "start_byte": 33560,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 412,
              "start_column": 14331,
              "end_line": 0,
              "end_column": 15203,
              "start_byte": 14331,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.EncodedFile.errors",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " None, \"\"\n\n    @p",
              "start_line": 413,
              "start_column": 14354,
              "end_line": 4,
              "end_column": 14371,
              "start_byte": 14354,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
              "start_line": 415,
              "start_column": 14419,
              "end_line": 4,
              "end_column": 14518,
              "start_byte": 14419,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.write",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 419,
              "start_column": 14524,
              "end_line": 4,
              "end_column": 14803,
              "start_byte": 14524,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.writelines",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 428,
              "start_column": 14809,
              "end_line": 4,
              "end_column": 14898,
              "start_byte": 14809,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.name",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 432,
              "start_column": 14904,
              "end_line": 4,
              "end_column": 15015,
              "start_byte": 14904,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.mode",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 437,
              "start_column": 15021,
              "end_line": 4,
              "end_column": 15099,
              "start_byte": 15021,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.__getattr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 441,
              "start_column": 15105,
              "end_line": 4,
              "end_column": 15203,
              "start_byte": 15105,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
              "start_line": 83,
              "start_column": 2200,
              "end_line": 0,
              "end_column": 9131,
              "start_byte": 2200,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml._NodeReporter.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
              "start_line": 84,
              "start_column": 2225,
              "end_line": 4,
              "end_column": 2519,
              "start_byte": 2225,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
              "start_line": 95,
              "start_column": 2525,
              "end_line": 4,
              "end_column": 2628,
              "start_byte": 2525,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.add_property",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
              "start_line": 99,
              "start_column": 2634,
              "end_line": 4,
              "end_column": 2737,
              "start_byte": 2634,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.add_attribute",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
              "start_line": 102,
              "start_column": 2743,
              "end_line": 4,
              "end_column": 2834,
              "start_byte": 2743,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.make_properties_node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
              "start_line": 105,
              "start_column": 2840,
              "end_line": 4,
              "end_column": 3199,
              "start_byte": 2840,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.record_testreport",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
              "start_line": 117,
              "start_column": 3205,
              "end_line": 4,
              "end_column": 4372,
              "start_byte": 3205,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.to_xml",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
              "start_line": 148,
              "start_column": 4378,
              "end_line": 4,
              "end_column": 4615,
              "start_byte": 4378,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter._add_simple",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
              "start_line": 155,
              "start_column": 4621,
              "end_line": 4,
              "end_column": 4774,
              "start_byte": 4621,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.write_captured_output",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
              "start_line": 160,
              "start_column": 4780,
              "end_line": 4,
              "end_column": 6736,
              "start_byte": 4780,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_pass",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
              "start_line": 213,
              "start_column": 6742,
              "end_line": 4,
              "end_column": 6805,
              "start_byte": 6742,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
              "start_line": 216,
              "start_column": 6811,
              "end_line": 4,
              "end_column": 7499,
              "start_byte": 6811,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_collect_error",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
              "start_line": 232,
              "start_column": 7505,
              "end_line": 4,
              "end_column": 7723,
              "start_byte": 7505,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
              "start_line": 238,
              "start_column": 7729,
              "end_line": 4,
              "end_column": 7849,
              "start_byte": 7729,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_error",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
              "start_line": 241,
              "start_column": 7855,
              "end_line": 4,
              "end_column": 8079,
              "start_byte": 7855,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_skipped",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
              "start_line": 248,
              "start_column": 8085,
              "end_line": 4,
              "end_column": 8982,
              "start_byte": 8085,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.finalize",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
              "start_line": 273,
              "start_column": 8988,
              "end_line": 4,
              "end_column": 9131,
              "start_byte": 8988,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
              "start_line": 333,
              "start_column": 11604,
              "end_line": 0,
              "end_column": 12534,
              "start_byte": 11604,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeKeywords.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
              "start_line": 334,
              "start_column": 11644,
              "end_line": 4,
              "end_column": 11770,
              "start_byte": 11644,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__getitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
              "start_line": 339,
              "start_column": 11776,
              "end_line": 4,
              "end_column": 11982,
              "start_byte": 11776,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__setitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
              "start_line": 347,
              "start_column": 11988,
              "end_line": 4,
              "end_column": 12057,
              "start_byte": 11988,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__delitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
              "start_line": 350,
              "start_column": 12063,
              "end_line": 4,
              "end_column": 12153,
              "start_byte": 12063,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__iter__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
              "start_line": 353,
              "start_column": 12159,
              "end_line": 4,
              "end_column": 12232,
              "start_byte": 12159,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords._seen",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
              "start_line": 357,
              "start_column": 12238,
              "end_line": 4,
              "end_column": 12390,
              "start_byte": 12238,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__len__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "        name = rel\n            name = name.replace(",
              "start_line": 363,
              "start_column": 12396,
              "end_line": 4,
              "end_column": 12447,
              "start_byte": 12396,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__repr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
              "start_line": 366,
              "start_column": 12453,
              "end_line": 4,
              "end_column": 12534,
              "start_byte": 12453,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
              "start_line": 371,
              "start_column": 12598,
              "end_line": 0,
              "end_column": 13270,
              "start_byte": 12598,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeMarkers.own_markers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
              "start_line": 382,
              "start_column": 12802,
              "end_line": 4,
              "end_column": 12851,
              "start_byte": 12802,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.update",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
              "start_line": 384,
              "start_column": 12857,
              "end_line": 4,
              "end_column": 12978,
              "start_byte": 12857,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.find",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
              "start_line": 389,
              "start_column": 12984,
              "end_line": 4,
              "end_column": 13207,
              "start_byte": 12984,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.__iter__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "one, session=None, nodeid=None):\n        super().__init__",
              "start_line": 398,
              "start_column": 13213,
              "end_line": 4,
              "end_column": 13270,
              "start_byte": 13213,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
              "start_line": 66,
              "start_column": 1943,
              "end_line": 0,
              "end_column": 9973,
              "start_byte": 1943,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Node.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
              "start_line": 70,
              "start_column": 2097,
              "end_line": 4,
              "end_column": 3399,
              "start_byte": 2097,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.ihook",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
              "start_line": 108,
              "start_column": 3405,
              "end_line": 4,
              "end_column": 3558,
              "start_byte": 3405,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.__repr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
              "start_line": 113,
              "start_column": 3564,
              "end_line": 4,
              "end_column": 3669,
              "start_byte": 3564,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.warn",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
              "start_line": 116,
              "start_column": 3675,
              "end_line": 4,
              "end_column": 4757,
              "start_byte": 3675,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.nodeid",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
              "start_line": 150,
              "start_column": 4796,
              "end_line": 4,
              "end_column": 4931,
              "start_byte": 4796,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.__hash__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
              "start_line": 155,
              "start_column": 4937,
              "end_line": 4,
              "end_column": 4989,
              "start_byte": 4937,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.setup",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def setup(self):\n        pass",
              "start_line": 158,
              "start_column": 4995,
              "end_line": 4,
              "end_column": 5024,
              "start_byte": 4995,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.teardown",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def teardown(self):\n        pass",
              "start_line": 161,
              "start_column": 5030,
              "end_line": 4,
              "end_column": 5062,
              "start_byte": 5030,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listchain",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
              "start_line": 164,
              "start_column": 5068,
              "end_line": 4,
              "end_column": 5382,
              "start_byte": 5068,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
              "start_line": 175,
              "start_column": 5388,
              "end_line": 4,
              "end_column": 6218,
              "start_byte": 5388,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
              "start_line": 199,
              "start_column": 6224,
              "end_line": 4,
              "end_column": 6470,
              "start_byte": 6224,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers_with_node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
              "start_line": 207,
              "start_column": 6476,
              "end_line": 4,
              "end_column": 6909,
              "start_byte": 6476,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.get_closest_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
              "start_line": 219,
              "start_column": 6915,
              "end_line": 4,
              "end_column": 7287,
              "start_byte": 6915,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listextrakeywords",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
              "start_line": 228,
              "start_column": 7293,
              "end_line": 4,
              "end_column": 7575,
              "start_byte": 7293,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listnames",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
              "start_line": 235,
              "start_column": 7581,
              "end_line": 4,
              "end_column": 7651,
              "start_byte": 7581,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.addfinalizer",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
              "start_line": 238,
              "start_column": 7657,
              "end_line": 4,
              "end_column": 7952,
              "start_byte": 7657,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.getparent",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
              "start_line": 246,
              "start_column": 7958,
              "end_line": 4,
              "end_column": 8230,
              "start_byte": 7958,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node._prunetraceback",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _prunetraceback(self, excinfo):\n        pass",
              "start_line": 254,
              "start_column": 8236,
              "end_line": 4,
              "end_column": 8284,
              "start_byte": 8236,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node._repr_failure_py",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
              "start_line": 257,
              "start_column": 8290,
              "end_line": 4,
              "end_column": 9870,
              "start_byte": 8290,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
              "start_line": 301,
              "start_column": 9876,
              "end_line": 4,
              "end_column": 9973,
              "start_byte": 9876,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
              "start_line": 323,
              "start_column": 10562,
              "end_line": 0,
              "end_column": 11863,
              "start_byte": 10562,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Collector.CollectError",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
              "start_line": 328,
              "start_column": 10703,
              "end_line": 4,
              "end_column": 10804,
              "start_byte": 10703,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector.collect",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
              "start_line": 331,
              "start_column": 10810,
              "end_line": 4,
              "end_column": 10986,
              "start_byte": 10810,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
              "start_line": 337,
              "start_column": 10992,
              "end_line": 4,
              "end_column": 11522,
              "start_byte": 10992,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector._prunetraceback",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
              "start_line": 351,
              "start_column": 11528,
              "end_line": 4,
              "end_column": 11863,
              "start_byte": 11528,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.FSCollector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
              "start_line": 366,
              "start_column": 12071,
              "end_line": 0,
              "end_column": 12907,
              "start_byte": 12071,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.FSCollector.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
              "start_line": 367,
              "start_column": 12105,
              "end_line": 4,
              "end_column": 12907,
              "start_byte": 12105,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.File",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
              "start_line": 390,
              "start_column": 12910,
              "end_line": 0,
              "end_column": 12991,
              "start_byte": 12910,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.PyCollector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 310,
              "start_column": 10773,
              "end_line": 0,
              "end_column": 15533,
              "start_byte": 10773,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.PyCollector.funcnamefilter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
              "start_line": 311,
              "start_column": 10825,
              "end_line": 4,
              "end_column": 10933,
              "start_byte": 10825,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.isnosetest",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
              "start_line": 314,
              "start_column": 10939,
              "end_line": 4,
              "end_column": 11332,
              "start_byte": 10939,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.classnamefilter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
              "start_line": 323,
              "start_column": 11338,
              "end_line": 4,
              "end_column": 11445,
              "start_byte": 11338,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.istestfunction",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
              "start_line": 326,
              "start_column": 11451,
              "end_line": 4,
              "end_column": 11894,
              "start_byte": 11451,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.istestclass",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
              "start_line": 338,
              "start_column": 11900,
              "end_line": 4,
              "end_column": 11999,
              "start_byte": 11900,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
              "start_line": 341,
              "start_column": 12005,
              "end_line": 4,
              "end_column": 12711,
              "start_byte": 12005,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.collect",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
              "start_line": 358,
              "start_column": 12717,
              "end_line": 4,
              "end_column": 13616,
              "start_byte": 12717,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._makeitem",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
              "start_line": 383,
              "start_column": 13622,
              "end_line": 4,
              "end_column": 13797,
              "start_byte": 13622,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._genfunctions",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 387,
              "start_column": 13803,
              "end_line": 4,
              "end_column": 15533,
              "start_byte": 13803,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": "s, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glo",
              "start_line": 93,
              "start_column": 3023,
              "end_line": 0,
              "end_column": 3399,
              "start_byte": 3023,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\"%d errors during collection\" % session.testsfailed)\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates for fname in bindir.listdir()])\n\n\ndef pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(",
              "start_line": 200,
              "start_column": 7163,
              "end_line": 4,
              "end_column": 9267,
              "start_byte": 7163,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "elected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\nclass FSHookProxy:\n    def __init__(self, fspath, pm, remove_mods):\n        self.fspath = fspath\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass NoMatch(Exception):\n    \"\"\" raised if matching cannot locate a matching names. \"\"\"\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\" signals an interrupted test run. \"\"\"\n\n    __module__ = \"builtins\"  # for py3\n\n\nclass Failed(Exception):\n    \"\"\" signals a stop as failed test run. \"\"\"\n\n\n@attr.s\nclass _bestrel",
              "start_line": 265,
              "start_column": 9886,
              "end_line": 4,
              "end_column": 10614,
              "start_byte": 9886,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1386,
              "start_column": 52212,
              "end_line": 4,
              "end_column": 52338,
              "start_byte": 52212,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": "    initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            ",
              "start_line": 154,
              "start_column": 5249,
              "end_line": 0,
              "end_column": 5507,
              "start_byte": 5249,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "se\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n",
              "start_line": 164,
              "start_column": 5510,
              "end_line": 0,
              "end_column": 5869,
              "start_byte": 5510,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collection_finish",
              "file_path": "src/_pytest/main.py",
              "file_content": "                 exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.ty",
              "start_line": 174,
              "start_column": 5872,
              "end_line": 0,
              "end_column": 6051,
              "start_byte": 5872,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": ".py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._c",
              "start_line": 512,
              "start_column": 17425,
              "end_line": 4,
              "end_column": 17846,
              "start_byte": 17425,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_collection(session):\n    return session.perform_collect()",
              "start_line": 244,
              "start_column": 7329,
              "end_line": 0,
              "end_column": 7397,
              "start_byte": 7329,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_collection_modifyitems(items, config):\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
              "start_line": 310,
              "start_column": 9500,
              "end_line": 0,
              "end_column": 9979,
              "start_byte": 9500,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def collect(self):\n        for initialpart in self._initialparts:\n            arg = \"::\".join(map(str, initialpart))\n            self.trace(\"processing argument\", arg)\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(arg)\n            except NoMatch:\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((arg, sys.exc_info()[1]))\n\n            self.trace.root.indent -= 1",
              "start_line": 480,
              "start_column": 15068,
              "end_line": 4,
              "end_column": 15589,
              "start_byte": 15068,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
              "start_line": 576,
              "start_column": 19301,
              "end_line": 4,
              "end_column": 20135,
              "start_byte": 19301,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": " default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debug",
              "start_line": 142,
              "start_column": 4581,
              "end_line": 0,
              "end_column": 4705,
              "start_byte": 4581,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        typ",
              "start_line": 39,
              "start_column": 1034,
              "end_line": 4,
              "end_column": 2112,
              "start_byte": 1034,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": "st in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            asse",
              "start_line": 487,
              "start_column": 16672,
              "end_line": 4,
              "end_column": 16990,
              "start_byte": 16672,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
              "file_path": "src/_pytest/main.py",
              "file_content": "(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _p",
              "start_line": 594,
              "start_column": 20705,
              "end_line": 4,
              "end_column": 21335,
              "start_byte": 20705,
              "end_byte": 4
            },
            {
              "name": "_pytest.warnings.pytest_collection",
              "file_path": "src/_pytest/main.py",
              "file_content": "d_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n ",
              "start_line": 116,
              "start_column": 3619,
              "end_line": 0,
              "end_column": 3851,
              "start_byte": 3619,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
              "start_line": 86,
              "start_column": 2432,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2432,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
              "start_line": 204,
              "start_column": 6768,
              "end_line": 0,
              "end_column": 7010,
              "start_byte": 6768,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
              "start_line": 175,
              "start_column": 6070,
              "end_line": 0,
              "end_column": 6478,
              "start_byte": 6070,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.path_matches_patterns",
              "file_path": "src/_pytest/python.py",
              "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
              "start_line": 187,
              "start_column": 6481,
              "end_line": 0,
              "end_column": 6690,
              "start_byte": 6481,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is that with pytest version 5.2.3, the tool attempts to import any `__init__.py` files in the current directory, causing errors if these files are not meant to be imported on the current operating system, like Linux.\n1.2 The issue was caused by a change or regression introduced in pytest 5.2.3, which results in it trying to collect `__init__.py` files.\n1.3 The expected result is that pytest should not attempt to collect `__init__.py` files as test modules unless specifically configured to do so.\n1.4 If no expected result was provided, the expectation should be that pytest behaves like version 5.2.2 and only collects files configured as test files.\n1.5 To fix this, pytest's collection logic should be adjusted so that it excludes `__init__.py` files unless explicitly included by user configuration.\n\n2. Evaluate the symbols provided:\n2.1 The symbol '_pytest.assertion.pytest_collection' in `src/_pytest/main.py` appears to deal with the collection options related to ignoring paths but not specifically '__init__.py' files.\n2.2 The symbol '_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems' suggests dealing with session and item modification but may not directly affect file collection.\n2.3 The symbol '_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems' deals with item collection modification, potentially impacting which items are collected during pytest runs.\n2.4 The symbol '_pytest.fixtures.FixtureManager.pytest_collection_modifyitems' was not available for review.\n2.5 The symbol '_pytest.hookspec.pytest_collection' mentions `pytest_collection` in the main.py, indicating its role in starting the collection process.\n2.6 '_pytest.hookspec.pytest_collection_finish' possibly ends the collection process but lacks relevant content provided.\n2.7 The symbols related to `encoded file`, `Node`, `NodeKeywords`, their methods, etc., in `_pytest/nodes.py, `_pytest/python.py`, or others, such as Node, NodeKeywords, Collector, FSCollector, might affect nodes but not directly '__init__.py' collection.\n\nTest strategies might involve ensuring pytest excludes '__init__.py' through its file patterns or configuration unless specified otherwise.\nUltimately, the adjustment to the `pytest_collect_file` method might be needed to ensure '__init__.py' files are filtered out appropriately.",
          "symbols": [
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "reason": "This function handles which files are considered test modules during collection. Modifying its logic to exclude `__init__.py` unless specified otherwise may resolve the issue."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "This symbol seems to deal with pytest collection options but doesn't provide enough insight to see if it's responsible for collecting '__init__.py' files.",
            "This symbol deals with pytest collection in terms of sessions and items, rather than files, so it seems less relevant to the '__init__.py' collection issue.",
            "This selection is relevant because it includes collection logic for file exclusion, which could influence which files are collected as tests.",
            "The symbol description was empty, unable to evaluate relevance.",
            "This symbol represents a central point in collection, might need adjusting to handle '__init__.py' exclusion.",
            "Description is not enough to determine relevance to '__init__.py' collection issue.",
            "This is not directly visible in the content provided, so its role is unclear without further details.",
            "Logs which metadata might be influencing collection decisions.",
            "Indicates the beginning of a collection session, possible check-point for when exclusions need to occur.",
            "Potentially looks like more directly links to pytest collection logic important for '__init__.py' issue.",
            "Description is not sufficient to determine influence on collection or '__init__.py' loading.",
            "This textual content doesn't aid in evaluating its connection to '__init__.py' collection."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/python.py"
        ],
        "symbols": [
          "_pytest.python.pytest_collect_file"
        ],
        "code_spans": {
          "_pytest._argcomplete.FastFilesCompleter": {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          "_pytest._argcomplete.FastFilesCompleter.__init__": {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          "_pytest._argcomplete.FastFilesCompleter.__call__": {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          "_pytest._code.ReprFileLocation": {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          "_pytest._code.ReprFileLocation.__init__": {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          "_pytest._code.ReprFileLocation.toterminal": {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile": {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          "_pytest.capture.EncodedFile.errors": {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.__init__": {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.write": {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.writelines": {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.name": {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.mode": {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.__getattr__": {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter": {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          "_pytest.junitxml._NodeReporter.__init__": {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append": {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.add_property": {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.add_attribute": {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.make_properties_node": {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.record_testreport": {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.to_xml": {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter._add_simple": {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.write_captured_output": {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_pass": {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_failure": {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_collect_error": {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_collect_skipped": {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_error": {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_skipped": {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.finalize": {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords": {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          "_pytest.mark.NodeKeywords.__init__": {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__getitem__": {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__setitem__": {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__delitem__": {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__iter__": {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords._seen": {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__len__": {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__repr__": {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers": {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          "_pytest.mark.NodeMarkers.own_markers": {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.update": {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.find": {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.__iter__": {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          "_pytest.nodes.Node": {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          "_pytest.nodes.Node.__init__": {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          "_pytest.nodes.Node.ihook": {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          "_pytest.nodes.Node.__repr__": {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          "_pytest.nodes.Node.warn": {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          "_pytest.nodes.Node.nodeid": {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          "_pytest.nodes.Node.__hash__": {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          "_pytest.nodes.Node.setup": {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          "_pytest.nodes.Node.teardown": {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listchain": {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers": {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers_with_node": {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          "_pytest.nodes.Node.get_closest_marker": {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listextrakeywords": {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listnames": {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          "_pytest.nodes.Node.addfinalizer": {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          "_pytest.nodes.Node.getparent": {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          "_pytest.nodes.Node._prunetraceback": {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          "_pytest.nodes.Node._repr_failure_py": {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          "_pytest.nodes.Node.repr_failure": {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          "_pytest.nodes.Collector": {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          "_pytest.nodes.Collector.CollectError": {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          "_pytest.nodes.Collector.collect": {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          "_pytest.nodes.Collector.repr_failure": {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          "_pytest.nodes.Collector._prunetraceback": {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          "_pytest.nodes.FSCollector": {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          "_pytest.nodes.FSCollector.__init__": {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          "_pytest.nodes.File": {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          "_pytest.python.PyCollector": {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          "_pytest.python.PyCollector.funcnamefilter": {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.isnosetest": {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.classnamefilter": {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.istestfunction": {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.istestclass": {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._matches_prefix_or_glob_option": {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.collect": {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._makeitem": {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._genfunctions": {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_collection": {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "s, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glo",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\"%d errors during collection\" % session.testsfailed)\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates for fname in bindir.listdir()])\n\n\ndef pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "elected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining\n\n\nclass FSHookProxy:\n    def __init__(self, fspath, pm, remove_mods):\n        self.fspath = fspath\n        self.pm = pm\n        self.remove_mods = remove_mods\n\n    def __getattr__(self, name):\n        x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)\n        self.__dict__[name] = x\n        return x\n\n\nclass NoMatch(Exception):\n    \"\"\" raised if matching cannot locate a matching names. \"\"\"\n\n\nclass Interrupted(KeyboardInterrupt):\n    \"\"\" signals an interrupted test run. \"\"\"\n\n    __module__ = \"builtins\"  # for py3\n\n\nclass Failed(Exception):\n    \"\"\" signals a stop as failed test run. \"\"\"\n\n\n@attr.s\nclass _bestrel",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_collection": {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "    initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            ",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collection_modifyitems": {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "se\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collection_finish": {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "                 exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.ty",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_collection": {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": ".py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._c",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          "_pytest.main.pytest_collection": {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection(session):\n    return session.perform_collect()",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_collection_modifyitems(items, config):\n    deselect_prefixes = tuple(config.getoption(\"deselect\") or [])\n    if not deselect_prefixes:\n        return\n\n    remaining = []\n    deselected = []\n    for colitem in items:\n        if colitem.nodeid.startswith(deselect_prefixes):\n            deselected.append(colitem)\n        else:\n            remaining.append(colitem)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for initialpart in self._initialparts:\n            arg = \"::\".join(map(str, initialpart))\n            self.trace(\"processing argument\", arg)\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(arg)\n            except NoMatch:\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((arg, sys.exc_info()[1]))\n\n            self.trace.root.indent -= 1",
            "start_line": 480,
            "start_column": 15068,
            "end_line": 4,
            "end_column": 15589,
            "start_byte": 15068,
            "end_byte": 4
          },
          "_pytest.main.Session._collectfile": {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          },
          "_pytest.mark.pytest_collection_modifyitems": {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debug",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems": {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        typ",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "st in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            asse",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/main.py",
            "file_content": "(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          "_pytest.warnings.pytest_collection": {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/main.py",
            "file_content": "d_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n ",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_collect_file": {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_file": {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          "_pytest.python.pytest_collect_file": {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          "_pytest.python.path_matches_patterns": {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          }
        }
      }
    }
  ]
}