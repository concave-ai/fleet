{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5840",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:23:39.592033",
        "usage": "1476.3522148132324 ms"
      },
      "request": {
        "repo_tokens": [
          "cleanup_candidates",
          "ensure_reset_dir",
          "__getitem__",
          "getfirstlinesource",
          "warn",
          "pastebin",
          "AssertionRewriter",
          "getitem",
          "_testcase",
          "FixtureManager",
          "_getreprcrash",
          "skip",
          "writelines",
          "_getcrashline",
          "getfuncargnames",
          "num_mock_patch_args",
          "DEFAULT_LOG_FORMAT",
          "_issue_warning_captured",
          "add_report_section",
          "getfixturedefs",
          "MoreQuietAction",
          "addini",
          "PytestExperimentalApiWarning",
          "hasinit",
          "InvocationParams",
          "_tryconvertpyarg",
          "wasvalid",
          "fullsource",
          "rex_session_duration",
          "capture_fixtures",
          "pytest_collection_finish",
          "FormattedExcinfo",
          "_make_xunit_fixture",
          "__setitem__",
          "_strtobool",
          "pytest_report_to_serializable",
          "pytest_plugin_registered",
          "Node",
          "combined_with",
          "BaseReport",
          "_width_of_current_line",
          "_update_message",
          "cacheprovider",
          "mangle_test_address",
          "readline",
          "_opentestcase",
          "records",
          "setmulti2",
          "write_ensure_prefix",
          "_in_venv",
          "_add_simple",
          "FixtureDef",
          "_bestrelpath_cache",
          "list",
          "append_collect_error",
          "get_scope_node",
          "showfspath",
          "NOTSET",
          "_get_flag_lookup",
          "__version_tuple__",
          "delattr",
          "cached_eval",
          "makedir",
          "SEP",
          "_repr_style",
          "_inject_setup_class_fixture",
          "_import_plugin_specs",
          "markname",
          "istestfunction",
          "set_when",
          "getmodpath",
          "python_api",
          "addFailure",
          "ConftestImportFailure",
          "getstatementrange_ast",
          "getcfg",
          "getfailedcollections",
          "_legal_ranges",
          "notify_exception",
          "__len__",
          "isnosetest",
          "_basetemp",
          "_yield_comparisons",
          "repr_args",
          "_truncate_recursive_traceback",
          "_getautousenames",
          "node_reporter",
          "write_line",
          "co_equal",
          "_getindent",
          "tmpdir_factory",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "pytest_collection_modifyitems",
          "buffer",
          "WarningsRecorder",
          "_format_boolop",
          "PytestArg",
          "ishidden",
          "fileno",
          "_log_text",
          "funcnamefilter",
          "_write_progress_information_filling_space",
          "add_stats",
          "reorder_items",
          "format_explanation",
          "_inject_setup_teardown_fixtures",
          "is_capturing",
          "iter_markers_with_node",
          "_getfailureheadline",
          "append_pass",
          "chdir",
          "pytest_pycollect_makemodule",
          "exec_module",
          "category",
          "builtin_plugins",
          "fail",
          "readlines",
          "FDCapture",
          "EMPTY_BUFFER",
          "RaisesContext",
          "_collect",
          "__str__",
          "from_current",
          "_initrequest",
          "reorder_items_atscope",
          "_makeitem",
          "xfail",
          "start_capturing",
          "with_args",
          "nextitem",
          "set_level",
          "_getscopeitem",
          "SysCapture",
          "merge_family",
          "tb",
          "_is_marked_for_rewrite",
          "fixtures",
          "_matches_prefix_or_glob_option",
          "pytest_runtest_protocol",
          "get_empty_parameterset_mark",
          "_disable_output_capturing_for_darwin",
          "_non_printable_ascii_translate_table",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_report_from_serializable",
          "LEVELNAME_FMT_REGEX",
          "importorskip",
          "iscoroutinefunction",
          "_addfinalizer",
          "_setup_cli_logging",
          "OK",
          "Item",
          "append_collect_skipped",
          "pytest_make_collect_report",
          "disabled",
          "MultipleDoctestFailures",
          "_outrep_summary",
          "capsys",
          "__all__",
          "USAGE_ERROR",
          "Junit",
          "TestReport",
          "_find_spec",
          "_done",
          "fix_cache_order",
          "__getattr__",
          "File",
          "_markers",
          "_from_json",
          "__array_ufunc__",
          "UnformattedWarning",
          "skipping",
          "_early_rewrite_bailout",
          "fixturenames",
          "ReprEntryNative",
          "_set_initial_conftests",
          "showheader",
          "fromdictargs",
          "runtest",
          "hasplugin",
          "ExceptionInfo",
          "get_plugin_manager",
          "name",
          "FuncargnamesCompatAttr",
          "getexplanation",
          "scopeproperty",
          "add_global_property",
          "append",
          "obj",
          "FuncFixtureInfo",
          "visit_Attribute",
          "_compare_eq_verbose",
          "helpconfig",
          "Code",
          "_preparse",
          "_import_pdb_cls",
          "_inject_setup_function_fixture",
          "excinfo",
          "gethookrecorder",
          "pytestPDB",
          "hasnew",
          "pytest_fixture_setup",
          "parse_num",
          "store_mark",
          "_init_runner_class",
          "global_and_fixture_disabled",
          "generic_visit",
          "_addoption",
          "faulthandler",
          "ApproxScalar",
          "_makepath",
          "getnode",
          "call_fixture_func",
          "_get_increasing_order",
          "listextrakeywords",
          "getstatement",
          "raiseerror",
          "set_log_path",
          "location",
          "_getglobals",
          "parse_args",
          "__eq__",
          "getfixturemarker",
          "get_optionflags",
          "derive_importpath",
          "LineMatcher_fixture",
          "stop_capturing",
          "nose",
          "_get_pdb_wrapper_class",
          "call_optional",
          "register_cleanup_lock_removal",
          "get_direct_param_fixture_func",
          "summary_stats",
          "deprecated",
          "EncodedFile",
          "finish_recording",
          "TerminalRepr",
          "__enter__",
          "_repr_failure_py",
          "pytest_runtest_logstart",
          "_getcapture",
          "_format_action_invocation",
          "_parse_lsof_output",
          "ColoredLevelFormatter",
          "_get_report_choice",
          "classnamefilter",
          "_code",
          "SysCaptureBinary",
          "freeze_support",
          "setenv",
          "_finalize",
          "pytest_runtest_logfinish",
          "teardown_nose",
          "AssertionState",
          "isset",
          "pytest_exception_interact",
          "__call__",
          "_py_ext_re",
          "catching_logs",
          "default_plugins",
          "cached_result",
          "build_summary_stats_line",
          "runpytest",
          "getreports",
          "_idvalset",
          "readouterr",
          "tolerance",
          "_printcollecteditems",
          "funcargnames",
          "parse_known_args",
          "PyobjMixin",
          "addSuccess",
          "helper",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_perform_collect",
          "repr",
          "putaround",
          "_factorytraceback",
          "getfslineno",
          "visit_BoolOp",
          "rewrite_asserts",
          "stopTest",
          "getreportopt",
          "Testdir",
          "_postmortem_traceback",
          "DOCTEST_REPORT_CHOICES",
          "fillfixtures",
          "scopenum_function",
          "resolve_from_str",
          "Entry",
          "report_collect",
          "cacheshow",
          "_show_fixture_action",
          "resume_fixture",
          "unique_path",
          "inline_run",
          "safe_getattr",
          "NO_TESTS_COLLECTED",
          "call_and_report",
          "isattrs",
          "stop",
          "inline_runsource",
          "exec_",
          "close",
          "_get_allow_bytes_flag",
          "_makefile",
          "ensure_newline",
          "_parse_parametrize_parameters",
          "patchsysdict",
          "_compare_eq_dict",
          "rm_rf",
          "MultiCapture",
          "Failed",
          "exists",
          "write",
          "_sys_snapshot",
          "TempPathFactory",
          "_validate_usepdb_cls",
          "emit",
          "getfailures",
          "cmdline",
          "version",
          "_recurse",
          "defaultfuncargprefixmarker",
          "_saved",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "CwdSnapshot",
          "PseudoFixtureDef",
          "CaptureManager",
          "annotated_getattr",
          "write_captured_output",
          "hookspec",
          "perform_collect",
          "_consider_importhook",
          "_compare_eq_iterable",
          "getfixturevalue",
          "Interrupted",
          "set",
          "resume_capturing",
          "_addexcinfo",
          "_warn_already_imported",
          "Cache",
          "_call_with_optional_argument",
          "setitem",
          "addSkip",
          "_assertion_pass",
          "scope",
          "failed",
          "approx",
          "_bytes_to_ascii",
          "short_test_summary",
          "_version",
          "LOGLEVEL_COLOROPTS",
          "finalize",
          "ensure_deletable",
          "pytest_make_parametrize_id",
          "_call_reprcompare",
          "LsofFdLeakChecker",
          "getinicfg",
          "_pluginmanager",
          "node",
          "HookRecorder",
          "_getentrysource",
          "head_line",
          "_enter_pdb",
          "finish",
          "saferepr",
          "message",
          "showversion",
          "add_funcarg_pseudo_fixture_def",
          "ExceptionRepr",
          "PYC_EXT",
          "addfinalizer",
          "_parse_parametrize_args",
          "_get_line_with_reprcrash_message",
          "initialnames",
          "pytest_load_initial_conftests",
          "MARK_GEN",
          "str",
          "record_testreport",
          "_do_configure",
          "families",
          "repr_failure",
          "ApproxSequencelike",
          "resolve",
          "format_session_duration",
          "messages",
          "_check_all_skipped",
          "get_terminal_writer",
          "Class",
          "find",
          "countoutcomes",
          "_cachedir",
          "update_testcase_duration",
          "getpathnode",
          "_striptext",
          "parse",
          "_create_formatter",
          "teardown",
          "_locationline",
          "_LiveLoggingStreamHandler",
          "_get_allow_unicode_flag",
          "recursionindex",
          "pytest_generate_tests",
          "raises",
          "pytest_cmdline_preparse",
          "pytest_runtest_makereport",
          "Function",
          "pytest_assertrepr_compare",
          "ReprTraceback",
          "directory_arg",
          "_diff_text",
          "on_rm_rf_error",
          "caplog",
          "matching_platform",
          "get_records",
          "Config",
          "_getini",
          "reports",
          "_ensure_basetemp",
          "_collectfile",
          "_legal_chars",
          "_check_initialpaths_for_relpath",
          "_matchnodes",
          "type",
          "pytest_runtest_setup",
          "PYTESTER_COPY_EXAMPLE",
          "spawn_pytest",
          "hasopt",
          "fspath",
          "pytestconfig",
          "MarkDecorator",
          "add_cleanup",
          "MonkeyPatch",
          "tmp_path",
          "DoctestModule",
          "_try_load_conftest",
          "_log",
          "undo",
          "showlocals",
          "_to_json",
          "from_item_and_call",
          "TimeoutExpired",
          "source",
          "_prunetraceback",
          "runpython",
          "getcalls",
          "restore",
          "DEFAULT_MAX_CHARS",
          "CaptureFixture",
          "_suspend",
          "OptionGroup",
          "_checkversion",
          "attrs",
          "safeformat",
          "find_spec",
          "_ensure_only_one_capture_fixture",
          "get_statement_startend2",
          "_for_parametrize",
          "get_actual_log_level",
          "from_exc_info",
          "extract_from",
          "cut",
          "_checkargnotcontained",
          "setupplan",
          "parse_setoption",
          "prepare",
          "_match_lines",
          "_iter_rewritable_modules",
          "CallSpec2",
          "reportinfo",
          "dir",
          "fnmatch_lines_random",
          "findsource",
          "README_CONTENT",
          "PytestPluginManager",
          "warning_record_to_str",
          "_rget_with_confmod",
          "_setup_fixtures",
          "tbfilter",
          "NodeMarkers",
          "from_config",
          "capstderr",
          "_node_location_to_relpath",
          "FixtureRequest",
          "mark_rewrite",
          "toterminal",
          "_rewrite_test",
          "getparent",
          "parts",
          "INTERNAL_ERROR",
          "isiterable",
          "statement",
          "suspend",
          "NFPlugin",
          "truncate_locals",
          "record_property",
          "_matchfactories",
          "__delitem__",
          "TempdirFactory",
          "getvalueorskip",
          "KeywordMapping",
          "__iter__",
          "_getobj",
          "to_xml",
          "capture",
          "DoctestItem",
          "getrepr",
          "_showfixtures_main",
          "_patch_unwrap_mock_aware",
          "_handle_skip",
          "__bool__",
          "_fail_on_non_top_pytest_plugins",
          "_report_keyboardinterrupt",
          "hookimpl",
          "ApproxMapping",
          "pytest_itemcollected",
          "wrap_session",
          "PrintHelp",
          "repr_traceback",
          "outcomes",
          "mkdir",
          "strip",
          "compile_",
          "python_keywords_allowed_list",
          "pytest_runtestloop",
          "Instance",
          "setup",
          "__array_priority__",
          "run",
          "UsageError",
          "STRING_TYPES",
          "filter",
          "__ne__",
          "_warn_incompatibility_with_xunit2",
          "maketxtfile",
          "_get_runner",
          "_schedule_finalizers",
          "make_hook_recorder",
          "_pytest",
          "frame",
          "RE_IMPORT_ERROR_NAME",
          "makeini",
          "deselect_by_mark",
          "append_skipped",
          "listchain",
          "pytest_doctest_prepare_content",
          "CLOSE_STDIN",
          "resolve_fixture_function",
          "pytest_runtest_teardown",
          "formatrepr",
          "warnings",
          "_get_override_ini_value",
          "name2fixturedefs",
          "check_strict_xfail",
          "ReprLocals",
          "set_session",
          "encoding",
          "getplugin",
          "ApproxNumpy",
          "_inject_setup_method_fixture",
          "Notset",
          "collect_by_name",
          "addError",
          "collect_one_node",
          "pytest_ignore_collect",
          "_get_direct_parametrize_args",
          "_mark_plugins_for_rewrite",
          "_fillfixtures",
          "Source",
          "filename_arg",
          "context",
          "_prepareconfig",
          "section",
          "PytestWarning",
          "_setup_collect_fakemodule",
          "ascii_escaped",
          "_compare_eq_sequence",
          "when",
          "_recursive_list_map",
          "_pop_and_teardown",
          "done",
          "addExpectedFailure",
          "_should_repr_global_name",
          "args",
          "__module__",
          "_seen",
          "_ensure_unconfigure",
          "_format_args",
          "get_lock_path",
          "mark",
          "simple",
          "show_fixtures_per_test",
          "_running_on_ci",
          "isinitpath",
          "_report_kwargs_from_json",
          "Traceback",
          "Mark",
          "summary_warnings",
          "_iter_all_modules",
          "pytest_sessionstart",
          "path_matches_patterns",
          "makeconftest",
          "cache_dir_from_config",
          "tracebackcutdir",
          "write_log_entry",
          "ApproxBase",
          "TYPE_CHECKING",
          "_excinfo",
          "set_location",
          "DontReadFromInput",
          "_runtest_for_main",
          "pytest_sessionfinish",
          "fill_unfilled",
          "scopename2class",
          "_PYTEST_DIR",
          "visit_Call",
          "_callfinalizers",
          "errisinstance",
          "__exit__",
          "make_properties_node",
          "result",
          "config",
          "get_exconly",
          "_traceback",
          "item_capture",
          "assign",
          "_get_fixturestack",
          "_check_scope",
          "repr_excinfo",
          "execute",
          "LineComp",
          "tmpdir",
          "pytest_keyboard_interrupt",
          "keywords",
          "linecomp",
          "scope2index",
          "_PytestWrapper",
          "get_option_ini",
          "__next__",
          "nodeid",
          "get_parametrized_fixture_keys",
          "parseoutcomes",
          "pytest_addoption",
          "PdbTrace",
          "names",
          "ExceptionChainRepr",
          "repr_instance",
          "fnmatch_lines",
          "consider_preparse",
          "_compilecounter",
          "matchnodes",
          "record_testsuite_property",
          "_update_current_test_var",
          "_legal_xml_re",
          "parse_known_and_unknown_args",
          "_ANSI_ESCAPE_SEQ",
          "pytest_internalerror",
          "pytester",
          "re_match_lines_random",
          "_split_explanation",
          "pytest_warning_captured",
          "mkpydir",
          "_argcomplete",
          "logging",
          "PytestCollectionWarning",
          "__init__",
          "nofuncargs",
          "syspathinsert",
          "CollectReport",
          "_exec_lsof",
          "HelpAction",
          "_non_numeric_type_error",
          "_assert_start_repr",
          "_visit_filter",
          "summary_failures",
          "getfixtureclosure",
          "extract_suffixes",
          "suspend_fixture",
          "mktemp",
          "PyCollector",
          "get_real_func",
          "SysModulesSnapshot",
          "safe_text_dupfile",
          "invocation_dir",
          "get_fslocation_from_item",
          "listoutcomes",
          "get",
          "pytest_unconfigure",
          "_start",
          "scope2props",
          "_mk_tmp",
          "_initini",
          "consider_conftest",
          "addinivalue_line",
          "_match_lines_random",
          "_trace",
          "entrysep",
          "SubRequest",
          "_get_active_fixturedef",
          "_ensure_removed_sysmodule",
          "suspend_capturing",
          "style",
          "matchmark",
          "_compare_eq_cls",
          "setattr",
          "check_testcase_implements_trial_reporter",
          "doctest_namespace",
          "_parsearg",
          "matchkeyword",
          "id",
          "OutcomeException",
          "getparam",
          "_is_capturing",
          "consider_env",
          "copy_example",
          "get_real_method",
          "_notin_text",
          "istestfunc",
          "indent",
          "delenv",
          "filter_traceback",
          "normalize_mark_list",
          "_getnextfixturedef",
          "popen",
          "idmaker",
          "consider_pluginarg",
          "copy",
          "CollectErrorRepr",
          "try_mkdir",
          "yield_fixture",
          "truncate_if_required",
          "_get_first_non_fixture_func",
          "DummyRewriteHook",
          "spawn",
          "istrue",
          "display",
          "template",
          "_get_continue_on_failure",
          "prog",
          "setuponly",
          "_resume",
          "freeze_includes",
          "ApproxDecimal",
          "_readline_workaround",
          "record_xml_attribute",
          "ReprEntry",
          "make_numbered_dir",
          "PyobjContext",
          "Argument",
          "warning_types",
          "safe_isclass",
          "INTERRUPTED",
          "relline",
          "_PY_DIR",
          "is_potential_nosetest",
          "WarningsChecker",
          "fail_marker",
          "is_true",
          "getitems",
          "addsection",
          "_getparser",
          "parse_hookspec_opts",
          "find_prefixed",
          "ArgumentError",
          "_check_record_param_type",
          "get_sections",
          "getrawcode",
          "recwarn",
          "isparseable",
          "terminal",
          "visit_Compare",
          "Package",
          "pytest_pyfunc_call",
          "get_location",
          "push_format_context",
          "CallInfo",
          "pytest_report_header",
          "showhelp",
          "_is_setup_py",
          "pop",
          "_init_pdb",
          "import_plugin",
          "astcache",
          "conftest_options",
          "_teardown_towards",
          "Parser",
          "_find_parametrized_scope",
          "nodes",
          "catch_warnings_for_item",
          "MyOptionParser",
          "inline_genitems",
          "matchreport",
          "getpluginversioninfo",
          "make_numbered_dir_with_cleanup",
          "delitem",
          "scopes",
          "get_lines_after",
          "assert_contains",
          "get_config",
          "__missing__",
          "visit_Name",
          "ReprFailDoctest",
          "pytest_cmdline_parse",
          "REGEX_TYPE",
          "ParsedCall",
          "for_later",
          "CaptureResult",
          "_inject_setup_module_fixture",
          "add_property",
          "update",
          "compile",
          "__version__",
          "USAGE_MSG",
          "MODULE_NOT_FOUND_ERROR",
          "NoMatch",
          "BASE_TYPE",
          "_is_numpy_array",
          "write_sep",
          "exconly",
          "newinstance",
          "_getpytestargs",
          "read_global_capture",
          "_get_progress_information_message",
          "last_failed_paths",
          "teardown_all",
          "_set_opt_strings",
          "_saferepr",
          "PytestAssertRewriteWarning",
          "ReprFileLocation",
          "_config_for_test",
          "_io",
          "Collector",
          "_resolve_arg_ids",
          "_idval",
          "TracebackEntry",
          "PytestConfigWarning",
          "cache_key",
          "TEST_OUTCOME",
          "funcargs",
          "main",
          "capsysbinary",
          "_state",
          "LOCK_TIMEOUT",
          "activate_fixture",
          "alias",
          "_ensure_immutable_ids",
          "parseconfig",
          "pytest_enter_pdb",
          "getfixtureinfo",
          "getargs",
          "getvalue",
          "BINOP_MAP",
          "_test_pytest_function",
          "_truncate_explanation",
          "ReprExceptionInfo",
          "_ellipsize",
          "prune_dependency_tree",
          "getoption",
          "_get_stderr_fileno",
          "_getconftest_pathlist",
          "PytestUnknownMarkWarning",
          "flow_marker",
          "try_cleanup",
          "fixture",
          "__hash__",
          "_importconftest",
          "FixtureLookupError",
          "get_data",
          "DropShorterLongHelpFormatter",
          "write_fspath_result",
          "capfdbinary",
          "isdict",
          "_compute_fixture_value",
          "get_user",
          "start_global_capturing",
          "LineMatcher",
          "for_config",
          "ihook",
          "Session",
          "_write_pyc",
          "ReprTracebackNative",
          "_assert_expr_to_lineno",
          "ParameterSet",
          "listnames",
          "_report_to_json",
          "plugins",
          "create_cleanup_lock",
          "assertrepr_compare",
          "param",
          "pytest_collectreport",
          "assertion",
          "instance",
          "_NodeReporter",
          "is_globally_capturing",
          "install_importhook",
          "collect",
          "is_rewrite_disabled",
          "pytest_leave_pdb",
          "pytest_fixture_post_finalizer",
          "pytest_collection",
          "_plugin_nameversions",
          "_dump_lines",
          "skipped",
          "_typ_map",
          "processoption",
          "_is_mocked",
          "unittest",
          "kwargs",
          "FastFilesCompleter",
          "abspath",
          "getsource",
          "handler",
          "pytest_collectstart",
          "snap",
          "_colorama_workaround",
          "_config",
          "_read_pyc",
          "params",
          "_compare_eq_set",
          "stop_global_capturing",
          "TestCaseFunction",
          "testdir",
          "istext",
          "register_assert_rewrite",
          "register",
          "fslocation",
          "_truncate_by_char_count",
          "own_mark_names",
          "__take_sys_modules_snapshot",
          "getcall",
          "_should_rewrite",
          "fail_fixturefunc",
          "traceback",
          "_check_type",
          "visit_Assert",
          "consider_module",
          "autouse",
          "stepwise",
          "visit_BinOp",
          "TerminalReporter",
          "_get_global_properties_node",
          "create_new_paste",
          "CollectError",
          "_get_checker",
          "get_scope_package",
          "runitem",
          "runpytest_inprocess",
          "set_trace",
          "_teardown_yield_fixture",
          "_py36_windowsconsoleio_workaround",
          "FSHookProxy",
          "NoCapture",
          "FunctionDefinition",
          "LFPlugin",
          "capstdout",
          "doctest",
          "_check_if_assertion_pass_impl",
          "_ensure_supporting_files",
          "_setoption",
          "variable",
          "CACHEDIR_TAG_CONTENT",
          "summary_passes",
          "_resolve_arg_value_types",
          "get_closest_marker",
          "pytest_configure",
          "ResultLog",
          "showlongtestinfo",
          "append_failure",
          "rewrite",
          "deindent",
          "add_marker",
          "RunResult",
          "typename",
          "runpython_c",
          "from_item",
          "SysPathsSnapshot",
          "RESULT_LOG",
          "NodeKeywords",
          "Skipped",
          "PYTEST_TAG",
          "Module",
          "FixtureLookupErrorRepr",
          "own_markers",
          "setns",
          "exit",
          "pop_format_context",
          "monkeypatch",
          "LogCaptureFixture",
          "pytest_collect_directory",
          "ischildnode",
          "python",
          "_tmppath_factory",
          "check_xfail_no_run",
          "fnmatch_ex",
          "_wrapped_pdb_cls",
          "get_unpacked_marks",
          "_splitnode",
          "CaptureIO",
          "getlocation",
          "pytest_runtest_logreport",
          "format",
          "applymarker",
          "get_public_names",
          "_given_basetemp",
          "MarkEvaluator",
          "cache",
          "makefile",
          "SafeRepr",
          "from_call",
          "writeorg",
          "_E",
          "match",
          "_istrue",
          "popcall",
          "determine_setup",
          "_should_truncate_item",
          "FixtureFunctionMarker",
          "_PLUGGY_DIR",
          "suspend_global_capture",
          "pytest_assertion_pass",
          "reset",
          "Exit",
          "parseconfigure",
          "teardown_exact",
          "_get_pos",
          "gethookproxy",
          "_genfunctions",
          "addoption",
          "DOCTEST_REPORT_CHOICE_NONE",
          "getini",
          "explanation_param",
          "cls",
          "check_interactive_exception",
          "runpytest_subprocess",
          "rex_outcome",
          "summary_errors",
          "pytest_pycollect_makeitem",
          "warn_about_none_ast",
          "visit_Starred",
          "parsefactories",
          "_main",
          "getcrashentry",
          "locals",
          "post_mortem",
          "parse_hookimpl_opts",
          "append_error",
          "re_match_lines",
          "_call_assertion_pass",
          "runtestprotocol",
          "_recursive_debug",
          "write_docstring",
          "assertoutcome",
          "pytest_addhooks",
          "pytest_collect_file",
          "_get_verbose_word",
          "version_tuple",
          "FUNCARGNAMES",
          "assert_contains_lines",
          "FunctionMixin",
          "repr_traceback_entry",
          "count_towards_summary",
          "_importtestmodule",
          "_getconftestmodules",
          "get_open_files",
          "_reprcompare",
          "ReprFuncArgs",
          "_ascii_escaped_by_config",
          "iter_markers",
          "_get_plugin_specs_as_list",
          "__nonzero__",
          "wrap_function_to_error_out_if_called_directly",
          "_format_assertmsg",
          "ids",
          "_warn_about_missing_assertion",
          "_show_fixtures_per_test",
          "start",
          "LoggingPlugin",
          "_get_marks",
          "_force_symlink",
          "FSCollector",
          "Frame",
          "_folded_skips",
          "log_outcome",
          "_log_cli_enabled",
          "IGNORE_PAM",
          "getmodulecol",
          "UNARY_MAP",
          "eval",
          "set_repr_style",
          "_ALLOW_MARKERS",
          "RUNNER_CLASS",
          "is_generator",
          "get_common_ancestor",
          "PdbInvoke",
          "deactivate_fixture",
          "invalidraise",
          "PercentStyleMultiline",
          "getimfunc",
          "get_dirs_from_args",
          "_assertion_supported",
          "resume",
          "longreprtext",
          "runner",
          "exprinfo",
          "compat",
          "Metafunc",
          "_pyfuncitem",
          "issequence",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_deselected",
          "REPORT_COLLECTING_RESOLUTION",
          "pytest_runtest_call",
          "_validate_args",
          "WarningReport",
          "module",
          "record_tuples",
          "isatty",
          "cleanup_numbered_dir",
          "getslaveinfoline",
          "getbasetemp",
          "scopemismatch",
          "find_suffixes",
          "DEFAULT_LOG_DATE_FORMAT",
          "show_test_item",
          "illegal_xml_re",
          "FDCaptureBinary",
          "XFailed",
          "PytestUnhandledCoroutineWarning",
          "MarkMapping",
          "errors",
          "MarkGenerator",
          "addUnexpectedSuccess",
          "UnitTestCase",
          "pytest_report_teststatus",
          "line",
          "__test__",
          "_result",
          "_getlines",
          "getgroup",
          "showfixtures",
          "capfd",
          "_write_report_lines_from_hooks",
          "create_terminal_writer",
          "_remove_ansi_escape_sequences",
          "pytest_terminal_summary",
          "_get_number_flag",
          "CFG_PYTEST_SECTION",
          "EMPTY_PARAMETERSET_OPTION",
          "print_teardown_sections",
          "warns",
          "builtin",
          "verbosity",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "LogCaptureHandler",
          "_approx_scalar",
          "create_module",
          "pytest_report_collectionfinish",
          "resume_global_capture",
          "maybe_delete_a_numbered_dir",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "text",
          "at_level",
          "passed",
          "resultlog",
          "tmp_path_factory",
          "argnames",
          "call_runtest_hook",
          "_processopt",
          "getdecoded",
          "getstatementrange",
          "pyobj_property",
          "makepyfile",
          "SetupState",
          "_is_doctest",
          "pathlib",
          "_addoption_instance",
          "notset",
          "value",
          "PytestCacheWarning",
          "get_source",
          "read",
          "function",
          "_format_repr_exception",
          "add_attribute",
          "_runtest_for",
          "junitxml",
          "istestclass",
          "startTest",
          "deselect_by_keyword",
          "pytest_itemstart",
          "AssertionRewritingHook",
          "_install_capture_fixture_on_item",
          "bin_xml_escape",
          "PYC_TAIL",
          "assert_outcomes",
          "LogXML",
          "isdatacls",
          "StepwisePlugin",
          "TESTS_FAILED",
          "debugging",
          "essential_plugins",
          "session",
          "__repr__",
          "pytest_cmdline_main",
          "_translate_non_printable",
          "cwd_relative_nodeid",
          "_getvaluepath",
          "_determine_show_progress_info",
          "deprecated_call",
          "chain",
          "repr_locals",
          "get_default_arg_names",
          "names_closure",
          "out",
          "DoctestTextfile",
          "syspath_prepend",
          "_validate_if_using_arg_names",
          "visit_UnaryOp",
          "pop_outerr_to_orig",
          "FILE_OR_DIR",
          "mode",
          "ExitCode",
          "DEFAULT_MAX_LINES",
          "error",
          "_get_assertion_exprs",
          "_teardown_with_finalization",
          "parametrize",
          "_format_lines",
          "_report_unserialization_failure",
          "path",
          "PytestDeprecationWarning",
          "genitems",
          "clear"
        ]
      },
      "response": {
        "keywords": [
          "conftest",
          "import",
          "ConftestImportFailure",
          "pytest_collection_finish",
          "pytest_collection_modifyitems",
          "pytest_plugin_registered",
          "pytest_addhooks",
          "pytest_collect_file",
          "Module",
          "Session"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:23:41.068409",
        "usage": "191.15281105041504 ms"
      },
      "request": {
        "tokens": [
          "conftest",
          "import",
          "ConftestImportFailure",
          "pytest_collection_finish",
          "pytest_collection_modifyitems",
          "pytest_plugin_registered",
          "pytest_addhooks",
          "pytest_collect_file",
          "Module",
          "Session"
        ]
      },
      "response": {
        "results": {
          "import": [
            "src/pytest.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/nose.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/__init__.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/debugging.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_version.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/pytester.py"
          ],
          "Session": [
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "Module": [
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "conftest": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collection_finish": [
            "src/_pytest/hookspec.py",
            "src/_pytest/terminal.py",
            "src/_pytest/main.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_addhooks": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py"
          ],
          "pytest_plugin_registered": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/terminal.py"
          ],
          "ConftestImportFailure": [
            "src/_pytest/config/__init__.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:23:41.259578",
        "usage": "7103.181600570679 ms"
      },
      "request": {
        "keyword_search_results": {
          "import": [
            "src/pytest.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/runner.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/nose.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/__init__.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/debugging.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_version.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/compat.py",
            "src/_pytest/reports.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/pytester.py"
          ],
          "Session": [
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "Module": [
            "src/pytest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "conftest": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collection_finish": [
            "src/_pytest/hookspec.py",
            "src/_pytest/terminal.py",
            "src/_pytest/main.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "pytest_addhooks": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py"
          ],
          "pytest_plugin_registered": [
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/terminal.py"
          ],
          "ConftestImportFailure": [
            "src/_pytest/config/__init__.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue involves an `ImportError` related to `conftest.py` due to casing issues in paths, specifically when migrating from `pytest` 5.1.1 to 5.1.2. The error is that the path gets converted to lower case, causing problems in module identification. Therefore, relevant files to focus on should include those that handle path and module imports.\n\nFrom the keyword search results:\n\n1. Keywords directly related to 'conftest' should be our primary focus as the issue is with `ImportError` while loading `conftest.py`.\n   - `conftest`: The files related to this keyword are more likely to contain code that handles how `conftest.py` is loaded.\n     - `src/_pytest/config/__init__.py`: This includes `ConftestImportFailure`, indicating it has error handling specific to conftest imports.\n     - `src/_pytest/hookspec.py`: Likely contains hooks related to `conftest` files.\n     - `src/_pytest/python.py`: Deals with importing Python files which might include `conftest`.\n     - `src/_pytest/main.py`: Possible central processing related to test discovery and execution.\n     \n2. Other keywords related to import, specifically `Import` and `ConftestImportFailure`, are significant because they could address the broader import system changes in `pytest` that might be responsible for the path casing transformation.\n - `ConftestImportFailure`: Represents a specific event or error that occurs during the conftest importation, which is the issue described.\n\nWith this in mind, the most probably relevant files, sorted by relevance:\n1. `src/_pytest/config/__init__.py` (handles `ConftestImportFailure`).\n2. `src/_pytest/hookspec.py` (deals with hooks related to `conftest`).\n3. `src/_pytest/python.py` (handles Python file imports).\n4. `src/_pytest/main.py` (central to pytest's processing, potentially affecting how tests and configurations are discovered and loaded).",
        "file_paths": [
          "src/_pytest/config/__init__.py",
          "src/_pytest/hookspec.py",
          "src/_pytest/python.py",
          "src/_pytest/main.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:48.362801",
        "usage": "8193.68314743042 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. **Issue Analysis**\n   1.1 The user is experiencing an `ImportError` while loading `conftest.py` due to path casing issues after upgrading pytest from version 5.1.1 to 5.1.2.\n   1.2 This issue was caused by a change in the handling of path cases in pytest 5.1.2, where the path is converted to lowercase, leading to module not found errors.\n   1.3 The expected result should be that the correct conftest file is imported, respecting the original casing of the path.\n   1.4 If not explicitly mentioned, the expectation would be that casing issues should not affect module import functionality, and the original path casing should be respected.\n   1.5 The issue should be fixed by either ensuring the path casing is preserved when importing, or by handling mismatches in file system casing gracefully.\n\n2. **File Evaluation**\n   - The file `src/_pytest/config/__init__.py` seems relevant as it involves configuration processing, which includes loading of `conftest.py` files.\n   - The `ConftestImportFailure` class and `_importconftest()` method might be directly involved in the process of importing conftest files and handling import errors.\n   - `_importconftest(conftestpath)` appears to import `conftest.py` files and could be influenced by casing if the path does not match the physical path in a case-sensitive or case-insensitive manner based on the file system.\n   - The error message format in `_importconftest()` refers to this error handling.\n   - The method `_getconftestmodules()` explores directory structures to find and load `conftest.py` files, indicating its potential involvement in path handling.\n   - The `unique_path()` function is used extensively to ensure unique paths, which might correct or change casing issues inadvertently.\n   - The method `_try_load_conftest(anchor)` attempts to load conftest files from a given anchor point with some consideration of path existence that might not be respecting casing.\n   - The file operations using `py.path.local()` don't explicitly respect casing unless the underlying library or function does; this can be a vector for path issues causing the observed behavior.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "ConftestImportFailure",
          "PytestPluginManager._importconftest",
          "PytestPluginManager._getconftestmodules",
          "unique_path",
          "_prepareconfig",
          "main"
        ],
        "root_cause_symbols": [
          "ConftestImportFailure",
          "PytestPluginManager._importconftest",
          "PytestPluginManager._getconftestmodules",
          "unique_path",
          "_prepareconfig",
          "main"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:23:56.556495",
        "usage": "7532.428741455078 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is experiencing an `ImportError` related to casing issues in folder paths after upgrading to pytest version 5.1.2 from 5.1.1. The path seems to be converted to lower case, resulting in a `ModuleNotFoundError`.\n1.2 The issue is likely caused by the handling of path casing in the new version of pytest 5.1.2, specifically when the tool tries to load the `conftest.py` file.\n1.3 The user expects that the casing used in the directory paths should remain consistent as in the previous version 5.1.1 to avoid the import errors.\n1.4 The expectation is that pytest should recognize and load `conftest.py` files regardless of the casing issues in directory paths.\n1.5 To fix this issue, ensure that pytest handles the directory casing correctly when locating `conftest.py` files, potentially preserving the original casing or adapting its path resolution to consider inconsistent casing in directory names.\n\n2. Make file evaluation:\n2.1 The file `hookspec.py` is being evaluated. This file contains hook specification definitions for plugins.\n2.2 The issue at hand involves path casing during import, and `hookspec.py` seems to define various hooks related to plugin management but does not explicitly handle path resolution or import logic.\n2.3 Symbols related to the import and path handling issues are not directly found in this file. The current analysis of hooks like `pytest_load_initial_conftests`, `pytest_collect_file`, and others does not indicate they handle path casing issues.\n2.4 Without seeing the part of codebase where path resolution happens, we may not determine if this file is directly modifying path casing.\n2.5 This file might not be directly related to the path conversion issue described.\n2.6 As this does not seem to handle path manipulation, it is not likely to be the root cause but could indirectly relate if hooks are misconfigured elsewhere.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:04.088964",
        "usage": "3919.5969104766846 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\nReading the reported issue, it's observed that there is an ImportError encountered in `pytest` version 5.1.2 when loading conftest due to Windows path casing. The user's path is converted to lowercase, causing `ModuleNotFoundError`. In previous version 5.1.1, no such error was reported.\n\nThe issue seems to be related to case-sensitivity in module importing. The expected result would be for the path to be correctly recognized without altering the case, and modules should be imported correctly regardless of case difference in file paths.\n\n2. Make file evaluation:\n\n- The file `src/_pytest/python.py` manages Python test discovery, setup, and the running of test functions, specifically relating to the importing and handling of test files and paths.\n\n- Functions like `pytest_collect_file`, `_collectfile`, `Module._importtestmodule()` and similar seem relevant, as these are involved with handling and importing files, which could relate to the issue with path casing.\n\n- The `Module._importtestmodule()` method specifically uses the import mechanism and could be an area where path case handling might introduce the error in question. Handling of `ImportError` specifically could impact how messages are raised during such cases.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "Module._importtestmodule",
          "pytest_collect_file",
          "_collectfile"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:08.008577",
        "usage": "6372.089862823486 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n   - The issue describes that after upgrading to pytest 5.1.2, an ImportError occurs while loading a conftest file due to path casing issues in Windows, where paths have been converted to lowercase.\n   - The issue might have been caused by changes in the path handling logic within pytest that might be normalizing or altering path case sensitivity.\n   - The expected result would be that paths retain their intended case as specified by the user or system instead of being forced to lowercase, allowing modules to be correctly found and imported.\n   - If the issue is caused by a specific file, the file should be adjusted to ensure path case is preserved or correctly handled according to the OS standards.\n\n2. **File Evaluation:**\n   - The file `src/_pytest/main.py` primarily deals with core initialization, session management, and test collection logic in pytest.\n   - During analysis, the `Session` class and its methods like `perform_collect` and `_collect` were highlighted as they manage the collection of test nodes. Within these methods, path handling for test modules and packages occurs.\n   - The `_tryconvertpyarg` method attempts to convert a dotted module name to a path, and might involve path manipulation where case sensitivity could be relevant.\n   - The `_parsearg` method processes the input arguments to pytest and involves path verification and conversion, again a place where path case might be transformed or normalized.\n   - No direct evidence of a transformation to lower case was found in this file. However, the handling of paths in the `Session` class is deeply tied to collection and import of test cases, making it relevant to the reported issue.\n\n   - It is not clear if this file is the root cause based solely on this analysis. However, some of its functionality (e.g., argument parsing, path conversion) may contribute to the issue if paths are being altered inadvertently.\n\n   **Conclusion:**\n   This file appears related to the issue, especially concerning how it potentially interacts with path manipulation during test collection. Further examination of related parts of pytest dealing with path handling (possibly in configuration or path utilities) is advised to confirm if this file is indeed the root cause or if changes here or elsewhere are needed.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config/__init__.py",
          "src/_pytest/python/__init__.py"
        ],
        "relevant_symbols": [
          "Session.perform_collect",
          "Session._collect",
          "Session._parsearg",
          "Session.gethookproxy"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:24:14.380710",
        "usage": "157.4251651763916 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [
              "ConftestImportFailure",
              "PytestPluginManager._importconftest",
              "PytestPluginManager._getconftestmodules",
              "unique_path",
              "_prepareconfig",
              "main"
            ],
            "root_cause_symbol_keys": [
              "ConftestImportFailure",
              "PytestPluginManager._importconftest",
              "PytestPluginManager._getconftestmodules",
              "unique_path",
              "_prepareconfig",
              "main"
            ]
          },
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "Module._importtestmodule",
              "pytest_collect_file",
              "_collectfile"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "Session.perform_collect",
              "Session._collect",
              "Session._parsearg",
              "Session.gethookproxy"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/python.py",
            "file_content": "t()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pyte",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Package._collectfile",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        if self.fspath == path:  # __init__.py\n            return [self]\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 601,
            "start_column": 22656,
            "end_line": 4,
            "end_column": 23564,
            "start_byte": 22656,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            parts[0] = self._tryconvertpyarg(parts[0])\n        relpath = parts[0].replace(\"/\", os.sep)\n        path = self.config.invocation_dir.join(relpath, abs=True)\n        if not path.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        parts[0] = path.realpath()\n        return parts",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.PytestPluginManager._getconftestmodules",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist",
            "start_line": 398,
            "start_column": 13049,
            "end_line": 4,
            "end_column": 13926,
            "start_byte": 13049,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plug",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:24:14.538141",
        "usage": "10174.139022827148 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/python.py",
            "file_content": "t()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pyte",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Package._collectfile",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        if self.fspath == path:  # __init__.py\n            return [self]\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 601,
            "start_column": 22656,
            "end_line": 4,
            "end_column": 23564,
            "start_byte": 22656,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            parts[0] = self._tryconvertpyarg(parts[0])\n        relpath = parts[0].replace(\"/\", os.sep)\n        path = self.config.invocation_dir.join(relpath, abs=True)\n        if not path.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        parts[0] = path.realpath()\n        return parts",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.PytestPluginManager._getconftestmodules",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist",
            "start_line": 398,
            "start_column": 13049,
            "end_line": 4,
            "end_column": 13926,
            "start_byte": 13049,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plug",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "Analyzing the issue:\n1. The user reports an `ImportError` when loading `conftest` after upgrading to pytest 5.1.2. The error mentions a `ModuleNotFoundError` for the module named 'python', indicating a path issue.\n2. The issue is likely caused by path misconfiguration, possibly due to case sensitivity differences in file paths on Windows in the latest pytest version.\n3. In pytest 5.1.1, paths might have been handled correctly with case insensitivity, but changes in 5.1.2 could have introduced stricter handling.\n\nAnalyzing symbols:\n- `_pytest.config.main`: Calls `_prepareconfig` and handles `ConftestImportFailure`. This function is crucial as it constructs the configuration and might involve loading paths.\n- `_pytest.config._prepareconfig`: Prepares configuration using paths and plugins, likely affects how paths are interpreted, impacting module imports.\n- `_pytest.config.PytestPluginManager._importconftest`: Directly deals with importing `conftest.py`, and would handle path translations that could trigger case-sensitivity issues.\n- `_pytest.main.Session._collectfile` from `src/_pytest/main.py`: Manages file collections and might interact with how path cases are resolved during import.\n\nSymbols needing changes for resolution:\nI suspect modifications might be needed in path handling logic around `_importconftest`, potentially checking for case insensitivity in path loading. `_prepareconfig` might also require adjustments to how paths are collected or handled for imports.",
        "symbols": [
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "reason": "Core function to handle conftest import, where path issues related to case sensitivity likely originate."
          },
          {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "reason": "Prepares the config potentially affecting path setup, crucial for differences in handling of paths."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "Skipping `_pytest.cacheprovider.pytest_cmdline_main` as it seems unrelated to path handling and conftest imports.",
          "Considering `_pytest.config.ConftestImportFailure` as it would wrap import errors but doesn't contribute to path resolution.",
          "Examining `_pytest.config.main`. It's central in processing commands and catching `ConftestImportFailure`, relevant but alteration likely less impactful.",
          "Ignoring `_pytest.config.cmdline.main` as redundant reference to `main`.",
          "Focusing on `_pytest.config._prepareconfig`. Its role in preparing configuration is vital and likely influences path handling.",
          "Analyzing `_pytest.config.PytestPluginManager._getconftestmodules`, relates to conftest path retrieval, touching on potential path casing issues.",
          "Detailed check of `_pytest.config.PytestPluginManager._importconftest` necessary, central to conftest import and path handling.",
          "Ignoring hookspec and logging sections as tangential to path handling.",
          "Skipping unrelated `ExitCode` definitions and other constants.",
          "Reviewing `_pytest.main.Session._collectfile` as it has a role in file path resolution during collect phase, potentially subject to case mis-matches."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:24:24.712317",
        "usage": "4.773139953613281 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
              "start_line": 86,
              "start_column": 2432,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2432,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
              "start_line": 204,
              "start_column": 6768,
              "end_line": 0,
              "end_column": 7010,
              "start_byte": 6768,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/python.py",
              "file_content": "t()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pyte",
              "start_line": 574,
              "start_column": 19273,
              "end_line": 4,
              "end_column": 20107,
              "start_byte": 19273,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
              "start_line": 175,
              "start_column": 6070,
              "end_line": 0,
              "end_column": 6478,
              "start_byte": 6070,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Module._importtestmodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
              "start_line": 496,
              "start_column": 18244,
              "end_line": 4,
              "end_column": 20458,
              "start_byte": 18244,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Package._collectfile",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        if self.fspath == path:  # __init__.py\n            return [self]\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
              "start_line": 601,
              "start_column": 22656,
              "end_line": 4,
              "end_column": 23564,
              "start_byte": 22656,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/main.py",
              "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
              "start_line": 419,
              "start_column": 12809,
              "end_line": 4,
              "end_column": 13381,
              "start_byte": 12809,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 433,
              "start_column": 13387,
              "end_line": 4,
              "end_column": 13855,
              "start_byte": 13387,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
              "start_line": 492,
              "start_column": 15567,
              "end_line": 4,
              "end_column": 19267,
              "start_byte": 15567,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
              "start_line": 574,
              "start_column": 19273,
              "end_line": 4,
              "end_column": 20107,
              "start_byte": 19273,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            parts[0] = self._tryconvertpyarg(parts[0])\n        relpath = parts[0].replace(\"/\", os.sep)\n        path = self.config.invocation_dir.join(relpath, abs=True)\n        if not path.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        parts[0] = path.realpath()\n        return parts",
              "start_line": 629,
              "start_column": 21301,
              "end_line": 4,
              "end_column": 21965,
              "start_byte": 21301,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.cacheprovider.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
              "start_line": 349,
              "start_column": 12632,
              "end_line": 0,
              "end_column": 12790,
              "start_byte": 12632,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.ConftestImportFailure",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
              "start_line": 39,
              "start_column": 1031,
              "end_line": 0,
              "end_column": 1213,
              "start_byte": 1031,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.ConftestImportFailure.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
              "start_line": 40,
              "start_column": 1075,
              "end_line": 4,
              "end_column": 1213,
              "start_byte": 1075,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
              "start_line": 46,
              "start_column": 1216,
              "end_line": 0,
              "end_column": 2631,
              "start_byte": 1216,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.cmdline.main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "main = staticmethod(main)",
              "start_line": 88,
              "start_column": 2680,
              "end_line": 4,
              "end_column": 2705,
              "start_byte": 2680,
              "end_byte": 4
            },
            {
              "name": "_pytest.config._prepareconfig",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
              "start_line": 184,
              "start_column": 4849,
              "end_line": 0,
              "end_column": 5907,
              "start_byte": 4849,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.PytestPluginManager._getconftestmodules",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "@lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist",
              "start_line": 398,
              "start_column": 13049,
              "end_line": 4,
              "end_column": 13926,
              "start_byte": 13049,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.PytestPluginManager._importconftest",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
              "start_line": 433,
              "start_column": 14219,
              "end_line": 4,
              "end_column": 15693,
              "start_byte": 14219,
              "end_byte": 4
            },
            {
              "name": "_pytest.helpconfig.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
              "start_line": 127,
              "start_column": 3839,
              "end_line": 0,
              "end_column": 4085,
              "start_byte": 3839,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
              "start_line": 122,
              "start_column": 4139,
              "end_line": 0,
              "end_column": 4583,
              "start_byte": 4139,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
              "start_line": 533,
              "start_column": 18086,
              "end_line": 4,
              "end_column": 19153,
              "start_byte": 18086,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
              "start_line": 20,
              "start_column": 425,
              "end_line": 0,
              "end_column": 877,
              "start_byte": 425,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.ExitCode.OK",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mport ",
              "start_line": 28,
              "start_column": 610,
              "end_line": 4,
              "end_column": 616,
              "start_byte": 610,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.TESTS_FAILED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "dpaths import ex",
              "start_line": 30,
              "start_column": 641,
              "end_line": 4,
              "end_column": 657,
              "start_byte": 641,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.INTERRUPTED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ptionInfo\nfrom ",
              "start_line": 32,
              "start_column": 692,
              "end_line": 4,
              "end_column": 707,
              "start_byte": 692,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ytest.compat impor",
              "start_line": 34,
              "start_column": 752,
              "end_line": 4,
              "end_column": 770,
              "start_byte": 752,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.USAGE_ERROR",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "st.outcomes imp",
              "start_line": 36,
              "start_column": 801,
              "end_line": 4,
              "end_column": 816,
              "start_byte": 801,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "kipped\nfrom _pytest.pa",
              "start_line": 38,
              "start_column": 855,
              "end_line": 4,
              "end_column": 877,
              "start_byte": 855,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
              "start_line": 41,
              "start_column": 880,
              "end_line": 0,
              "end_column": 4997,
              "start_byte": 880,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.wrap_session",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
              "start_line": 179,
              "start_column": 5000,
              "end_line": 0,
              "end_column": 6841,
              "start_byte": 5000,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
              "start_line": 226,
              "start_column": 6844,
              "end_line": 0,
              "end_column": 6915,
              "start_byte": 6844,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
              "start_line": 230,
              "start_column": 6918,
              "end_line": 0,
              "end_column": 7299,
              "start_byte": 6918,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
              "start_line": 242,
              "start_column": 7302,
              "end_line": 0,
              "end_column": 7370,
              "start_byte": 7302,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_runtestloop",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
              "start_line": 246,
              "start_column": 7373,
              "end_line": 0,
              "end_column": 8037,
              "start_byte": 7373,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._in_venv",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
              "start_line": 263,
              "start_column": 8040,
              "end_line": 0,
              "end_column": 8570,
              "start_byte": 8040,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_ignore_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
              "start_line": 280,
              "start_column": 8573,
              "end_line": 0,
              "end_column": 9470,
              "start_byte": 8573,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection_modifyitems",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
              "start_line": 308,
              "start_column": 9473,
              "end_line": 0,
              "end_column": 9952,
              "start_byte": 9473,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.FSHookProxy",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
              "start_line": 326,
              "start_column": 9955,
              "end_line": 0,
              "end_column": 10272,
              "start_byte": 9955,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.FSHookProxy.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
              "start_line": 327,
              "start_column": 9978,
              "end_line": 4,
              "end_column": 10111,
              "start_byte": 9978,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.FSHookProxy.__getattr__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
              "start_line": 332,
              "start_column": 10117,
              "end_line": 4,
              "end_column": 10272,
              "start_byte": 10117,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.NoMatch",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
              "start_line": 338,
              "start_column": 10275,
              "end_line": 0,
              "end_column": 10363,
              "start_byte": 10275,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Interrupted",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
              "start_line": 342,
              "start_column": 10366,
              "end_line": 0,
              "end_column": 10488,
              "start_byte": 10366,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Interrupted.__module__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "self.consider_module(pl",
              "start_line": 345,
              "start_column": 10454,
              "end_line": 4,
              "end_column": 10477,
              "start_byte": 10454,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Failed",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
              "start_line": 348,
              "start_column": 10491,
              "end_line": 0,
              "end_column": 10562,
              "start_byte": 10491,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._bestrelpath_cache",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
              "start_line": 352,
              "start_column": 10565,
              "end_line": 0,
              "end_column": 10739,
              "start_byte": 10565,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._bestrelpath_cache.path",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "     return self",
              "start_line": 354,
              "start_column": 10609,
              "end_line": 4,
              "end_column": 10625,
              "start_byte": 10609,
              "end_byte": 4
            },
            {
              "name": "_pytest.main._bestrelpath_cache.__missing__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
              "start_line": 356,
              "start_column": 10631,
              "end_line": 4,
              "end_column": 10739,
              "start_byte": 10631,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
              "start_line": 362,
              "start_column": 10742,
              "end_line": 0,
              "end_column": 24478,
              "start_byte": 10742,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.Interrupted",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin(name))\n\n    def pyt",
              "start_line": 363,
              "start_column": 10780,
              "end_line": 4,
              "end_column": 10805,
              "start_byte": 10780,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.Failed",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "onfigure(self, ",
              "start_line": 364,
              "start_column": 10810,
              "end_line": 4,
              "end_column": 10825,
              "start_byte": 10810,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
              "start_line": 366,
              "start_column": 10831,
              "end_line": 4,
              "end_column": 11652,
              "start_byte": 10831,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__repr__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
              "start_line": 386,
              "start_column": 11658,
              "end_line": 4,
              "end_column": 11938,
              "start_byte": 11658,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
              "start_line": 395,
              "start_column": 11944,
              "end_line": 4,
              "end_column": 12087,
              "start_byte": 11944,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectstart",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
              "start_line": 399,
              "start_column": 12093,
              "end_line": 4,
              "end_column": 12307,
              "start_byte": 12093,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_runtest_logreport",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
              "start_line": 406,
              "start_column": 12313,
              "end_line": 4,
              "end_column": 12675,
              "start_byte": 12313,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectreport",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "\n        if not foundanchor:\n            self._",
              "start_line": 414,
              "start_column": 12681,
              "end_line": 4,
              "end_column": 12728,
              "start_byte": 12681,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
              "start_line": 416,
              "start_column": 12734,
              "end_line": 4,
              "end_column": 12803,
              "start_byte": 12734,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
              "start_line": 419,
              "start_column": 12809,
              "end_line": 4,
              "end_column": 13381,
              "start_byte": 12809,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
              "start_line": 433,
              "start_column": 13387,
              "end_line": 4,
              "end_column": 13855,
              "start_byte": 13387,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
              "start_line": 446,
              "start_column": 13861,
              "end_line": 4,
              "end_column": 15034,
              "start_byte": 13861,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
              "start_line": 478,
              "start_column": 15040,
              "end_line": 4,
              "end_column": 15561,
              "start_byte": 15040,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
              "start_line": 492,
              "start_column": 15567,
              "end_line": 4,
              "end_column": 19267,
              "start_byte": 15567,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
              "start_line": 574,
              "start_column": 19273,
              "end_line": 4,
              "end_column": 20107,
              "start_byte": 19273,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._recurse",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
              "start_line": 596,
              "start_column": 20113,
              "end_line": 4,
              "end_column": 20609,
              "start_byte": 20113,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._visit_filter",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
              "start_line": 609,
              "start_column": 20615,
              "end_line": 4,
              "end_column": 20685,
              "start_byte": 20615,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
              "start_line": 613,
              "start_column": 20691,
              "end_line": 4,
              "end_column": 21295,
              "start_byte": 20691,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
              "start_line": 629,
              "start_column": 21301,
              "end_line": 4,
              "end_column": 21965,
              "start_byte": 21301,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.matchnodes",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
              "start_line": 645,
              "start_column": 21971,
              "end_line": 4,
              "end_column": 22355,
              "start_byte": 21971,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._matchnodes",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
              "start_line": 656,
              "start_column": 22361,
              "end_line": 4,
              "end_column": 24003,
              "start_byte": 22361,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.genitems",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
              "start_line": 693,
              "start_column": 24009,
              "end_line": 4,
              "end_column": 24478,
              "start_byte": 24009,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
              "start_line": 76,
              "start_column": 2812,
              "end_line": 0,
              "end_column": 3320,
              "start_byte": 2812,
              "end_byte": 0
            },
            {
              "name": "_pytest.pathlib.unique_path",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plug",
              "start_line": 339,
              "start_column": 10287,
              "end_line": 0,
              "end_column": 10582,
              "start_byte": 10287,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
              "start_line": 110,
              "start_column": 3366,
              "end_line": 0,
              "end_column": 3580,
              "start_byte": 3366,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "",
              "start_line": 1261,
              "start_column": 48043,
              "end_line": 0,
              "end_column": 49900,
              "start_byte": 48043,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
              "start_line": 80,
              "start_column": 2459,
              "end_line": 0,
              "end_column": 2594,
              "start_byte": 2459,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
              "start_line": 22,
              "start_column": 582,
              "end_line": 0,
              "end_column": 756,
              "start_byte": 582,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Analyzing the issue:\n1. The user reports an `ImportError` when loading `conftest` after upgrading to pytest 5.1.2. The error mentions a `ModuleNotFoundError` for the module named 'python', indicating a path issue.\n2. The issue is likely caused by path misconfiguration, possibly due to case sensitivity differences in file paths on Windows in the latest pytest version.\n3. In pytest 5.1.1, paths might have been handled correctly with case insensitivity, but changes in 5.1.2 could have introduced stricter handling.\n\nAnalyzing symbols:\n- `_pytest.config.main`: Calls `_prepareconfig` and handles `ConftestImportFailure`. This function is crucial as it constructs the configuration and might involve loading paths.\n- `_pytest.config._prepareconfig`: Prepares configuration using paths and plugins, likely affects how paths are interpreted, impacting module imports.\n- `_pytest.config.PytestPluginManager._importconftest`: Directly deals with importing `conftest.py`, and would handle path translations that could trigger case-sensitivity issues.\n- `_pytest.main.Session._collectfile` from `src/_pytest/main.py`: Manages file collections and might interact with how path cases are resolved during import.\n\nSymbols needing changes for resolution:\nI suspect modifications might be needed in path handling logic around `_importconftest`, potentially checking for case insensitivity in path loading. `_prepareconfig` might also require adjustments to how paths are collected or handled for imports.",
          "symbols": [
            {
              "name": "_pytest.config.PytestPluginManager._importconftest",
              "file_path": "src/_pytest/config/__init__.py",
              "reason": "Core function to handle conftest import, where path issues related to case sensitivity likely originate."
            },
            {
              "name": "_pytest.config._prepareconfig",
              "file_path": "src/_pytest/config/__init__.py",
              "reason": "Prepares the config potentially affecting path setup, crucial for differences in handling of paths."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "Skipping `_pytest.cacheprovider.pytest_cmdline_main` as it seems unrelated to path handling and conftest imports.",
            "Considering `_pytest.config.ConftestImportFailure` as it would wrap import errors but doesn't contribute to path resolution.",
            "Examining `_pytest.config.main`. It's central in processing commands and catching `ConftestImportFailure`, relevant but alteration likely less impactful.",
            "Ignoring `_pytest.config.cmdline.main` as redundant reference to `main`.",
            "Focusing on `_pytest.config._prepareconfig`. Its role in preparing configuration is vital and likely influences path handling.",
            "Analyzing `_pytest.config.PytestPluginManager._getconftestmodules`, relates to conftest path retrieval, touching on potential path casing issues.",
            "Detailed check of `_pytest.config.PytestPluginManager._importconftest` necessary, central to conftest import and path handling.",
            "Ignoring hookspec and logging sections as tangential to path handling.",
            "Skipping unrelated `ExitCode` definitions and other constants.",
            "Reviewing `_pytest.main.Session._collectfile` as it has a role in file path resolution during collect phase, potentially subject to case mis-matches."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/config/__init__.py"
        ],
        "symbols": [
          "_pytest.config.PytestPluginManager._importconftest",
          "_pytest.config._prepareconfig"
        ],
        "code_spans": {
          "_pytest.doctest.pytest_collect_file": {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_file": {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          "_pytest.main.Session._collectfile": {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          "_pytest.python.pytest_collect_file": {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          "_pytest.python.Module._importtestmodule": {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          "_pytest.python.Package._collectfile": {
            "name": "_pytest.python.Package._collectfile",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        if self.fspath == path:  # __init__.py\n            return [self]\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 601,
            "start_column": 22656,
            "end_line": 4,
            "end_column": 23564,
            "start_byte": 22656,
            "end_byte": 4
          },
          "_pytest.main.Session.gethookproxy": {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          "_pytest.main.Session._parsearg": {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          "_pytest.cacheprovider.pytest_cmdline_main": {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          "_pytest.config.ConftestImportFailure": {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          "_pytest.config.ConftestImportFailure.__init__": {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          "_pytest.config.main": {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          "_pytest.config.cmdline.main": {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          "_pytest.config._prepareconfig": {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          "_pytest.config.PytestPluginManager._getconftestmodules": {
            "name": "_pytest.config.PytestPluginManager._getconftestmodules",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "@lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist",
            "start_line": 398,
            "start_column": 13049,
            "end_line": 4,
            "end_column": 13926,
            "start_byte": 13049,
            "end_byte": 4
          },
          "_pytest.config.PytestPluginManager._importconftest": {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          "_pytest.helpconfig.pytest_cmdline_main": {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_cmdline_main": {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin._runtest_for_main": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          "_pytest.main.ExitCode": {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          "_pytest.main.ExitCode.OK": {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.TESTS_FAILED": {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.INTERRUPTED": {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.INTERNAL_ERROR": {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.USAGE_ERROR": {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.NO_TESTS_COLLECTED": {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          "_pytest.main.wrap_session": {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          "_pytest.main.pytest_cmdline_main": {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          "_pytest.main._main": {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection": {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          "_pytest.main.pytest_runtestloop": {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          "_pytest.main._in_venv": {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          "_pytest.main.pytest_ignore_collect": {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          "_pytest.main.FSHookProxy": {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          "_pytest.main.FSHookProxy.__init__": {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          "_pytest.main.FSHookProxy.__getattr__": {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          "_pytest.main.NoMatch": {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          "_pytest.main.Interrupted": {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          "_pytest.main.Interrupted.__module__": {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          "_pytest.main.Failed": {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          "_pytest.main._bestrelpath_cache": {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          "_pytest.main._bestrelpath_cache.path": {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          "_pytest.main._bestrelpath_cache.__missing__": {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          "_pytest.main.Session": {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          "_pytest.main.Session.Interrupted": {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          "_pytest.main.Session.Failed": {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          "_pytest.main.Session.__init__": {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          "_pytest.main.Session.__repr__": {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          "_pytest.main.Session._node_location_to_relpath": {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectstart": {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_runtest_logreport": {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectreport": {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          "_pytest.main.Session._recurse": {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          "_pytest.main.Session._visit_filter": {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          "_pytest.main.Session._tryconvertpyarg": {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          "_pytest.main.Session.matchnodes": {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          "_pytest.main.Session._matchnodes": {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          "_pytest.main.Session.genitems": {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          "_pytest.mark.pytest_cmdline_main": {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          "_pytest.pathlib.unique_path": {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plug",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          },
          "_pytest.python.pytest_cmdline_main": {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          "_pytest.python._showfixtures_main": {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_cmdline_main": {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_cmdline_main": {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          }
        }
      }
    }
  ]
}