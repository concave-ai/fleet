{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7521",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:46.966480",
        "usage": "1243.011236190796 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_py_ext_re",
          "_seen",
          "filename_arg",
          "Exception",
          "name2fixturedefs",
          "_create",
          "CollectErrorRepr",
          "resultlog",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "warning_types",
          "_legal_ranges",
          "get_scope_package",
          "param",
          "BINOP_MAP",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "_in_suspended",
          "evaluate_xfail_marks",
          "_get_active_fixturedef",
          "create_new_paste",
          "CHECKER_CLASS",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "AND",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_T",
          "get_extended_length_path_str",
          "_ensure_basetemp",
          "add_report_section",
          "_get_teardown_reports",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "_highlight",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "passed",
          "_REPORTCHARS_DEFAULT",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "_FixtureValue",
          "__repr__",
          "pytest_runtest_call",
          "unset_fixture",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "collect_one_node",
          "typename",
          "start",
          "capfdbinary",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "own_mark_names",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "PYTEST_TAG",
          "repr_locals",
          "illegal_xml_re",
          "wcswidth",
          "outcomes",
          "FakeCollectModule",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "_surrounding_parens_on_own_lines",
          "get_default_arg_names",
          "AssertionState",
          "_prepare_content",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "extraline",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "timing",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "sep",
          "_has_param_ids",
          "_determine_main_color",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "scopename2class",
          "cleanup_numbered_dir",
          "makepyprojecttoml",
          "pytest_collection_finish",
          "isinitpath",
          "_AnyPurePath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "_typ_map",
          "from_item_and_call",
          "prog",
          "_recurse",
          "_R",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "flush",
          "pytest_warning_captured",
          "__contains__",
          "_resolve_arg_ids",
          "stream",
          "FDCapture",
          "OK",
          "setdefault",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_stderr_fileno",
          "_get_allow_bytes_flag",
          "get_timeout_config_value",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "MarkMatcher",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "_get_multicapture",
          "File",
          "fail_fixturefunc",
          "not_expr",
          "AssertionRewriter",
          "FaultHandlerHooks",
          "IDENT",
          "__next__",
          "StoreKey",
          "PytestAssertRewriteWarning",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "old_mark_config_key",
          "write_ensure_prefix",
          "_for_parametrize",
          "Xfail",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "markup",
          "_is_last_item",
          "append_error",
          "pytest_unconfigure",
          "TeeCaptureIO",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "LPAREN",
          "_prunetraceback",
          "pytest_internalerror",
          "_update_message",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "pytest",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "lineno",
          "finish",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "try_makedirs",
          "caplog_handler_key",
          "getfixturedefs",
          "pytest_warning_recorded",
          "warn",
          "_py36_windowsconsoleio_workaround",
          "writeorg",
          "setitem",
          "findsource",
          "_handle_teardown_sections",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "Store",
          "_params_converter",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "NotSetType",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "addError",
          "call_fixture_func",
          "compile",
          "_names",
          "scope2index",
          "_Markable",
          "get_last_failed_paths",
          "emit",
          "_excinfo",
          "matching_platform",
          "and_expr",
          "accept",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_split_lines",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "NODE_USE_FROM_PARENT",
          "_start",
          "runitem",
          "records",
          "get_log_level_for_setting",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "_warn_or_fail_if_strict",
          "find_suffixes",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "RPAREN",
          "re_match_lines_random",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "_legal_chars",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "store",
          "Scanner",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "_set_main_color",
          "V",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "__slots__",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "_assert_expr_to_lineno",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "_S",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "_with_exception",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "_F",
          "makepyfile",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "NoMatch",
          "getreports",
          "assertstate_key",
          "short_test_summary",
          "_ensure_immutable_ids",
          "_param_ids_generated",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "_W",
          "add_property",
          "ids",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "width_of_current_line",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "_color_for_type",
          "rex_outcome",
          "_param_ids_from",
          "addFailure",
          "reportinfo",
          "fixture",
          "_get_pos",
          "_ET",
          "_NodeReporter",
          "patchsysdict",
          "MINUS_K_COLON",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "pastebinfile_key",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "async_warn_and_skip",
          "_report_kwargs_from_json",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "_expecting_failure",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "_compare_eq_any",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "_perform_collect",
          "expression",
          "add_stats",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_write_source",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "cache_key",
          "tmpdir",
          "__version__",
          "_E",
          "params",
          "TestReport",
          "Parser",
          "evaluate",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "resultlog_key",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "exitstatus",
          "listchain",
          "write_sep",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reject",
          "wrap_pytest_function_for_tracing",
          "reorder_items_atscope",
          "Metafunc",
          "reprcrash",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "_CACHE_PREFIX_DIRS",
          "message",
          "reset",
          "reprtraceback",
          "summary_warnings",
          "_esctable",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "_no_match_line",
          "ImportPathMismatchError",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_setupstate",
          "_get_plugin_specs_as_list",
          "_get_unknown_ini_keys",
          "_non_printable_ascii_translate_table",
          "inline_genitems",
          "_format_args",
          "TokenType",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "_check_non_top_pytest_plugins",
          "import_plugin",
          "__ne__",
          "ensure_extended_length_path",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "__dir__",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "filter_traceback_for_conftest_import_failure",
          "relline",
          "resolve_package_path",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "fullwidth",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "OR",
          "getfailures",
          "_write_entry_lines",
          "make_numbered_dir",
          "pytest_collectreport",
          "_Key",
          "NodeMeta",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "longrepr",
          "_format_assertmsg",
          "names",
          "repr_excinfo",
          "_idvalset",
          "_PluggyPlugin",
          "__attrs_post_init__",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "caplog_records_key",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "prepend",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "_get_auto_indent",
          "parse_setoption",
          "unexpectedsuccess_key",
          "compat",
          "ishidden",
          "find_prefixed",
          "_FixtureFunction",
          "create_module",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "JUNIT_XML_DEFAULT_FAMILY",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "TerminalWriter",
          "_assertion_pass",
          "addsection",
          "AlwaysDispatchingPrettyPrinter",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "validate_basetemp",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "FUNCARGNAMES",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "NO_TESTS_COLLECTED",
          "encoding",
          "ensure_newline",
          "exec_module",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "lines",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "locate_config",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "ParseError",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "no_header",
          "_getfailureheadline",
          "_read_pyc",
          "value",
          "K",
          "set_trace",
          "write",
          "_parse_filter",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "no_re_match_line",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "handleError",
          "istext",
          "_from_json",
          "SubRequest",
          "TERMINALWRITER_WRITER",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "ImportMode",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MINUS_K_DASH",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "Token",
          "FILLFUNCARGS",
          "reprentries",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "NOT",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "from_item",
          "write_line",
          "_get_runner",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "evaluate_skip_marks",
          "_fixturemanager",
          "_get_continue_on_failure",
          "invocation_dir",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "_LiveLoggingNullHandler",
          "lex",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "reason",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "_assert_state",
          "notify_exception",
          "_eval_scope_callable",
          "_strtobool",
          "formatrepr",
          "_validate_plugins",
          "_compare_eq_dict",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "from_exc_info",
          "is_globally_capturing",
          "_visit_filter",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "WARNING_CAPTURED_HOOK",
          "kwargs",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "IDENT_PREFIX",
          "junitxml",
          "getrawcode",
          "evaluate_condition",
          "reprlocals",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "writer",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "getworkerinfoline",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "xfailed_key",
          "get",
          "resume_capturing",
          "load_config_dict_from_file",
          "maybe_wrap_pytest_function_for_tracing",
          "__delitem__",
          "entrysep",
          "reprfuncargs",
          "get_fslocation_from_item",
          "section",
          "_match_lines_random",
          "_fail",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "import_path",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "hasopt",
          "LFPluginCollSkipfiles",
          "UNARY_MAP",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "_init_checker_class",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "on_rm_rf_error",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "_color_for_type_default",
          "_get_main_color",
          "PdbTrace",
          "symlink_or_skip",
          "pop",
          "Skip",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "_get_assertion_exprs",
          "_opentestcase",
          "no_fnmatch_line",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "_getlines",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "mkpydir",
          "from_parent",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "xml_key",
          "_make_plural",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "get_source",
          "popen",
          "T",
          "Notset",
          "fail",
          "debugging",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "skipped_by_mark_key",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "expr",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "safe_isclass",
          "_write_content",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "_NodeType",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "COLLECT_DIRECTORY_HOOK",
          "_runtest_for",
          "_validate_keys",
          "_format_lines",
          "_FileHandler",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "_FixtureCachedResult",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "_validate_ids",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "get_terminal_width",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "KeywordMatcher",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "KNOWN_TYPES",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "reprfileloc",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "_CACHE_PREFIX_VALUES",
          "DEFAULT_MAX_CHARS",
          "_parse_ini_config",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "_legal_xml_re",
          "assert_never",
          "_checkargnotcontained",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_enter_pdb",
          "_outrep_summary",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "wcwidth",
          "_WithException",
          "clear_cache",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "console_main",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "pos",
          "_is_skipped",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "strict",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "get_cache_dir",
          "record_testreport",
          "_add_stats",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "no_summary",
          "extract_suffixes",
          "TimeoutExpired",
          "should_do_markup",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "LFPluginCollWrapper",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "_ensure_relative_to_basetemp",
          "safeformat",
          "nose",
          "sections",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "_format",
          "EOF",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "cache",
          "Code",
          "_FixtureFunc",
          "Junit",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "set_fixture",
          "generic_visit",
          "fault_handler_stderr_key",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "_pformat_dispatch",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "token",
          "__call__",
          "instance",
          "get_optionflags",
          "visit_BoolOp",
          "duration",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "parse_summary_nouns",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "is_async_function",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "_gethookproxy",
          "call_and_report",
          "showfspath",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "MatcherAdapter",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "_HandlerType",
          "importlib",
          "listoutcomes",
          "exprinfo",
          "text",
          "_args_converter",
          "D",
          "_try_repr_or_str",
          "DoctestModule",
          "_write_pyc_fp",
          "XFailed",
          "Expression",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "capfd",
          "capfdbinary",
          "capture",
          "readouterr",
          "CaptureResult",
          "SysCapture"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:48.209502",
        "usage": "162.7650260925293 ms"
      },
      "request": {
        "tokens": [
          "capfd",
          "capfdbinary",
          "capture",
          "readouterr",
          "CaptureResult",
          "SysCapture"
        ]
      },
      "response": {
        "results": {
          "capture": [
            "src/_pytest/nodes.py",
            "src/_pytest/terminal.py",
            "src/_pytest/capture.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py"
          ],
          "readouterr": [
            "src/_pytest/capture.py",
            "src/_pytest/pytester.py"
          ],
          "SysCapture": [
            "src/_pytest/capture.py"
          ],
          "CaptureResult": [
            "src/_pytest/capture.py"
          ],
          "capfd": [
            "src/_pytest/capture.py"
          ],
          "capfdbinary": [
            "src/_pytest/capture.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:48.372281",
        "usage": "5383.7010860443115 ms"
      },
      "request": {
        "keyword_search_results": {
          "capture": [
            "src/_pytest/nodes.py",
            "src/_pytest/terminal.py",
            "src/_pytest/capture.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/python_api.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py"
          ],
          "readouterr": [
            "src/_pytest/capture.py",
            "src/_pytest/pytester.py"
          ],
          "SysCapture": [
            "src/_pytest/capture.py"
          ],
          "CaptureResult": [
            "src/_pytest/capture.py"
          ],
          "capfd": [
            "src/_pytest/capture.py"
          ],
          "capfdbinary": [
            "src/_pytest/capture.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue is regarding the behavior of `capfd.readouterr()` which seems to convert `\\r` to `\\n`. This method is part of the capturing functionality of pytest. Given this description, we need to locate the file or files responsible for capturing and the `readouterr` method specifically.\n\n1. **Keywords 'capture' and 'capfd':**\n   - The keyword 'capture' leads to multiple files but `src/_pytest/capture.py` appears to be the most relevant due to the context of the issue.\n   - 'capfd' specifically points to `src/_pytest/capture.py`, suggesting this file houses code dealing with `capfd` and capturing functionalities.\n\n2. **Keyword 'readouterr':**\n   - The `readouterr` is a clear function call in the issue, and it specifically directs us to `src/_pytest/capture.py` and `src/_pytest/pytester.py`.\n   - Since capturing and returning outputs is a central functionality likely housed within `capture.py`, this file is highly relevant.\n\n3. **Keywords 'SysCapture' and 'CaptureResult':**\n   - Both keywords are only found in `src/_pytest/capture.py`, suggesting this file contains implementations related to the capturing system and results, which are probably part of or called by `readouterr()` functionality.\n\nConsidering all these observations, the file `src/_pytest/capture.py` is most likely where the relevant code for this issue resides, as it covers various related keywords focusing on capture functionality and methods like `readouterr`.\n\nBased on this analysis, `src/_pytest/capture.py` is the only file necessary to look into for the issue with `capfd.readouterr()` changing carriage returns to newlines.",
        "file_paths": [
          "src/_pytest/capture.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:53.756061",
        "usage": "11595.7612991333 ms"
      },
      "request": {
        "file_path": "src/_pytest/capture.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue described is about `capfd.readouterr()` function of pytest 6.0.0rc1 converting carriage return '\\r' to newline '\\n', which causes tests to fail because they expect '\\r'.\n1.2 The user provides a reproducer that demonstrates the problem: a test that prints with an end carriage return and asserts that the output ends with '\\r'. The assertion fails in pytest 6.0.0rc1.\n1.3 This issue was likely caused by a change in the way pytest 6.0.0rc1 handles output capturing. It seems that instead of preserving the original line endings, it normalizes line endings to '\\n'.\n1.4 User expects the output to preserve '\\r' characters as it did in pytest 5.x, but pytest 6.0.0rc1 alters it, causing a regression that breaks tests relying on this behavior.\n1.5 Possible solutions include modifying pytest's capturing mechanism to preserve '\\r' or providing an option to disable this behavior.\n\n2. Make file evaluation:\n2.1 Analyze file content:\n- The core capturing mechanism seems to be within the classes `SysCapture`, `FDCapture`, and `MultiCapture`.\n- `CaptureFixture` and `CaptureManager` are responsible for setting up and managing the capture.\n- The capturing is handled through `snap` methods that fetch captured data, potentially altering line endings.\n2.2 Review methods in `CaptureFixture` and `MultiCapture` since they are central for capturing Logic.\n2.3 Check `CaptureFixture.readouterr` method since it's responsible for returning captured output and may alter '\\r'.\n2.4 Review how outputs are stored and retrieved in `CaptureIO`, `SysCapture`, and `FDCapture`.\n\n2.5 Verifying references:\n- The capturing mechanisms use `io.TextIOWrapper`, where newline conversion might occur, especially if \"newline=\" is altered during setup.\n- `CaptureIO` is configured with `newline=\"\"`, which should technically preserve line endings, but something might change it elsewhere.\n\n2.6 Determine if the file is the root cause:\n- It is plausible this file is the root cause, as it directly involves capturing I/O and the issue described.\n\n3. Decision:\n- The `readouterr()` method in `CaptureFixture` and related capturing classes could contain logic leading to the regression.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "CaptureFixture.readouterr",
          "CaptureFixture",
          "MultiCapture.snap",
          "SysCapture",
          "FDCapture"
        ],
        "root_cause_symbols": [
          "CaptureFixture.readouterr",
          "CaptureFixture",
          "MultiCapture.snap",
          "SysCapture",
          "FDCapture"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:05.351845",
        "usage": "58.435916900634766 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/capture.py",
            "relevant_symbol_keys": [
              "CaptureFixture.readouterr",
              "CaptureFixture",
              "MultiCapture.snap",
              "SysCapture",
              "FDCapture"
            ],
            "root_cause_symbol_keys": [
              "CaptureFixture.readouterr",
              "CaptureFixture",
              "MultiCapture.snap",
              "SysCapture",
              "FDCapture"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.capture.SysCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCaptureBinary:\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"\n\n    def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 251,
            "start_column": 7366,
            "end_line": 0,
            "end_column": 9959,
            "start_byte": 7366,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 253,
            "start_column": 7395,
            "end_line": 4,
            "end_column": 7413,
            "start_byte": 7395,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"",
            "start_line": 255,
            "start_column": 7419,
            "end_line": 4,
            "end_column": 7856,
            "start_byte": 7419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.repr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 267,
            "start_column": 7862,
            "end_line": 4,
            "end_column": 8143,
            "start_byte": 7862,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 276,
            "start_column": 8149,
            "end_line": 4,
            "end_column": 8430,
            "start_byte": 8149,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 285,
            "start_column": 8436,
            "end_line": 4,
            "end_column": 8675,
            "start_byte": 8436,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 292,
            "start_column": 8681,
            "end_line": 4,
            "end_column": 8837,
            "start_byte": 8681,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 297,
            "start_column": 8843,
            "end_line": 4,
            "end_column": 9069,
            "start_byte": 8843,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 305,
            "start_column": 9075,
            "end_line": 4,
            "end_column": 9358,
            "start_byte": 9075,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"",
            "start_line": 314,
            "start_column": 9364,
            "end_line": 4,
            "end_column": 9531,
            "start_byte": 9364,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 319,
            "start_column": 9537,
            "end_line": 4,
            "end_column": 9759,
            "start_byte": 9537,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 326,
            "start_column": 9765,
            "end_line": 4,
            "end_column": 9959,
            "start_byte": 9765,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]\n\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 333,
            "start_column": 9962,
            "end_line": 0,
            "end_column": 10338,
            "start_byte": 9962,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.SysCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 334,
            "start_column": 10002,
            "end_line": 4,
            "end_column": 10019,
            "start_byte": 10002,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 336,
            "start_column": 10053,
            "end_line": 4,
            "end_column": 10186,
            "start_byte": 10053,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 342,
            "start_column": 10192,
            "end_line": 4,
            "end_column": 10338,
            "start_byte": 10192,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces `bytes`\n    \"\"\"\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 348,
            "start_column": 10341,
            "end_line": 0,
            "end_column": 14635,
            "start_byte": 10341,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 354,
            "start_column": 10465,
            "end_line": 4,
            "end_column": 10483,
            "start_byte": 10465,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"",
            "start_line": 356,
            "start_column": 10489,
            "end_line": 4,
            "end_column": 12259,
            "start_byte": 10489,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 399,
            "start_column": 12265,
            "end_line": 4,
            "end_column": 12515,
            "start_byte": 12265,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 408,
            "start_column": 12521,
            "end_line": 4,
            "end_column": 12760,
            "start_byte": 12521,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"",
            "start_line": 415,
            "start_column": 12766,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 12766,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 422,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13263,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 430,
            "start_column": 13269,
            "end_line": 4,
            "end_column": 13903,
            "start_byte": 13269,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"",
            "start_line": 446,
            "start_column": 13909,
            "end_line": 4,
            "end_column": 14176,
            "start_byte": 13909,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"",
            "start_line": 454,
            "start_column": 14182,
            "end_line": 4,
            "end_column": 14445,
            "start_byte": 14182,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 462,
            "start_column": 14451,
            "end_line": 4,
            "end_column": 14635,
            "start_byte": 14451,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 468,
            "start_column": 14638,
            "end_line": 0,
            "end_column": 15275,
            "start_byte": 14638,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.FDCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 475,
            "start_column": 14849,
            "end_line": 4,
            "end_column": 14866,
            "start_byte": 14849,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 477,
            "start_column": 14888,
            "end_line": 4,
            "end_column": 15107,
            "start_byte": 14888,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 485,
            "start_column": 15113,
            "end_line": 4,
            "end_column": 15275,
            "start_byte": 15113,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class CaptureFixture:\n    \"\"\"\n    Object returned by :py:func:`capsys`, :py:func:`capsysbinary`, :py:func:`capfd` and :py:func:`capfdbinary`\n    fixtures.\n    \"\"\"\n\n    def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n\n    def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()\n\n    def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None\n\n    def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)\n\n    def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()\n\n    def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()\n\n    @contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 759,
            "start_column": 24437,
            "end_line": 0,
            "end_column": 26743,
            "start_byte": 24437,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER",
            "start_line": 765,
            "start_column": 24605,
            "end_line": 4,
            "end_column": 24920,
            "start_byte": 24605,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()",
            "start_line": 772,
            "start_column": 24926,
            "end_line": 4,
            "end_column": 25163,
            "start_byte": 24926,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.close",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None",
            "start_line": 779,
            "start_column": 25169,
            "end_line": 4,
            "end_column": 25441,
            "start_byte": 25169,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.readouterr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)",
            "start_line": 787,
            "start_column": 25447,
            "end_line": 4,
            "end_column": 26065,
            "start_byte": 25447,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()",
            "start_line": 801,
            "start_column": 26071,
            "end_line": 4,
            "end_column": 26247,
            "start_byte": 26071,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()",
            "start_line": 806,
            "start_column": 26253,
            "end_line": 4,
            "end_column": 26426,
            "start_byte": 26253,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.disabled",
            "file_path": "src/_pytest/capture.py",
            "file_content": "@contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 811,
            "start_column": 26432,
            "end_line": 4,
            "end_column": 26743,
            "start_byte": 26432,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "lf.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state = None\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n        ",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/capture.py",
            "file_content": "  write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfil",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/capture.py",
            "file_content": ">\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n      ",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "   def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        ",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/capture.py",
            "file_content": "state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buf",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ad()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, ",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/capture.py",
            "file_content": "e streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n        ",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/capture.py",
            "file_content": " self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    ",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/capture.py",
            "file_content": "iteorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"s",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ed\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state ",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:05.410287",
        "usage": "11396.657943725586 ms"
      },
      "request": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.capture.SysCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCaptureBinary:\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"\n\n    def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 251,
            "start_column": 7366,
            "end_line": 0,
            "end_column": 9959,
            "start_byte": 7366,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 253,
            "start_column": 7395,
            "end_line": 4,
            "end_column": 7413,
            "start_byte": 7395,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"",
            "start_line": 255,
            "start_column": 7419,
            "end_line": 4,
            "end_column": 7856,
            "start_byte": 7419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.repr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 267,
            "start_column": 7862,
            "end_line": 4,
            "end_column": 8143,
            "start_byte": 7862,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 276,
            "start_column": 8149,
            "end_line": 4,
            "end_column": 8430,
            "start_byte": 8149,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 285,
            "start_column": 8436,
            "end_line": 4,
            "end_column": 8675,
            "start_byte": 8436,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 292,
            "start_column": 8681,
            "end_line": 4,
            "end_column": 8837,
            "start_byte": 8681,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 297,
            "start_column": 8843,
            "end_line": 4,
            "end_column": 9069,
            "start_byte": 8843,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 305,
            "start_column": 9075,
            "end_line": 4,
            "end_column": 9358,
            "start_byte": 9075,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"",
            "start_line": 314,
            "start_column": 9364,
            "end_line": 4,
            "end_column": 9531,
            "start_byte": 9364,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 319,
            "start_column": 9537,
            "end_line": 4,
            "end_column": 9759,
            "start_byte": 9537,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 326,
            "start_column": 9765,
            "end_line": 4,
            "end_column": 9959,
            "start_byte": 9765,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]\n\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 333,
            "start_column": 9962,
            "end_line": 0,
            "end_column": 10338,
            "start_byte": 9962,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.SysCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 334,
            "start_column": 10002,
            "end_line": 4,
            "end_column": 10019,
            "start_byte": 10002,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 336,
            "start_column": 10053,
            "end_line": 4,
            "end_column": 10186,
            "start_byte": 10053,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.SysCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 342,
            "start_column": 10192,
            "end_line": 4,
            "end_column": 10338,
            "start_byte": 10192,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces `bytes`\n    \"\"\"\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 348,
            "start_column": 10341,
            "end_line": 0,
            "end_column": 14635,
            "start_byte": 10341,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 354,
            "start_column": 10465,
            "end_line": 4,
            "end_column": 10483,
            "start_byte": 10465,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"",
            "start_line": 356,
            "start_column": 10489,
            "end_line": 4,
            "end_column": 12259,
            "start_byte": 10489,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 399,
            "start_column": 12265,
            "end_line": 4,
            "end_column": 12515,
            "start_byte": 12265,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 408,
            "start_column": 12521,
            "end_line": 4,
            "end_column": 12760,
            "start_byte": 12521,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"",
            "start_line": 415,
            "start_column": 12766,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 12766,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 422,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13263,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 430,
            "start_column": 13269,
            "end_line": 4,
            "end_column": 13903,
            "start_byte": 13269,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"",
            "start_line": 446,
            "start_column": 13909,
            "end_line": 4,
            "end_column": 14176,
            "start_byte": 13909,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"",
            "start_line": 454,
            "start_column": 14182,
            "end_line": 4,
            "end_column": 14445,
            "start_byte": 14182,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 462,
            "start_column": 14451,
            "end_line": 4,
            "end_column": 14635,
            "start_byte": 14451,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 468,
            "start_column": 14638,
            "end_line": 0,
            "end_column": 15275,
            "start_byte": 14638,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.FDCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 475,
            "start_column": 14849,
            "end_line": 4,
            "end_column": 14866,
            "start_byte": 14849,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 477,
            "start_column": 14888,
            "end_line": 4,
            "end_column": 15107,
            "start_byte": 14888,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.FDCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 485,
            "start_column": 15113,
            "end_line": 4,
            "end_column": 15275,
            "start_byte": 15113,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class CaptureFixture:\n    \"\"\"\n    Object returned by :py:func:`capsys`, :py:func:`capsysbinary`, :py:func:`capfd` and :py:func:`capfdbinary`\n    fixtures.\n    \"\"\"\n\n    def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n\n    def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()\n\n    def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None\n\n    def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)\n\n    def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()\n\n    def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()\n\n    @contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 759,
            "start_column": 24437,
            "end_line": 0,
            "end_column": 26743,
            "start_byte": 24437,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.CaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER",
            "start_line": 765,
            "start_column": 24605,
            "end_line": 4,
            "end_column": 24920,
            "start_byte": 24605,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()",
            "start_line": 772,
            "start_column": 24926,
            "end_line": 4,
            "end_column": 25163,
            "start_byte": 24926,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.close",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None",
            "start_line": 779,
            "start_column": 25169,
            "end_line": 4,
            "end_column": 25441,
            "start_byte": 25169,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.readouterr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)",
            "start_line": 787,
            "start_column": 25447,
            "end_line": 4,
            "end_column": 26065,
            "start_byte": 25447,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()",
            "start_line": 801,
            "start_column": 26071,
            "end_line": 4,
            "end_column": 26247,
            "start_byte": 26071,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture._resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()",
            "start_line": 806,
            "start_column": 26253,
            "end_line": 4,
            "end_column": 26426,
            "start_byte": 26253,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureFixture.disabled",
            "file_path": "src/_pytest/capture.py",
            "file_content": "@contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 811,
            "start_column": 26432,
            "end_line": 4,
            "end_column": 26743,
            "start_byte": 26432,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "lf.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state = None\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n        ",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/capture.py",
            "file_content": "  write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfil",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/capture.py",
            "file_content": ">\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n      ",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "   def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        ",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/capture.py",
            "file_content": "state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buf",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ad()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, ",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/capture.py",
            "file_content": "e streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n        ",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/capture.py",
            "file_content": " self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    ",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/capture.py",
            "file_content": "iteorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"s",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ed\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state ",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an issue where `capfd.readouterr()` in pytest 6.0.0rc1 converts `\\r` (carriage returns) to `\\n` (new lines), causing assertion errors in tests comparing expected output with carriage returns.\n1.2 The issue seems to be caused by a change in how pytest captures output between versions 5 and 6, potentially in the way captured output is stored or processed internally.\n1.3 The expected result, based on the given test cases, is that `capfd.readouterr()` should return the output with the original carriage returns intact.\n1.4 If the user did not provide an expected result, one would expect `capfd.readouterr()` to preserve the exact format of the output, including carriage returns (`\\r`), without conversion to new lines (`\\n`).\n1.5 The likely area for fixing is within the capture mechanism of pytest, particularly how strings are read and written to temporary files or buffers.\n\n2. Make the evaluation:\n2.1 Reviewed the provided symbols for how they handle output capture.\n2.2 The issue is likely in the classes and methods related to capturing stdout/stderr, particularly in how it processes carriage return characters.\n2.3 Symbols like `SysCaptureBinary`, `SysCapture`, `CaptureFixture`, and similar classes related to capturing may be involved.\n2.4 Based on the inspection of methods like `snap`, `writeorg`, and buffer manipulations, these seem relevant.\n2.5 Since there is no explicit handling for carriage return characters being converted to new lines, an investigation or alteration may be required in methods dealing with reading and writing captured data.\n2.6 Therefore, I will list changes to methods that handle direct reading from temporary files or buffers and ensure handling for carriage return characters.\n\n3. Symbols selected for change:\n- The potential targets for changes could include methods responsible for output handling within `SysCapture`, `FDCapture`, and related classes.",
        "symbols": [
          {
            "name": "_pytest.capture.SysCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "reason": "Modification needed to ensure that captured buffer content maintains carriage return characters instead of replacing them with new lines."
          },
          {
            "name": "_pytest.capture.SysCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "reason": "This snap function is intended to work with text data. It needs adjustment to ensure that handling of '\\r' to '\\n' conversion is controlled based on intended behavior."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "The `SysCaptureBinary.snap` method has a critical role in handling captured binary output. It reads the content of `tmpfile` into a byte string and truncates the file. Since the issue involves carriage returns turning into new lines, altering how this method handles and reads from the buffer could be a key to resolving the problem.",
          "The `SysCapture.snap` method is similar, but for handling text outputs. As text handling could introduce conversion of '\\r' to '\\n', ensuring the preservation of '\\r' in text operations is crucial."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:16.806960",
        "usage": "2.460002899169922 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [],
          "root_caused_symbols": [
            {
              "name": "_pytest.capture.SysCaptureBinary",
              "file_path": "src/_pytest/capture.py",
              "file_content": "class SysCaptureBinary:\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"\n\n    def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
              "start_line": 251,
              "start_column": 7366,
              "end_line": 0,
              "end_column": 9959,
              "start_byte": 7366,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.EMPTY_BUFFER",
              "file_path": "src/_pytest/capture.py",
              "file_content": "EMPTY_BUFFER = b\"\"",
              "start_line": 253,
              "start_column": 7395,
              "end_line": 4,
              "end_column": 7413,
              "start_byte": 7395,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.__init__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"",
              "start_line": 255,
              "start_column": 7419,
              "end_line": 4,
              "end_column": 7856,
              "start_byte": 7419,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.repr",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
              "start_line": 267,
              "start_column": 7862,
              "end_line": 4,
              "end_column": 8143,
              "start_byte": 7862,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.__repr__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
              "start_line": 276,
              "start_column": 8149,
              "end_line": 4,
              "end_column": 8430,
              "start_byte": 8149,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary._assert_state",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
              "start_line": 285,
              "start_column": 8436,
              "end_line": 4,
              "end_column": 8675,
              "start_byte": 8436,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.start",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
              "start_line": 292,
              "start_column": 8681,
              "end_line": 4,
              "end_column": 8837,
              "start_byte": 8681,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.snap",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
              "start_line": 297,
              "start_column": 8843,
              "end_line": 4,
              "end_column": 9069,
              "start_byte": 8843,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.done",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"",
              "start_line": 305,
              "start_column": 9075,
              "end_line": 4,
              "end_column": 9358,
              "start_byte": 9075,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.suspend",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"",
              "start_line": 314,
              "start_column": 9364,
              "end_line": 4,
              "end_column": 9531,
              "start_byte": 9364,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.resume",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
              "start_line": 319,
              "start_column": 9537,
              "end_line": 4,
              "end_column": 9759,
              "start_byte": 9537,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCaptureBinary.writeorg",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
              "start_line": 326,
              "start_column": 9765,
              "end_line": 4,
              "end_column": 9959,
              "start_byte": 9765,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCapture",
              "file_path": "src/_pytest/capture.py",
              "file_content": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]\n\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
              "start_line": 333,
              "start_column": 9962,
              "end_line": 0,
              "end_column": 10338,
              "start_byte": 9962,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.SysCapture.EMPTY_BUFFER",
              "file_path": "src/_pytest/capture.py",
              "file_content": "EMPTY_BUFFER = \"\"",
              "start_line": 334,
              "start_column": 10002,
              "end_line": 4,
              "end_column": 10019,
              "start_byte": 10002,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCapture.snap",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
              "start_line": 336,
              "start_column": 10053,
              "end_line": 4,
              "end_column": 10186,
              "start_byte": 10053,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.SysCapture.writeorg",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
              "start_line": 342,
              "start_column": 10192,
              "end_line": 4,
              "end_column": 10338,
              "start_byte": 10192,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary",
              "file_path": "src/_pytest/capture.py",
              "file_content": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces `bytes`\n    \"\"\"\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
              "start_line": 348,
              "start_column": 10341,
              "end_line": 0,
              "end_column": 14635,
              "start_byte": 10341,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.EMPTY_BUFFER",
              "file_path": "src/_pytest/capture.py",
              "file_content": "EMPTY_BUFFER = b\"\"",
              "start_line": 354,
              "start_column": 10465,
              "end_line": 4,
              "end_column": 10483,
              "start_byte": 10465,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.__init__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"",
              "start_line": 356,
              "start_column": 10489,
              "end_line": 4,
              "end_column": 12259,
              "start_byte": 10489,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.__repr__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )",
              "start_line": 399,
              "start_column": 12265,
              "end_line": 4,
              "end_column": 12515,
              "start_byte": 12265,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary._assert_state",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
              "start_line": 408,
              "start_column": 12521,
              "end_line": 4,
              "end_column": 12760,
              "start_byte": 12521,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.start",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"",
              "start_line": 415,
              "start_column": 12766,
              "end_line": 4,
              "end_column": 13031,
              "start_byte": 12766,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.snap",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
              "start_line": 422,
              "start_column": 13037,
              "end_line": 4,
              "end_column": 13263,
              "start_byte": 13037,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.done",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"",
              "start_line": 430,
              "start_column": 13269,
              "end_line": 4,
              "end_column": 13903,
              "start_byte": 13269,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.suspend",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"",
              "start_line": 446,
              "start_column": 13909,
              "end_line": 4,
              "end_column": 14176,
              "start_byte": 13909,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.resume",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"",
              "start_line": 454,
              "start_column": 14182,
              "end_line": 4,
              "end_column": 14445,
              "start_byte": 14182,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCaptureBinary.writeorg",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
              "start_line": 462,
              "start_column": 14451,
              "end_line": 4,
              "end_column": 14635,
              "start_byte": 14451,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCapture",
              "file_path": "src/_pytest/capture.py",
              "file_content": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
              "start_line": 468,
              "start_column": 14638,
              "end_line": 0,
              "end_column": 15275,
              "start_byte": 14638,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.FDCapture.EMPTY_BUFFER",
              "file_path": "src/_pytest/capture.py",
              "file_content": "EMPTY_BUFFER = \"\"",
              "start_line": 475,
              "start_column": 14849,
              "end_line": 4,
              "end_column": 14866,
              "start_byte": 14849,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCapture.snap",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
              "start_line": 477,
              "start_column": 14888,
              "end_line": 4,
              "end_column": 15107,
              "start_byte": 14888,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.FDCapture.writeorg",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
              "start_line": 485,
              "start_column": 15113,
              "end_line": 4,
              "end_column": 15275,
              "start_byte": 15113,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture",
              "file_path": "src/_pytest/capture.py",
              "file_content": "class CaptureFixture:\n    \"\"\"\n    Object returned by :py:func:`capsys`, :py:func:`capsysbinary`, :py:func:`capfd` and :py:func:`capfdbinary`\n    fixtures.\n    \"\"\"\n\n    def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n\n    def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()\n\n    def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None\n\n    def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)\n\n    def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()\n\n    def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()\n\n    @contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
              "start_line": 759,
              "start_column": 24437,
              "end_line": 0,
              "end_column": 26743,
              "start_byte": 24437,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.CaptureFixture.__init__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER",
              "start_line": 765,
              "start_column": 24605,
              "end_line": 4,
              "end_column": 24920,
              "start_byte": 24605,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture._start",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()",
              "start_line": 772,
              "start_column": 24926,
              "end_line": 4,
              "end_column": 25163,
              "start_byte": 24926,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture.close",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None",
              "start_line": 779,
              "start_column": 25169,
              "end_line": 4,
              "end_column": 25441,
              "start_byte": 25169,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture.readouterr",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)",
              "start_line": 787,
              "start_column": 25447,
              "end_line": 4,
              "end_column": 26065,
              "start_byte": 25447,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture._suspend",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()",
              "start_line": 801,
              "start_column": 26071,
              "end_line": 4,
              "end_column": 26247,
              "start_byte": 26071,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture._resume",
              "file_path": "src/_pytest/capture.py",
              "file_content": "def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()",
              "start_line": 806,
              "start_column": 26253,
              "end_line": 4,
              "end_column": 26426,
              "start_byte": 26253,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureFixture.disabled",
              "file_path": "src/_pytest/capture.py",
              "file_content": "@contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
              "start_line": 811,
              "start_column": 26432,
              "end_line": 4,
              "end_column": 26743,
              "start_byte": 26432,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture",
              "file_path": "src/_pytest/capture.py",
              "file_content": "lf.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state = None\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
              "start_line": 340,
              "start_column": 11698,
              "end_line": 0,
              "end_column": 16210,
              "start_byte": 11698,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.__init__",
              "file_path": "src/_pytest/capture.py",
              "file_content": "ile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n        ",
              "start_line": 343,
              "start_column": 11784,
              "end_line": 4,
              "end_column": 12007,
              "start_byte": 11784,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture._finalize",
              "file_path": "src/_pytest/capture.py",
              "file_content": "  write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfil",
              "start_line": 349,
              "start_column": 12013,
              "end_line": 4,
              "end_column": 12342,
              "start_byte": 12013,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.handler",
              "file_path": "src/_pytest/capture.py",
              "file_content": ">\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n      ",
              "start_line": 359,
              "start_column": 12348,
              "end_line": 4,
              "end_column": 12512,
              "start_byte": 12348,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.get_records",
              "file_path": "src/_pytest/capture.py",
              "file_content": "   def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        ",
              "start_line": 366,
              "start_column": 12518,
              "end_line": 4,
              "end_column": 13008,
              "start_byte": 12518,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.text",
              "file_path": "src/_pytest/capture.py",
              "file_content": "state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buf",
              "start_line": 380,
              "start_column": 13014,
              "end_line": 4,
              "end_column": 13173,
              "start_byte": 13014,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.records",
              "file_path": "src/_pytest/capture.py",
              "file_content": "ad()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, ",
              "start_line": 385,
              "start_column": 13179,
              "end_line": 4,
              "end_column": 13321,
              "start_byte": 13179,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.record_tuples",
              "file_path": "src/_pytest/capture.py",
              "file_content": "e streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n        ",
              "start_line": 390,
              "start_column": 13327,
              "end_line": 4,
              "end_column": 13684,
              "start_byte": 13327,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.messages",
              "file_path": "src/_pytest/capture.py",
              "file_content": " self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    ",
              "start_line": 401,
              "start_column": 13690,
              "end_line": 4,
              "end_column": 14451,
              "start_byte": 13690,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.clear",
              "file_path": "src/_pytest/capture.py",
              "file_content": "iteorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"s",
              "start_line": 417,
              "start_column": 14457,
              "end_line": 4,
              "end_column": 14581,
              "start_byte": 14457,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.set_level",
              "file_path": "src/_pytest/capture.py",
              "file_content": "ed\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state ",
              "start_line": 421,
              "start_column": 14587,
              "end_line": 4,
              "end_column": 15399,
              "start_byte": 14587,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.at_level",
              "file_path": "src/_pytest/capture.py",
              "file_content": "\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
              "start_line": 438,
              "start_column": 15405,
              "end_line": 4,
              "end_column": 16210,
              "start_byte": 15405,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an issue where `capfd.readouterr()` in pytest 6.0.0rc1 converts `\\r` (carriage returns) to `\\n` (new lines), causing assertion errors in tests comparing expected output with carriage returns.\n1.2 The issue seems to be caused by a change in how pytest captures output between versions 5 and 6, potentially in the way captured output is stored or processed internally.\n1.3 The expected result, based on the given test cases, is that `capfd.readouterr()` should return the output with the original carriage returns intact.\n1.4 If the user did not provide an expected result, one would expect `capfd.readouterr()` to preserve the exact format of the output, including carriage returns (`\\r`), without conversion to new lines (`\\n`).\n1.5 The likely area for fixing is within the capture mechanism of pytest, particularly how strings are read and written to temporary files or buffers.\n\n2. Make the evaluation:\n2.1 Reviewed the provided symbols for how they handle output capture.\n2.2 The issue is likely in the classes and methods related to capturing stdout/stderr, particularly in how it processes carriage return characters.\n2.3 Symbols like `SysCaptureBinary`, `SysCapture`, `CaptureFixture`, and similar classes related to capturing may be involved.\n2.4 Based on the inspection of methods like `snap`, `writeorg`, and buffer manipulations, these seem relevant.\n2.5 Since there is no explicit handling for carriage return characters being converted to new lines, an investigation or alteration may be required in methods dealing with reading and writing captured data.\n2.6 Therefore, I will list changes to methods that handle direct reading from temporary files or buffers and ensure handling for carriage return characters.\n\n3. Symbols selected for change:\n- The potential targets for changes could include methods responsible for output handling within `SysCapture`, `FDCapture`, and related classes.",
          "symbols": [
            {
              "name": "_pytest.capture.SysCaptureBinary.snap",
              "file_path": "src/_pytest/capture.py",
              "reason": "Modification needed to ensure that captured buffer content maintains carriage return characters instead of replacing them with new lines."
            },
            {
              "name": "_pytest.capture.SysCapture.snap",
              "file_path": "src/_pytest/capture.py",
              "reason": "This snap function is intended to work with text data. It needs adjustment to ensure that handling of '\\r' to '\\n' conversion is controlled based on intended behavior."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "The `SysCaptureBinary.snap` method has a critical role in handling captured binary output. It reads the content of `tmpfile` into a byte string and truncates the file. Since the issue involves carriage returns turning into new lines, altering how this method handles and reads from the buffer could be a key to resolving the problem.",
            "The `SysCapture.snap` method is similar, but for handling text outputs. As text handling could introduce conversion of '\\r' to '\\n', ensuring the preservation of '\\r' in text operations is crucial."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/capture.py"
        ],
        "symbols": [
          "_pytest.capture.SysCaptureBinary.snap",
          "_pytest.capture.SysCapture.snap"
        ],
        "code_spans": {
          "_pytest.capture.SysCaptureBinary": {
            "name": "_pytest.capture.SysCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCaptureBinary:\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"\n\n    def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"\n\n    def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 251,
            "start_column": 7366,
            "end_line": 0,
            "end_column": 9959,
            "start_byte": 7366,
            "end_byte": 0
          },
          "_pytest.capture.SysCaptureBinary.EMPTY_BUFFER": {
            "name": "_pytest.capture.SysCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 253,
            "start_column": 7395,
            "end_line": 4,
            "end_column": 7413,
            "start_byte": 7395,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.__init__": {
            "name": "_pytest.capture.SysCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, fd: int, tmpfile=None, *, tee: bool = False) -> None:\n        name = patchsysdict[fd]\n        self._old = getattr(sys, name)\n        self.name = name\n        if tmpfile is None:\n            if name == \"stdin\":\n                tmpfile = DontReadFromInput()\n            else:\n                tmpfile = CaptureIO() if not tee else TeeCaptureIO(self._old)\n        self.tmpfile = tmpfile\n        self._state = \"initialized\"",
            "start_line": 255,
            "start_column": 7419,
            "end_line": 4,
            "end_column": 7856,
            "start_byte": 7419,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.repr": {
            "name": "_pytest.capture.SysCaptureBinary.repr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def repr(self, class_name: str) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            class_name,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 267,
            "start_column": 7862,
            "end_line": 4,
            "end_column": 8143,
            "start_byte": 7862,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.__repr__": {
            "name": "_pytest.capture.SysCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} _old={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.name,\n            hasattr(self, \"_old\") and repr(self._old) or \"<UNSET>\",\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 276,
            "start_column": 8149,
            "end_line": 4,
            "end_column": 8430,
            "start_byte": 8149,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary._assert_state": {
            "name": "_pytest.capture.SysCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 285,
            "start_column": 8436,
            "end_line": 4,
            "end_column": 8675,
            "start_byte": 8436,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.start": {
            "name": "_pytest.capture.SysCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        self._assert_state(\"start\", (\"initialized\",))\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 292,
            "start_column": 8681,
            "end_line": 4,
            "end_column": 8837,
            "start_byte": 8681,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.snap": {
            "name": "_pytest.capture.SysCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 297,
            "start_column": 8843,
            "end_line": 4,
            "end_column": 9069,
            "start_byte": 8843,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.done": {
            "name": "_pytest.capture.SysCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        setattr(sys, self.name, self._old)\n        del self._old\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 305,
            "start_column": 9075,
            "end_line": 4,
            "end_column": 9358,
            "start_byte": 9075,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.suspend": {
            "name": "_pytest.capture.SysCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        setattr(sys, self.name, self._old)\n        self._state = \"suspended\"",
            "start_line": 314,
            "start_column": 9364,
            "end_line": 4,
            "end_column": 9531,
            "start_byte": 9364,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.resume": {
            "name": "_pytest.capture.SysCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        setattr(sys, self.name, self.tmpfile)\n        self._state = \"started\"",
            "start_line": 319,
            "start_column": 9537,
            "end_line": 4,
            "end_column": 9759,
            "start_byte": 9537,
            "end_byte": 4
          },
          "_pytest.capture.SysCaptureBinary.writeorg": {
            "name": "_pytest.capture.SysCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data) -> None:\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.flush()\n        self._old.buffer.write(data)\n        self._old.buffer.flush()",
            "start_line": 326,
            "start_column": 9765,
            "end_line": 4,
            "end_column": 9959,
            "start_byte": 9765,
            "end_byte": 4
          },
          "_pytest.capture.SysCapture": {
            "name": "_pytest.capture.SysCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class SysCapture(SysCaptureBinary):\n    EMPTY_BUFFER = \"\"  # type: ignore[assignment]\n\n    def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 333,
            "start_column": 9962,
            "end_line": 0,
            "end_column": 10338,
            "start_byte": 9962,
            "end_byte": 0
          },
          "_pytest.capture.SysCapture.EMPTY_BUFFER": {
            "name": "_pytest.capture.SysCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 334,
            "start_column": 10002,
            "end_line": 4,
            "end_column": 10019,
            "start_byte": 10002,
            "end_byte": 4
          },
          "_pytest.capture.SysCapture.snap": {
            "name": "_pytest.capture.SysCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        res = self.tmpfile.getvalue()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 336,
            "start_column": 10053,
            "end_line": 4,
            "end_column": 10186,
            "start_byte": 10053,
            "end_byte": 4
          },
          "_pytest.capture.SysCapture.writeorg": {
            "name": "_pytest.capture.SysCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        self._old.write(data)\n        self._old.flush()",
            "start_line": 342,
            "start_column": 10192,
            "end_line": 4,
            "end_column": 10338,
            "start_byte": 10192,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary": {
            "name": "_pytest.capture.FDCaptureBinary",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCaptureBinary:\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces `bytes`\n    \"\"\"\n\n    EMPTY_BUFFER = b\"\"\n\n    def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 348,
            "start_column": 10341,
            "end_line": 0,
            "end_column": 14635,
            "start_byte": 10341,
            "end_byte": 0
          },
          "_pytest.capture.FDCaptureBinary.EMPTY_BUFFER": {
            "name": "_pytest.capture.FDCaptureBinary.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = b\"\"",
            "start_line": 354,
            "start_column": 10465,
            "end_line": 4,
            "end_column": 10483,
            "start_byte": 10465,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.__init__": {
            "name": "_pytest.capture.FDCaptureBinary.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, targetfd: int) -> None:\n        self.targetfd = targetfd\n\n        try:\n            os.fstat(targetfd)\n        except OSError:\n            # FD capturing is conceptually simple -- create a temporary file,\n            # redirect the FD to it, redirect back when done. But when the\n            # target FD is invalid it throws a wrench into this loveley scheme.\n            #\n            # Tests themselves shouldn't care if the FD is valid, FD capturing\n            # should work regardless of external circumstances. So falling back\n            # to just sys capturing is not a good option.\n            #\n            # Further complications are the need to support suspend() and the\n            # possibility of FD reuse (e.g. the tmpfile getting the very same\n            # target FD). The following approach is robust, I believe.\n            self.targetfd_invalid = os.open(\n                os.devnull, os.O_RDWR\n            )  # type: Optional[int]\n            os.dup2(self.targetfd_invalid, targetfd)\n        else:\n            self.targetfd_invalid = None\n        self.targetfd_save = os.dup(targetfd)\n\n        if targetfd == 0:\n            self.tmpfile = open(os.devnull)\n            self.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"",
            "start_line": 356,
            "start_column": 10489,
            "end_line": 4,
            "end_column": 12259,
            "start_byte": 10489,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.__repr__": {
            "name": "_pytest.capture.FDCaptureBinary.__repr__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )",
            "start_line": 399,
            "start_column": 12265,
            "end_line": 4,
            "end_column": 12515,
            "start_byte": 12265,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary._assert_state": {
            "name": "_pytest.capture.FDCaptureBinary._assert_state",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )",
            "start_line": 408,
            "start_column": 12521,
            "end_line": 4,
            "end_column": 12760,
            "start_byte": 12521,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.start": {
            "name": "_pytest.capture.FDCaptureBinary.start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"",
            "start_line": 415,
            "start_column": 12766,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 12766,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.snap": {
            "name": "_pytest.capture.FDCaptureBinary.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 422,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13263,
            "start_byte": 13037,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.done": {
            "name": "_pytest.capture.FDCaptureBinary.done",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"",
            "start_line": 430,
            "start_column": 13269,
            "end_line": 4,
            "end_column": 13903,
            "start_byte": 13269,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.suspend": {
            "name": "_pytest.capture.FDCaptureBinary.suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"",
            "start_line": 446,
            "start_column": 13909,
            "end_line": 4,
            "end_column": 14176,
            "start_byte": 13909,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.resume": {
            "name": "_pytest.capture.FDCaptureBinary.resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"",
            "start_line": 454,
            "start_column": 14182,
            "end_line": 4,
            "end_column": 14445,
            "start_byte": 14182,
            "end_byte": 4
          },
          "_pytest.capture.FDCaptureBinary.writeorg": {
            "name": "_pytest.capture.FDCaptureBinary.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)",
            "start_line": 462,
            "start_column": 14451,
            "end_line": 4,
            "end_column": 14635,
            "start_byte": 14451,
            "end_byte": 4
          },
          "_pytest.capture.FDCapture": {
            "name": "_pytest.capture.FDCapture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 468,
            "start_column": 14638,
            "end_line": 0,
            "end_column": 15275,
            "start_byte": 14638,
            "end_byte": 0
          },
          "_pytest.capture.FDCapture.EMPTY_BUFFER": {
            "name": "_pytest.capture.FDCapture.EMPTY_BUFFER",
            "file_path": "src/_pytest/capture.py",
            "file_content": "EMPTY_BUFFER = \"\"",
            "start_line": 475,
            "start_column": 14849,
            "end_line": 4,
            "end_column": 14866,
            "start_byte": 14849,
            "end_byte": 4
          },
          "_pytest.capture.FDCapture.snap": {
            "name": "_pytest.capture.FDCapture.snap",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res",
            "start_line": 477,
            "start_column": 14888,
            "end_line": 4,
            "end_column": 15107,
            "start_byte": 14888,
            "end_byte": 4
          },
          "_pytest.capture.FDCapture.writeorg": {
            "name": "_pytest.capture.FDCapture.writeorg",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream",
            "start_line": 485,
            "start_column": 15113,
            "end_line": 4,
            "end_column": 15275,
            "start_byte": 15113,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture": {
            "name": "_pytest.capture.CaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "class CaptureFixture:\n    \"\"\"\n    Object returned by :py:func:`capsys`, :py:func:`capsysbinary`, :py:func:`capfd` and :py:func:`capfdbinary`\n    fixtures.\n    \"\"\"\n\n    def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n\n    def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()\n\n    def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None\n\n    def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)\n\n    def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()\n\n    def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()\n\n    @contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 759,
            "start_column": 24437,
            "end_line": 0,
            "end_column": 26743,
            "start_byte": 24437,
            "end_byte": 0
          },
          "_pytest.capture.CaptureFixture.__init__": {
            "name": "_pytest.capture.CaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def __init__(self, captureclass, request: SubRequest) -> None:\n        self.captureclass = captureclass\n        self.request = request\n        self._capture = None  # type: Optional[MultiCapture]\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER",
            "start_line": 765,
            "start_column": 24605,
            "end_line": 4,
            "end_column": 24920,
            "start_byte": 24605,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture._start": {
            "name": "_pytest.capture.CaptureFixture._start",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _start(self) -> None:\n        if self._capture is None:\n            self._capture = MultiCapture(\n                in_=None, out=self.captureclass(1), err=self.captureclass(2),\n            )\n            self._capture.start_capturing()",
            "start_line": 772,
            "start_column": 24926,
            "end_line": 4,
            "end_column": 25163,
            "start_byte": 24926,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture.close": {
            "name": "_pytest.capture.CaptureFixture.close",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def close(self) -> None:\n        if self._capture is not None:\n            out, err = self._capture.pop_outerr_to_orig()\n            self._captured_out += out\n            self._captured_err += err\n            self._capture.stop_capturing()\n            self._capture = None",
            "start_line": 779,
            "start_column": 25169,
            "end_line": 4,
            "end_column": 25441,
            "start_byte": 25169,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture.readouterr": {
            "name": "_pytest.capture.CaptureFixture.readouterr",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def readouterr(self):\n        \"\"\"Read and return the captured output so far, resetting the internal buffer.\n\n        :return: captured content as a namedtuple with ``out`` and ``err`` string attributes\n        \"\"\"\n        captured_out, captured_err = self._captured_out, self._captured_err\n        if self._capture is not None:\n            out, err = self._capture.readouterr()\n            captured_out += out\n            captured_err += err\n        self._captured_out = self.captureclass.EMPTY_BUFFER\n        self._captured_err = self.captureclass.EMPTY_BUFFER\n        return CaptureResult(captured_out, captured_err)",
            "start_line": 787,
            "start_column": 25447,
            "end_line": 4,
            "end_column": 26065,
            "start_byte": 25447,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture._suspend": {
            "name": "_pytest.capture.CaptureFixture._suspend",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _suspend(self) -> None:\n        \"\"\"Suspends this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.suspend_capturing()",
            "start_line": 801,
            "start_column": 26071,
            "end_line": 4,
            "end_column": 26247,
            "start_byte": 26071,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture._resume": {
            "name": "_pytest.capture.CaptureFixture._resume",
            "file_path": "src/_pytest/capture.py",
            "file_content": "def _resume(self) -> None:\n        \"\"\"Resumes this fixture's own capturing temporarily.\"\"\"\n        if self._capture is not None:\n            self._capture.resume_capturing()",
            "start_line": 806,
            "start_column": 26253,
            "end_line": 4,
            "end_column": 26426,
            "start_byte": 26253,
            "end_byte": 4
          },
          "_pytest.capture.CaptureFixture.disabled": {
            "name": "_pytest.capture.CaptureFixture.disabled",
            "file_path": "src/_pytest/capture.py",
            "file_content": "@contextlib.contextmanager\n    def disabled(self) -> Generator[None, None, None]:\n        \"\"\"Temporarily disables capture while inside the 'with' block.\"\"\"\n        capmanager = self.request.config.pluginmanager.getplugin(\"capturemanager\")\n        with capmanager.global_and_fixture_disabled():\n            yield",
            "start_line": 811,
            "start_column": 26432,
            "end_line": 4,
            "end_column": 26743,
            "start_byte": 26432,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture": {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/capture.py",
            "file_content": "lf.syscapture = SysCapture(targetfd)\n        else:\n            self.tmpfile = EncodedFile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n                write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfile={!r}>\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n        )\n\n    def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        self._state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buffer.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, restore streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n            if self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"suspended\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state = None\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          "_pytest.logging.LogCaptureFixture.__init__": {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ile(\n                # TODO: Remove type ignore, fixed in next mypy release.\n                TemporaryFile(buffering=0),  # type: ignore[arg-type]\n                encoding=\"utf-8\",\n                errors=\"replace\",\n        ",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture._finalize": {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/capture.py",
            "file_content": "  write_through=True,\n            )\n            if targetfd in patchsysdict:\n                self.syscapture = SysCapture(targetfd, self.tmpfile)\n            else:\n                self.syscapture = NoCapture()\n\n        self._state = \"initialized\"\n\n    def __repr__(self) -> str:\n        return \"<{} {} oldfd={} _state={!r} tmpfil",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.handler": {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/capture.py",
            "file_content": ">\".format(\n            self.__class__.__name__,\n            self.targetfd,\n            self.targetfd_save,\n            self._state,\n            self.tmpfile,\n      ",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.get_records": {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "   def _assert_state(self, op: str, states: Tuple[str, ...]) -> None:\n        assert (\n            self._state in states\n        ), \"cannot {} in state {!r}: expected one of {}\".format(\n            op, self._state, \", \".join(states)\n        )\n\n    def start(self) -> None:\n        \"\"\" Start capturing on targetfd using memorized tmpfile. \"\"\"\n        self._assert_state(\"start\", (\"initialized\",))\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self.syscapture.start()\n        ",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.text": {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/capture.py",
            "file_content": "state = \"started\"\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.buf",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.records": {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ad()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def done(self) -> None:\n        \"\"\" stop capturing, ",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.record_tuples": {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/capture.py",
            "file_content": "e streams, return original capture file,\n        seeked to position zero. \"\"\"\n        self._assert_state(\"done\", (\"initialized\", \"started\", \"suspended\", \"done\"))\n        if self._state == \"done\":\n            return\n        os.dup2(self.targetfd_save, self.targetfd)\n        os.close(self.targetfd_save)\n        if self.targetfd_invalid is not None:\n        ",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.messages": {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/capture.py",
            "file_content": " self.targetfd_invalid != self.targetfd:\n                os.close(self.targetfd)\n            os.close(self.targetfd_invalid)\n        self.syscapture.done()\n        self.tmpfile.close()\n        self._state = \"done\"\n\n    def suspend(self) -> None:\n        self._assert_state(\"suspend\", (\"started\", \"suspended\"))\n        if self._state == \"suspended\":\n            return\n        self.syscapture.suspend()\n        os.dup2(self.targetfd_save, self.targetfd)\n        self._state = \"suspended\"\n\n    def resume(self) -> None:\n        self._assert_state(\"resume\", (\"started\", \"suspended\"))\n        if self._state == \"started\":\n            return\n        self.syscapture.resume()\n        os.dup2(self.tmpfile.fileno(), self.targetfd)\n        self._state = \"started\"\n\n    ",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.clear": {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/capture.py",
            "file_content": "iteorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        self._assert_state(\"writeorg\", (\"started\", \"s",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.set_level": {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "ed\"))\n        os.write(self.targetfd_save, data)\n\n\nclass FDCapture(FDCaptureBinary):\n    \"\"\"Capture IO to/from a given os-level filedescriptor.\n\n    snap() produces text\n    \"\"\"\n\n    # Ignore type because it doesn't match the type in the superclass (bytes).\n    EMPTY_BUFFER = \"\"  # type: ignore\n\n    def snap(self):\n        self._assert_state(\"snap\", (\"started\", \"suspended\"))\n        self.tmpfile.seek(0)\n        res = self.tmpfile.read()\n        self.tmpfile.seek(0)\n        self.tmpfile.truncate()\n        return res\n\n    def writeorg(self, data):\n        \"\"\" write to original file descriptor. \"\"\"\n        super().writeorg(data.encode(\"utf-8\"))  # XXX use encoding of original stream\n\n\n# MultiCapture\n\nCaptureResult = collections.namedtuple(\"CaptureResult\", [\"out\", \"err\"])\n\n\nclass MultiCapture:\n    _state ",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.at_level": {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/capture.py",
            "file_content": "\n    _in_suspended = False\n\n    def __init__(self, in_, out, err) -> None:\n        self.in_ = in_\n        self.out = out\n        self.err = err\n\n    def __repr__(self) -> str:\n        return \"<MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}>\".format(\n            self.out, self.err, self.in_, self._state, self._in_suspended,\n        )\n\n    def start_capturing(self) -> None:\n        self._state = \"started\"\n        if self.in_:\n            self.in_.start()\n        if self.out:\n            self.out.start()\n        if self.err:\n            self.err.start()\n\n    def pop_outerr_to_orig(self):\n        \"\"\" pop current snapshot out/err capture and flush to orig streams. \"\"\"\n        out, err = self.readouterr()\n        if out:\n            self.out.writeorg(out)\n        if err:\n     ",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          }
        }
      }
    }
  ]
}