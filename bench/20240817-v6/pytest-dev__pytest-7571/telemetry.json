{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7571",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:49.634679",
        "usage": "3280.9648513793945 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_seen",
          "filename_arg",
          "Exception",
          "name2fixturedefs",
          "_create",
          "CollectErrorRepr",
          "resultlog",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "warning_types",
          "get_scope_package",
          "param",
          "BINOP_MAP",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "_in_suspended",
          "evaluate_xfail_marks",
          "_get_active_fixturedef",
          "create_new_paste",
          "CHECKER_CLASS",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "AND",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_T",
          "get_extended_length_path_str",
          "_ensure_basetemp",
          "add_report_section",
          "_get_teardown_reports",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "_highlight",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "passed",
          "_REPORTCHARS_DEFAULT",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "_FixtureValue",
          "__repr__",
          "pytest_runtest_call",
          "unset_fixture",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "collect_one_node",
          "typename",
          "start",
          "capfdbinary",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "own_mark_names",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "PYTEST_TAG",
          "repr_locals",
          "wcswidth",
          "outcomes",
          "FakeCollectModule",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "_surrounding_parens_on_own_lines",
          "get_default_arg_names",
          "AssertionState",
          "_prepare_content",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "extraline",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "timing",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "sep",
          "_has_param_ids",
          "_determine_main_color",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "scopename2class",
          "cleanup_numbered_dir",
          "makepyprojecttoml",
          "pytest_collection_finish",
          "isinitpath",
          "_AnyPurePath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "_typ_map",
          "from_item_and_call",
          "prog",
          "_recurse",
          "_R",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "flush",
          "pytest_warning_captured",
          "__contains__",
          "_resolve_arg_ids",
          "stream",
          "FDCapture",
          "OK",
          "setdefault",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_stderr_fileno",
          "_get_allow_bytes_flag",
          "get_timeout_config_value",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "MarkMatcher",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "_get_multicapture",
          "File",
          "fail_fixturefunc",
          "not_expr",
          "AssertionRewriter",
          "FaultHandlerHooks",
          "IDENT",
          "__next__",
          "StoreKey",
          "PytestAssertRewriteWarning",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "old_mark_config_key",
          "write_ensure_prefix",
          "_for_parametrize",
          "Xfail",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "markup",
          "_is_last_item",
          "append_error",
          "pytest_unconfigure",
          "TeeCaptureIO",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "LPAREN",
          "_prunetraceback",
          "pytest_internalerror",
          "_update_message",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "pytest",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "lineno",
          "finish",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "try_makedirs",
          "caplog_handler_key",
          "getfixturedefs",
          "pytest_warning_recorded",
          "warn",
          "_py36_windowsconsoleio_workaround",
          "writeorg",
          "setitem",
          "findsource",
          "_handle_teardown_sections",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "Store",
          "_params_converter",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "NotSetType",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "addError",
          "call_fixture_func",
          "compile",
          "_names",
          "scope2index",
          "_Markable",
          "get_last_failed_paths",
          "emit",
          "_excinfo",
          "matching_platform",
          "and_expr",
          "accept",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_split_lines",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "NODE_USE_FROM_PARENT",
          "_start",
          "runitem",
          "records",
          "get_log_level_for_setting",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "_warn_or_fail_if_strict",
          "find_suffixes",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "RPAREN",
          "re_match_lines_random",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "store",
          "Scanner",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "_set_main_color",
          "V",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "__slots__",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "_assert_expr_to_lineno",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "_S",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "_with_exception",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "_F",
          "makepyfile",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "NoMatch",
          "getreports",
          "assertstate_key",
          "short_test_summary",
          "_ensure_immutable_ids",
          "_param_ids_generated",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "_W",
          "add_property",
          "ids",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "width_of_current_line",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "_color_for_type",
          "rex_outcome",
          "_param_ids_from",
          "addFailure",
          "reportinfo",
          "fixture",
          "_get_pos",
          "_ET",
          "_NodeReporter",
          "patchsysdict",
          "MINUS_K_COLON",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "pastebinfile_key",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "async_warn_and_skip",
          "_report_kwargs_from_json",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "_expecting_failure",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "_compare_eq_any",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "_perform_collect",
          "expression",
          "add_stats",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_write_source",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "cache_key",
          "tmpdir",
          "__version__",
          "_E",
          "params",
          "TestReport",
          "Parser",
          "evaluate",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "resultlog_key",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "exitstatus",
          "listchain",
          "write_sep",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reject",
          "wrap_pytest_function_for_tracing",
          "reorder_items_atscope",
          "Metafunc",
          "reprcrash",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "_CACHE_PREFIX_DIRS",
          "message",
          "reset",
          "reprtraceback",
          "summary_warnings",
          "_esctable",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "_no_match_line",
          "ImportPathMismatchError",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_setupstate",
          "_get_plugin_specs_as_list",
          "_get_unknown_ini_keys",
          "_non_printable_ascii_translate_table",
          "inline_genitems",
          "_format_args",
          "TokenType",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "_check_non_top_pytest_plugins",
          "import_plugin",
          "__ne__",
          "ensure_extended_length_path",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "__dir__",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "filter_traceback_for_conftest_import_failure",
          "relline",
          "resolve_package_path",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "fullwidth",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "OR",
          "getfailures",
          "_write_entry_lines",
          "make_numbered_dir",
          "pytest_collectreport",
          "_Key",
          "NodeMeta",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "longrepr",
          "_format_assertmsg",
          "names",
          "repr_excinfo",
          "_idvalset",
          "_PluggyPlugin",
          "__attrs_post_init__",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "caplog_records_key",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "prepend",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "_get_auto_indent",
          "parse_setoption",
          "unexpectedsuccess_key",
          "compat",
          "ishidden",
          "find_prefixed",
          "_FixtureFunction",
          "create_module",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "JUNIT_XML_DEFAULT_FAMILY",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "TerminalWriter",
          "_assertion_pass",
          "addsection",
          "AlwaysDispatchingPrettyPrinter",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "validate_basetemp",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "FUNCARGNAMES",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "NO_TESTS_COLLECTED",
          "encoding",
          "ensure_newline",
          "exec_module",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "lines",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "locate_config",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "ParseError",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "no_header",
          "_getfailureheadline",
          "_read_pyc",
          "value",
          "K",
          "set_trace",
          "write",
          "_parse_filter",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "no_re_match_line",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "handleError",
          "istext",
          "_from_json",
          "SubRequest",
          "TERMINALWRITER_WRITER",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "ImportMode",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MINUS_K_DASH",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "Token",
          "FILLFUNCARGS",
          "reprentries",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "NOT",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "from_item",
          "write_line",
          "_get_runner",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "evaluate_skip_marks",
          "_fixturemanager",
          "_get_continue_on_failure",
          "invocation_dir",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "_LiveLoggingNullHandler",
          "lex",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "reason",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "_assert_state",
          "notify_exception",
          "_eval_scope_callable",
          "_strtobool",
          "formatrepr",
          "_validate_plugins",
          "_compare_eq_dict",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "from_exc_info",
          "is_globally_capturing",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "WARNING_CAPTURED_HOOK",
          "kwargs",
          "visit",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "IDENT_PREFIX",
          "junitxml",
          "getrawcode",
          "evaluate_condition",
          "reprlocals",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "writer",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "getworkerinfoline",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "xfailed_key",
          "get",
          "resume_capturing",
          "load_config_dict_from_file",
          "maybe_wrap_pytest_function_for_tracing",
          "__delitem__",
          "entrysep",
          "reprfuncargs",
          "get_fslocation_from_item",
          "section",
          "_match_lines_random",
          "_fail",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "import_path",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "hasopt",
          "LFPluginCollSkipfiles",
          "UNARY_MAP",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "_init_checker_class",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "on_rm_rf_error",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "_color_for_type_default",
          "_get_main_color",
          "PdbTrace",
          "symlink_or_skip",
          "pop",
          "Skip",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "_get_assertion_exprs",
          "_opentestcase",
          "no_fnmatch_line",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "_getlines",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "mkpydir",
          "from_parent",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "xml_key",
          "_make_plural",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "get_source",
          "popen",
          "T",
          "Notset",
          "fail",
          "debugging",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "skipped_by_mark_key",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "expr",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "safe_isclass",
          "_write_content",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "_NodeType",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "COLLECT_DIRECTORY_HOOK",
          "_runtest_for",
          "_validate_keys",
          "_format_lines",
          "_FileHandler",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "_FixtureCachedResult",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "_validate_ids",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "get_terminal_width",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "KeywordMatcher",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "KNOWN_TYPES",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "reprfileloc",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "_CACHE_PREFIX_VALUES",
          "DEFAULT_MAX_CHARS",
          "_parse_ini_config",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "assert_never",
          "_checkargnotcontained",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_enter_pdb",
          "_outrep_summary",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "wcwidth",
          "_WithException",
          "clear_cache",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "console_main",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "pos",
          "_is_skipped",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "strict",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "get_cache_dir",
          "record_testreport",
          "_add_stats",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "no_summary",
          "extract_suffixes",
          "TimeoutExpired",
          "should_do_markup",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "LFPluginCollWrapper",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "_ensure_relative_to_basetemp",
          "safeformat",
          "nose",
          "sections",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "_format",
          "EOF",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "cache",
          "Code",
          "_FixtureFunc",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "set_fixture",
          "generic_visit",
          "fault_handler_stderr_key",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "_pformat_dispatch",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "token",
          "__call__",
          "instance",
          "get_optionflags",
          "visit_BoolOp",
          "duration",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "parse_summary_nouns",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "is_async_function",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "_gethookproxy",
          "call_and_report",
          "showfspath",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "MatcherAdapter",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "_HandlerType",
          "importlib",
          "listoutcomes",
          "exprinfo",
          "text",
          "_args_converter",
          "D",
          "_try_repr_or_str",
          "DoctestModule",
          "_write_pyc_fp",
          "XFailed",
          "Expression",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "caplog",
          "LogCaptureFixture",
          "logging",
          "set_level",
          "pytest_runtest_protocol",
          "LogCaptureHandler",
          "restore",
          "LoggingPlugin",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "caplog_handler_key"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:52.915663",
        "usage": "193.38297843933105 ms"
      },
      "request": {
        "tokens": [
          "caplog",
          "LogCaptureFixture",
          "logging",
          "set_level",
          "pytest_runtest_protocol",
          "LogCaptureHandler",
          "restore",
          "LoggingPlugin",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "caplog_handler_key"
        ]
      },
      "response": {
        "results": {
          "caplog": [
            "src/_pytest/logging.py",
            "src/_pytest/reports.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/debugging.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ],
          "restore": [
            "src/_pytest/logging.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pytester.py"
          ],
          "logging": [
            "src/_pytest/compat.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py"
          ],
          "caplog_handler_key": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureHandler": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "set_level": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "FIXTURE_POSITIONAL_ARGUMENTS": [
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:53.109055",
        "usage": "5158.013820648193 ms"
      },
      "request": {
        "keyword_search_results": {
          "caplog": [
            "src/_pytest/logging.py",
            "src/_pytest/reports.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/debugging.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ],
          "restore": [
            "src/_pytest/logging.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pytester.py"
          ],
          "logging": [
            "src/_pytest/compat.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py"
          ],
          "caplog_handler_key": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureHandler": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "set_level": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "FIXTURE_POSITIONAL_ARGUMENTS": [
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue described pertains to the `caplog` fixture not restoring the log level correctly after a test in the new pytest 6.0 release.\n\n1. **Relevant Keywords**: \n   - `caplog`: This directly relates to the `caplog` fixture, so we look into files associated with this keyword.\n   - `restore`: The issue is about restoring the log level, so files found under this search might be relevant.\n   - `logging`: Since it involves log levels, this might contain related logic.\n   - `set_level`, `LogCaptureHandler`, `LogCaptureFixture`: These are potentially direct associations with the functionality of setting and capturing logs.\n\n2. **Key Files**:\n   - `src/_pytest/logging.py`: This file appears under several keyword searches including `caplog`, `restore`, `logging`, `set_level`, `caplog_handler_key`, `LogCaptureHandler`, and `LogCaptureFixture`. It likely contains the core implementation of the `caplog` fixture, its associated handlers, and potentially the restore logic.\n   - Other files like `src/_pytest/junitxml.py`, `src/_pytest/config/__init__.py`, `src/_pytest/capture.py`, etc., appear under some keywords but are less likely directly concerned with the `caplog` fixture or restoring the log level specifically, compared to `src/_pytest/logging.py`.\n\n3. **File Selection**:\n   - Given the issue specifics, focusing on `src/_pytest/logging.py` is the most logical initial step as it contains the related classes and methods for `caplog` and likely the bug-related code.",
        "file_paths": [
          "src/_pytest/logging.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:58.267100",
        "usage": "5827.803134918213 ms"
      },
      "request": {
        "file_path": "src/_pytest/logging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user reports an issue where the `caplog` fixture in pytest version 6.0 does not restore log levels after a test concludes as expected, leading subsequent tests to inherit log levels set in prior tests.\n1.2 The user provides a minimal reproduction example demonstrating how `caplog.set_level(42)` affects a subsequent test where the log level should have been reset.\n1.3 The issue appears because the log level set in one test is not reset before the next test runs.\n1.4 The user's expectation is that each test should start with a default log level unless changed explicitly. The issue arises due to a failure in restoring log levels after tests.\n1.5 Possible solutions include ensuring the log level is reverted to its original state after each test.\n\n2. File Evaluation:\n2.1 The `LogCaptureFixture` class has the `_finalize` method, which is responsible for restoring log levels at the end of the test.\n2.2 The method `set_level` in `LogCaptureFixture` modifies the logger's level and stores the original level for restoration.\n2.3 The caplog fixture uses `LogCaptureFixture`, and `_finalize` gets called during teardown.\n2.4 It seems like `_finalize` is supposed to reset the logger levels, but it might be failing due to some implementation error or missing part, which is why the levels are not being reset.\n2.5 Reviewing the `_finalize` method as well as interaction points like `caplog` and `set_level` could reveal the root cause.\n\nBased on the evaluation, the method `LogCaptureFixture._finalize` seems crucial since it's supposed to handle restoring log levels.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "LogCaptureFixture",
          "LogCaptureFixture._finalize",
          "LogCaptureFixture.set_level",
          "caplog"
        ],
        "root_cause_symbols": [
          "LogCaptureFixture._finalize",
          "LogCaptureFixture.set_level"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:04.094930",
        "usage": "72.66497611999512 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/logging.py",
            "relevant_symbol_keys": [
              "LogCaptureFixture",
              "LogCaptureFixture._finalize",
              "LogCaptureFixture.set_level",
              "caplog"
            ],
            "root_cause_symbol_keys": [
              "LogCaptureFixture._finalize",
              "LogCaptureFixture.set_level"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.logging.caplog_handler_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()",
            "start_line": 36,
            "start_column": 1081,
            "end_line": 0,
            "end_column": 1133,
            "start_byte": 1081,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.caplog_records_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()",
            "start_line": 37,
            "start_column": 1134,
            "end_line": 0,
            "end_column": 1201,
            "start_byte": 1134,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n\n    def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n\n    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n\n    @property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]\n\n    def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n\n    @property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records\n\n    @property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n\n    @property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]\n\n    def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()\n\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n\n    @contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()",
            "start_line": 460,
            "start_column": 16213,
            "end_line": 0,
            "end_column": 16896,
            "start_byte": 16213,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "e(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n\n    def __init__(self, fm",
            "start_line": 108,
            "start_column": 3122,
            "end_line": 4,
            "end_column": 3384,
            "start_byte": 3122,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:04.167601",
        "usage": "11647.75800704956 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.logging.caplog_handler_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()",
            "start_line": 36,
            "start_column": 1081,
            "end_line": 0,
            "end_column": 1133,
            "start_byte": 1081,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.caplog_records_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()",
            "start_line": 37,
            "start_column": 1134,
            "end_line": 0,
            "end_column": 1201,
            "start_byte": 1134,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n\n    def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n\n    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n\n    @property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]\n\n    def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n\n    @property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records\n\n    @property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n\n    @property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]\n\n    def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()\n\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n\n    @contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()",
            "start_line": 460,
            "start_column": 16213,
            "end_line": 0,
            "end_column": 16896,
            "start_byte": 16213,
            "end_byte": 0
          },
          {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "e(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n\n    def __init__(self, fm",
            "start_line": 108,
            "start_column": 3122,
            "end_line": 4,
            "end_column": 3384,
            "start_byte": 3122,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The user is describing that after updating to pytest 6.0, the `caplog` fixture does not restore the log level after a test completes.\n   - In pytest versions before 6.0, when `caplog.set_level(42)` was set in a test, the level would reset to 0 at the end of the test. However, now the level remains at 42.\n\n2. The issue is likely due to the `_finalize` method not functioning properly.\n   - Analyzing the `_finalize` method, it should restore the levels using `_initial_logger_levels` but seems like the restoration is not occurring as expected.\n\n3. Key component to fix:\n   - Ensure `_finalize` correctly tracks and restores the levels after the test.\n   - `set_level` should ensure all state changes are captured properly for later restoration.\n\n4. Expected Result:\n   - After each test that uses `caplog.set_level`, the level should reset to its initial state.\n\n5. Checking related symbols:\n   - `_finalize` method already aims to restore log levels.\n   - `set_level` method should be capturing current levels properly.\n   - Other methods and properties like `handler`, `caplog_handler_key`, `caplog_records_key`, `caplog`, which involve log fetching or setting logic.\n\n6. Fix implementation:\n   - Focus is on `_finalize` and `set_level`.\n   - Verify if `_initial_logger_levels` captures all necessary loggers, including the root, during `set_level`.\n   - Ensure `_finalize` iterates through all necessary loggers and reassigns the original levels effectively.",
        "symbols": [
          {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/logging.py",
            "reason": "This method is intended to restore log levels after test finalization. It directly relates to the problem since it's expected to restore the changed log levels but didn't seem to do it for pytest>=6.0."
          },
          {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/logging.py",
            "reason": "This method changes the log level and saves the original level for later restoration. It should ensure that log level changes are correctly recorded so `_finalize()` can restore them."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The `_finalize` method is crucial for restoring the log level after the test ends. It uses `_initial_logger_levels` to reset the log levels. Confirming it includes all loggers in `_initial_logger_levels` during the test can solve it.",
          "`set_level` saves the current log level before setting a new one; ensuring this captures all necessary changes (including to the root logger) is crucial. Aligning its functionality with `_finalize()` could resolve the issue.",
          "This symbol does not actively contribute to the issue of restoring log levels. It's used for typing and customization purposes.",
          "This symbol does not actively contribute to the issue of restoring log levels. It's used for typing and customization purposes.",
          "`LogCaptureFixture` class houses `set_level` and `_finalize` that are central to resolving the issue. The related methods within this class should ensure restoration of initial log levels correctly.",
          "This method is relevant as it initializes the `LogCaptureFixture` and should ensure `_initial_logger_levels` is correctly prepared for test setup.",
          "Handler property provides handler which is used to fetch logs. It's indirectly relevant in terms of how it's levels are manipulated.",
          "`get_records` method provides records but does not directly impact log level setting or restoration.",
          "`text` method provides log messages and isn't directly involved in log level restoration or setting.",
          "Returns various properties related to log records, not directly relevant to log level changes.",
          "Returns message tuples, not directly relevant to log level restoration.",
          "Provides text messages, not related to log level setting, though it ties into log structure workflows.",
          "Clears records which is more about maintenance of log state rather than log level changes.",
          "This context manager directly sets and restores log levels inline, which could show expected behavior but the main automated restoration issue in `_finalize()` remains.",
          "This is the main fixture definition that processes finalization subsequently calling `_finalize`. Relevant to wrap up or testing potential initial setup issues.",
          "Doesn\u2019t seem to be relevant based on its partial definition and typical naming alignment."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:15.815378",
        "usage": "1.2640953063964844 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.logging.caplog_handler_key",
              "file_path": "src/_pytest/logging.py",
              "file_content": "caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()",
              "start_line": 36,
              "start_column": 1081,
              "end_line": 0,
              "end_column": 1133,
              "start_byte": 1081,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.caplog_records_key",
              "file_path": "src/_pytest/logging.py",
              "file_content": "caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()",
              "start_line": 37,
              "start_column": 1134,
              "end_line": 0,
              "end_column": 1201,
              "start_byte": 1134,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LogCaptureFixture",
              "file_path": "src/_pytest/logging.py",
              "file_content": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n\n    def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n\n    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n\n    @property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]\n\n    def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n\n    @property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records\n\n    @property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n\n    @property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]\n\n    def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()\n\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n\n    @contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
              "start_line": 340,
              "start_column": 11698,
              "end_line": 0,
              "end_column": 16210,
              "start_byte": 11698,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.__init__",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]",
              "start_line": 343,
              "start_column": 11784,
              "end_line": 4,
              "end_column": 12007,
              "start_byte": 11784,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.handler",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]",
              "start_line": 359,
              "start_column": 12348,
              "end_line": 4,
              "end_column": 12512,
              "start_byte": 12348,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.get_records",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])",
              "start_line": 366,
              "start_column": 12518,
              "end_line": 4,
              "end_column": 13008,
              "start_byte": 12518,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.text",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())",
              "start_line": 380,
              "start_column": 13014,
              "end_line": 4,
              "end_column": 13173,
              "start_byte": 13014,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.records",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records",
              "start_line": 385,
              "start_column": 13179,
              "end_line": 4,
              "end_column": 13321,
              "start_byte": 13179,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.record_tuples",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]",
              "start_line": 390,
              "start_column": 13327,
              "end_line": 4,
              "end_column": 13684,
              "start_byte": 13327,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.messages",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]",
              "start_line": 401,
              "start_column": 13690,
              "end_line": 4,
              "end_column": 14451,
              "start_byte": 13690,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.clear",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()",
              "start_line": 417,
              "start_column": 14457,
              "end_line": 4,
              "end_column": 14581,
              "start_byte": 14457,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.at_level",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
              "start_line": 438,
              "start_column": 15405,
              "end_line": 4,
              "end_column": 16210,
              "start_byte": 15405,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.caplog",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()",
              "start_line": 460,
              "start_column": 16213,
              "end_line": 0,
              "end_column": 16896,
              "start_byte": 16213,
              "end_byte": 0
            },
            {
              "name": "_pytest.reports.BaseReport.caplog",
              "file_path": "src/_pytest/logging.py",
              "file_content": "e(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n\n    def __init__(self, fm",
              "start_line": 108,
              "start_column": 3122,
              "end_line": 4,
              "end_column": 3384,
              "start_byte": 3122,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.logging.LogCaptureFixture._finalize",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)",
              "start_line": 349,
              "start_column": 12013,
              "end_line": 4,
              "end_column": 12342,
              "start_byte": 12013,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.set_level",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)",
              "start_line": 421,
              "start_column": 14587,
              "end_line": 4,
              "end_column": 15399,
              "start_byte": 14587,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The user is describing that after updating to pytest 6.0, the `caplog` fixture does not restore the log level after a test completes.\n   - In pytest versions before 6.0, when `caplog.set_level(42)` was set in a test, the level would reset to 0 at the end of the test. However, now the level remains at 42.\n\n2. The issue is likely due to the `_finalize` method not functioning properly.\n   - Analyzing the `_finalize` method, it should restore the levels using `_initial_logger_levels` but seems like the restoration is not occurring as expected.\n\n3. Key component to fix:\n   - Ensure `_finalize` correctly tracks and restores the levels after the test.\n   - `set_level` should ensure all state changes are captured properly for later restoration.\n\n4. Expected Result:\n   - After each test that uses `caplog.set_level`, the level should reset to its initial state.\n\n5. Checking related symbols:\n   - `_finalize` method already aims to restore log levels.\n   - `set_level` method should be capturing current levels properly.\n   - Other methods and properties like `handler`, `caplog_handler_key`, `caplog_records_key`, `caplog`, which involve log fetching or setting logic.\n\n6. Fix implementation:\n   - Focus is on `_finalize` and `set_level`.\n   - Verify if `_initial_logger_levels` captures all necessary loggers, including the root, during `set_level`.\n   - Ensure `_finalize` iterates through all necessary loggers and reassigns the original levels effectively.",
          "symbols": [
            {
              "name": "_pytest.logging.LogCaptureFixture._finalize",
              "file_path": "src/_pytest/logging.py",
              "reason": "This method is intended to restore log levels after test finalization. It directly relates to the problem since it's expected to restore the changed log levels but didn't seem to do it for pytest>=6.0."
            },
            {
              "name": "_pytest.logging.LogCaptureFixture.set_level",
              "file_path": "src/_pytest/logging.py",
              "reason": "This method changes the log level and saves the original level for later restoration. It should ensure that log level changes are correctly recorded so `_finalize()` can restore them."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The `_finalize` method is crucial for restoring the log level after the test ends. It uses `_initial_logger_levels` to reset the log levels. Confirming it includes all loggers in `_initial_logger_levels` during the test can solve it.",
            "`set_level` saves the current log level before setting a new one; ensuring this captures all necessary changes (including to the root logger) is crucial. Aligning its functionality with `_finalize()` could resolve the issue.",
            "This symbol does not actively contribute to the issue of restoring log levels. It's used for typing and customization purposes.",
            "This symbol does not actively contribute to the issue of restoring log levels. It's used for typing and customization purposes.",
            "`LogCaptureFixture` class houses `set_level` and `_finalize` that are central to resolving the issue. The related methods within this class should ensure restoration of initial log levels correctly.",
            "This method is relevant as it initializes the `LogCaptureFixture` and should ensure `_initial_logger_levels` is correctly prepared for test setup.",
            "Handler property provides handler which is used to fetch logs. It's indirectly relevant in terms of how it's levels are manipulated.",
            "`get_records` method provides records but does not directly impact log level setting or restoration.",
            "`text` method provides log messages and isn't directly involved in log level restoration or setting.",
            "Returns various properties related to log records, not directly relevant to log level changes.",
            "Returns message tuples, not directly relevant to log level restoration.",
            "Provides text messages, not related to log level setting, though it ties into log structure workflows.",
            "Clears records which is more about maintenance of log state rather than log level changes.",
            "This context manager directly sets and restores log levels inline, which could show expected behavior but the main automated restoration issue in `_finalize()` remains.",
            "This is the main fixture definition that processes finalization subsequently calling `_finalize`. Relevant to wrap up or testing potential initial setup issues.",
            "Doesn\u2019t seem to be relevant based on its partial definition and typical naming alignment."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/logging.py"
        ],
        "symbols": [
          "_pytest.logging.LogCaptureFixture._finalize",
          "_pytest.logging.LogCaptureFixture.set_level"
        ],
        "code_spans": {
          "_pytest.logging.caplog_handler_key": {
            "name": "_pytest.logging.caplog_handler_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_handler_key = StoreKey[\"LogCaptureHandler\"]()",
            "start_line": 36,
            "start_column": 1081,
            "end_line": 0,
            "end_column": 1133,
            "start_byte": 1081,
            "end_byte": 0
          },
          "_pytest.logging.caplog_records_key": {
            "name": "_pytest.logging.caplog_records_key",
            "file_path": "src/_pytest/logging.py",
            "file_content": "caplog_records_key = StoreKey[Dict[str, List[logging.LogRecord]]]()",
            "start_line": 37,
            "start_column": 1134,
            "end_line": 0,
            "end_column": 1201,
            "start_byte": 1134,
            "end_byte": 0
          },
          "_pytest.logging.LogCaptureFixture": {
            "name": "_pytest.logging.LogCaptureFixture",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LogCaptureFixture:\n    \"\"\"Provides access and control of log capturing.\"\"\"\n\n    def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n\n    def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)\n\n    @property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]\n\n    def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n\n    @property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records\n\n    @property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n\n    @property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]\n\n    def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()\n\n    def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)\n\n    @contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 340,
            "start_column": 11698,
            "end_line": 0,
            "end_column": 16210,
            "start_byte": 11698,
            "end_byte": 0
          },
          "_pytest.logging.LogCaptureFixture.__init__": {
            "name": "_pytest.logging.LogCaptureFixture.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, item: nodes.Node) -> None:\n        \"\"\"Creates a new funcarg.\"\"\"\n        self._item = item\n        # dict of log name -> log level\n        self._initial_logger_levels = {}  # type: Dict[Optional[str], int]",
            "start_line": 343,
            "start_column": 11784,
            "end_line": 4,
            "end_column": 12007,
            "start_byte": 11784,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.handler": {
            "name": "_pytest.logging.LogCaptureFixture.handler",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def handler(self) -> LogCaptureHandler:\n        \"\"\"\n        :rtype: LogCaptureHandler\n        \"\"\"\n        return self._item._store[caplog_handler_key]",
            "start_line": 359,
            "start_column": 12348,
            "end_line": 4,
            "end_column": 12512,
            "start_byte": 12348,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.get_records": {
            "name": "_pytest.logging.LogCaptureFixture.get_records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def get_records(self, when: str) -> List[logging.LogRecord]:\n        \"\"\"\n        Get the logging records for one of the possible test phases.\n\n        :param str when:\n            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n\n        :rtype: List[logging.LogRecord]\n        :return: the list of captured records at the given stage\n\n        .. versionadded:: 3.4\n        \"\"\"\n        return self._item._store[caplog_records_key].get(when, [])",
            "start_line": 366,
            "start_column": 12518,
            "end_line": 4,
            "end_column": 13008,
            "start_byte": 12518,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.text": {
            "name": "_pytest.logging.LogCaptureFixture.text",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def text(self) -> str:\n        \"\"\"Returns the formatted log text.\"\"\"\n        return _remove_ansi_escape_sequences(self.handler.stream.getvalue())",
            "start_line": 380,
            "start_column": 13014,
            "end_line": 4,
            "end_column": 13173,
            "start_byte": 13014,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.records": {
            "name": "_pytest.logging.LogCaptureFixture.records",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def records(self) -> List[logging.LogRecord]:\n        \"\"\"Returns the list of log records.\"\"\"\n        return self.handler.records",
            "start_line": 385,
            "start_column": 13179,
            "end_line": 4,
            "end_column": 13321,
            "start_byte": 13179,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.record_tuples": {
            "name": "_pytest.logging.LogCaptureFixture.record_tuples",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def record_tuples(self) -> List[Tuple[str, int, str]]:\n        \"\"\"Returns a list of a stripped down version of log records intended\n        for use in assertion comparison.\n\n        The format of the tuple is:\n\n            (logger_name, log_level, message)\n        \"\"\"\n        return [(r.name, r.levelno, r.getMessage()) for r in self.records]",
            "start_line": 390,
            "start_column": 13327,
            "end_line": 4,
            "end_column": 13684,
            "start_byte": 13327,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.messages": {
            "name": "_pytest.logging.LogCaptureFixture.messages",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@property\n    def messages(self) -> List[str]:\n        \"\"\"Returns a list of format-interpolated log messages.\n\n        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n        are all interpolated.\n        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n        levels, timestamps, etc, making exact comparisons more reliable.\n\n        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n        to the logging functions) is not included, as this is added by the formatter in the handler.\n\n        .. versionadded:: 3.7\n        \"\"\"\n        return [r.getMessage() for r in self.records]",
            "start_line": 401,
            "start_column": 13690,
            "end_line": 4,
            "end_column": 14451,
            "start_byte": 13690,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.clear": {
            "name": "_pytest.logging.LogCaptureFixture.clear",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def clear(self) -> None:\n        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n        self.handler.reset()",
            "start_line": 417,
            "start_column": 14457,
            "end_line": 4,
            "end_column": 14581,
            "start_byte": 14457,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.at_level": {
            "name": "_pytest.logging.LogCaptureFixture.at_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def at_level(\n        self, level: int, logger: Optional[str] = None\n    ) -> Generator[None, None, None]:\n        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n        level is restored to its original value.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        orig_level = logger_obj.level\n        logger_obj.setLevel(level)\n        handler_orig_level = self.handler.level\n        self.handler.setLevel(level)\n        try:\n            yield\n        finally:\n            logger_obj.setLevel(orig_level)\n            self.handler.setLevel(handler_orig_level)",
            "start_line": 438,
            "start_column": 15405,
            "end_line": 4,
            "end_column": 16210,
            "start_byte": 15405,
            "end_byte": 4
          },
          "_pytest.logging.caplog": {
            "name": "_pytest.logging.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.fixture\ndef caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n    \"\"\"Access and control log capturing.\n\n    Captured logs are available through the following properties/methods::\n\n    * caplog.messages        -> list of format-interpolated log messages\n    * caplog.text            -> string containing formatted log output\n    * caplog.records         -> list of logging.LogRecord instances\n    * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n    * caplog.clear()         -> clear captured records and formatted log output string\n    \"\"\"\n    result = LogCaptureFixture(request.node)\n    yield result\n    result._finalize()",
            "start_line": 460,
            "start_column": 16213,
            "end_line": 0,
            "end_column": 16896,
            "start_byte": 16213,
            "end_byte": 0
          },
          "_pytest.reports.BaseReport.caplog": {
            "name": "_pytest.reports.BaseReport.caplog",
            "file_path": "src/_pytest/logging.py",
            "file_content": "e(logging.PercentStyle):\n    \"\"\"A logging style with special support for multiline messages.\n\n    If the message of a record consists of multiple lines, this style\n    formats the message as if each line were logged separately.\n    \"\"\"\n\n    def __init__(self, fm",
            "start_line": 108,
            "start_column": 3122,
            "end_line": 4,
            "end_column": 3384,
            "start_byte": 3122,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture._finalize": {
            "name": "_pytest.logging.LogCaptureFixture._finalize",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _finalize(self) -> None:\n        \"\"\"Finalizes the fixture.\n\n        This restores the log levels changed by :meth:`set_level`.\n        \"\"\"\n        # restore log levels\n        for logger_name, level in self._initial_logger_levels.items():\n            logger = logging.getLogger(logger_name)\n            logger.setLevel(level)",
            "start_line": 349,
            "start_column": 12013,
            "end_line": 4,
            "end_column": 12342,
            "start_byte": 12013,
            "end_byte": 4
          },
          "_pytest.logging.LogCaptureFixture.set_level": {
            "name": "_pytest.logging.LogCaptureFixture.set_level",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n        the test.\n\n        :param int level: the logger to level.\n        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n\n        .. versionchanged:: 3.4\n            The levels of the loggers changed by this function will be restored to their initial values at the\n            end of the test.\n        \"\"\"\n        logger_obj = logging.getLogger(logger)\n        # save the original log-level to restore it during teardown\n        self._initial_logger_levels.setdefault(logger, logger_obj.level)\n        logger_obj.setLevel(level)\n        self.handler.setLevel(level)",
            "start_line": 421,
            "start_column": 14587,
            "end_line": 4,
            "end_column": 15399,
            "start_byte": 14587,
            "end_byte": 4
          }
        }
      }
    }
  ]
}