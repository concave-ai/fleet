{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5840",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:47.209112",
        "usage": "1000.1158714294434 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_py_ext_re",
          "_seen",
          "filename_arg",
          "name2fixturedefs",
          "CollectErrorRepr",
          "resultlog",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "_get_marks",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "setns",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "warning_types",
          "_legal_ranges",
          "get_scope_package",
          "param",
          "BINOP_MAP",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "_get_active_fixturedef",
          "create_new_paste",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_ensure_basetemp",
          "add_report_section",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "cached_eval",
          "passed",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "MarkEvaluator",
          "__repr__",
          "pytest_runtest_call",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "_istrue",
          "collect_one_node",
          "typename",
          "capfdbinary",
          "start",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "putaround",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "_fail_on_non_top_pytest_plugins",
          "own_mark_names",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "PYTEST_TAG",
          "repr_locals",
          "illegal_xml_re",
          "outcomes",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "unique_path",
          "get_default_arg_names",
          "AssertionState",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "safe_text_dupfile",
          "scopename2class",
          "cleanup_numbered_dir",
          "pytest_collection_finish",
          "isinitpath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "MarkMapping",
          "_typ_map",
          "from_item_and_call",
          "compile_",
          "prog",
          "_recurse",
          "PyobjContext",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "pytest_warning_captured",
          "_resolve_arg_ids",
          "FDCapture",
          "OK",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_stderr_fileno",
          "_get_allow_bytes_flag",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "File",
          "fail_fixturefunc",
          "AssertionRewriter",
          "__next__",
          "_getglobals",
          "PytestAssertRewriteWarning",
          "check_xfail_no_run",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "write_ensure_prefix",
          "_for_parametrize",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "append_error",
          "pytest_unconfigure",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "_prunetraceback",
          "pytest_internalerror",
          "_update_message",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "finish",
          "__bool__",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "getfixturedefs",
          "warn",
          "writeorg",
          "_py36_windowsconsoleio_workaround",
          "setitem",
          "findsource",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "_parse_lsof_output",
          "addError",
          "call_fixture_func",
          "compile",
          "scope2index",
          "emit",
          "_excinfo",
          "matching_platform",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "_ensure_only_one_capture_fixture",
          "_start",
          "runitem",
          "records",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "find_suffixes",
          "_setoption",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "re_match_lines_random",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_compilecounter",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "_legal_chars",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "_assert_expr_to_lineno",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "makepyfile",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "NoMatch",
          "getreports",
          "short_test_summary",
          "_ensure_immutable_ids",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "add_property",
          "ids",
          "warn_about_none_ast",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "_done",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "rex_outcome",
          "addFailure",
          "reportinfo",
          "fixture",
          "_get_pos",
          "try_mkdir",
          "_NodeReporter",
          "patchsysdict",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "_report_kwargs_from_json",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "wasvalid",
          "_perform_collect",
          "add_stats",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "cache_key",
          "tmpdir",
          "__version__",
          "_E",
          "params",
          "TestReport",
          "Parser",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "last_failed_paths",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "listchain",
          "write_sep",
          "getslaveinfoline",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reorder_items_atscope",
          "Metafunc",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_runtest_for_main",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "message",
          "reset",
          "summary_warnings",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_get_plugin_specs_as_list",
          "_non_printable_ascii_translate_table",
          "NodeMarkers",
          "inline_genitems",
          "_format_args",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "import_plugin",
          "__ne__",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "relline",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "getfailures",
          "make_numbered_dir",
          "pytest_collectreport",
          "errors",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "_format_assertmsg",
          "names",
          "repr_excinfo",
          "_idvalset",
          "find",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "parse_setoption",
          "pyobj_property",
          "_test_pytest_function",
          "compat",
          "ishidden",
          "find_prefixed",
          "create_module",
          "_setup_cli_logging",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_handle_skip",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "_assertion_pass",
          "addsection",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "FUNCARGNAMES",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "NO_TESTS_COLLECTED",
          "encoding",
          "ensure_newline",
          "exec_module",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "_getfailureheadline",
          "_read_pyc",
          "value",
          "getexplanation",
          "set_trace",
          "write",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "own_markers",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "istext",
          "_from_json",
          "SubRequest",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "matchmark",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "pytest_itemstart",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "check_strict_xfail",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "isparseable",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "write_line",
          "from_item",
          "_get_runner",
          "matchkeyword",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "getcfg",
          "_get_continue_on_failure",
          "invocation_dir",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "invalidraise",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "exists",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "defaultfuncargprefixmarker",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "notify_exception",
          "_strtobool",
          "formatrepr",
          "_compare_eq_dict",
          "get_actual_log_level",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "from_exc_info",
          "is_globally_capturing",
          "_visit_filter",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "kwargs",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "junitxml",
          "getrawcode",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "FunctionMixin",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "__nonzero__",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "istrue",
          "get",
          "resume_capturing",
          "__delitem__",
          "entrysep",
          "section",
          "get_fslocation_from_item",
          "alias",
          "_match_lines_random",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "is_true",
          "hasopt",
          "UNARY_MAP",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "out",
          "on_rm_rf_error",
          "capture_fixtures",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "PdbTrace",
          "pop",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "_get_assertion_exprs",
          "_opentestcase",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "getdecoded",
          "_getlines",
          "FuncargnamesCompatAttr",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "_exec_lsof",
          "mkpydir",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "get_source",
          "popen",
          "Notset",
          "fail",
          "debugging",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "_write_pyc",
          "safe_isclass",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "_runtest_for",
          "_format_lines",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "python_keywords_allowed_list",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "DEFAULT_MAX_CHARS",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "_legal_xml_re",
          "_checkargnotcontained",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "update",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_outrep_summary",
          "_enter_pdb",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "writelines",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "exec_",
          "KeywordMapping",
          "Entry",
          "record_testreport",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "extract_suffixes",
          "TimeoutExpired",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "safeformat",
          "nose",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "cache",
          "Code",
          "Junit",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "generic_visit",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "_setup_collect_fakemodule",
          "__call__",
          "instance",
          "get_optionflags",
          "pytest_doctest_prepare_content",
          "visit_BoolOp",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "_getcapture",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "call_and_report",
          "showfspath",
          "_install_capture_fixture_on_item",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "listoutcomes",
          "exprinfo",
          "text",
          "DoctestModule",
          "XFailed",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "ImportError",
          "ModuleNotFoundError",
          "conftest",
          "lower",
          "windows",
          "import",
          "pytest"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:48.209247",
        "usage": "200.531005859375 ms"
      },
      "request": {
        "tokens": [
          "ImportError",
          "ModuleNotFoundError",
          "conftest",
          "lower",
          "windows",
          "import",
          "pytest"
        ]
      },
      "response": {
        "results": {
          "import": [
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/__init__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/nose.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/pytest.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/_version.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/pastebin.py"
          ],
          "pytest": [
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/nodes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python_api.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/pytest.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "lower": [
            "src/_pytest/pathlib.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/doctest.py"
          ],
          "ImportError": [
            "src/_pytest/monkeypatch.py",
            "src/_pytest/compat.py",
            "src/_pytest/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/capture.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/doctest.py"
          ],
          "conftest": [
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py"
          ],
          "ModuleNotFoundError": [
            "src/_pytest/compat.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:48.409787",
        "usage": "5340.585231781006 ms"
      },
      "request": {
        "keyword_search_results": {
          "import": [
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/__init__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/nose.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/pytest.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/_version.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/pastebin.py"
          ],
          "pytest": [
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/nodes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python_api.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/main.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/pytest.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "lower": [
            "src/_pytest/pathlib.py",
            "src/_pytest/python.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/doctest.py"
          ],
          "ImportError": [
            "src/_pytest/monkeypatch.py",
            "src/_pytest/compat.py",
            "src/_pytest/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/capture.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/doctest.py"
          ],
          "conftest": [
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py"
          ],
          "ModuleNotFoundError": [
            "src/_pytest/compat.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue describes an ImportError while loading a conftest.py file in a project structure where after upgrading to version 5.1.2, the path was converted to lowercase, leading to the error. \n\nKey elements to consider:\n1. The ImportError specifically related to `conftest.py` and `ModuleNotFoundError`.\n2. Issue appears when paths are being converted or checked considering the casing.\n\n### Search Results Consideration:\n- **import**: This keyword appeared in various files, but not all are relevant. Focus should be on those possibly handling imports specifically linked to test collections or related path issues. \n- **pytest**: It's a broad keyword here pointing to many files. Direct correlation with path and import needs to be examined for relevance.\n- **lower**: This keyword is very relevant because it mentions conversion to lowercase, which is central to the problem described.\n- **ImportError**: Files dealing with this error directly could contribute to the solution.\n- **conftest**: This file is critical since the error occurs during its loading.\n- **ModuleNotFoundError**: Directly relevant as this is the error observed.\n\n### Selected Files:\n1. **src/_pytest/python.py** - Mentioned in `conftest` and `import`, potentially holds logic related to import paths and handling of conftest files.\n2. **src/_pytest/config/__init__.py** - Related to `import`, `pytest`, and `lower`. Likely involves path configuration logic.\n3. **src/_pytest/compat.py** - Directly handles `ModuleNotFoundError`.\n4. **src/_pytest/main.py** - Listed under `ImportError` and `conftest`, might manage main logic for path management and imports in pytest.\n5. **src/_pytest/pathlib.py** - Listed under `lower`, indicating possible relation to path case handling.",
        "file_paths": [
          "src/_pytest/python.py",
          "src/_pytest/config/__init__.py",
          "src/_pytest/compat.py",
          "src/_pytest/main.py",
          "src/_pytest/pathlib.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:53.750404",
        "usage": "16304.744958877563 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "### Analyzing the Issue\n1. **What issue is the user describing?**\n   The user is experiencing an `ImportError` related to `conftest.py` files when using pytest on Windows. The error specifically mentions a `ModuleNotFoundError` as the file paths appear to be converted to lowercase when using pytest 5.1.2, which was not the case in 5.1.1.\n\n2. **User-provided Steps:**\n   The provided steps include upgrading pytest from 5.1.1 to 5.1.2 and running pytest with specific options which result in an import error where the file paths are converted to lowercase.\n\n3. **How was this issue caused?**\n   The issue seems to be related to a change in how pytest imports modules, specifically module paths being converted to lowercase when running on Windows. This could be a result of a modification in how pytest interacts with file paths or how it handles module imports.\n\n4. **User expectation and cause:**\n   The user expects that the case sensitivity of the file paths will be maintained as it was in version 5.1.1. The change in behavior might be due to changes in path handling in pytest 5.1.2.\n\n5. **Possible solutions:**\n   Potential solutions could involve checking changes in the pytest path handling, particularly how paths are resolved and imported, and ensuring that case sensitivity is preserved. Also, configurations or settings related to path importing modes should be reviewed.\n\n### Analyzing the File\n1. **Symbolic References:**\n   - Several functions in the file handle the importing and path manipulation for pytest. Mainly functions like `pytest_collect_file`, `pytest_pycollect_makemodule`, `path_matches_patterns`, `_importtestmodule`, etc. are directly interacting with file paths and importing modules.\n\n2. **Key Areas:**\n   - **Handling of Path Importing: Function `pytest_collect_file` and `_importtestmodule.`**\n   Both these functions include logic related to importing paths and handle error conditions related to importing.\n\n3. **Potential Relevance to Issue:**\n   - These functions could indeed be responsible for the case sensitivity discrepancies. Especially `_importtestmodule` attempts to import modules and has error handling for mismatches which could interact poorly with different casing.\n\n4. **File Determination:**\n   While this file contains functions that interact with paths and modules which are highly relevant to the user's issue, it might not alone be the root cause. There's a chance that this issue stems from changes across multiple files related to path imports in pytest.\n\n5. **References Needed:**\n   - Further inspection might be needed in other files that deal with import paths or configurations related to the import behavior in pytest 5.1.2.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pathlib.py",
          "src/_pytest/config.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "pytest_collect_file",
          "_importtestmodule",
          "pytest_collect_file.path_matches_patterns",
          "pytest_pycollect_makemodule"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:10.055167",
        "usage": "14255.146980285645 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. The issue describes that after upgrading to pytest 5.1.2, paths are converted to lower case, leading to a ImportError related to loading the conftest.py file. Specifically, it mentions 'ModuleNotFoundError: No module named 'python' due to path casing.\n\n2. The user provides reproduction steps as simply upgrading pytest from 5.1.1 to 5.1.2, which results in paths being lowercased inappropriately on Windows.\n\n3. The cause of the issue seems to be related to how pytest 5.1.2 handles paths on Windows, specifically changes made around the ConftestImportFailure and path handling.\n\n4. The user's expectation is that the system should be able to load conftest.py correctly without altering the case of the path.\n\n5. Possible solutions might include looking at path handling logic differences between versions 5.1.1 and 5.1.2, especially around file system interactions, conftest imports, and Windows-specific path handling.\n\nFile Analysis:\n* The file contains code related to handling conftest import failures through `ConftestImportFailure` and its invocation in various parts of the code.\n* It manages plugin registrations, configurations, command handling, and error logging.\n* The class `ConftestImportFailure` is used to signal import failures including path issues, as seen in the `main()` function.\n* It seems this code could potentially contribute to casing issues if path manipulations are done incorrectly.\n* Import errors are caught and rerouted in `main()` and `_prepareconfig()` methods.\n* Investigate `_try_load_conftest`, `_importconftest`, or path handling logic closely related to how conftest are identified and imported which can lead to this issue when combined with the changes in version 5.1.2\n\nOverall, this file seems to be part of the problem regarding path handling for conftest which results in load failures. But without clear evidence of lowercasing logic here, it's not conclusively the singular root cause but relevant for full issue comprehension.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/hookspec.py",
          "src/_pytest/findpaths.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "ConftestImportFailure",
          "main",
          "_prepareconfig",
          "_try_load_conftest",
          "PytestPluginManager._importconftest"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:24.310351",
        "usage": "4495.680809020996 ms"
      },
      "request": {
        "file_path": "src/_pytest/compat.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the User Issue:\nThe user describes an ImportError encountered after upgrading pytest from version 5.1.1 to version 5.1.2. Specifically, the path is being converted to lowercase on a Windows system, leading to a `ModuleNotFoundError` stating \"No module named 'python'\". This occurs during pytest's attempt to load `conftest.py` from the specified directory.\n\n2. Understanding the Cause and Expectations:\na. The issue likely stems from a difference in how file paths are being handled by pytest 5.1.2 on Windows systems. Python, being case-sensitive on most operating systems, may misinterpret case conversions, especially if directories are being accessed in a way that's case-dependent.\nb. The expectation is that the path should remain case-sensitive or be handled consistently regardless of platform to ensure module discovery is accurate.\nc. The root cause seems to be related to path handling or filesystem interactions within pytest 5.1.2.\n\n3. Analyzing the Provided File (compat.py):\nThis file (`compat.py`) contains compatibility code but does not appear to directly manage path handling across filesystems or affect how paths are altered. Functions in this file are more related to compatibility functions and utilities rather than filesystem path management. Critical path handling functions and filesystem interactions that might affect the module import paths need to be in the pytest logic related to test discovery and path interpretation.\n\n4. Evaluation:\na. The symbols/functions in this file do not seem to relate to the particular issue of path casing leading to ImportError.\nb. This file does not appear to be the root cause of the observed issue.\n\nNext Steps:\nI need to check parts of the pytest codebase that handle file/path interactions, particularly those that changed between versions 5.1.1 and 5.1.2. Files related to test collection or file handling should be considered.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config.py",
          "src/_pytest/main.py",
          "src/_pytest/pathlib.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:28.806046",
        "usage": "4964.395999908447 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the Issue:\n   - The issue occurs after upgrading pytest from version 5.1.1 to 5.1.2.\n   - There is an ImportError due to a case sensitivity problem with the file path, specifically the path is converted to lower case.\n   - The expected behavior is that the file path should remain in the original case as it was in the previous pytest version 5.1.1.\n\n2. User Expectation and Cause:\n   - Users expect pytest to maintain the correct case sensitivity of paths because on case-sensitive filesystems, a mismatch can lead to ImportError.\n   - This issue may have been introduced by changes in how pytest 5.1.2 handles or resolves paths.\n\n3. Possible Solutions:\n   - Look into changes in path handling between the versions.\n   - Ensure that path handling preserves case sensitivity.\n   - Add additional debugging or configuration options to specify case sensitivity behavior explicitly.\n   - Revert the changes if possible to ensure it aligns with expected behavior without breaking other functionalities.\n\n4. File Content Analysis:\n   - Focus on parts of the code where path processing and module imports occur.\n   - An important method to consider here is `_tryconvertpyarg` where there is an attempt to convert a module name to path.\n   - Other methods involved in collection and path handling, such as `perform_collect` and `gethookproxy`, may also be relevant here.\n\n5. Conclusion:\n   - Since actual path transformation isn't explicitly visible here, it might not be the root cause but closely related.\n   - Need to check if there's any change related to importing or path resolution configuration here that could affect behavior.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [
          "Session._tryconvertpyarg",
          "Session.perform_collect",
          "Session.gethookproxy"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:33.770457",
        "usage": "6192.788124084473 ms"
      },
      "request": {
        "file_path": "src/_pytest/pathlib.py"
      },
      "response": {
        "scratch_pad": "## Scratch Pad\n\n1. Analyze User Instructions:\n   - **Issue Summary:** The issue describes that on upgrading pytest from version 5.1.1 to 5.1.2, there is an ImportError related to the change in path casing. The path is converted to lowercase, which seems to be causing the issue.\n   - **Reproduce Steps:** The user uninstalled pytest 5.1.1 and installed 5.1.2, then tried executing a pytest command which resulted in the error.\n   - **Cause Analysis:** The issue likely arises from case sensitivity changes in path handling in version 5.1.2. On Windows, paths are typically case-insensitive but case-preserving, suggesting an internal change might be converting paths to lower case erroneously.\n   - **User Expectation:** The user expects the path used in the conftest to remain case-preserving and not be changed to all lowercase which causes `ModuleNotFoundError`.\n   - **Possible Solutions:** This could involve correcting the path handling logic, possibly avoiding converting the path to lowercase unless necessary or ensuring correct case handling when resolving paths.\n\n2. Make File Evaluation:\n   - The file `src/_pytest/pathlib.py` includes several utilities dealing with path operations, which are relevant to the path casing issue described.\n   - Functions like `unique_path()` and `find_prefixed()` involve path case handling:\n     - `unique_path()` seems to return a case-normalized path using `normcase`, which might be relevant if this operation leads to casing issues.\n     - Other functions such as `fnmatch_ex()` have conditional logic based on platform-specific path separators that could indirectly affect path casing.\n   - The file contains no direct conversion of paths to lowercase but instead might involve case handling that affects certain operations in a case-insensitive system like Windows.\n\nOverall, the issue described seems related to how this module might be handling path casing, especially if `unique_path()` or `normcase` is applied at some point that causes a loss of original path casing.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "unique_path",
          "fnmatch_ex",
          "find_prefixed",
          "find_suffixes"
        ],
        "root_cause_symbols": [
          "unique_path",
          "fnmatch_ex"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:39.963305",
        "usage": "216.14694595336914 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "pytest_collect_file",
              "_importtestmodule",
              "pytest_collect_file.path_matches_patterns",
              "pytest_pycollect_makemodule"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [
              "ConftestImportFailure",
              "main",
              "_prepareconfig",
              "_try_load_conftest",
              "PytestPluginManager._importconftest"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/compat.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "Session._tryconvertpyarg",
              "Session.perform_collect",
              "Session.gethookproxy"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/pathlib.py",
            "relevant_symbol_keys": [
              "unique_path",
              "fnmatch_ex",
              "find_prefixed",
              "find_suffixes"
            ],
            "root_cause_symbol_keys": [
              "unique_path",
              "fnmatch_ex"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n  ",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.PytestPluginManager._try_load_conftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)",
            "start_line": 390,
            "start_column": 12760,
            "end_line": 4,
            "end_column": 13043,
            "start_byte": 12760,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.pathlib.find_prefixed",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_prefixed(root, prefix):\n    \"\"\"finds all elements in root that begin with the prefix, case insensitive\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x",
            "start_line": 86,
            "start_column": 2046,
            "end_line": 0,
            "end_column": 2287,
            "start_byte": 2046,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.find_suffixes",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_suffixes(root, prefix):\n    \"\"\"combines find_prefixes and extract_suffixes\n    \"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)",
            "start_line": 105,
            "start_column": 2569,
            "end_line": 0,
            "end_column": 2725,
            "start_byte": 2569,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.pathlib.fnmatch_ex",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def fnmatch_ex(pattern, path):\n    \"\"\"FNMatcher port from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the latter matches \"**\" glob expressions\n    for each part of the path, while this algorithm uses the whole path instead.\n\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\" with this algorithm, but not with\n        PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing settings which assume paths match according\n    this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    \"\"\"\n    path = PurePath(path)\n    iswin32 = sys.platform.startswith(\"win\")\n\n    if iswin32 and sep not in pattern and posix_sep in pattern:\n        # Running on Windows, the pattern has no Windows path separators,\n        # and the pattern has one or more Posix path separators. Replace\n        # the Posix path separators with the Windows path separator.\n        pattern = pattern.replace(posix_sep, sep)\n\n    if sep not in pattern:\n        name = path.name\n    else:\n        name = str(path)\n        if path.is_absolute() and not os.path.isabs(pattern):\n            pattern = \"*{}{}\".format(os.sep, pattern)\n    return fnmatch.fnmatch(name, pattern)",
            "start_line": 299,
            "start_column": 8817,
            "end_line": 0,
            "end_column": 10171,
            "start_byte": 8817,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def unique_path(path):\n    \"\"\"Returns a unique path in case-insensitive (but case-preserving) file\n    systems such as Windows.\n\n    This is needed only for ``py.path.local``; ``pathlib.Path`` handles this\n    natively with ``resolve()``.\"\"\"\n    return type(path)(normcase(str(path.realpath())))",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:40.179459",
        "usage": "7784.245014190674 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n  ",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.PytestPluginManager._try_load_conftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)",
            "start_line": 390,
            "start_column": 12760,
            "end_line": 4,
            "end_column": 13043,
            "start_byte": 12760,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          {
            "name": "_pytest.pathlib.find_prefixed",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_prefixed(root, prefix):\n    \"\"\"finds all elements in root that begin with the prefix, case insensitive\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x",
            "start_line": 86,
            "start_column": 2046,
            "end_line": 0,
            "end_column": 2287,
            "start_byte": 2046,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.find_suffixes",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_suffixes(root, prefix):\n    \"\"\"combines find_prefixes and extract_suffixes\n    \"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)",
            "start_line": 105,
            "start_column": 2569,
            "end_line": 0,
            "end_column": 2725,
            "start_byte": 2569,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.pathlib.fnmatch_ex",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def fnmatch_ex(pattern, path):\n    \"\"\"FNMatcher port from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the latter matches \"**\" glob expressions\n    for each part of the path, while this algorithm uses the whole path instead.\n\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\" with this algorithm, but not with\n        PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing settings which assume paths match according\n    this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    \"\"\"\n    path = PurePath(path)\n    iswin32 = sys.platform.startswith(\"win\")\n\n    if iswin32 and sep not in pattern and posix_sep in pattern:\n        # Running on Windows, the pattern has no Windows path separators,\n        # and the pattern has one or more Posix path separators. Replace\n        # the Posix path separators with the Windows path separator.\n        pattern = pattern.replace(posix_sep, sep)\n\n    if sep not in pattern:\n        name = path.name\n    else:\n        name = str(path)\n        if path.is_absolute() and not os.path.isabs(pattern):\n            pattern = \"*{}{}\".format(os.sep, pattern)\n    return fnmatch.fnmatch(name, pattern)",
            "start_line": 299,
            "start_column": 8817,
            "end_line": 0,
            "end_column": 10171,
            "start_byte": 8817,
            "end_byte": 0
          },
          {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def unique_path(path):\n    \"\"\"Returns a unique path in case-insensitive (but case-preserving) file\n    systems such as Windows.\n\n    This is needed only for ``py.path.local``; ``pathlib.Path`` handles this\n    natively with ``resolve()``.\"\"\"\n    return type(path)(normcase(str(path.realpath())))",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The issue described by the user appears to be related to a case sensitivity change in paths between pytest version 5.1.1 and 5.1.2 on a Windows machine.\n2. The issue is likely caused by the path conversion to lower case due to the mechanism of path handling in pytest 5.1.2, which wasn't happening in 5.1.1.\n3. Expected result: The paths should remain case-preserving when tests are collected and executed.\n4. The expectation is that Pytest should handle paths on Windows as case-preserving, since Windows filesystems typically are case-insensitive but case-preserving.\n5. To fix the issue, paths should be treated in a case-preserving manner throughout the pytest collection and configuration process.",
        "symbols": [
          {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "reason": "The unique_path function is used here to ensure unique paths in a case-insensitive manner, which might be converting paths to lower case. This could be causing the issue with path case sensitivity."
          },
          {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/pathlib.py",
            "reason": "This function modifies paths to ensure uniqueness on case-insensitive file systems by using normcase, which may lead to unexpected lowercasing on Windows."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "Symbol _pytest.pathlib.fnmatch_ex seems to handle fnmatch operations. While it adapts path separators for Windows and Posix systems, it does not relate directly to path case sensitivity issues mentioned in the issue.",
          "Symbol _pytest.pathlib.unique_path leverages normcase to handle paths on case-insensitive file systems. This is highly relevant as it may lead to paths being lowercased systematically.",
          "The _pytest.doctest.pytest_collect_file symbol deals with python file collection patterns, which might influence file path processing but does not directly deal with case sensitivity or path normalization.",
          "Symbol _pytest.hookspec.pytest_collect_file does not seem to directly address path conversion or normalization concerns, focusing instead on file collection hooks.",
          "Symbol _pytest.hookspec.pytest_pycollect_makemodule seems focused on module collection and doesn't interact with file paths directly in a way that would cause casing changes as described in the issue.",
          "Within symbol _pytest.python.pytest_collect_file, file extension handling is done, with some path pattern matching, but no direct intervention on path case sensitivity.",
          "The _pytest.python.pytest_pycollect_makemodule symbol focuses mostly on returning Packages or Modules based on file names and has limited interaction with path changes at a case-sensitive level.",
          "The symbol _pytest.python.Module._importtestmodule addresses module import errors and mismatches, possibly alerting to ImportErrors but not relevant to path casing manipulation.",
          "Symbol _pytest.config.ConftestImportFailure signifies import failure cases but does not handle path casing changes directly or normcase utilization.",
          "The _try_load_conftest function in PytestPluginManager evaluates conftest modules within directories but does not operate directly on path transformation relevant to case.",
          "The _importconftest function in PytestPluginManager uses unique_path to normalize file paths and could be involved in path naming convention issues as raised in the user's problem description.",
          "The main function in _pytest.config may catch import-related errors but does not directly involve path formatting changes as seen in version 5.1.2.",
          "Symbol _pytest.main.Session.gethookproxy relates to hook proxies and plugin engagement at specific file paths but doesn't manage paths in manner influencing casing directly."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:47.963762",
        "usage": "5.436182022094727 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
              "start_line": 86,
              "start_column": 2432,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2432,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
              "start_line": 204,
              "start_column": 6768,
              "end_line": 0,
              "end_column": 7010,
              "start_byte": 6768,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_pycollect_makemodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n  ",
              "start_line": 243,
              "start_column": 7772,
              "end_line": 0,
              "end_column": 8254,
              "start_byte": 7772,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
              "start_line": 175,
              "start_column": 6070,
              "end_line": 0,
              "end_column": 6478,
              "start_byte": 6070,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_pycollect_makemodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
              "start_line": 192,
              "start_column": 6693,
              "end_line": 0,
              "end_column": 6847,
              "start_byte": 6693,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Module._importtestmodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
              "start_line": 496,
              "start_column": 18244,
              "end_line": 4,
              "end_column": 20458,
              "start_byte": 18244,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
              "start_line": 349,
              "start_column": 12632,
              "end_line": 0,
              "end_column": 12790,
              "start_byte": 12632,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.ConftestImportFailure",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
              "start_line": 39,
              "start_column": 1031,
              "end_line": 0,
              "end_column": 1213,
              "start_byte": 1031,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.ConftestImportFailure.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
              "start_line": 40,
              "start_column": 1075,
              "end_line": 4,
              "end_column": 1213,
              "start_byte": 1075,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
              "start_line": 46,
              "start_column": 1216,
              "end_line": 0,
              "end_column": 2631,
              "start_byte": 1216,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.cmdline.main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "main = staticmethod(main)",
              "start_line": 88,
              "start_column": 2680,
              "end_line": 4,
              "end_column": 2705,
              "start_byte": 2680,
              "end_byte": 4
            },
            {
              "name": "_pytest.config._prepareconfig",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
              "start_line": 184,
              "start_column": 4849,
              "end_line": 0,
              "end_column": 5907,
              "start_byte": 4849,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.PytestPluginManager._try_load_conftest",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)",
              "start_line": 390,
              "start_column": 12760,
              "end_line": 4,
              "end_column": 13043,
              "start_byte": 12760,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.PytestPluginManager._importconftest",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
              "start_line": 433,
              "start_column": 14219,
              "end_line": 4,
              "end_column": 15693,
              "start_byte": 14219,
              "end_byte": 4
            },
            {
              "name": "_pytest.helpconfig.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
              "start_line": 127,
              "start_column": 3839,
              "end_line": 0,
              "end_column": 4085,
              "start_byte": 3839,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
              "start_line": 122,
              "start_column": 4139,
              "end_line": 0,
              "end_column": 4583,
              "start_byte": 4139,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
              "start_line": 533,
              "start_column": 18086,
              "end_line": 4,
              "end_column": 19153,
              "start_byte": 18086,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
              "start_line": 20,
              "start_column": 425,
              "end_line": 0,
              "end_column": 877,
              "start_byte": 425,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.ExitCode.OK",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mport ",
              "start_line": 28,
              "start_column": 610,
              "end_line": 4,
              "end_column": 616,
              "start_byte": 610,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.TESTS_FAILED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "dpaths import ex",
              "start_line": 30,
              "start_column": 641,
              "end_line": 4,
              "end_column": 657,
              "start_byte": 641,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.INTERRUPTED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ptionInfo\nfrom ",
              "start_line": 32,
              "start_column": 692,
              "end_line": 4,
              "end_column": 707,
              "start_byte": 692,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ytest.compat impor",
              "start_line": 34,
              "start_column": 752,
              "end_line": 4,
              "end_column": 770,
              "start_byte": 752,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.USAGE_ERROR",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "st.outcomes imp",
              "start_line": 36,
              "start_column": 801,
              "end_line": 4,
              "end_column": 816,
              "start_byte": 801,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "kipped\nfrom _pytest.pa",
              "start_line": 38,
              "start_column": 855,
              "end_line": 4,
              "end_column": 877,
              "start_byte": 855,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
              "start_line": 41,
              "start_column": 880,
              "end_line": 0,
              "end_column": 4997,
              "start_byte": 880,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.wrap_session",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
              "start_line": 179,
              "start_column": 5000,
              "end_line": 0,
              "end_column": 6841,
              "start_byte": 5000,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
              "start_line": 226,
              "start_column": 6844,
              "end_line": 0,
              "end_column": 6915,
              "start_byte": 6844,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
              "start_line": 230,
              "start_column": 6918,
              "end_line": 0,
              "end_column": 7299,
              "start_byte": 6918,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
              "start_line": 242,
              "start_column": 7302,
              "end_line": 0,
              "end_column": 7370,
              "start_byte": 7302,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_runtestloop",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
              "start_line": 246,
              "start_column": 7373,
              "end_line": 0,
              "end_column": 8037,
              "start_byte": 7373,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._in_venv",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
              "start_line": 263,
              "start_column": 8040,
              "end_line": 0,
              "end_column": 8570,
              "start_byte": 8040,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_ignore_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
              "start_line": 280,
              "start_column": 8573,
              "end_line": 0,
              "end_column": 9470,
              "start_byte": 8573,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection_modifyitems",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
              "start_line": 308,
              "start_column": 9473,
              "end_line": 0,
              "end_column": 9952,
              "start_byte": 9473,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.FSHookProxy",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
              "start_line": 326,
              "start_column": 9955,
              "end_line": 0,
              "end_column": 10272,
              "start_byte": 9955,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.FSHookProxy.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
              "start_line": 327,
              "start_column": 9978,
              "end_line": 4,
              "end_column": 10111,
              "start_byte": 9978,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.FSHookProxy.__getattr__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
              "start_line": 332,
              "start_column": 10117,
              "end_line": 4,
              "end_column": 10272,
              "start_byte": 10117,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.NoMatch",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
              "start_line": 338,
              "start_column": 10275,
              "end_line": 0,
              "end_column": 10363,
              "start_byte": 10275,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Interrupted",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
              "start_line": 342,
              "start_column": 10366,
              "end_line": 0,
              "end_column": 10488,
              "start_byte": 10366,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Interrupted.__module__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "self.consider_module(pl",
              "start_line": 345,
              "start_column": 10454,
              "end_line": 4,
              "end_column": 10477,
              "start_byte": 10454,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Failed",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
              "start_line": 348,
              "start_column": 10491,
              "end_line": 0,
              "end_column": 10562,
              "start_byte": 10491,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._bestrelpath_cache",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
              "start_line": 352,
              "start_column": 10565,
              "end_line": 0,
              "end_column": 10739,
              "start_byte": 10565,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._bestrelpath_cache.path",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "     return self",
              "start_line": 354,
              "start_column": 10609,
              "end_line": 4,
              "end_column": 10625,
              "start_byte": 10609,
              "end_byte": 4
            },
            {
              "name": "_pytest.main._bestrelpath_cache.__missing__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
              "start_line": 356,
              "start_column": 10631,
              "end_line": 4,
              "end_column": 10739,
              "start_byte": 10631,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
              "start_line": 362,
              "start_column": 10742,
              "end_line": 0,
              "end_column": 24478,
              "start_byte": 10742,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.Interrupted",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "lugin(name))\n\n    def pyt",
              "start_line": 363,
              "start_column": 10780,
              "end_line": 4,
              "end_column": 10805,
              "start_byte": 10780,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.Failed",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "onfigure(self, ",
              "start_line": 364,
              "start_column": 10810,
              "end_line": 4,
              "end_column": 10825,
              "start_byte": 10810,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
              "start_line": 366,
              "start_column": 10831,
              "end_line": 4,
              "end_column": 11652,
              "start_byte": 10831,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__repr__",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
              "start_line": 386,
              "start_column": 11658,
              "end_line": 4,
              "end_column": 11938,
              "start_byte": 11658,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
              "start_line": 395,
              "start_column": 11944,
              "end_line": 4,
              "end_column": 12087,
              "start_byte": 11944,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectstart",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
              "start_line": 399,
              "start_column": 12093,
              "end_line": 4,
              "end_column": 12307,
              "start_byte": 12093,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_runtest_logreport",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
              "start_line": 406,
              "start_column": 12313,
              "end_line": 4,
              "end_column": 12675,
              "start_byte": 12313,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectreport",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "\n        if not foundanchor:\n            self._",
              "start_line": 414,
              "start_column": 12681,
              "end_line": 4,
              "end_column": 12728,
              "start_byte": 12681,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
              "start_line": 416,
              "start_column": 12734,
              "end_line": 4,
              "end_column": 12803,
              "start_byte": 12734,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "f._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.root",
              "start_line": 419,
              "start_column": 12809,
              "end_line": 4,
              "end_column": 13381,
              "start_byte": 12809,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "      # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)",
              "start_line": 433,
              "start_column": 13387,
              "end_line": 4,
              "end_column": 13855,
              "start_byte": 13387,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
              "start_line": 446,
              "start_column": 13861,
              "end_line": 4,
              "end_column": 15034,
              "start_byte": 13861,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
              "start_line": 478,
              "start_column": 15040,
              "end_line": 4,
              "end_column": 15561,
              "start_byte": 15040,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
              "start_line": 492,
              "start_column": 15567,
              "end_line": 4,
              "end_column": 19267,
              "start_byte": 15567,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
              "start_line": 574,
              "start_column": 19273,
              "end_line": 4,
              "end_column": 20107,
              "start_byte": 19273,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._recurse",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
              "start_line": 596,
              "start_column": 20113,
              "end_line": 4,
              "end_column": 20609,
              "start_byte": 20113,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._visit_filter",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
              "start_line": 609,
              "start_column": 20615,
              "end_line": 4,
              "end_column": 20685,
              "start_byte": 20615,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option a",
              "start_line": 613,
              "start_column": 20691,
              "end_line": 4,
              "end_column": 21295,
              "start_byte": 20691,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
              "start_line": 629,
              "start_column": 21301,
              "end_line": 4,
              "end_column": 21965,
              "start_byte": 21301,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.matchnodes",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
              "start_line": 645,
              "start_column": 21971,
              "end_line": 4,
              "end_column": 22355,
              "start_byte": 21971,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._matchnodes",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
              "start_line": 656,
              "start_column": 22361,
              "end_line": 4,
              "end_column": 24003,
              "start_byte": 22361,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.genitems",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
              "start_line": 693,
              "start_column": 24009,
              "end_line": 4,
              "end_column": 24478,
              "start_byte": 24009,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
              "start_line": 76,
              "start_column": 2812,
              "end_line": 0,
              "end_column": 3320,
              "start_byte": 2812,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
              "start_line": 110,
              "start_column": 3366,
              "end_line": 0,
              "end_column": 3580,
              "start_byte": 3366,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "",
              "start_line": 1261,
              "start_column": 48043,
              "end_line": 0,
              "end_column": 49900,
              "start_byte": 48043,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
              "start_line": 80,
              "start_column": 2459,
              "end_line": 0,
              "end_column": 2594,
              "start_byte": 2459,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_cmdline_main",
              "file_path": "src/_pytest/config/__init__.py",
              "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
              "start_line": 22,
              "start_column": 582,
              "end_line": 0,
              "end_column": 756,
              "start_byte": 582,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/main.py",
              "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
              "start_line": 419,
              "start_column": 12809,
              "end_line": 4,
              "end_column": 13381,
              "start_byte": 12809,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 433,
              "start_column": 13387,
              "end_line": 4,
              "end_column": 13855,
              "start_byte": 13387,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
              "start_line": 613,
              "start_column": 20691,
              "end_line": 4,
              "end_column": 21295,
              "start_byte": 20691,
              "end_byte": 4
            },
            {
              "name": "_pytest.pathlib.find_prefixed",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "def find_prefixed(root, prefix):\n    \"\"\"finds all elements in root that begin with the prefix, case insensitive\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x",
              "start_line": 86,
              "start_column": 2046,
              "end_line": 0,
              "end_column": 2287,
              "start_byte": 2046,
              "end_byte": 0
            },
            {
              "name": "_pytest.pathlib.find_suffixes",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "def find_suffixes(root, prefix):\n    \"\"\"combines find_prefixes and extract_suffixes\n    \"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)",
              "start_line": 105,
              "start_column": 2569,
              "end_line": 0,
              "end_column": 2725,
              "start_byte": 2569,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.pathlib.fnmatch_ex",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "def fnmatch_ex(pattern, path):\n    \"\"\"FNMatcher port from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the latter matches \"**\" glob expressions\n    for each part of the path, while this algorithm uses the whole path instead.\n\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\" with this algorithm, but not with\n        PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing settings which assume paths match according\n    this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    \"\"\"\n    path = PurePath(path)\n    iswin32 = sys.platform.startswith(\"win\")\n\n    if iswin32 and sep not in pattern and posix_sep in pattern:\n        # Running on Windows, the pattern has no Windows path separators,\n        # and the pattern has one or more Posix path separators. Replace\n        # the Posix path separators with the Windows path separator.\n        pattern = pattern.replace(posix_sep, sep)\n\n    if sep not in pattern:\n        name = path.name\n    else:\n        name = str(path)\n        if path.is_absolute() and not os.path.isabs(pattern):\n            pattern = \"*{}{}\".format(os.sep, pattern)\n    return fnmatch.fnmatch(name, pattern)",
              "start_line": 299,
              "start_column": 8817,
              "end_line": 0,
              "end_column": 10171,
              "start_byte": 8817,
              "end_byte": 0
            },
            {
              "name": "_pytest.pathlib.unique_path",
              "file_path": "src/_pytest/pathlib.py",
              "file_content": "def unique_path(path):\n    \"\"\"Returns a unique path in case-insensitive (but case-preserving) file\n    systems such as Windows.\n\n    This is needed only for ``py.path.local``; ``pathlib.Path`` handles this\n    natively with ``resolve()``.\"\"\"\n    return type(path)(normcase(str(path.realpath())))",
              "start_line": 339,
              "start_column": 10287,
              "end_line": 0,
              "end_column": 10582,
              "start_byte": 10287,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The issue described by the user appears to be related to a case sensitivity change in paths between pytest version 5.1.1 and 5.1.2 on a Windows machine.\n2. The issue is likely caused by the path conversion to lower case due to the mechanism of path handling in pytest 5.1.2, which wasn't happening in 5.1.1.\n3. Expected result: The paths should remain case-preserving when tests are collected and executed.\n4. The expectation is that Pytest should handle paths on Windows as case-preserving, since Windows filesystems typically are case-insensitive but case-preserving.\n5. To fix the issue, paths should be treated in a case-preserving manner throughout the pytest collection and configuration process.",
          "symbols": [
            {
              "name": "_pytest.config.PytestPluginManager._importconftest",
              "file_path": "src/_pytest/config/__init__.py",
              "reason": "The unique_path function is used here to ensure unique paths in a case-insensitive manner, which might be converting paths to lower case. This could be causing the issue with path case sensitivity."
            },
            {
              "name": "_pytest.pathlib.unique_path",
              "file_path": "src/_pytest/pathlib.py",
              "reason": "This function modifies paths to ensure uniqueness on case-insensitive file systems by using normcase, which may lead to unexpected lowercasing on Windows."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "Symbol _pytest.pathlib.fnmatch_ex seems to handle fnmatch operations. While it adapts path separators for Windows and Posix systems, it does not relate directly to path case sensitivity issues mentioned in the issue.",
            "Symbol _pytest.pathlib.unique_path leverages normcase to handle paths on case-insensitive file systems. This is highly relevant as it may lead to paths being lowercased systematically.",
            "The _pytest.doctest.pytest_collect_file symbol deals with python file collection patterns, which might influence file path processing but does not directly deal with case sensitivity or path normalization.",
            "Symbol _pytest.hookspec.pytest_collect_file does not seem to directly address path conversion or normalization concerns, focusing instead on file collection hooks.",
            "Symbol _pytest.hookspec.pytest_pycollect_makemodule seems focused on module collection and doesn't interact with file paths directly in a way that would cause casing changes as described in the issue.",
            "Within symbol _pytest.python.pytest_collect_file, file extension handling is done, with some path pattern matching, but no direct intervention on path case sensitivity.",
            "The _pytest.python.pytest_pycollect_makemodule symbol focuses mostly on returning Packages or Modules based on file names and has limited interaction with path changes at a case-sensitive level.",
            "The symbol _pytest.python.Module._importtestmodule addresses module import errors and mismatches, possibly alerting to ImportErrors but not relevant to path casing manipulation.",
            "Symbol _pytest.config.ConftestImportFailure signifies import failure cases but does not handle path casing changes directly or normcase utilization.",
            "The _try_load_conftest function in PytestPluginManager evaluates conftest modules within directories but does not operate directly on path transformation relevant to case.",
            "The _importconftest function in PytestPluginManager uses unique_path to normalize file paths and could be involved in path naming convention issues as raised in the user's problem description.",
            "The main function in _pytest.config may catch import-related errors but does not directly involve path formatting changes as seen in version 5.1.2.",
            "Symbol _pytest.main.Session.gethookproxy relates to hook proxies and plugin engagement at specific file paths but doesn't manage paths in manner influencing casing directly."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/config/__init__.py",
          "src/_pytest/pathlib.py"
        ],
        "symbols": [
          "_pytest.config.PytestPluginManager._importconftest",
          "_pytest.pathlib.unique_path"
        ],
        "code_spans": {
          "_pytest.doctest.pytest_collect_file": {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_file": {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_pycollect_makemodule": {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n  ",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          "_pytest.python.pytest_collect_file": {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          "_pytest.python.pytest_pycollect_makemodule": {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          "_pytest.python.Module._importtestmodule": {
            "name": "_pytest.python.Module._importtestmodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _importtestmodule(self):\n        # we assume we are only called once per module\n        importmode = self.config.getoption(\"--import-mode\")\n        try:\n            mod = self.fspath.pyimport(ensuresyspath=importmode)\n        except SyntaxError:\n            raise self.CollectError(\n                _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n            )\n        except self.fspath.ImportMismatchError:\n            e = sys.exc_info()[1]\n            raise self.CollectError(\n                \"import file mismatch:\\n\"\n                \"imported module %r has this __file__ attribute:\\n\"\n                \"  %s\\n\"\n                \"which is not the same as the test file we want to collect:\\n\"\n                \"  %s\\n\"\n                \"HINT: remove __pycache__ / .pyc files and/or use a \"\n                \"unique basename for your test file modules\" % e.args\n            )\n        except ImportError:\n            from _pytest._code.code import ExceptionInfo\n\n            exc_info = ExceptionInfo.from_current()\n            if self.config.getoption(\"verbose\") < 2:\n                exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\")\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            raise self.CollectError(\n                \"ImportError while importing test module '{fspath}'.\\n\"\n                \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n                \"Traceback:\\n\"\n                \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n            )\n        except _pytest.runner.Skipped as e:\n            if e.allow_module_level:\n                raise\n            raise self.CollectError(\n                \"Using pytest.skip outside of a test is not allowed. \"\n                \"To decorate a test function, use the @pytest.mark.skip \"\n                \"or @pytest.mark.skipif decorators instead, and to skip a \"\n                \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n            )\n        self.config.pluginmanager.consider_module(mod)\n        return mod",
            "start_line": 496,
            "start_column": 18244,
            "end_line": 4,
            "end_column": 20458,
            "start_byte": 18244,
            "end_byte": 4
          },
          "_pytest.cacheprovider.pytest_cmdline_main": {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "nftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, a",
            "start_line": 349,
            "start_column": 12632,
            "end_line": 0,
            "end_column": 12790,
            "start_byte": 12632,
            "end_byte": 0
          },
          "_pytest.config.ConftestImportFailure": {
            "name": "_pytest.config.ConftestImportFailure",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 39,
            "start_column": 1031,
            "end_line": 0,
            "end_column": 1213,
            "start_byte": 1031,
            "end_byte": 0
          },
          "_pytest.config.ConftestImportFailure.__init__": {
            "name": "_pytest.config.ConftestImportFailure.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo",
            "start_line": 40,
            "start_column": 1075,
            "end_line": 4,
            "end_column": 1213,
            "start_byte": 1075,
            "end_byte": 4
          },
          "_pytest.config.main": {
            "name": "_pytest.config.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
            "start_line": 46,
            "start_column": 1216,
            "end_line": 0,
            "end_column": 2631,
            "start_byte": 1216,
            "end_byte": 0
          },
          "_pytest.config.cmdline.main": {
            "name": "_pytest.config.cmdline.main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "main = staticmethod(main)",
            "start_line": 88,
            "start_column": 2680,
            "end_line": 4,
            "end_column": 2705,
            "start_byte": 2680,
            "end_byte": 4
          },
          "_pytest.config._prepareconfig": {
            "name": "_pytest.config._prepareconfig",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise",
            "start_line": 184,
            "start_column": 4849,
            "end_line": 0,
            "end_column": 5907,
            "start_byte": 4849,
            "end_byte": 0
          },
          "_pytest.config.PytestPluginManager._try_load_conftest": {
            "name": "_pytest.config.PytestPluginManager._try_load_conftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)",
            "start_line": 390,
            "start_column": 12760,
            "end_line": 4,
            "end_column": 13043,
            "start_byte": 12760,
            "end_byte": 4
          },
          "_pytest.config.PytestPluginManager._importconftest": {
            "name": "_pytest.config.PytestPluginManager._importconftest",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod",
            "start_line": 433,
            "start_column": 14219,
            "end_line": 4,
            "end_column": 15693,
            "start_byte": 14219,
            "end_byte": 4
          },
          "_pytest.helpconfig.pytest_cmdline_main": {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fre",
            "start_line": 127,
            "start_column": 3839,
            "end_line": 0,
            "end_column": 4085,
            "start_byte": 3839,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_cmdline_main": {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance o",
            "start_line": 122,
            "start_column": 4139,
            "end_line": 0,
            "end_column": 4583,
            "start_byte": 4139,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin._runtest_for_main": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n   ",
            "start_line": 533,
            "start_column": 18086,
            "end_line": 4,
            "end_column": 19153,
            "start_byte": 18086,
            "end_byte": 4
          },
          "_pytest.main.ExitCode": {
            "name": "_pytest.main.ExitCode",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "est.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.pa",
            "start_line": 20,
            "start_column": 425,
            "end_line": 0,
            "end_column": 877,
            "start_byte": 425,
            "end_byte": 0
          },
          "_pytest.main.ExitCode.OK": {
            "name": "_pytest.main.ExitCode.OK",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mport ",
            "start_line": 28,
            "start_column": 610,
            "end_line": 4,
            "end_column": 616,
            "start_byte": 610,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.TESTS_FAILED": {
            "name": "_pytest.main.ExitCode.TESTS_FAILED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "dpaths import ex",
            "start_line": 30,
            "start_column": 641,
            "end_line": 4,
            "end_column": 657,
            "start_byte": 641,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.INTERRUPTED": {
            "name": "_pytest.main.ExitCode.INTERRUPTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ptionInfo\nfrom ",
            "start_line": 32,
            "start_column": 692,
            "end_line": 4,
            "end_column": 707,
            "start_byte": 692,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.INTERNAL_ERROR": {
            "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ytest.compat impor",
            "start_line": 34,
            "start_column": 752,
            "end_line": 4,
            "end_column": 770,
            "start_byte": 752,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.USAGE_ERROR": {
            "name": "_pytest.main.ExitCode.USAGE_ERROR",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st.outcomes imp",
            "start_line": 36,
            "start_column": 801,
            "end_line": 4,
            "end_column": 816,
            "start_byte": 801,
            "end_byte": 4
          },
          "_pytest.main.ExitCode.NO_TESTS_COLLECTED": {
            "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "kipped\nfrom _pytest.pa",
            "start_line": 38,
            "start_column": 855,
            "end_line": 4,
            "end_column": 877,
            "start_byte": 855,
            "end_byte": 4
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ib import unique_path\nfrom _pytest.warning_types import PytestConfigWarning\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo\n\n\ndef main(args=None, plugins=None):\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return 4\n        else:\n            try:\n                return config.hook.pytest_cmdline_main(config=config)\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args, plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        pluginmanager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    warning = None\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.l",
            "start_line": 41,
            "start_column": 880,
            "end_line": 0,
            "end_column": 4997,
            "start_byte": 880,
            "end_byte": 0
          },
          "_pytest.main.wrap_session": {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "l):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        if warning:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(warning, hook=config.hook, stacklevel=4)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclass PytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pluggy.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loadi",
            "start_line": 179,
            "start_column": 5000,
            "end_line": 0,
            "end_column": 6841,
            "start_byte": 5000,
            "end_byte": 0
          },
          "_pytest.main.pytest_cmdline_main": {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__ini",
            "start_line": 226,
            "start_column": 6844,
            "end_line": 0,
            "end_column": 6915,
            "start_byte": 6844,
            "end_byte": 0
          },
          "_pytest.main._main": {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "(\"pytest\")\n        self._conftest_plugins = set()\n\n        # state related to local conftest plugins\n        self._dirpath2confmods = {}\n        self._conftestpath2mod = {}\n        self._confcutdir = None\n        self._noconftest = False\n        self._duplicatepaths = set()\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTES",
            "start_line": 230,
            "start_column": 6918,
            "end_line": 0,
            "end_column": 7299,
            "start_byte": 6918,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection": {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "EBUG\"):\n            err = sys.stderr\n            encoding = getattr(",
            "start_line": 242,
            "start_column": 7302,
            "end_line": 0,
            "end_column": 7370,
            "start_byte": 7302,
            "end_byte": 0
          },
          "_pytest.main.pytest_runtestloop": {
            "name": "_pytest.main.pytest_runtestloop",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": ", \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=encoding)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes",
            "start_line": 246,
            "start_column": 7373,
            "end_line": 0,
            "end_column": 8037,
            "start_byte": 7373,
            "end_byte": 0
          },
          "_pytest.main._in_venv": {
            "name": "_pytest.main._in_venv",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "      # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"p",
            "start_line": 263,
            "start_column": 8040,
            "end_line": 0,
            "end_column": 8570,
            "start_byte": 8040,
            "end_byte": 0
          },
          "_pytest.main.pytest_ignore_collect": {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "st_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues/4562\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n  ",
            "start_line": 280,
            "start_column": 8573,
            "end_line": 0,
            "end_column": 9470,
            "start_byte": 8573,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "           opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"historic\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin, name=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                PytestConfigWarning(\n                 ",
            "start_line": 308,
            "start_column": 9473,
            "end_line": 0,
            "end_column": 9952,
            "start_byte": 9473,
            "end_byte": 0
          },
          "_pytest.main.FSHookProxy": {
            "name": "_pytest.main.FSHookProxy",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\"{} plugin has been merged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 326,
            "start_column": 9955,
            "end_line": 0,
            "end_column": 10272,
            "start_byte": 9955,
            "end_byte": 0
          },
          "_pytest.main.FSHookProxy.__init__": {
            "name": "_pytest.main.FSHookProxy.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ged into the core, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\",",
            "start_line": 327,
            "start_column": 9978,
            "end_line": 4,
            "end_column": 10111,
            "start_byte": 9978,
            "end_byte": 4
          },
          "_pytest.main.FSHookProxy.__getattr__": {
            "name": "_pytest.main.FSHookProxy.__getattr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "                    )\n                )\n            )\n            return\n        ret = super().register(plugin, name)\n        if ret:\n            self.hook",
            "start_line": 332,
            "start_column": 10117,
            "end_line": 4,
            "end_column": 10272,
            "start_byte": 10117,
            "end_byte": 4
          },
          "_pytest.main.NoMatch": {
            "name": "_pytest.main.NoMatch",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "test_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager",
            "start_line": 338,
            "start_column": 10275,
            "end_line": 0,
            "end_column": 10363,
            "start_byte": 10275,
            "end_byte": 0
          },
          "_pytest.main.Interrupted": {
            "name": "_pytest.main.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lf)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n     ",
            "start_line": 342,
            "start_column": 10366,
            "end_line": 0,
            "end_column": 10488,
            "start_byte": 10366,
            "end_byte": 0
          },
          "_pytest.main.Interrupted.__module__": {
            "name": "_pytest.main.Interrupted.__module__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.consider_module(pl",
            "start_line": 345,
            "start_column": 10454,
            "end_line": 4,
            "end_column": 10477,
            "start_byte": 10454,
            "end_byte": 4
          },
          "_pytest.main.Failed": {
            "name": "_pytest.main.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "return ret\n\n    def getplugin(self, name):\n        # support deprecated",
            "start_line": 348,
            "start_column": 10491,
            "end_line": 0,
            "end_column": 10562,
            "start_byte": 10491,
            "end_byte": 0
          },
          "_pytest.main._bestrelpath_cache": {
            "name": "_pytest.main._bestrelpath_cache",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 352,
            "start_column": 10565,
            "end_line": 0,
            "end_column": 10739,
            "start_byte": 10565,
            "end_byte": 0
          },
          "_pytest.main._bestrelpath_cache.path": {
            "name": "_pytest.main._bestrelpath_cache.path",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "     return self",
            "start_line": 354,
            "start_column": 10609,
            "end_line": 4,
            "end_column": 10625,
            "start_byte": 10609,
            "end_byte": 4
          },
          "_pytest.main._bestrelpath_cache.__missing__": {
            "name": "_pytest.main._bestrelpath_cache.__missing__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is regi",
            "start_line": 356,
            "start_column": 10631,
            "end_line": 4,
            "end_column": 10739,
            "start_byte": 10631,
            "end_byte": 4
          },
          "_pytest.main.Session": {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "red.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        directory = unique_path(directory)\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest implicitly, not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n        while self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 362,
            "start_column": 10742,
            "end_line": 0,
            "end_column": 24478,
            "start_byte": 10742,
            "end_byte": 0
          },
          "_pytest.main.Session.Interrupted": {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "lugin(name))\n\n    def pyt",
            "start_line": 363,
            "start_column": 10780,
            "end_line": 4,
            "end_column": 10805,
            "start_byte": 10780,
            "end_byte": 4
          },
          "_pytest.main.Session.Failed": {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "onfigure(self, ",
            "start_line": 364,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10825,
            "start_byte": 10810,
            "end_byte": 4
          },
          "_pytest.main.Session.__init__": {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may ",
            "start_line": 366,
            "start_column": 10831,
            "end_line": 4,
            "end_column": 11652,
            "start_byte": 10831,
            "end_byte": 4
          },
          "_pytest.main.Session.__repr__": {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "eir own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n       ",
            "start_line": 386,
            "start_column": 11658,
            "end_line": 4,
            "end_column": 11938,
            "start_byte": 11658,
            "end_byte": 4
          },
          "_pytest.main.Session._node_location_to_relpath": {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "       current = py.path.local()\n        self._confcutdir = (\n            unique_path(current.join(namespace.confcutdir, abs=True))\n           ",
            "start_line": 395,
            "start_column": 11944,
            "end_line": 4,
            "end_column": 12087,
            "start_byte": 11944,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectstart": {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False",
            "start_line": 399,
            "start_column": 12093,
            "end_line": 4,
            "end_column": 12307,
            "start_byte": 12093,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_runtest_logreport": {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor ",
            "start_line": 406,
            "start_column": 12313,
            "end_line": 4,
            "end_column": 12675,
            "start_byte": 12313,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectreport": {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "\n        if not foundanchor:\n            self._",
            "start_line": 414,
            "start_column": 12681,
            "end_line": 4,
            "end_column": 12728,
            "start_byte": 12681,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ad_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n     ",
            "start_line": 416,
            "start_column": 12734,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12734,
            "end_byte": 4
          },
          "_pytest.main.Session.gethookproxy": {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugis are active for this fspath\n            proxy = self.config.hook\n        return proxy",
            "start_line": 419,
            "start_column": 12809,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12809,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 433,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13855,
            "start_byte": 13387,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "   self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use realpath to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        conftestpath = unique_path(conftestpath)\n        try:\n            return self._conftestpath2mod[conftestpath]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self.",
            "start_line": 446,
            "start_column": 13861,
            "end_line": 4,
            "end_column": 15034,
            "start_byte": 13861,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "utdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[conftestpath] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.a",
            "start_line": 478,
            "start_column": 15040,
            "end_line": 4,
            "end_column": 15561,
            "start_byte": 15040,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n      ",
            "start_line": 492,
            "start_column": 15567,
            "end_line": 4,
            "end_column": 19267,
            "start_byte": 15567,
            "end_byte": 4
          },
          "_pytest.main.Session._collectfile": {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs ",
            "start_line": 574,
            "start_column": 19273,
            "end_line": 4,
            "end_column": 20107,
            "start_byte": 19273,
            "end_byte": 4
          },
          "_pytest.main.Session._recurse": {
            "name": "_pytest.main.Session._recurse",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "]\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_",
            "start_line": 596,
            "start_column": 20113,
            "end_line": 4,
            "end_column": 20609,
            "start_byte": 20113,
            "end_byte": 4
          },
          "_pytest.main.Session._visit_filter": {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "able_modules(package_files):\n    for fn in package_files:\n        is_s",
            "start_line": 609,
            "start_column": 20615,
            "end_line": 4,
            "end_column": 20685,
            "start_byte": 20615,
            "end_byte": 4
          },
          "_pytest.main.Session._tryconvertpyarg": {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 613,
            "start_column": 20691,
            "end_line": 4,
            "end_column": 21295,
            "start_byte": 20691,
            "end_byte": 4
          },
          "_pytest.main.Session._parsearg": {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ibutes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: list of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. note::\n\n            Currently the environment variable PYTEST_ADDOPTS is also handled by\n            pytest impli",
            "start_line": 629,
            "start_column": 21301,
            "end_line": 4,
            "end_column": 21965,
            "start_byte": 21301,
            "end_byte": 4
          },
          "_pytest.main.Session.matchnodes": {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " not being part of the invocation.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib()\n        plugins = attr.ib()\n        dir = attr.ib()\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_par",
            "start_line": 645,
            "start_column": 21971,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21971,
            "end_byte": 4
          },
          "_pytest.main.Session._matchnodes": {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}\n        self._override_ini = ()\n        self._opt2dest = {}\n        self._cleanup = []\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"default\")\n            self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n\n    def _ensure_unconfigure(self):\n        if self._configured:\n            self._configured = False\n            self.hook.pytest_unconfigure(config=self)\n            self.hook.pytest_configure._call_history = []\n    ",
            "start_line": 656,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 22361,
            "end_byte": 4
          },
          "_pytest.main.Session.genitems": {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "ile self._cleanup:\n            fin = self._cleanup.pop()\n            fin()\n\n    def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n\n    def pytest_cmdline_parse(self, pluginmanager, args):\n        try:\n            self.parse(args)\n        except UsageError:\n\n            # Handle --version and --help here in a minimal fashion.\n            # This gets done via helpconfig normally, but its\n            # pytest_cmdline_m",
            "start_line": 693,
            "start_column": 24009,
            "end_line": 4,
            "end_column": 24478,
            "start_byte": 24009,
            "end_byte": 4
          },
          "_pytest.mark.pytest_cmdline_main": {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "h of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disa",
            "start_line": 76,
            "start_column": 2812,
            "end_line": 0,
            "end_column": 3320,
            "start_byte": 2812,
            "end_byte": 0
          },
          "_pytest.python.pytest_cmdline_main": {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "s = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"un",
            "start_line": 110,
            "start_column": 3366,
            "end_line": 0,
            "end_column": 3580,
            "start_byte": 3366,
            "end_byte": 0
          },
          "_pytest.python._showfixtures_main": {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "",
            "start_line": 1261,
            "start_column": 48043,
            "end_line": 0,
            "end_column": 49900,
            "start_byte": 48043,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_cmdline_main": {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": " as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True",
            "start_line": 80,
            "start_column": 2459,
            "end_line": 0,
            "end_column": 2594,
            "start_byte": 2459,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_cmdline_main": {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/config/__init__.py",
            "file_content": "UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom _pytest._code import filter_traceback\nfrom _pytes",
            "start_line": 22,
            "start_column": 582,
            "end_line": 0,
            "end_column": 756,
            "start_byte": 582,
            "end_byte": 0
          },
          "_pytest.pathlib.find_prefixed": {
            "name": "_pytest.pathlib.find_prefixed",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_prefixed(root, prefix):\n    \"\"\"finds all elements in root that begin with the prefix, case insensitive\"\"\"\n    l_prefix = prefix.lower()\n    for x in root.iterdir():\n        if x.name.lower().startswith(l_prefix):\n            yield x",
            "start_line": 86,
            "start_column": 2046,
            "end_line": 0,
            "end_column": 2287,
            "start_byte": 2046,
            "end_byte": 0
          },
          "_pytest.pathlib.find_suffixes": {
            "name": "_pytest.pathlib.find_suffixes",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def find_suffixes(root, prefix):\n    \"\"\"combines find_prefixes and extract_suffixes\n    \"\"\"\n    return extract_suffixes(find_prefixed(root, prefix), prefix)",
            "start_line": 105,
            "start_column": 2569,
            "end_line": 0,
            "end_column": 2725,
            "start_byte": 2569,
            "end_byte": 0
          },
          "_pytest.pathlib.fnmatch_ex": {
            "name": "_pytest.pathlib.fnmatch_ex",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def fnmatch_ex(pattern, path):\n    \"\"\"FNMatcher port from py.path.common which works with PurePath() instances.\n\n    The difference between this algorithm and PurePath.match() is that the latter matches \"**\" glob expressions\n    for each part of the path, while this algorithm uses the whole path instead.\n\n    For example:\n        \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\" with this algorithm, but not with\n        PurePath.match().\n\n    This algorithm was ported to keep backward-compatibility with existing settings which assume paths match according\n    this logic.\n\n    References:\n    * https://bugs.python.org/issue29249\n    * https://bugs.python.org/issue34731\n    \"\"\"\n    path = PurePath(path)\n    iswin32 = sys.platform.startswith(\"win\")\n\n    if iswin32 and sep not in pattern and posix_sep in pattern:\n        # Running on Windows, the pattern has no Windows path separators,\n        # and the pattern has one or more Posix path separators. Replace\n        # the Posix path separators with the Windows path separator.\n        pattern = pattern.replace(posix_sep, sep)\n\n    if sep not in pattern:\n        name = path.name\n    else:\n        name = str(path)\n        if path.is_absolute() and not os.path.isabs(pattern):\n            pattern = \"*{}{}\".format(os.sep, pattern)\n    return fnmatch.fnmatch(name, pattern)",
            "start_line": 299,
            "start_column": 8817,
            "end_line": 0,
            "end_column": 10171,
            "start_byte": 8817,
            "end_byte": 0
          },
          "_pytest.pathlib.unique_path": {
            "name": "_pytest.pathlib.unique_path",
            "file_path": "src/_pytest/pathlib.py",
            "file_content": "def unique_path(path):\n    \"\"\"Returns a unique path in case-insensitive (but case-preserving) file\n    systems such as Windows.\n\n    This is needed only for ``py.path.local``; ``pathlib.Path`` handles this\n    natively with ``resolve()``.\"\"\"\n    return type(path)(normcase(str(path.realpath())))",
            "start_line": 339,
            "start_column": 10287,
            "end_line": 0,
            "end_column": 10582,
            "start_byte": 10287,
            "end_byte": 0
          }
        }
      }
    }
  ]
}