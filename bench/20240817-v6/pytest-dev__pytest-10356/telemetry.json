{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-10356",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:48.253175",
        "usage": "1881.0381889343262 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Pytester",
          "Function",
          "copytree",
          "filename_arg",
          "Exception",
          "name2fixturedefs",
          "_create",
          "CollectErrorRepr",
          "absolutepath",
          "get_unpacked_marks",
          "_locationline",
          "Node_fspath",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "threadexception",
          "warning_types",
          "get_scope_package",
          "_resolve_ids",
          "name2pseudofixturedef_key",
          "param",
          "BINOP_MAP",
          "rootpath",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "get_scope_node",
          "deactivate_fixture",
          "_in_suspended",
          "evaluate_xfail_marks",
          "_get_active_fixturedef",
          "create_new_paste",
          "CHECKER_CLASS",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "AND",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "Config_inifile",
          "_T",
          "get_extended_length_path_str",
          "PytestUnraisableExceptionWarning",
          "_ensure_basetemp",
          "add_report_section",
          "_get_teardown_reports",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "WARNS_NONE_ARG",
          "_highlight",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "tell",
          "pytest_keyboard_interrupt",
          "passed",
          "_REPORTCHARS_DEFAULT",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "__repr__",
          "pytest_runtest_call",
          "unset_fixture",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "collect_one_node",
          "typename",
          "start",
          "capfdbinary",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "values",
          "ArgsSource",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "own_mark_names",
          "_build_normal_summary_stats_line",
          "fault_handler_originally_enabled_key",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "_ignore_error",
          "PYTEST_TAG",
          "_warn_about_skipped_plugins",
          "repr_locals",
          "wcswidth",
          "YIELD_FIXTURE",
          "outcomes",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "_surrounding_parens_on_own_lines",
          "get_default_arg_names",
          "RecordedHookCall",
          "_idval_from_value",
          "AssertionState",
          "writable",
          "_prepare_content",
          "set_when",
          "__lt__",
          "PytestWarning",
          "FixtureFunctionMarker",
          "readable",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "extraline",
          "next_higher",
          "build_summary_stats_line",
          "__module__",
          "_idval_from_function",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "apply_warning_filters",
          "timing",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "Config__getini_unknown_type",
          "sep",
          "_has_param_ids",
          "_determine_main_color",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "cleanup_numbered_dir",
          "_replace",
          "makepyprojecttoml",
          "pytest_collection_finish",
          "isinitpath",
          "_AnyPurePath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "marks",
          "HIGH_SCOPES",
          "_typ_map",
          "from_item_and_call",
          "prog",
          "_recurse",
          "_R",
          "runpython_c",
          "pytest_pyfunc_call",
          "_given_basetemp",
          "flush",
          "__contains__",
          "TResult",
          "stream",
          "FDCapture",
          "OK",
          "setdefault",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_allow_bytes_flag",
          "get_timeout_config_value",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "MarkMatcher",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "_get_multicapture",
          "File",
          "fail_fixturefunc",
          "not_expr",
          "AssertionRewriter",
          "IDENT",
          "__next__",
          "PytestAssertRewriteWarning",
          "initialnames",
          "runtest",
          "isnamedtuple",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "old_mark_config_key",
          "write_ensure_prefix",
          "_for_parametrize",
          "Xfail",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "markup",
          "_is_last_item",
          "append_error",
          "index",
          "pytest_unconfigure",
          "TeeCaptureIO",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "LPAREN",
          "_prunetraceback",
          "pytest_internalerror",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "pytest",
          "locals",
          "syspathinsert",
          "lineno",
          "_SCOPE_INDICES",
          "finish",
          "__bool__",
          "_check_scope",
          "_should_repr_global_name",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "try_makedirs",
          "caplog_handler_key",
          "getfixturedefs",
          "pytest_warning_recorded",
          "warn",
          "writeorg",
          "setitem",
          "findsource",
          "_pretty_fixture_path",
          "legacy_path",
          "_handle_teardown_sections",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "TESTPATHS",
          "_params_converter",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "NotSetType",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "addError",
          "call_fixture_func",
          "compile",
          "_names",
          "get_last_failed_paths",
          "emit",
          "_excinfo",
          "matching_platform",
          "and_expr",
          "_collectfile",
          "accept",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "INSTANCE_COLLECTOR",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_split_lines",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "_start",
          "runitem",
          "records",
          "get_log_level_for_setting",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "_warn_or_fail_if_strict",
          "find_suffixes",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "RPAREN",
          "re_match_lines_random",
          "_is_started",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "_get_reports_to_display",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "Config_rootdir",
          "DontReadFromInput",
          "report_collect",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "_arg2scope",
          "ReprEntry",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "is_started",
          "Skipped",
          "Frame",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "ApproxSequenceLike",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "Scanner",
          "append_collect_skipped",
          "strip",
          "reports",
          "_set_main_color",
          "V",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "FixtureRequest_fspath",
          "FixtureFunction",
          "testdir",
          "DEFAULT_REPR_MAX_SIZE",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "__slots__",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "startpath",
          "pytest_sessionstart",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "_S",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "parametersets",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "_with_exception",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "_F",
          "makepyfile",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "getreports",
          "assertstate_key",
          "short_test_summary",
          "_ensure_immutable_ids",
          "_param_ids_generated",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "check_ispytest",
          "_W",
          "add_property",
          "ids",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "width_of_current_line",
          "inline_runsource",
          "_ALL_SCOPES",
          "maybe_delete_a_numbered_dir",
          "idfn",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "ARGUMENT_TYPE_STR",
          "conftest_options",
          "fullsource",
          "python_api",
          "_EmptyClass",
          "_trace",
          "_init_pdb",
          "_color_for_type",
          "rex_outcome",
          "_param_ids_from",
          "addFailure",
          "reportinfo",
          "fixture",
          "_is_main_py",
          "IdMaker",
          "_ET",
          "_NodeReporter",
          "patchsysdict",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "pastebinfile_key",
          "SysPathsSnapshot",
          "f_globals",
          "_getini_unknown_type",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "pluralize",
          "_testcase",
          "HookRecorder",
          "async_warn_and_skip",
          "_report_kwargs_from_json",
          "getitem",
          "_recursive_sequence_map",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "to_xml",
          "_get_global_properties_node",
          "suspend",
          "_validate_config_options",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "StashKey",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "_compare_eq_any",
          "suspend_capturing",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "expression",
          "add_stats",
          "IGNORED_ATTRIBUTES",
          "_IGNORED_ERRORS",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_write_source",
          "_truncate_by_char_count",
          "saferepr_unlimited",
          "ParameterSet",
          "_import_plugin_specs",
          "traverse_node",
          "FixtureManager",
          "cache_key",
          "_get_legacy_hook_marks",
          "next_lower",
          "tmpdir",
          "__version__",
          "params",
          "TestReport",
          "Parser",
          "evaluate",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "frame",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "_repr_compare",
          "DOCTEST_REPORT_CHOICES",
          "exitstatus",
          "Stash",
          "listchain",
          "unraisable_exception_runtest_hook",
          "write_sep",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reject",
          "wrap_pytest_function_for_tracing",
          "reorder_items_atscope",
          "Metafunc",
          "reprcrash",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "get_stderr_fileno",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "_CACHE_PREFIX_DIRS",
          "message",
          "reset",
          "reprtraceback",
          "summary_warnings",
          "_esctable",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "InstanceDummy",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "_format_trimmed",
          "_no_match_line",
          "ImportPathMismatchError",
          "Cache",
          "delitem",
          "explanation_param",
          "issue_config_time_warning",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_setupstate",
          "_get_plugin_specs_as_list",
          "_get_unknown_ini_keys",
          "_non_printable_ascii_translate_table",
          "inline_genitems",
          "_format_args",
          "TokenType",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "_check_non_top_pytest_plugins",
          "import_plugin",
          "__ne__",
          "ensure_extended_length_path",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "PytestReturnNotNoneWarning",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "__dir__",
          "tmp_path",
          "FixtureRequest",
          "TerminalReporter_startdir",
          "capstderr",
          "filter_traceback_for_conftest_import_failure",
          "relline",
          "resolve_package_path",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "HOOK_LEGACY_PATH_ARG",
          "from_config",
          "fullwidth",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "OR",
          "getfailures",
          "_write_entry_lines",
          "_parse_expression",
          "make_numbered_dir",
          "pytest_collectreport",
          "_Key",
          "NodeMeta",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "ARGUMENT_TYPE_STR_CHOICE",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_IGNORED_WINERRORS",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "longrepr",
          "_format_assertmsg",
          "names",
          "STEPWISE_CACHE_DIR",
          "repr_excinfo",
          "_PluggyPlugin",
          "__attrs_post_init__",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "ARGS",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "caplog_records_key",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "prepend",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "_get_auto_indent",
          "parse_setoption",
          "ARGUMENT_PERCENT_DEFAULT",
          "compat",
          "ishidden",
          "find_prefixed",
          "bestrelpath",
          "create_module",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "add_marker",
          "from_user",
          "python_path",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "_idval_from_argname",
          "getplugin",
          "funcargs",
          "Exit",
          "NODE_CTOR_FSPATH_ARG",
          "read",
          "Markable",
          "template",
          "summary_stats",
          "TerminalWriter",
          "Session_stardir",
          "_assertion_pass",
          "addsection",
          "AlwaysDispatchingPrettyPrinter",
          "Config_invocation_dir",
          "RUNNER_CLASS",
          "messages",
          "_prepareconfig",
          "validate_basetemp",
          "_get_flag_lookup",
          "Scope",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "_is_in_confcutdir",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "NO_TESTS_COLLECTED",
          "LegacyTestdirPlugin",
          "encoding",
          "ensure_newline",
          "exec_module",
          "__init__",
          "lines",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "insert_missing_modules",
          "locate_config",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "_importconftest",
          "ParseError",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "no_header",
          "_getfailureheadline",
          "PytestRemovedIn8Warning",
          "_read_pyc",
          "value",
          "STRICT_OPTION",
          "K",
          "set_trace",
          "write",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "firstlineno",
          "_compare_eq_sequence",
          "count",
          "no_re_match_line",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "from_function",
          "_get_allow_unicode_flag",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "pytester_assertions",
          "handleError",
          "istext",
          "_from_json",
          "SubRequest",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "ImportMode",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MultipleDoctestFailures",
          "stash",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "Token",
          "reprentries",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "NOT",
          "pytest_plugins",
          "_checkversion",
          "_resume",
          "catch_unraisable_exception",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "_resolve_warning_category",
          "from_item",
          "write_line",
          "_get_runner",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "evaluate_skip_marks",
          "_fixturemanager",
          "PytestUnhandledThreadExceptionWarning",
          "_get_continue_on_failure",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "_LiveLoggingNullHandler",
          "lex",
          "_translate_non_printable",
          "funcnamefilter",
          "syspath_prepend",
          "module_name_from_path",
          "EMPTY_BUFFER",
          "_reprcompare",
          "readline",
          "search_pypath",
          "repr_traceback",
          "add_color_level",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "_check_path",
          "HOOK_LEGACY_MARKING",
          "__test__",
          "unraisableexception",
          "reason",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "running_on_ci",
          "_assert_state",
          "notify_exception",
          "test_tmproot",
          "_eval_scope_callable",
          "_strtobool",
          "formatrepr",
          "_validate_plugins",
          "_compare_eq_dict",
          "pytest_collectstart",
          "f_locals",
          "Item",
          "setuponly",
          "_striptext",
          "from_exc_info",
          "is_globally_capturing",
          "has_default_eq",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "visit",
          "kwargs",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "IDENT_PREFIX",
          "junitxml",
          "getrawcode",
          "KEYWORD_MSG_ARG",
          "evaluate_condition",
          "reprlocals",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "catch_threading_exception",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "warn_explicit_for",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "getworkerinfoline",
          "_check_item_and_collector_diamond_inheritance",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "code",
          "make_properties_node",
          "hasnew",
          "xfailed_key",
          "get",
          "resume_capturing",
          "load_config_dict_from_file",
          "maybe_wrap_pytest_function_for_tracing",
          "iterparentnodeids",
          "__delitem__",
          "entrysep",
          "INCOVATION_DIR",
          "reprfuncargs",
          "get_fslocation_from_item",
          "section",
          "request",
          "_match_lines_random",
          "_fail",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "import_path",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "hasopt",
          "LFPluginCollSkipfiles",
          "UNARY_MAP",
          "Cache_makedir",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "_init_checker_class",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "_as_numpy_array",
          "on_rm_rf_error",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "_getparser",
          "legacypath",
          "_PytestWrapper",
          "_showfixtures_main",
          "_color_for_type_default",
          "_get_main_color",
          "PdbTrace",
          "symlink_or_skip",
          "pop",
          "Skip",
          "set_session",
          "get_option_ini",
          "PRIVATE",
          "_get_assertion_exprs",
          "_opentestcase",
          "no_fnmatch_line",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "_getlines",
          "setmulti",
          "thread_exception_runtest_hook",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "_get_raw_skip_reason",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "mkpydir",
          "_idlist",
          "LEGACY_PATH",
          "from_parent",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "xml_key",
          "truncate",
          "obj",
          "E",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "seek",
          "get_source",
          "popen",
          "T",
          "Notset",
          "fail",
          "debugging",
          "outcome",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "_get_increasing_order",
          "WARNING_CMDLINE_PREPARSE_HOOK",
          "families",
          "_traceback",
          "expr",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "_idval_from_value_required",
          "_write_pyc",
          "safe_isclass",
          "_write_content",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "_resolve_parameter_set_ids",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "_NodeType",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "_build_collect_only_summary_stats_line",
          "make_unique_parameterset_ids",
          "store_mark",
          "_runtest_for",
          "_format_lines",
          "_FileHandler",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "_FixtureCachedResult",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "_validate_ids",
          "write_docstring",
          "_get_maxsize_for_saferepr",
          "isiterable",
          "indices",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "_resolve_msg_to_reason",
          "get_terminal_width",
          "startTest",
          "_get_directory",
          "pytest_markeval_namespace",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "KeywordMatcher",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "KNOWN_TYPES",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "reprfileloc",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "_CACHE_PREFIX_VALUES",
          "DEFAULT_MAX_CHARS",
          "_parse_ini_config",
          "assertoutcome",
          "inipath",
          "_is_mocked",
          "fileno",
          "assert_never",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "PathAwareHookProxy",
          "pytest_generate_tests",
          "update",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_enter_pdb",
          "_outrep_summary",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "wcwidth",
          "_WithException",
          "clear_cache",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "func_name",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "seekable",
          "console_main",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
          "writelines",
          "pos",
          "_is_skipped",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "strict",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "get_cache_dir",
          "FixtureValue",
          "record_testreport",
          "_add_stats",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "_compare_approx",
          "no_summary",
          "extract_suffixes",
          "TimeoutExpired",
          "should_do_markup",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "LFPluginCollWrapper",
          "ExceptionChainRepr",
          "_scope",
          "directory_arg",
          "runpytest_subprocess",
          "imply_paths_hooks",
          "CallSpec2",
          "pytest_addoption",
          "_ensure_relative_to_basetemp",
          "safeformat",
          "nose",
          "sections",
          "pytest_ignore_collect",
          "_format",
          "EOF",
          "Session",
          "pytest_pycollect_makeitem",
          "_get_node_id_with_markup",
          "prune_dependency_tree",
          "_windowsconsoleio_workaround",
          "cache",
          "Code",
          "_FixtureFunc",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "set_fixture",
          "generic_visit",
          "fault_handler_stderr_key",
          "derive_importpath",
          "perform_collect",
          "commonpath",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "_pformat_dispatch",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "token",
          "__call__",
          "_hook",
          "instance",
          "resolve_collection_argument",
          "get_optionflags",
          "visit_BoolOp",
          "duration",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "parse_summary_nouns",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "is_async_function",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "LegacyTmpdirPlugin",
          "call_and_report",
          "showfspath",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "MatcherAdapter",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "_imply_path",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "_HandlerType",
          "importlib",
          "listoutcomes",
          "_idval_from_hook",
          "text",
          "_args_converter",
          "D",
          "parse_warning_filter",
          "_try_repr_or_str",
          "DoctestModule",
          "_write_pyc_fp",
          "XFailed",
          "Expression",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "Node_fspath_set",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "pytestmark",
          "get_unpacked_marks",
          "own_mark_names",
          "marks",
          "iter_markers",
          "iter_markers_with_node",
          "evaluate_xfail_marks",
          "evaluate_skip_marks",
          "Mark",
          "mark"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:50.134234",
        "usage": "166.02683067321777 ms"
      },
      "request": {
        "tokens": [
          "pytestmark",
          "get_unpacked_marks",
          "own_mark_names",
          "marks",
          "iter_markers",
          "iter_markers_with_node",
          "evaluate_xfail_marks",
          "evaluate_skip_marks",
          "Mark",
          "mark"
        ]
      },
      "response": {
        "results": {
          "mark": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python_api.py",
            "src/_pytest/hookspec.py"
          ],
          "marks": [
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/deprecated.py"
          ],
          "iter_markers": [
            "src/_pytest/nodes.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "Mark": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py"
          ],
          "pytestmark": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/structures.py"
          ],
          "get_unpacked_marks": [
            "src/_pytest/python.py",
            "src/_pytest/mark/structures.py"
          ],
          "evaluate_skip_marks": [
            "src/_pytest/skipping.py"
          ],
          "evaluate_xfail_marks": [
            "src/_pytest/skipping.py"
          ],
          "iter_markers_with_node": [
            "src/_pytest/nodes.py"
          ],
          "own_mark_names": [
            "src/_pytest/mark/__init__.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:50.300270",
        "usage": "6140.893936157227 ms"
      },
      "request": {
        "keyword_search_results": {
          "mark": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python_api.py",
            "src/_pytest/hookspec.py"
          ],
          "marks": [
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/deprecated.py"
          ],
          "iter_markers": [
            "src/_pytest/nodes.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py"
          ],
          "Mark": [
            "src/pytest/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py"
          ],
          "pytestmark": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/structures.py"
          ],
          "get_unpacked_marks": [
            "src/_pytest/python.py",
            "src/_pytest/mark/structures.py"
          ],
          "evaluate_skip_marks": [
            "src/_pytest/skipping.py"
          ],
          "evaluate_xfail_marks": [
            "src/_pytest/skipping.py"
          ],
          "iter_markers_with_node": [
            "src/_pytest/nodes.py"
          ],
          "own_mark_names": [
            "src/_pytest/mark/__init__.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "### Understanding the Problem Description:\nThe problem is related to the way pytest markers are handled in classes that inherit from multiple base classes. There is an issue with the Method Resolution Order (MRO) causing markers from one base class to be overridden by another instead of merging them. The issue needs handling to ensure that markers from all base classes are preserved.\n\nFrom the description, it involves manipulating or checking marker attributes and likely involves functions or properties that manage these markers in pytest.\n\n### Related Keywords and Analysis:\n1. **mark** - A general term that is closely related to the problem as it deals with pytest markers. Files related to `mark` might contain code relevant to how markers are handled, especially in the context of multiple class inheritance.\n2. **marks** - Another keyword around marking which might have files detailing the structure or behavior of multiple markers.\n3. **iter_markers** - This hints at iteration over markers, and can have logic relevant to resolving multiple markers together.\n4. **pytestmark** - Specifically mentioned in the problem, it is a property being manipulated, and understanding its handling is crucial.\n\n### Files Selection:\nGiven these insights, here are the files most likely related to the issue:\n\n1. **src/_pytest/mark/structures.py** - The most relevant file given it appears in many keyword results ('mark', 'pytestmark', 'get_unpacked_marks'), indicating a central role in the implementation of marker structures.\n2. **src/_pytest/mark/__init__.py** - Likely controls initialization routines or core exports related to markers.\n3. **src/_pytest/nodes.py** - Present for both 'mark' and 'iter_markers', suggests involvement in traversing or managing markers at a node level, possibly useful for understanding MRO applications.\n4. **src/_pytest/python.py** - Part of it deals with 'mark', 'marks', and 'get_unpacked_marks', indicating potential relations to how markers are processed in Python tests.\n5. **src/_pytest/skipping.py** - Associated with 'mark', 'marks', 'iter_markers'; while it might handle conditions generally, marker resolution and skipping are somewhat adjacent in purpose.\n6. **src/_pytest/config/__init__.py** - Comes up with 'mark' and 'pytestmark', could hold configuration mechanisms related to marker management, potentially affecting global behavior.\n   \nThese selected files likely include the logic governing fetching, applying, or merging markers impacted by MRO.",
        "file_paths": [
          "src/_pytest/mark/structures.py",
          "src/_pytest/mark/__init__.py",
          "src/_pytest/nodes.py",
          "src/_pytest/python.py",
          "src/_pytest/skipping.py",
          "src/_pytest/config/__init__.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:56.441176",
        "usage": "5527.188777923584 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/structures.py"
      },
      "response": {
        "scratch_pad": "### Analyze User Instructions\n1.1 The issue described involves pytest markers being lost when inheriting from multiple base classes with markers. Specifically, when two base classes (e.g., `Foo` and `Bar`) both have pytest markers, inheriting from both classes results in only one class's markers being recognized (due to Method Resolution Order or MRO).\n1.2 The user provides a reproduction case using example classes and notes why markers appear lost without a metaclass workaround.\n1.3 This issue likely arises because pytest marks are treated as class attributes, which follow Python's standard MRO rules, causing some markers to be overwritten.\n1.4 The user wants both markers from `Foo` and `Bar` to be present in a derived class `TestDings` without needing to use a metaclass workaround.\n1.5 The issue might be caused by the way pytest marks are aggregated or assigned, and consideration of MRO might have been overlooked.\n1.6 A solution may involve modifying how pytest aggregates markers across class hierarchies, potentially merging marker lists instead of overwriting them following MRO.\n\n### Make file evaluation (structures.py)\n2.1 We need to analyze how marks are applied, stored, and retrieved.\n2.3 This file defines how marks are applied, combined, and normalized. This seems pertinent to how inheritance might affect mark application, specifically the MarkDecorator and related logic.\n2.4 The `MarkDecorator` and `store_mark` functions are key symbols to understand how marks are stored on objects/classes.\n2.5 The `normalize_mark_list` function also seems relevant as it involves unpacking and normalizing marks.\n",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/python.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "store_mark",
          "normalize_mark_list",
          "Mark.combined_with",
          "MarkDecorator.__call__",
          "MarkGenerator.__getattr__"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:01.968381",
        "usage": "6915.217161178589 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/__init__.py"
      },
      "response": {
        "scratch_pad": "The issue described is about how pytest handles markers when a test class inherits from multiple base classes. The current behavior is such that markers from one of the base classes may be lost due to Python's Method Resolution Order (MRO), and the user has suggested an improvement to merge marker values instead.\n\nUpon analyzing the provided file `src/_pytest/mark/__init__.py`, several things are clear:\n\n1. The file is primarily dealing with how markers are defined, matched, and deselected according to command-line options and configuration settings.\n\n2. The `MarkMatcher` class in this file is responsible for creating a matcher for markers present, which is relevant because the issue involves marker resolution.\n\n3. Various functions like `deselect_by_mark` and `pytest_collection_modifyitems` involve the selection and deselection of tests based on markers, suggesting that they play a role in how markers affect test item execution.\n\nHowever, the issue described does not seem to be caused directly by functionality in this file. Instead, it is more about how markers are merged or resolved when dealing with test class inheritance, which is likely handled at a different abstraction level involving class definitions and MRO behavior.\n\nIn conclusion, while this file deals with markers extensively, its role in resolving the issue is indirect. The root of the issue lies in how Python handles attribute resolution across multiple inherited classes, which might require changes or extensions to the current metaclass definitions to correctly combine markers from all base classes.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark/structures.py",
          "src/_pytest/python.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "KeywordMatcher",
          "deselect_by_mark",
          "pytest_collection_modifyitems"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:08.883609",
        "usage": "4876.269817352295 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is regarding the pytest markers being used in multiple base classes (`Foo` and `Bar`) where inheriting from both causes markers to override each other, resulting in markers from only one class being used. This is due to Markers being treated as a single attribute, hence MRO (Method Resolution Order) causes one to override the other.\n1.2 The steps to reproduce are to create base classes with markers, then create a class that inherits from both base classes, and check the effective markers on a test within the inherited class.\n1.3 This issue is caused due to the default behavior where markers are treated as single attributes and do not merge markers based on inheritance unless a custom metaclass is applied.\n1.4 The user expects both markers (`foo` and `bar`) to be applied to tests in inherited classes. However, without a metaclass, MRO causes one marker to be overridden by the other.\n1.5 A metaclass merging markers maintains both markers.\n1.6 Possible solutions include updating the class attributes or metaclasses to merge markers or redefining the marker retrieval process in pytest to consider MRO and handle merging accordingly.\n\n2. Make file evaluation:\n2.1-2.6 Check the given file to see if it relates to processing or managing markers for nodes or items in pytest.\n\nAfter reviewing the content of `src/_pytest/nodes.py`, there is relevant code related to markers as seen in the `Node` class through methods like `add_marker`, `iter_markers`, `iter_markers_with_node`, etc. These methods handle association and retrieval of markers on nodes/items, directly impacting how tests would resolve or inherit markers.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark/structures.py"
        ],
        "relevant_symbols": [
          "Node.add_marker",
          "Node.iter_markers",
          "Node.iter_markers_with_node",
          "Node.get_closest_marker"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:13.759889",
        "usage": "8597.223281860352 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "User Issue Analysis:\n\n1.1 The issue described is about pytest markers in multiple base classes being lost due to how Python's Method Resolution Order (MRO) handles class attributes. The user wants markers from both base classes `Foo` and `Bar` to be available in a derived class but sees markers of one class overriding those of the other.\n\n1.2 The user provides a code reproduction showing how `pytest.mark` on `Foo` and `Bar` lose one of the markers when a subclass `TestDings` inherits from both. The metaclass `BaseMeta` is used to address this issue by merging marks from the MRO of classes.\n\n1.3 This issue is caused by how Python MRO functions \u2014 it will take the first occurrence of an attribute it finds going from left to right in its MRO hierarchy unless specifically told otherwise, as the provided metaclass does.\n\n1.4 The user expects that both markers (`foo` and `bar`) should be associated with `test_dings`. The default Python behavior is to take only the first; this behavior should change to combine markers from both base classes.\n\n1.5 Solutions to this should involve modifying how markers(getattr of markers) are accumulated from the class hierarchy, typically by checking the MRO to incorporate markers from all parent classes.\n\nFile Evaluation:\n2.1-2.3 Reading through the file content, particularly focusing around collecting and managing test function and test class attributes which would include markers.\n2.4 The code involving markers and attributes are methods closely related to class `PyCollector` and functions like `pytest_pycollect_makeitem` which determine how markers might get collected and processed from classes.\n2.5 There also appears to be handling for marker collection and object attribute fetching which might be tied into how this bug manifests \u2014 `get_unpacked_marks` and similar.\n2.6 Being a central file for test setup, execution, and attribute handling, it is relevant to the issue as this is where changes could impact how markers are processed.\n\nSymbols of interest related to marker collection:\n3.1 `PyCollector.funcnamefilter`\n3.2 `PyCollector.istestfunction`\n3.3 `PyCollector.collect`\n3.4 `get_unpacked_marks`\n3.5 `pytest_generate_tests`",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark.py",
          "src/_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "PyCollector.funcnamefilter",
          "PyCollector.istestfunction",
          "PyCollector.collect",
          "get_unpacked_marks",
          "pytest_generate_tests"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:22.357127",
        "usage": "6343.68109703064 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n   1.1 The user is reporting an issue about pytest markers being lost in certain inheritance cases when multiple classes are involved.\n   1.2 The user provides a reproduction case using a metaclass to work around the issue where normally foo and bar markers wouldn't both apply due to MRO.\n   1.3 The issue is likely caused by the way pytest is handling markers on classes through MRO, which may not account for merging marker attributes from multiple base classes.\n   1.4 The user expects that markers from both base classes (Foo and Bar) should be present, but they're not unless a metaclass is used to modify this behavior.\n   1.5 The proposed solution involves considering MRO and merging marker values, possibly deduplicating them by MRO.\n\n2. Make File evaluation:\n   2.1 `_pytest/skipping.py` is focused on skip/xfail markers, which is related to the management of markers.\n   2.2 Functions and structures related to customization or special handling of markers in the context of skipping and xfail could be involved or need adjustment.\n   2.3 The file primarily documents the process of handling `skip` and `xfail`, and it includes functions for adding options, configuring, and handling tests with these markers.\n   2.4 There is no direct code related to solving an attribute merging issue suggestive of tackling the MRO marker merging here.\n\nConclusion:\nFrom my evaluation, this file seems more focused on handling the skip/xfail functions rather than addressing the core issue of attribute merging during class inheritance. It's not handling `pytestmark` directly for generic pytest markers, and more specifically for class decorators or marker gathering based on MRO.\n\nTherefore, I would suggest this might not be the root cause, but might be relevant for understanding marker-based decisions. The core issue might be elsewhere, such as in the part of pytest which collates marker information during test discovery.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark/structures.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:28.700833",
        "usage": "6568.244934082031 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:** \n   - The reported issue is about losing pytest markers in a class hierarchy due to Python's MRO (Method Resolution Order). When multiple base classes have pytest markers, only one set of markers is retained due to MRO. The expectation is to merge such markers from all classes to give a more intuitive behavior.\n\n2. **Analyzing Source Code in `config/__init__.py`:**\n   - The file contains various functionalities related to pytest configuration and plugin management. However, there is no direct reference or handling of pytest markers or class inheritance in relation to markers.\n   - The file primarily deals with configuring pytest, handling plugins, managing command-line options, loading conftest files, etc. \n   - There are no specific functions or classes that seem to handle pytest markers or their combination in inheritance scenarios, which is the crux of the reported issue.\n\n3. **Relevance:**\n   - The main issue is about how pytest markers are handled in class hierarchies. The file `config/__init__.py` does not seem to contain code that manipulates or manages markers from classes. \n   - It's focused on configuration, argument parsing, and plugins rather than test-specific functionalities like markers.\n   - As such, this file is not relevant to resolving the issue of marker aggregation from multiple base classes in a MRO synergy.\n\n4. **Conclusion:**\n   - No symbols or classes related to the specific issue of marker merger across class hierarchies have been identified in this file.\n   - Thus, this file is neither the root cause nor relevant to the described issue.\n   - The root cause is likely in a different part of the pytest codebase where test markers are actively utilized as part of the test collection or execution flow.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark.py",
          "src/_pytest/python.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:35.269125",
        "usage": "209.52177047729492 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/mark/structures.py",
            "relevant_symbol_keys": [
              "store_mark",
              "normalize_mark_list",
              "Mark.combined_with",
              "MarkDecorator.__call__",
              "MarkGenerator.__getattr__"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/mark/__init__.py",
            "relevant_symbol_keys": [
              "KeywordMatcher",
              "deselect_by_mark",
              "pytest_collection_modifyitems"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node.add_marker",
              "Node.iter_markers",
              "Node.iter_markers_with_node",
              "Node.get_closest_marker"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "PyCollector.funcnamefilter",
              "PyCollector.istestfunction",
              "PyCollector.collect",
              "get_unpacked_marks",
              "pytest_generate_tests"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param Mark other: The mark to combine with.\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from: Optional[Mark] = None\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n            _ispytest=True,\n        )",
            "start_line": 229,
            "start_column": 7679,
            "end_line": 4,
            "end_column": 8509,
            "start_byte": 7679,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, arg: Markable) -> Markable:  # type: ignore[misc]\n        pass",
            "start_line": 338,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 11611,
            "start_byte": 11516,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        pass",
            "start_line": 342,
            "start_column": 11617,
            "end_line": 4,
            "end_column": 11715,
            "start_byte": 11617,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 346,
            "start_column": 11721,
            "end_line": 4,
            "end_column": 12100,
            "start_byte": 11721,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(\n    mark_list: Iterable[Union[Mark, MarkDecorator]]\n) -> Iterable[Mark]:\n    \"\"\"\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    \"\"\"\n    for mark in mark_list:\n        mark_obj = getattr(mark, \"mark\", mark)\n        if not isinstance(mark_obj, Mark):\n            raise TypeError(f\"got {repr(mark_obj)} instead of Mark\")\n        yield mark_obj",
            "start_line": 365,
            "start_column": 12387,
            "end_line": 0,
            "end_column": 12953,
            "start_byte": 12387,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = [*get_unpacked_marks(obj), mark]",
            "start_line": 382,
            "start_column": 12956,
            "end_line": 0,
            "end_column": 13308,
            "start_byte": 12956,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        \"\"\"Generate a new :class:`MarkDecorator` with the given name.\"\"\"\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers or self._config.option.strict:\n                    fail(\n                        f\"{name!r} not found in `markers` configuration option\",\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(f\"Unknown '{name}' mark, did you mean 'parametrize'?\")\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/how-to/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}, _ispytest=True), _ispytest=True)",
            "start_line": 489,
            "start_column": 16391,
            "end_line": 4,
            "end_column": 18508,
            "start_byte": 16391,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 326,
            "start_column": 11780,
            "end_line": 4,
            "end_column": 14011,
            "start_byte": 11780,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14748,
            "end_line": 4,
            "end_column": 15546,
            "start_byte": 14748,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 1582,
            "start_column": 61968,
            "end_line": 4,
            "end_column": 62121,
            "start_byte": 61968,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 244,
            "start_column": 8470,
            "end_line": 0,
            "end_column": 8816,
            "start_byte": 8470,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 405,
            "start_column": 12885,
            "end_line": 0,
            "end_column": 13398,
            "start_byte": 12885,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@attr.s(slots=True, auto_attribs=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 132,
            "start_column": 4196,
            "end_line": 0,
            "end_column": 5875,
            "start_byte": 4196,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher._names",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "_names: AbstractSet[str]",
            "start_line": 147,
            "start_column": 4738,
            "end_line": 4,
            "end_column": 4762,
            "start_byte": 4738,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.from_item",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)",
            "start_line": 149,
            "start_column": 4768,
            "end_line": 4,
            "end_column": 5630,
            "start_byte": 4768,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.__call__",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 173,
            "start_column": 5636,
            "end_line": 4,
            "end_column": 5875,
            "start_byte": 5636,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.deselect_by_mark",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    expr = _parse_expression(matchexpr, \"Wrong expression passed to '-m'\")\n    remaining: List[Item] = []\n    deselected: List[Item] = []\n    for item in items:\n        if expr.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 221,
            "start_column": 6925,
            "end_line": 0,
            "end_column": 7473,
            "start_byte": 6925,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
            "start_line": 246,
            "start_column": 7687,
            "end_line": 0,
            "end_column": 7841,
            "start_byte": 7687,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "  group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"Only run tests which match the given substring expression. \"\n        \"An expression is a Python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching ",
            "start_line": 67,
            "start_column": 2067,
            "end_line": 4,
            "end_column": 3011,
            "start_byte": 2067,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 338,
            "start_column": 10576,
            "end_line": 4,
            "end_column": 11343,
            "start_byte": 10576,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of the markers of the node.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 362,
            "start_column": 11349,
            "end_line": 4,
            "end_column": 11681,
            "start_byte": 11349,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 370,
            "start_column": 11687,
            "end_line": 4,
            "end_column": 12183,
            "start_byte": 11687,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        ...",
            "start_line": 383,
            "start_column": 12189,
            "end_line": 4,
            "end_column": 12273,
            "start_byte": 12189,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n        ...",
            "start_line": 387,
            "start_column": 12279,
            "end_line": 4,
            "end_column": 12368,
            "start_byte": 12279,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 391,
            "start_column": 12374,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12374,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    def get_best_relpath(func) -> str:\n        loc = getlocation(func, str(curdir))\n        return bestrelpath(curdir, Path(loc))\n\n    def write_fixture(fixture_def: fixtures.FixtureDef[object]) -> None:\n        argname = fixture_def.argname\n        if verbose <= 0 and argname.startswith(\"_\"):\n            return\n        prettypath = _pretty_fixture_path(fixture_def.func)\n        tw.write(f\"{argname}\", green=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        fixture_doc = inspect.getdoc(fixture_def.func)\n        if fixture_doc:\n            write_docstring(\n                tw, fixture_doc.split(\"\\n\\n\")[0] if verbose <= 0 else fixture_doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n\n    def write_item(item: nodes.Item) -> None:\n        # Not all items have _fixtureinfo attribute.\n        info: Optional[FuncFixtureInfo] = getattr(item, \"_fixtureinfo\", None)\n        if info is None or not info.name2fixturedefs:\n            # This test item does not use any fixtures.\n            return\n        tw.line()\n        tw.sep(\"-\", f\"fixtures used by {item.name}\")\n        # TODO: Fix this type ignore.\n        tw.sep(\"-\", f\"({get_best_relpath(item.function)})\")  # type: ignore[attr-defined]\n        # dict key not used in loop but needed for sorting.\n        for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n            assert fixturedefs is not None\n            if not fixturedefs:\n                continue\n            # Last item is expected to be the one used by the test item.\n            write_fixture(fixturedefs[-1])\n\n    for session_item in session.items:\n        write_item(session_item)\n\n\ndef showfixtures(config: Config) -> Union[int, ExitCode]:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n\n\ndef _showfixture",
            "start_line": 1537,
            "start_column": 59998,
            "end_line": 4,
            "end_column": 61962,
            "start_byte": 59998,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        as",
            "start_line": 409,
            "start_column": 13185,
            "end_line": 0,
            "end_column": 13405,
            "start_byte": 13185,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/python.py",
            "file_content": "name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            na",
            "start_line": 357,
            "start_column": 12103,
            "end_line": 0,
            "end_column": 12384,
            "start_byte": 12103,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)",
            "start_line": 147,
            "start_column": 4645,
            "end_line": 0,
            "end_column": 4853,
            "start_byte": 4645,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/python.py",
            "file_content": "def funcnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)",
            "start_line": 387,
            "start_column": 14095,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14095,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False",
            "start_line": 402,
            "start_column": 14763,
            "end_line": 4,
            "end_column": 15156,
            "start_byte": 14763,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/python.py",
            "file_content": "def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered.\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name, obj in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n                    continue\n                elif isinstance(res, list):\n                    values.extend(res)\n                else:\n                    values.append(res)\n            dict_values.append(values)\n\n        # Between classes in the class hierarchy, reverse-MRO order -- nodes\n        # inherited from base classes should come before subclasses.\n        result = []\n        for values in reversed(dict_values):\n            result.extend(values)\n        return result",
            "start_line": 429,
            "start_column": 16000,
            "end_line": 4,
            "end_column": 17717,
            "start_byte": 16000,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:35.478655",
        "usage": "10722.630262374878 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param Mark other: The mark to combine with.\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from: Optional[Mark] = None\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n            _ispytest=True,\n        )",
            "start_line": 229,
            "start_column": 7679,
            "end_line": 4,
            "end_column": 8509,
            "start_byte": 7679,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, arg: Markable) -> Markable:  # type: ignore[misc]\n        pass",
            "start_line": 338,
            "start_column": 11516,
            "end_line": 4,
            "end_column": 11611,
            "start_byte": 11516,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        pass",
            "start_line": 342,
            "start_column": 11617,
            "end_line": 4,
            "end_column": 11715,
            "start_byte": 11617,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 346,
            "start_column": 11721,
            "end_line": 4,
            "end_column": 12100,
            "start_byte": 11721,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(\n    mark_list: Iterable[Union[Mark, MarkDecorator]]\n) -> Iterable[Mark]:\n    \"\"\"\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    \"\"\"\n    for mark in mark_list:\n        mark_obj = getattr(mark, \"mark\", mark)\n        if not isinstance(mark_obj, Mark):\n            raise TypeError(f\"got {repr(mark_obj)} instead of Mark\")\n        yield mark_obj",
            "start_line": 365,
            "start_column": 12387,
            "end_line": 0,
            "end_column": 12953,
            "start_byte": 12387,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = [*get_unpacked_marks(obj), mark]",
            "start_line": 382,
            "start_column": 12956,
            "end_line": 0,
            "end_column": 13308,
            "start_byte": 12956,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        \"\"\"Generate a new :class:`MarkDecorator` with the given name.\"\"\"\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers or self._config.option.strict:\n                    fail(\n                        f\"{name!r} not found in `markers` configuration option\",\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(f\"Unknown '{name}' mark, did you mean 'parametrize'?\")\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/how-to/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}, _ispytest=True), _ispytest=True)",
            "start_line": 489,
            "start_column": 16391,
            "end_line": 4,
            "end_column": 18508,
            "start_byte": 16391,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 326,
            "start_column": 11780,
            "end_line": 4,
            "end_column": 14011,
            "start_byte": 11780,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14748,
            "end_line": 4,
            "end_column": 15546,
            "start_byte": 14748,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 1582,
            "start_column": 61968,
            "end_line": 4,
            "end_column": 62121,
            "start_byte": 61968,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 244,
            "start_column": 8470,
            "end_line": 0,
            "end_column": 8816,
            "start_byte": 8470,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 405,
            "start_column": 12885,
            "end_line": 0,
            "end_column": 13398,
            "start_byte": 12885,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@attr.s(slots=True, auto_attribs=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 132,
            "start_column": 4196,
            "end_line": 0,
            "end_column": 5875,
            "start_byte": 4196,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher._names",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "_names: AbstractSet[str]",
            "start_line": 147,
            "start_column": 4738,
            "end_line": 4,
            "end_column": 4762,
            "start_byte": 4738,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.from_item",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)",
            "start_line": 149,
            "start_column": 4768,
            "end_line": 4,
            "end_column": 5630,
            "start_byte": 4768,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.__call__",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 173,
            "start_column": 5636,
            "end_line": 4,
            "end_column": 5875,
            "start_byte": 5636,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.deselect_by_mark",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    expr = _parse_expression(matchexpr, \"Wrong expression passed to '-m'\")\n    remaining: List[Item] = []\n    deselected: List[Item] = []\n    for item in items:\n        if expr.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 221,
            "start_column": 6925,
            "end_line": 0,
            "end_column": 7473,
            "start_byte": 6925,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
            "start_line": 246,
            "start_column": 7687,
            "end_line": 0,
            "end_column": 7841,
            "start_byte": 7687,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "  group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"Only run tests which match the given substring expression. \"\n        \"An expression is a Python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching ",
            "start_line": 67,
            "start_column": 2067,
            "end_line": 4,
            "end_column": 3011,
            "start_byte": 2067,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 338,
            "start_column": 10576,
            "end_line": 4,
            "end_column": 11343,
            "start_byte": 10576,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of the markers of the node.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 362,
            "start_column": 11349,
            "end_line": 4,
            "end_column": 11681,
            "start_byte": 11349,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 370,
            "start_column": 11687,
            "end_line": 4,
            "end_column": 12183,
            "start_byte": 11687,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        ...",
            "start_line": 383,
            "start_column": 12189,
            "end_line": 4,
            "end_column": 12273,
            "start_byte": 12189,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n        ...",
            "start_line": 387,
            "start_column": 12279,
            "end_line": 4,
            "end_column": 12368,
            "start_byte": 12279,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 391,
            "start_column": 12374,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12374,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    def get_best_relpath(func) -> str:\n        loc = getlocation(func, str(curdir))\n        return bestrelpath(curdir, Path(loc))\n\n    def write_fixture(fixture_def: fixtures.FixtureDef[object]) -> None:\n        argname = fixture_def.argname\n        if verbose <= 0 and argname.startswith(\"_\"):\n            return\n        prettypath = _pretty_fixture_path(fixture_def.func)\n        tw.write(f\"{argname}\", green=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        fixture_doc = inspect.getdoc(fixture_def.func)\n        if fixture_doc:\n            write_docstring(\n                tw, fixture_doc.split(\"\\n\\n\")[0] if verbose <= 0 else fixture_doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n\n    def write_item(item: nodes.Item) -> None:\n        # Not all items have _fixtureinfo attribute.\n        info: Optional[FuncFixtureInfo] = getattr(item, \"_fixtureinfo\", None)\n        if info is None or not info.name2fixturedefs:\n            # This test item does not use any fixtures.\n            return\n        tw.line()\n        tw.sep(\"-\", f\"fixtures used by {item.name}\")\n        # TODO: Fix this type ignore.\n        tw.sep(\"-\", f\"({get_best_relpath(item.function)})\")  # type: ignore[attr-defined]\n        # dict key not used in loop but needed for sorting.\n        for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n            assert fixturedefs is not None\n            if not fixturedefs:\n                continue\n            # Last item is expected to be the one used by the test item.\n            write_fixture(fixturedefs[-1])\n\n    for session_item in session.items:\n        write_item(session_item)\n\n\ndef showfixtures(config: Config) -> Union[int, ExitCode]:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n\n\ndef _showfixture",
            "start_line": 1537,
            "start_column": 59998,
            "end_line": 4,
            "end_column": 61962,
            "start_byte": 59998,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        as",
            "start_line": 409,
            "start_column": 13185,
            "end_line": 0,
            "end_column": 13405,
            "start_byte": 13185,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/python.py",
            "file_content": "name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            na",
            "start_line": 357,
            "start_column": 12103,
            "end_line": 0,
            "end_column": 12384,
            "start_byte": 12103,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)",
            "start_line": 147,
            "start_column": 4645,
            "end_line": 0,
            "end_column": 4853,
            "start_byte": 4645,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/python.py",
            "file_content": "def funcnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)",
            "start_line": 387,
            "start_column": 14095,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14095,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False",
            "start_line": 402,
            "start_column": 14763,
            "end_line": 4,
            "end_column": 15156,
            "start_byte": 14763,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/python.py",
            "file_content": "def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered.\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name, obj in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n                    continue\n                elif isinstance(res, list):\n                    values.extend(res)\n                else:\n                    values.append(res)\n            dict_values.append(values)\n\n        # Between classes in the class hierarchy, reverse-MRO order -- nodes\n        # inherited from base classes should come before subclasses.\n        result = []\n        for values in reversed(dict_values):\n            result.extend(values)\n        return result",
            "start_line": 429,
            "start_column": 16000,
            "end_line": 4,
            "end_column": 17717,
            "start_byte": 16000,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions: \n1.1 The user is describing an issue where inheriting from two base classes `Foo` and `Bar` with pytest markers leads to losing markers of one of those classes, apparently due to MRO (Method Resolution Order).\n1.2 This issue might be caused by the current way pytest processes markers with MRO, where one marker is overridden by another when classes are combined.\n1.3 The expected result is that both markers (`foo` and `bar`) should be present when running tests on a class inheriting both `Foo` and `Bar`.\n1.4 If no result is provided, the expectation should be that both markers from the base classes are visible and correctly applied to derived classes.\n1.5 The issue should be fixed by adjusting how markers are inherited and merged, possibly using a method that takes both markers into account and deduplicates by MRO.\n\n2. Evaluating Symbols:\n2.1 The relevant code parts are related to how pytest handles marks and modifies the collection you want:\n\n  - `_pytest.mark.Mark.combined_with` suggests a feature for merging or combining marks could align with merging markers during inheritance.\n  - `_pytest.mark.MarkDecorator.__call__` and `store_mark`, are crucial as they deal with storing and applying marks and thus, managing inheritance could depend on how decorators are processed.\n  - `_pytest.mark.normalize_mark_list` could relate to normalizing or consolidating markers across classes.\n\n2.2 We need to investigate how markers get stored and retrieved (`store_mark`, `combined_with`, `normalize_mark_list`) and if they consider MRO.\n\n2.3 Symbols Relevant to Issue:\n - `_pytest.mark.Mark.combined_with`: May need to ensure it applies in class inheritance scenarios effectively merging markers.\n - `_pytest.mark.store_mark`: Looks relevant to how marks are stored; might need adjustment to consider inherited markers.\n - `_pytest.nodes.Node.get_unpacked_marks`: Possibly used for retrieving markers, needs to consider multi-inheritance setups.\n\nDetermining How Many Symbols Need Change:\n - Since `combined_with` might not directly concern multi-class inheritance but rather any two marks, focus should be on `store_mark` and how it's applied.\n - `store_mark` and potentially `get_unpacked_marks` with their use of MRO or extending it with a helper, need altering. They should take into account a proper merge of markers rather than overriding them. \n \nConclusion:\n - Focus on changing these three as they relate closely to handling, storing, and merging marks which is directly tied to the issue described.",
        "symbols": [
          {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "reason": "This function is potentially responsible for combining or merging two marks together, which is closely tied to resolving the issue of handling multiple markers from inherited classes. It would need changes to reflect and properly merge markers when inheritance is involved."
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "reason": "Responsible for storing marks on an object, this might need changes to accommodate multi-inheritance scenarios, ensuring marks are not lost and are correctly merged from all parent classes."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "`_pytest.mark.Mark.combined_with` is responsible for combining two Mark instances, and considering this function for merging markers across base classes is essential. There's a need to adapt it for multi-class inheritance to prevent marker loss.",
          "The decorator `__call__` might not need immediate changes considering it handles the decoration part but not specifically inheritance resolutions.",
          "The `normalize_mark_list` seems to focus more on normalizing marks. However, it doesn't deal directly with MRO or inheritance issues based on its description.",
          "`store_mark` sets the mark which is crucial here. It requires a modification to align with how markers should be handled when multiple classes are inherited from.",
          ""
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:46.201344",
        "usage": "3.002166748046875 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.mark.Mark.combined_with",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param Mark other: The mark to combine with.\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from: Optional[Mark] = None\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n            _ispytest=True,\n        )",
              "start_line": 229,
              "start_column": 7679,
              "end_line": 4,
              "end_column": 8509,
              "start_byte": 7679,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@overload\n    def __call__(self, arg: Markable) -> Markable:  # type: ignore[misc]\n        pass",
              "start_line": 338,
              "start_column": 11516,
              "end_line": 4,
              "end_column": 11611,
              "start_byte": 11516,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@overload\n    def __call__(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        pass",
              "start_line": 342,
              "start_column": 11617,
              "end_line": 4,
              "end_column": 11715,
              "start_byte": 11617,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __call__(self, *args: object, **kwargs: object):\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
              "start_line": 346,
              "start_column": 11721,
              "end_line": 4,
              "end_column": 12100,
              "start_byte": 11721,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.normalize_mark_list",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def normalize_mark_list(\n    mark_list: Iterable[Union[Mark, MarkDecorator]]\n) -> Iterable[Mark]:\n    \"\"\"\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    \"\"\"\n    for mark in mark_list:\n        mark_obj = getattr(mark, \"mark\", mark)\n        if not isinstance(mark_obj, Mark):\n            raise TypeError(f\"got {repr(mark_obj)} instead of Mark\")\n        yield mark_obj",
              "start_line": 365,
              "start_column": 12387,
              "end_line": 0,
              "end_column": 12953,
              "start_byte": 12387,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.store_mark",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = [*get_unpacked_marks(obj), mark]",
              "start_line": 382,
              "start_column": 12956,
              "end_line": 0,
              "end_column": 13308,
              "start_byte": 12956,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkGenerator.__getattr__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        \"\"\"Generate a new :class:`MarkDecorator` with the given name.\"\"\"\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers or self._config.option.strict:\n                    fail(\n                        f\"{name!r} not found in `markers` configuration option\",\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(f\"Unknown '{name}' mark, did you mean 'parametrize'?\")\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/how-to/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}, _ispytest=True), _ispytest=True)",
              "start_line": 489,
              "start_column": 16391,
              "end_line": 4,
              "end_column": 18508,
              "start_byte": 16391,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "",
              "start_line": 326,
              "start_column": 11780,
              "end_line": 4,
              "end_column": 14011,
              "start_byte": 11780,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "",
              "start_line": 398,
              "start_column": 14748,
              "end_line": 4,
              "end_column": 15546,
              "start_byte": 14748,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "",
              "start_line": 1582,
              "start_column": 61968,
              "end_line": 4,
              "end_column": 62121,
              "start_byte": 61968,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "",
              "start_line": 244,
              "start_column": 8470,
              "end_line": 0,
              "end_column": 8816,
              "start_byte": 8470,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "",
              "start_line": 405,
              "start_column": 12885,
              "end_line": 0,
              "end_column": 13398,
              "start_byte": 12885,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.KeywordMatcher",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "@attr.s(slots=True, auto_attribs=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
              "start_line": 132,
              "start_column": 4196,
              "end_line": 0,
              "end_column": 5875,
              "start_byte": 4196,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.KeywordMatcher._names",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "_names: AbstractSet[str]",
              "start_line": 147,
              "start_column": 4738,
              "end_line": 4,
              "end_column": 4762,
              "start_byte": 4738,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.KeywordMatcher.from_item",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "@classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)",
              "start_line": 149,
              "start_column": 4768,
              "end_line": 4,
              "end_column": 5630,
              "start_byte": 4768,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.KeywordMatcher.__call__",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
              "start_line": 173,
              "start_column": 5636,
              "end_line": 4,
              "end_column": 5875,
              "start_byte": 5636,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.deselect_by_mark",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    expr = _parse_expression(matchexpr, \"Wrong expression passed to '-m'\")\n    remaining: List[Item] = []\n    deselected: List[Item] = []\n    for item in items:\n        if expr.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
              "start_line": 221,
              "start_column": 6925,
              "end_line": 0,
              "end_column": 7473,
              "start_byte": 6925,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
              "start_line": 246,
              "start_column": 7687,
              "end_line": 0,
              "end_column": 7841,
              "start_byte": 7687,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/mark/__init__.py",
              "file_content": "  group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"Only run tests which match the given substring expression. \"\n        \"An expression is a Python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching ",
              "start_line": 67,
              "start_column": 2067,
              "end_line": 4,
              "end_column": 3011,
              "start_byte": 2067,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
              "start_line": 338,
              "start_column": 10576,
              "end_line": 4,
              "end_column": 11343,
              "start_byte": 10576,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of the markers of the node.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
              "start_line": 362,
              "start_column": 11349,
              "end_line": 4,
              "end_column": 11681,
              "start_byte": 11349,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers_with_node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
              "start_line": 370,
              "start_column": 11687,
              "end_line": 4,
              "end_column": 12183,
              "start_byte": 11687,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.get_closest_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        ...",
              "start_line": 383,
              "start_column": 12189,
              "end_line": 4,
              "end_column": 12273,
              "start_byte": 12189,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.get_closest_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@overload\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:\n        ...",
              "start_line": 387,
              "start_column": 12279,
              "end_line": 4,
              "end_column": 12368,
              "start_byte": 12279,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.get_closest_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
              "start_line": 391,
              "start_column": 12374,
              "end_line": 4,
              "end_column": 12803,
              "start_byte": 12374,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    def get_best_relpath(func) -> str:\n        loc = getlocation(func, str(curdir))\n        return bestrelpath(curdir, Path(loc))\n\n    def write_fixture(fixture_def: fixtures.FixtureDef[object]) -> None:\n        argname = fixture_def.argname\n        if verbose <= 0 and argname.startswith(\"_\"):\n            return\n        prettypath = _pretty_fixture_path(fixture_def.func)\n        tw.write(f\"{argname}\", green=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        fixture_doc = inspect.getdoc(fixture_def.func)\n        if fixture_doc:\n            write_docstring(\n                tw, fixture_doc.split(\"\\n\\n\")[0] if verbose <= 0 else fixture_doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n\n    def write_item(item: nodes.Item) -> None:\n        # Not all items have _fixtureinfo attribute.\n        info: Optional[FuncFixtureInfo] = getattr(item, \"_fixtureinfo\", None)\n        if info is None or not info.name2fixturedefs:\n            # This test item does not use any fixtures.\n            return\n        tw.line()\n        tw.sep(\"-\", f\"fixtures used by {item.name}\")\n        # TODO: Fix this type ignore.\n        tw.sep(\"-\", f\"({get_best_relpath(item.function)})\")  # type: ignore[attr-defined]\n        # dict key not used in loop but needed for sorting.\n        for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n            assert fixturedefs is not None\n            if not fixturedefs:\n                continue\n            # Last item is expected to be the one used by the test item.\n            write_fixture(fixturedefs[-1])\n\n    for session_item in session.items:\n        write_item(session_item)\n\n\ndef showfixtures(config: Config) -> Union[int, ExitCode]:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n\n\ndef _showfixture",
              "start_line": 1537,
              "start_column": 59998,
              "end_line": 4,
              "end_column": 61962,
              "start_byte": 59998,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_generate_tests",
              "file_path": "src/_pytest/python.py",
              "file_content": "e_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        as",
              "start_line": 409,
              "start_column": 13185,
              "end_line": 0,
              "end_column": 13405,
              "start_byte": 13185,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.get_unpacked_marks",
              "file_path": "src/_pytest/python.py",
              "file_content": "name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            na",
              "start_line": 357,
              "start_column": 12103,
              "end_line": 0,
              "end_column": 12384,
              "start_byte": 12103,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_generate_tests",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)",
              "start_line": 147,
              "start_column": 4645,
              "end_line": 0,
              "end_column": 4853,
              "start_byte": 4645,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.PyCollector.funcnamefilter",
              "file_path": "src/_pytest/python.py",
              "file_content": "def funcnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)",
              "start_line": 387,
              "start_column": 14095,
              "end_line": 4,
              "end_column": 14216,
              "start_byte": 14095,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.istestfunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False",
              "start_line": 402,
              "start_column": 14763,
              "end_line": 4,
              "end_column": 15156,
              "start_byte": 14763,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.collect",
              "file_path": "src/_pytest/python.py",
              "file_content": "def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered.\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name, obj in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n                    continue\n                elif isinstance(res, list):\n                    values.extend(res)\n                else:\n                    values.append(res)\n            dict_values.append(values)\n\n        # Between classes in the class hierarchy, reverse-MRO order -- nodes\n        # inherited from base classes should come before subclasses.\n        result = []\n        for values in reversed(dict_values):\n            result.extend(values)\n        return result",
              "start_line": 429,
              "start_column": 16000,
              "end_line": 4,
              "end_column": 17717,
              "start_byte": 16000,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyzing User Instructions: \n1.1 The user is describing an issue where inheriting from two base classes `Foo` and `Bar` with pytest markers leads to losing markers of one of those classes, apparently due to MRO (Method Resolution Order).\n1.2 This issue might be caused by the current way pytest processes markers with MRO, where one marker is overridden by another when classes are combined.\n1.3 The expected result is that both markers (`foo` and `bar`) should be present when running tests on a class inheriting both `Foo` and `Bar`.\n1.4 If no result is provided, the expectation should be that both markers from the base classes are visible and correctly applied to derived classes.\n1.5 The issue should be fixed by adjusting how markers are inherited and merged, possibly using a method that takes both markers into account and deduplicates by MRO.\n\n2. Evaluating Symbols:\n2.1 The relevant code parts are related to how pytest handles marks and modifies the collection you want:\n\n  - `_pytest.mark.Mark.combined_with` suggests a feature for merging or combining marks could align with merging markers during inheritance.\n  - `_pytest.mark.MarkDecorator.__call__` and `store_mark`, are crucial as they deal with storing and applying marks and thus, managing inheritance could depend on how decorators are processed.\n  - `_pytest.mark.normalize_mark_list` could relate to normalizing or consolidating markers across classes.\n\n2.2 We need to investigate how markers get stored and retrieved (`store_mark`, `combined_with`, `normalize_mark_list`) and if they consider MRO.\n\n2.3 Symbols Relevant to Issue:\n - `_pytest.mark.Mark.combined_with`: May need to ensure it applies in class inheritance scenarios effectively merging markers.\n - `_pytest.mark.store_mark`: Looks relevant to how marks are stored; might need adjustment to consider inherited markers.\n - `_pytest.nodes.Node.get_unpacked_marks`: Possibly used for retrieving markers, needs to consider multi-inheritance setups.\n\nDetermining How Many Symbols Need Change:\n - Since `combined_with` might not directly concern multi-class inheritance but rather any two marks, focus should be on `store_mark` and how it's applied.\n - `store_mark` and potentially `get_unpacked_marks` with their use of MRO or extending it with a helper, need altering. They should take into account a proper merge of markers rather than overriding them. \n \nConclusion:\n - Focus on changing these three as they relate closely to handling, storing, and merging marks which is directly tied to the issue described.",
          "symbols": [
            {
              "name": "_pytest.mark.Mark.combined_with",
              "file_path": "src/_pytest/mark/structures.py",
              "reason": "This function is potentially responsible for combining or merging two marks together, which is closely tied to resolving the issue of handling multiple markers from inherited classes. It would need changes to reflect and properly merge markers when inheritance is involved."
            },
            {
              "name": "_pytest.mark.store_mark",
              "file_path": "src/_pytest/mark/structures.py",
              "reason": "Responsible for storing marks on an object, this might need changes to accommodate multi-inheritance scenarios, ensuring marks are not lost and are correctly merged from all parent classes."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "`_pytest.mark.Mark.combined_with` is responsible for combining two Mark instances, and considering this function for merging markers across base classes is essential. There's a need to adapt it for multi-class inheritance to prevent marker loss.",
            "The decorator `__call__` might not need immediate changes considering it handles the decoration part but not specifically inheritance resolutions.",
            "The `normalize_mark_list` seems to focus more on normalizing marks. However, it doesn't deal directly with MRO or inheritance issues based on its description.",
            "`store_mark` sets the mark which is crucial here. It requires a modification to align with how markers should be handled when multiple classes are inherited from.",
            ""
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/mark/structures.py"
        ],
        "symbols": [
          "_pytest.mark.Mark.combined_with",
          "_pytest.mark.store_mark"
        ],
        "code_spans": {
          "_pytest.mark.Mark.combined_with": {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param Mark other: The mark to combine with.\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from: Optional[Mark] = None\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n            _ispytest=True,\n        )",
            "start_line": 229,
            "start_column": 7679,
            "end_line": 4,
            "end_column": 8509,
            "start_byte": 7679,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.__call__": {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 346,
            "start_column": 11721,
            "end_line": 4,
            "end_column": 12100,
            "start_byte": 11721,
            "end_byte": 4
          },
          "_pytest.mark.normalize_mark_list": {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(\n    mark_list: Iterable[Union[Mark, MarkDecorator]]\n) -> Iterable[Mark]:\n    \"\"\"\n    Normalize an iterable of Mark or MarkDecorator objects into a list of marks\n    by retrieving the `mark` attribute on MarkDecorator instances.\n\n    :param mark_list: marks to normalize\n    :returns: A new list of the extracted Mark objects\n    \"\"\"\n    for mark in mark_list:\n        mark_obj = getattr(mark, \"mark\", mark)\n        if not isinstance(mark_obj, Mark):\n            raise TypeError(f\"got {repr(mark_obj)} instead of Mark\")\n        yield mark_obj",
            "start_line": 365,
            "start_column": 12387,
            "end_line": 0,
            "end_column": 12953,
            "start_byte": 12387,
            "end_byte": 0
          },
          "_pytest.mark.store_mark": {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = [*get_unpacked_marks(obj), mark]",
            "start_line": 382,
            "start_column": 12956,
            "end_line": 0,
            "end_column": 13308,
            "start_byte": 12956,
            "end_byte": 0
          },
          "_pytest.mark.MarkGenerator.__getattr__": {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        \"\"\"Generate a new :class:`MarkDecorator` with the given name.\"\"\"\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers or self._config.option.strict:\n                    fail(\n                        f\"{name!r} not found in `markers` configuration option\",\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(f\"Unknown '{name}' mark, did you mean 'parametrize'?\")\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/how-to/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}, _ispytest=True), _ispytest=True)",
            "start_line": 489,
            "start_column": 16391,
            "end_line": 4,
            "end_column": 18508,
            "start_byte": 16391,
            "end_byte": 4
          },
          "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 326,
            "start_column": 11780,
            "end_line": 4,
            "end_column": 14011,
            "start_byte": 11780,
            "end_byte": 4
          },
          "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 398,
            "start_column": 14748,
            "end_line": 4,
            "end_column": 15546,
            "start_byte": 14748,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 1582,
            "start_column": 61968,
            "end_line": 4,
            "end_column": 62121,
            "start_byte": 61968,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_collection_modifyitems": {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 244,
            "start_column": 8470,
            "end_line": 0,
            "end_column": 8816,
            "start_byte": 8470,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 405,
            "start_column": 12885,
            "end_line": 0,
            "end_column": 13398,
            "start_byte": 12885,
            "end_byte": 0
          },
          "_pytest.mark.KeywordMatcher": {
            "name": "_pytest.mark.KeywordMatcher",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@attr.s(slots=True, auto_attribs=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names: AbstractSet[str]\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 132,
            "start_column": 4196,
            "end_line": 0,
            "end_column": 5875,
            "start_byte": 4196,
            "end_byte": 0
          },
          "_pytest.mark.KeywordMatcher._names": {
            "name": "_pytest.mark.KeywordMatcher._names",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "_names: AbstractSet[str]",
            "start_line": 147,
            "start_column": 4738,
            "end_line": 4,
            "end_column": 4762,
            "start_byte": 4738,
            "end_byte": 4
          },
          "_pytest.mark.KeywordMatcher.from_item": {
            "name": "_pytest.mark.KeywordMatcher.from_item",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items.\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, pytest.Session):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items.\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment.\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # Add the markers to the keywords as we no longer handle them correctly.\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)",
            "start_line": 149,
            "start_column": 4768,
            "end_line": 4,
            "end_column": 5630,
            "start_byte": 4768,
            "end_byte": 4
          },
          "_pytest.mark.KeywordMatcher.__call__": {
            "name": "_pytest.mark.KeywordMatcher.__call__",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 173,
            "start_column": 5636,
            "end_line": 4,
            "end_column": 5875,
            "start_byte": 5636,
            "end_byte": 4
          },
          "_pytest.mark.deselect_by_mark": {
            "name": "_pytest.mark.deselect_by_mark",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    expr = _parse_expression(matchexpr, \"Wrong expression passed to '-m'\")\n    remaining: List[Item] = []\n    deselected: List[Item] = []\n    for item in items:\n        if expr.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 221,
            "start_column": 6925,
            "end_line": 0,
            "end_column": 7473,
            "start_byte": 6925,
            "end_byte": 0
          },
          "_pytest.mark.pytest_collection_modifyitems": {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
            "start_line": 246,
            "start_column": 7687,
            "end_line": 0,
            "end_column": 7841,
            "start_byte": 7687,
            "end_byte": 0
          },
          "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems": {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "  group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"Only run tests which match the given substring expression. \"\n        \"An expression is a Python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywords are matched to classes and functions \"\n        \"containing extra names in their 'extra_keyword_matches' set, \"\n        \"as well as functions which have names assigned directly to them. \"\n        \"The matching ",
            "start_line": 67,
            "start_column": 2067,
            "end_line": 4,
            "end_column": 3011,
            "start_byte": 2067,
            "end_byte": 4
          },
          "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"Dynamically add a marker object to the node.\n\n        :param marker:\n            The marker.\n        :param append:\n            Whether to append the marker, or prepend it.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 338,
            "start_column": 10576,
            "end_line": 4,
            "end_column": 11343,
            "start_byte": 10576,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers": {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of the markers of the node.\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 362,
            "start_column": 11349,
            "end_line": 4,
            "end_column": 11681,
            "start_byte": 11349,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers_with_node": {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"Iterate over all markers of the node.\n\n        :param name: If given, filter the results by the name attribute.\n        :returns: An iterator of (node, mark) tuples.\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 370,
            "start_column": 11687,
            "end_line": 4,
            "end_column": 12183,
            "start_byte": 11687,
            "end_byte": 4
          },
          "_pytest.nodes.Node.get_closest_marker": {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"Return the first marker matching the name, from closest (for\n        example function) to farther level (for example module level).\n\n        :param default: Fallback return value if no marker was found.\n        :param name: Name to filter by.\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 391,
            "start_column": 12374,
            "end_line": 4,
            "end_column": 12803,
            "start_byte": 12374,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_generate_tests": {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    def get_best_relpath(func) -> str:\n        loc = getlocation(func, str(curdir))\n        return bestrelpath(curdir, Path(loc))\n\n    def write_fixture(fixture_def: fixtures.FixtureDef[object]) -> None:\n        argname = fixture_def.argname\n        if verbose <= 0 and argname.startswith(\"_\"):\n            return\n        prettypath = _pretty_fixture_path(fixture_def.func)\n        tw.write(f\"{argname}\", green=True)\n        tw.write(f\" -- {prettypath}\", yellow=True)\n        tw.write(\"\\n\")\n        fixture_doc = inspect.getdoc(fixture_def.func)\n        if fixture_doc:\n            write_docstring(\n                tw, fixture_doc.split(\"\\n\\n\")[0] if verbose <= 0 else fixture_doc\n            )\n        else:\n            tw.line(\"    no docstring available\", red=True)\n\n    def write_item(item: nodes.Item) -> None:\n        # Not all items have _fixtureinfo attribute.\n        info: Optional[FuncFixtureInfo] = getattr(item, \"_fixtureinfo\", None)\n        if info is None or not info.name2fixturedefs:\n            # This test item does not use any fixtures.\n            return\n        tw.line()\n        tw.sep(\"-\", f\"fixtures used by {item.name}\")\n        # TODO: Fix this type ignore.\n        tw.sep(\"-\", f\"({get_best_relpath(item.function)})\")  # type: ignore[attr-defined]\n        # dict key not used in loop but needed for sorting.\n        for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n            assert fixturedefs is not None\n            if not fixturedefs:\n                continue\n            # Last item is expected to be the one used by the test item.\n            write_fixture(fixturedefs[-1])\n\n    for session_item in session.items:\n        write_item(session_item)\n\n\ndef showfixtures(config: Config) -> Union[int, ExitCode]:\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)\n\n\ndef _showfixture",
            "start_line": 1537,
            "start_column": 59998,
            "end_line": 4,
            "end_column": 61962,
            "start_byte": 59998,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_generate_tests": {
            "name": "_pytest.hookspec.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "e_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        as",
            "start_line": 409,
            "start_column": 13185,
            "end_line": 0,
            "end_column": 13405,
            "start_byte": 13185,
            "end_byte": 0
          },
          "_pytest.mark.get_unpacked_marks": {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/python.py",
            "file_content": "name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            na",
            "start_line": 357,
            "start_column": 12103,
            "end_line": 0,
            "end_column": 12384,
            "start_byte": 12103,
            "end_byte": 0
          },
          "_pytest.python.pytest_generate_tests": {
            "name": "_pytest.python.pytest_generate_tests",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_generate_tests(metafunc: \"Metafunc\") -> None:\n    for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n        metafunc.parametrize(*marker.args, **marker.kwargs, _param_mark=marker)",
            "start_line": 147,
            "start_column": 4645,
            "end_line": 0,
            "end_column": 4853,
            "start_byte": 4645,
            "end_byte": 0
          },
          "_pytest.python.PyCollector.funcnamefilter": {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/python.py",
            "file_content": "def funcnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_functions\", name)",
            "start_line": 387,
            "start_column": 14095,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14095,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.istestfunction": {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False",
            "start_line": 402,
            "start_column": 14763,
            "end_line": 4,
            "end_column": 15156,
            "start_byte": 14763,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.collect": {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/python.py",
            "file_content": "def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered.\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name, obj in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n                    continue\n                elif isinstance(res, list):\n                    values.extend(res)\n                else:\n                    values.append(res)\n            dict_values.append(values)\n\n        # Between classes in the class hierarchy, reverse-MRO order -- nodes\n        # inherited from base classes should come before subclasses.\n        result = []\n        for values in reversed(dict_values):\n            result.extend(values)\n        return result",
            "start_line": 429,
            "start_column": 16000,
            "end_line": 4,
            "end_column": 17717,
            "start_byte": 16000,
            "end_byte": 4
          }
        }
      }
    }
  ]
}