{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7490",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:47.708258",
        "usage": "2276.658773422241 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_py_ext_re",
          "_seen",
          "filename_arg",
          "Exception",
          "name2fixturedefs",
          "_create",
          "CollectErrorRepr",
          "resultlog",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "warning_types",
          "_legal_ranges",
          "get_scope_package",
          "param",
          "BINOP_MAP",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "_in_suspended",
          "evaluate_xfail_marks",
          "_get_active_fixturedef",
          "create_new_paste",
          "CHECKER_CLASS",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "AND",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_T",
          "get_extended_length_path_str",
          "_ensure_basetemp",
          "add_report_section",
          "_get_teardown_reports",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "_highlight",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "passed",
          "_REPORTCHARS_DEFAULT",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "_FixtureValue",
          "__repr__",
          "pytest_runtest_call",
          "unset_fixture",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "collect_one_node",
          "typename",
          "start",
          "capfdbinary",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "own_mark_names",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "PYTEST_TAG",
          "repr_locals",
          "illegal_xml_re",
          "wcswidth",
          "outcomes",
          "FakeCollectModule",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "_surrounding_parens_on_own_lines",
          "get_default_arg_names",
          "AssertionState",
          "_prepare_content",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "extraline",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "timing",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "sep",
          "_has_param_ids",
          "_determine_main_color",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "scopename2class",
          "cleanup_numbered_dir",
          "makepyprojecttoml",
          "pytest_collection_finish",
          "isinitpath",
          "_AnyPurePath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "_typ_map",
          "from_item_and_call",
          "prog",
          "_recurse",
          "_R",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "flush",
          "pytest_warning_captured",
          "__contains__",
          "_resolve_arg_ids",
          "stream",
          "FDCapture",
          "OK",
          "setdefault",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_stderr_fileno",
          "_get_allow_bytes_flag",
          "get_timeout_config_value",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "MarkMatcher",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "_get_multicapture",
          "File",
          "fail_fixturefunc",
          "not_expr",
          "AssertionRewriter",
          "FaultHandlerHooks",
          "IDENT",
          "__next__",
          "StoreKey",
          "PytestAssertRewriteWarning",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "old_mark_config_key",
          "write_ensure_prefix",
          "_for_parametrize",
          "Xfail",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "markup",
          "_is_last_item",
          "append_error",
          "pytest_unconfigure",
          "TeeCaptureIO",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "LPAREN",
          "_prunetraceback",
          "pytest_internalerror",
          "_update_message",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "pytest",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "lineno",
          "finish",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "try_makedirs",
          "caplog_handler_key",
          "getfixturedefs",
          "pytest_warning_recorded",
          "warn",
          "_py36_windowsconsoleio_workaround",
          "writeorg",
          "setitem",
          "findsource",
          "_handle_teardown_sections",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "Store",
          "_params_converter",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "NotSetType",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "addError",
          "call_fixture_func",
          "compile",
          "_names",
          "scope2index",
          "_Markable",
          "get_last_failed_paths",
          "emit",
          "_excinfo",
          "matching_platform",
          "and_expr",
          "accept",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_split_lines",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "NODE_USE_FROM_PARENT",
          "_start",
          "runitem",
          "records",
          "get_log_level_for_setting",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "_warn_or_fail_if_strict",
          "find_suffixes",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "RPAREN",
          "re_match_lines_random",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "_legal_chars",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "store",
          "Scanner",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "_set_main_color",
          "V",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "__slots__",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "_assert_expr_to_lineno",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "_S",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "_with_exception",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "_F",
          "makepyfile",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "NoMatch",
          "getreports",
          "assertstate_key",
          "short_test_summary",
          "_ensure_immutable_ids",
          "_param_ids_generated",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "_W",
          "add_property",
          "ids",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "width_of_current_line",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "_color_for_type",
          "rex_outcome",
          "_param_ids_from",
          "addFailure",
          "reportinfo",
          "fixture",
          "_get_pos",
          "_ET",
          "_NodeReporter",
          "patchsysdict",
          "MINUS_K_COLON",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "pastebinfile_key",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "async_warn_and_skip",
          "_report_kwargs_from_json",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "_expecting_failure",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "_compare_eq_any",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "_perform_collect",
          "expression",
          "add_stats",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_write_source",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "cache_key",
          "tmpdir",
          "__version__",
          "_E",
          "params",
          "TestReport",
          "Parser",
          "evaluate",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "resultlog_key",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "exitstatus",
          "listchain",
          "write_sep",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reject",
          "wrap_pytest_function_for_tracing",
          "reorder_items_atscope",
          "Metafunc",
          "reprcrash",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "_CACHE_PREFIX_DIRS",
          "message",
          "reset",
          "reprtraceback",
          "summary_warnings",
          "_esctable",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "_no_match_line",
          "ImportPathMismatchError",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_setupstate",
          "_get_plugin_specs_as_list",
          "_get_unknown_ini_keys",
          "_non_printable_ascii_translate_table",
          "inline_genitems",
          "_format_args",
          "TokenType",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "_check_non_top_pytest_plugins",
          "import_plugin",
          "__ne__",
          "ensure_extended_length_path",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "__dir__",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "filter_traceback_for_conftest_import_failure",
          "relline",
          "resolve_package_path",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "fullwidth",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "OR",
          "getfailures",
          "_write_entry_lines",
          "make_numbered_dir",
          "pytest_collectreport",
          "_Key",
          "NodeMeta",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "longrepr",
          "_format_assertmsg",
          "names",
          "repr_excinfo",
          "_idvalset",
          "_PluggyPlugin",
          "__attrs_post_init__",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "caplog_records_key",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "prepend",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "_get_auto_indent",
          "parse_setoption",
          "unexpectedsuccess_key",
          "compat",
          "ishidden",
          "find_prefixed",
          "_FixtureFunction",
          "create_module",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "JUNIT_XML_DEFAULT_FAMILY",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "TerminalWriter",
          "_assertion_pass",
          "addsection",
          "AlwaysDispatchingPrettyPrinter",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "validate_basetemp",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "FUNCARGNAMES",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "NO_TESTS_COLLECTED",
          "encoding",
          "ensure_newline",
          "exec_module",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "lines",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "locate_config",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "ParseError",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "no_header",
          "_getfailureheadline",
          "_read_pyc",
          "value",
          "K",
          "set_trace",
          "write",
          "_parse_filter",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "no_re_match_line",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "handleError",
          "istext",
          "_from_json",
          "SubRequest",
          "TERMINALWRITER_WRITER",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "ImportMode",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "PYTEST_COLLECT_MODULE",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MINUS_K_DASH",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "Token",
          "FILLFUNCARGS",
          "reprentries",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "NOT",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "from_item",
          "write_line",
          "_get_runner",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "evaluate_skip_marks",
          "_fixturemanager",
          "_get_continue_on_failure",
          "invocation_dir",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "_LiveLoggingNullHandler",
          "lex",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "reason",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "_assert_state",
          "notify_exception",
          "_eval_scope_callable",
          "_strtobool",
          "formatrepr",
          "_validate_plugins",
          "_compare_eq_dict",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "from_exc_info",
          "is_globally_capturing",
          "_visit_filter",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "WARNING_CAPTURED_HOOK",
          "kwargs",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "IDENT_PREFIX",
          "junitxml",
          "getrawcode",
          "evaluate_condition",
          "reprlocals",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "writer",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "getworkerinfoline",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "xfailed_key",
          "get",
          "resume_capturing",
          "load_config_dict_from_file",
          "maybe_wrap_pytest_function_for_tracing",
          "__delitem__",
          "entrysep",
          "reprfuncargs",
          "get_fslocation_from_item",
          "section",
          "_match_lines_random",
          "_fail",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "import_path",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "hasopt",
          "LFPluginCollSkipfiles",
          "UNARY_MAP",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "_init_checker_class",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "on_rm_rf_error",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "_color_for_type_default",
          "_get_main_color",
          "PdbTrace",
          "symlink_or_skip",
          "pop",
          "Skip",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "_get_assertion_exprs",
          "_opentestcase",
          "no_fnmatch_line",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "_getlines",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "mkpydir",
          "from_parent",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "xml_key",
          "_make_plural",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "get_source",
          "popen",
          "T",
          "Notset",
          "fail",
          "debugging",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "skipped_by_mark_key",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "expr",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "safe_isclass",
          "_write_content",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "_NodeType",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "COLLECT_DIRECTORY_HOOK",
          "_runtest_for",
          "_validate_keys",
          "_format_lines",
          "_FileHandler",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "_FixtureCachedResult",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "_validate_ids",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "get_terminal_width",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "KeywordMatcher",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "KNOWN_TYPES",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "reprfileloc",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "_CACHE_PREFIX_VALUES",
          "DEFAULT_MAX_CHARS",
          "_parse_ini_config",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "_legal_xml_re",
          "assert_never",
          "_checkargnotcontained",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_enter_pdb",
          "_outrep_summary",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "wcwidth",
          "_WithException",
          "clear_cache",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "console_main",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "pos",
          "_is_skipped",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "strict",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "get_cache_dir",
          "record_testreport",
          "_add_stats",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "no_summary",
          "extract_suffixes",
          "TimeoutExpired",
          "should_do_markup",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "LFPluginCollWrapper",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "_ensure_relative_to_basetemp",
          "safeformat",
          "nose",
          "sections",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "_format",
          "EOF",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "cache",
          "Code",
          "_FixtureFunc",
          "Junit",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "set_fixture",
          "generic_visit",
          "fault_handler_stderr_key",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "_pformat_dispatch",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "token",
          "__call__",
          "instance",
          "get_optionflags",
          "visit_BoolOp",
          "duration",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "parse_summary_nouns",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "is_async_function",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "_gethookproxy",
          "call_and_report",
          "showfspath",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "MatcherAdapter",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "_HandlerType",
          "importlib",
          "listoutcomes",
          "exprinfo",
          "text",
          "_args_converter",
          "D",
          "_try_repr_or_str",
          "DoctestModule",
          "_write_pyc_fp",
          "XFailed",
          "Expression",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "pytest",
          "test_xfail_test",
          "request",
          "add_marker",
          "xfail",
          "AssertionError",
          "xfail marker",
          "pytest marker",
          "pytest.mark.xfail",
          "test_foo.py"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:49.984931",
        "usage": "183.31193923950195 ms"
      },
      "request": {
        "tokens": [
          "pytest",
          "test_xfail_test",
          "request",
          "add_marker",
          "xfail",
          "AssertionError",
          "xfail marker",
          "pytest marker",
          "pytest.mark.xfail",
          "test_foo.py"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/pytest/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/pytest/__main__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/nodes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/pytest/collect.py",
            "src/_pytest/timing.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/pastebin.py"
          ],
          "request": [
            "src/_pytest/runner.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pytester.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/pastebin.py"
          ],
          "xfail": [
            "src/pytest/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/outcomes.py"
          ],
          "AssertionError": [
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "test_foo.py": [
            "src/_pytest/nodes.py",
            "src/_pytest/pathlib.py"
          ],
          "add_marker": [
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:50.168252",
        "usage": "4940.310001373291 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/pytest/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/freeze_support.py",
            "src/pytest/__main__.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/nodes.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/doctest.py",
            "src/pytest/collect.py",
            "src/_pytest/timing.py",
            "src/_pytest/main.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/pastebin.py"
          ],
          "request": [
            "src/_pytest/runner.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py",
            "src/_pytest/capture.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pytester.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/pastebin.py"
          ],
          "xfail": [
            "src/pytest/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/outcomes.py"
          ],
          "AssertionError": [
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "test_foo.py": [
            "src/_pytest/nodes.py",
            "src/_pytest/pathlib.py"
          ],
          "add_marker": [
            "src/_pytest/nodes.py",
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The problem is about the behavior change in pytest 6 compared to 5.x when dynamically adding an xfail marker using `request.node.add_marker(mark)`.\n\nKeywords and their relevance:\n- **pytest**: General keyword that appears in many modules, not specific enough for this issue.\n- **request**: This is used in the context of the test function to add markers. Relevant files would involve how `request` interacts with tests.\n- **xfail**: Directly relevant since the issue is about the xfail marker behavior change.\n- **AssertionError**: While we get an AssertionError in the example, it's a result of the behavior change; the focus is more on marker addition.\n- **test_foo.py**: This is the test file example given, included in results, but will not be a part of production code.\n- **add_marker**: Directly relevant because the method is used to add the xfail dynamically.\n\nConsidering these keywords, the most directly related files are:\n1. `src/_pytest/mark/structures.py`: Highly likely to be relevant due to `xfail` being a marker.\n2. `src/_pytest/skipping.py`: Related to handling of skipping/xfailed tests.\n3. `src/_pytest/nodes.py`: Involved with nodes where markers might be added.\n4. `src/_pytest/python.py`: Might involve the test collection and marker processing.\n\nOther files related to `add_marker` and `xfail` are less direct but can be included if necessary based on strict 6 file limit.",
        "file_paths": [
          "src/_pytest/mark/structures.py",
          "src/_pytest/skipping.py",
          "src/_pytest/nodes.py",
          "src/_pytest/python.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:55.108591",
        "usage": "6740.446090698242 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/structures.py"
      },
      "response": {
        "scratch_pad": "1. The issue mentioned is that dynamically adding an xfail marker using `request.node.add_marker(mark)` in pytest 5.x used to treat the failing test as a test marked statically with an `xfail`, but with pytest 6.0.0rc0, it results in a failure.\n2. The key component of the issue is that the behavior of xfail markers added via `request.node.add_marker(mark)` has changed between pytest versions 5.x and 6.x.\n\nThe file content provided is the `structures.py` file in the `mark` module of pytest, which deals with the creation and application of marks. This is the place where relevant changes could be introduced relative to the issue.\n\nAnalyzing the file:\n- The code defines classes for Marks (`Mark`, `MarkDecorator`, `MarkGenerator`) and processes marks, which includes marking test functions or classes with decorators.\n- Significant part related to `xfail` marker which might influence the issue is in the `class MarkDecorator:`.\n\nSymbols of interest for this issue:\n- Inside the `MarkDecorator` class, we have `__call__()` and `with_args()` methods, which are key to how marks are applied to functions dynamically or otherwise.\n- Specifically, the `call()` method in `MarkDecorator` might be involved in processing marks added dynamically as it creates or updates the mark association to a function/class.\n\nHowever, this implementation may not provide the entire picture. We need to find out how the newly added behavior differs in the collection or execution time which happens beyond just marking.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/main.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:01.849050",
        "usage": "6931.057929992676 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing the issue:\n- The issue is about a change in behavior between pytest 5.x and 6.x regarding how dynamically added xfail markers behave. In pytest 5.x, dynamically adding an xfail marker using `request.node.add_marker(mark)` would treat the test as expected to fail, i.e., marked with xfail. However, in pytest 6.0.0, such a dynamically marked test raises an assertion error rather than being marked as xfailed.\n- The issue seems to be caused by the handling of the xfail marker in the pytest execution.\n\n2. Evaluating the file `src/_pytest/skipping.py`:\n- The file contains functions and classes that manage skip and xfail markers in pytest.\n- Functions like `evaluate_xfail_marks` and hook implementations like `pytest_runtest_makereport` are involved in evaluating and reporting xfail markers.\n- The `pytest_runtest_makereport` function seems pivotal as it handles the reporting of xfail tests.\n- In particular, the code block that sets `rep.wasxfail` and modifies `rep.outcome` based on xfail evaluation is relevant to the observed behavior change.\n\n3. Identifying relevant symbols:\n- `evaluate_xfail_marks(item: Item) -> Optional[Xfail]`: Evaluates xfail markers on test items; integral to understanding why xfail does not behave as expected.\n- `pytest_runtest_makereport(item: Item, call: CallInfo[None])`: Modifies the test report based on xfail evaluation. This function likely contains the logic that has changed between pytest versions.\n- `.get(xfailed_key, None)` and the subsequent logic that changes the report outcome based on `xfailed` content.\n\nConclusion:\n- The file `src/_pytest/skipping.py` is likely the root cause of the issue since it handles the logic for marking and reporting xfail tests.\n- The symbols `evaluate_xfail_marks` and `pytest_runtest_makereport` are key to this logic.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "evaluate_xfail_marks",
          "pytest_runtest_makereport"
        ],
        "root_cause_symbols": [
          "evaluate_xfail_marks",
          "pytest_runtest_makereport"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:08.780123",
        "usage": "6722.002983093262 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue where the Pytest framework version 6 does not handle dynamically added xfail markers in the same way as version 5 did.\n1.2 Yes, the user provided steps to reproduce the issue: in Pytest 5, adding an xfail marker dynamically using `request.node.add_marker(mark)` causes the test to be marked as xfail. However, in Pytest 6, the test fails instead.\n1.3 The issue was likely caused by changes in how markers are processed or implemented in Pytest 6.\n1.4 User expects dynamically xfail tests to be recognized and handled similarly to statically marked xfail tests. The breaking change might be in how markers are handled or checked during the test execution which does not recognize the dynamically added xfail marker.\n1.5 Possible solutions might involve ensuring that dynamic markers are applied correctly or modifying the add_marker method to trigger similar behavior for dynamic markers as for static markers.\n\n2. Make file evaluation:\n2.1 The `add_marker` method in the `Node` class looks relevant to the problem since it deals with adding markers to test nodes.\n2.2 The issue arises from changes in dynamic marker handling in Pytest 6. The `add_marker` function in the `Node` class could be involved in the deviation of behavior if there's additional logic in this or in other collaborating methods that does not process xfail markers correctly.\n2.3 The content of `add_marker()` and possibly `Node` class methods that apply test outcomes seem most relevant. No other symbols are apparent from node processing logic that indicate direct relevance beyond add_marker and associated marker processing.\n\nThe file appears relevant to the issue, but it might not contain the full context of when test outcomes are marked failed or xfailed, suggesting that the issue could also span into other files responsible for finalizing the test outcome.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Node.add_marker"
        ],
        "root_cause_symbols": [
          "Node.add_marker"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:15.502158",
        "usage": "5663.38586807251 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "### Issue Analysis\n\n1. **Issue Description**:\n   - The issue is about dynamically adding an `xfail` marker to a test using `request.node.add_marker(mark)` in Pytest. It used to be treated as a statically marked `xfail` with Pytest 5.x, but in 6.0.0rc0, it raises an error, causing the test not to be marked as `xfail`.\n\n2. **Reproduce Steps and Cause**:\n   - Using `request.node.add_marker(mark)` and marking a test as `xfail` dynamically was not causing it to fail in pytest 5.x, but with pytest 6.0.0rc0, the failure is not ignored, and an `AssertionError` is raised.\n   - This suggests a change in how markers are applied or handled between versions.\n\n3. **Expected Behavior**:\n   - User expects dynamically added `xfail` markers to behave the same way as if they were added statically.\n\n4. **Possible Solutions**:\n   - Check if the method of dynamically adding the xfail marker has changed.\n   - Check for a different API or correct usage pattern introduced in the newer version of pytest that aligns with its intended usage.\n",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "Function"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:21.165602",
        "usage": "181.31303787231445 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/mark/structures.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [
              "evaluate_xfail_marks",
              "pytest_runtest_makereport"
            ],
            "root_cause_symbol_keys": [
              "evaluate_xfail_marks",
              "pytest_runtest_makereport"
            ]
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node.add_marker"
            ],
            "root_cause_symbol_keys": [
              "Node.add_marker"
            ]
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "Function"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:21.346921",
        "usage": "11825.484991073608 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions:\n1.1 The issue described is that pytest version 6.0.0rc0 is no longer ignoring the failure of tests when dynamically adding an `xfail` marker via `request.node.add_marker(mark)`, which used to work in pytest 5.x.\n1.2 This issue was likely caused by changes in the pytest internal logic for handling xfail markers between versions 5.x and 6.0.0rc0.\n1.3 The expected result is that when an xfail marker is dynamically added to a test using `request.node.add_marker(mark)`, pytest should treat the failing test as expectedly failing, similar to statically marked xfail tests.\n1.4 If no expected result was given, it could be ensuring compatibility with the behavior in previous pytest versions (5.x), where such tests were not considered failures.\n1.5 To fix it, the implementation should check if dynamically added xfail markers are being handled in the same manner as they were previously, i.e., ensure that the test outcome is 'skipped' or 'xfailed'. The logic in `pytest_runtest_makereport` seems particularly relevant for ensuring this behavior.\n\n2. Evaluating Symbols:\n2.1 Analyzing each provided symbol to determine its relevance to the issue with dynamically adding xfail markers.\n2.2 Investigating the implementation details in `pytest_runtest_makereport` found in `src/_pytest/skipping.py` which seem to deal directly with handling the xfail conditions during the test report generation.\n2.3 Consideration of other relevant symbols such as `_pytest.nodes.Node.add_marker` to understand how markers are added to nodes within pytest.\n2.4 Determining that the critical part here involves the logic within `pytest_runtest_makereport` to ensure dynamically added xfail marks are properly processed.\n2.5 Other symbols more related to tests set up or unrelated logic (like `FixtureFunctionMarker`) seem to not directly influence the xfail issue as described and can be deprioritized or dismissed.\n2.6 Based on this, we should potentially change or add logic in `pytest_runtest_makereport` to handle dynamic xfail as intended.",
        "symbols": [
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "reason": "The function implements the report creation logic that should handle xfail markers during test execution. Ensuring this code correctly processes dynamically added xfail markers to produce an 'xfail' result rather than a failure as described in the issue is necessary."
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "reason": "Handles how markers are added to nodes; relevant to ensure dynamic addition of xfail markers aligns with established marker registration practices and potentially influences the modification of test execution flow."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "This is related to how pytest handles test reports. It can decide whether an outcome should be marked as 'xfailed'. If dynamically adding xfail markers isn't working correctly, this might need to be adapted or revisited.",
          "This seems like partial or misaligned logic for setting outcomes based on xfail; only a small, clipped portion of the logic is visible.",
          "The function seems to deal with evaluating xfail marks, determining which should trigger based on given conditions; relevant for understanding if dynamically added xfail marks are being captured by this evaluation process.",
          "This appears to be key logic for producing test results and may directly influence how pytest handles skipped or expected failure outcomes, including xfails.",
          "This is unrelated content or potentially non-consequential logic; lacking specific visible logic in this context for xfail handling.",
          "This defines how to add markers in general, which is directly relevant for the mechanism of adding xfail markers to a request node, potentially influencing if they take effect properly."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:33.172427",
        "usage": "3.219127655029297 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.fixtures._FixtureFunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
              "start_line": 73,
              "start_column": 2273,
              "end_line": 0,
              "end_column": 2348,
              "start_byte": 2273,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker",
              "file_path": "src/_pytest/python.py",
              "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
              "start_line": 1174,
              "start_column": 45925,
              "end_line": 0,
              "end_column": 47430,
              "start_byte": 45925,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
              "file_path": "src/_pytest/python.py",
              "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
              "start_line": 1176,
              "start_column": 45979,
              "end_line": 4,
              "end_column": 46049,
              "start_byte": 45979,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.params",
              "file_path": "src/_pytest/python.py",
              "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
              "start_line": 1177,
              "start_column": 46054,
              "end_line": 4,
              "end_column": 46134,
              "start_byte": 46054,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
              "file_path": "src/_pytest/python.py",
              "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
              "start_line": 1178,
              "start_column": 46139,
              "end_line": 4,
              "end_column": 46182,
              "start_byte": 46139,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
              "file_path": "src/_pytest/python.py",
              "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
              "start_line": 1179,
              "start_column": 46187,
              "end_line": 4,
              "end_column": 46411,
              "start_byte": 46187,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.name",
              "file_path": "src/_pytest/python.py",
              "file_content": "s), return the most narrow scope based on the fi",
              "start_line": 1187,
              "start_column": 46416,
              "end_line": 4,
              "end_column": 46464,
              "start_byte": 46416,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
              "file_path": "src/_pytest/python.py",
              "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
              "start_line": 1189,
              "start_column": 46470,
              "end_line": 4,
              "end_column": 47430,
              "start_byte": 46470,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function",
              "file_path": "src/_pytest/python.py",
              "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1444,
              "start_column": 55214,
              "end_line": 0,
              "end_column": 61637,
              "start_byte": 55214,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Function._ALLOW_MARKERS",
              "file_path": "src/_pytest/python.py",
              "file_content": "_ALLOW_MARKERS = False",
              "start_line": 1450,
              "start_column": 55414,
              "end_line": 4,
              "end_column": 55436,
              "start_byte": 55414,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.__init__",
              "file_path": "src/_pytest/python.py",
              "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
              "start_line": 1452,
              "start_column": 55442,
              "end_line": 4,
              "end_column": 58875,
              "start_byte": 55442,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.from_parent",
              "file_path": "src/_pytest/python.py",
              "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
              "start_line": 1532,
              "start_column": 58881,
              "end_line": 4,
              "end_column": 59087,
              "start_byte": 58881,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._initrequest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
              "start_line": 1539,
              "start_column": 59093,
              "end_line": 4,
              "end_column": 59232,
              "start_byte": 59093,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.function",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
              "start_line": 1543,
              "start_column": 59238,
              "end_line": 4,
              "end_column": 59352,
              "start_byte": 59238,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._getobj",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
              "start_line": 1548,
              "start_column": 59358,
              "end_line": 4,
              "end_column": 59504,
              "start_byte": 59358,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._pyfuncitem",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
              "start_line": 1552,
              "start_column": 59510,
              "end_line": 4,
              "end_column": 59641,
              "start_byte": 59510,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.funcargnames",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
              "start_line": 1557,
              "start_column": 59647,
              "end_line": 4,
              "end_column": 59858,
              "start_byte": 59647,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
              "start_line": 1563,
              "start_column": 59864,
              "end_line": 4,
              "end_column": 59999,
              "start_byte": 59864,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
              "start_line": 1567,
              "start_column": 60005,
              "end_line": 4,
              "end_column": 60189,
              "start_byte": 60005,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
              "start_line": 1573,
              "start_column": 60195,
              "end_line": 4,
              "end_column": 61273,
              "start_byte": 60195,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1595,
              "start_column": 61335,
              "end_line": 4,
              "end_column": 61637,
              "start_byte": 61335,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition",
              "file_path": "src/_pytest/python.py",
              "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
              "start_line": 1604,
              "start_column": 61640,
              "end_line": 0,
              "end_column": 61918,
              "start_byte": 61640,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.FunctionDefinition.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
              "start_line": 1610,
              "start_column": 61792,
              "end_line": 4,
              "end_column": 61897,
              "start_byte": 61792,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "setup = runtest",
              "start_line": 1613,
              "start_column": 61903,
              "end_line": 4,
              "end_column": 61918,
              "start_byte": 61903,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
              "start_line": 141,
              "start_column": 4727,
              "end_line": 0,
              "end_column": 10680,
              "start_byte": 4727,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
              "file_path": "src/_pytest/python.py",
              "file_content": "nly one name \"\n  ",
              "start_line": 142,
              "start_column": 4765,
              "end_line": 4,
              "end_column": 4782,
              "start_byte": 4765,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._excinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": " \"or a list of ",
              "start_line": 143,
              "start_column": 4787,
              "end_line": 4,
              "end_column": 4802,
              "start_byte": 4787,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._testcase",
              "file_path": "src/_pytest/python.py",
              "file_content": "       \"Example:",
              "start_line": 144,
              "start_column": 4860,
              "end_line": 4,
              "end_column": 4876,
              "start_byte": 4860,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
              "start_line": 146,
              "start_column": 4919,
              "end_line": 4,
              "end_column": 5357,
              "start_byte": 4919,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.teardown",
              "file_path": "src/_pytest/python.py",
              "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
              "start_line": 155,
              "start_column": 5363,
              "end_line": 4,
              "end_column": 5574,
              "start_byte": 5363,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.startTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
              "start_line": 162,
              "start_column": 5580,
              "end_line": 4,
              "end_column": 5652,
              "start_byte": 5580,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
              "start_line": 165,
              "start_column": 5658,
              "end_line": 4,
              "end_column": 7099,
              "start_byte": 5658,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addError",
              "file_path": "src/_pytest/python.py",
              "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
              "start_line": 198,
              "start_column": 7105,
              "end_line": 4,
              "end_column": 7399,
              "start_byte": 7105,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
              "start_line": 208,
              "start_column": 7405,
              "end_line": 4,
              "end_column": 7547,
              "start_byte": 7405,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSkip",
              "file_path": "src/_pytest/python.py",
              "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
              "start_line": 213,
              "start_column": 7553,
              "end_line": 4,
              "end_column": 7789,
              "start_byte": 7553,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
              "start_line": 220,
              "start_column": 7795,
              "end_line": 4,
              "end_column": 8072,
              "start_byte": 7795,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
              "start_line": 231,
              "start_column": 8078,
              "end_line": 4,
              "end_column": 8232,
              "start_byte": 8078,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
              "start_line": 236,
              "start_column": 8238,
              "end_line": 4,
              "end_column": 8311,
              "start_byte": 8238,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.stopTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
              "start_line": 239,
              "start_column": 8317,
              "end_line": 4,
              "end_column": 8388,
              "start_byte": 8317,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
              "start_line": 242,
              "start_column": 8394,
              "end_line": 4,
              "end_column": 8842,
              "start_byte": 8394,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
              "start_line": 251,
              "start_column": 8848,
              "end_line": 4,
              "end_column": 10372,
              "start_byte": 8848,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
              "start_line": 281,
              "start_column": 10378,
              "end_line": 4,
              "end_column": 10680,
              "start_byte": 10378,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.hookspec.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 486,
              "start_column": 17380,
              "end_line": 0,
              "end_column": 17867,
              "start_byte": 17380,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
              "start_line": 318,
              "start_column": 10464,
              "end_line": 0,
              "end_column": 10595,
              "start_byte": 10464,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.evaluate_xfail_marks",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
              "start_line": 199,
              "start_column": 6507,
              "end_line": 0,
              "end_column": 7408,
              "start_byte": 6507,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
              "start_line": 259,
              "start_column": 8490,
              "end_line": 0,
              "end_column": 10447,
              "start_byte": 8490,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
              "start_line": 290,
              "start_column": 10683,
              "end_line": 0,
              "end_column": 11441,
              "start_byte": 10683,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
              "start_line": 260,
              "start_column": 8242,
              "end_line": 4,
              "end_column": 9073,
              "start_byte": 8242,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyzing User Instructions:\n1.1 The issue described is that pytest version 6.0.0rc0 is no longer ignoring the failure of tests when dynamically adding an `xfail` marker via `request.node.add_marker(mark)`, which used to work in pytest 5.x.\n1.2 This issue was likely caused by changes in the pytest internal logic for handling xfail markers between versions 5.x and 6.0.0rc0.\n1.3 The expected result is that when an xfail marker is dynamically added to a test using `request.node.add_marker(mark)`, pytest should treat the failing test as expectedly failing, similar to statically marked xfail tests.\n1.4 If no expected result was given, it could be ensuring compatibility with the behavior in previous pytest versions (5.x), where such tests were not considered failures.\n1.5 To fix it, the implementation should check if dynamically added xfail markers are being handled in the same manner as they were previously, i.e., ensure that the test outcome is 'skipped' or 'xfailed'. The logic in `pytest_runtest_makereport` seems particularly relevant for ensuring this behavior.\n\n2. Evaluating Symbols:\n2.1 Analyzing each provided symbol to determine its relevance to the issue with dynamically adding xfail markers.\n2.2 Investigating the implementation details in `pytest_runtest_makereport` found in `src/_pytest/skipping.py` which seem to deal directly with handling the xfail conditions during the test report generation.\n2.3 Consideration of other relevant symbols such as `_pytest.nodes.Node.add_marker` to understand how markers are added to nodes within pytest.\n2.4 Determining that the critical part here involves the logic within `pytest_runtest_makereport` to ensure dynamically added xfail marks are properly processed.\n2.5 Other symbols more related to tests set up or unrelated logic (like `FixtureFunctionMarker`) seem to not directly influence the xfail issue as described and can be deprioritized or dismissed.\n2.6 Based on this, we should potentially change or add logic in `pytest_runtest_makereport` to handle dynamic xfail as intended.",
          "symbols": [
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "reason": "The function implements the report creation logic that should handle xfail markers during test execution. Ensuring this code correctly processes dynamically added xfail markers to produce an 'xfail' result rather than a failure as described in the issue is necessary."
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "reason": "Handles how markers are added to nodes; relevant to ensure dynamic addition of xfail markers aligns with established marker registration practices and potentially influences the modification of test execution flow."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "This is related to how pytest handles test reports. It can decide whether an outcome should be marked as 'xfailed'. If dynamically adding xfail markers isn't working correctly, this might need to be adapted or revisited.",
            "This seems like partial or misaligned logic for setting outcomes based on xfail; only a small, clipped portion of the logic is visible.",
            "The function seems to deal with evaluating xfail marks, determining which should trigger based on given conditions; relevant for understanding if dynamically added xfail marks are being captured by this evaluation process.",
            "This appears to be key logic for producing test results and may directly influence how pytest handles skipped or expected failure outcomes, including xfails.",
            "This is unrelated content or potentially non-consequential logic; lacking specific visible logic in this context for xfail handling.",
            "This defines how to add markers in general, which is directly relevant for the mechanism of adding xfail markers to a request node, potentially influencing if they take effect properly."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/skipping.py",
          "src/_pytest/nodes.py"
        ],
        "symbols": [
          "_pytest.skipping.pytest_runtest_makereport",
          "_pytest.nodes.Node.add_marker"
        ],
        "code_spans": {
          "_pytest.fixtures._FixtureFunction": {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          "_pytest.python.Function": {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          "_pytest.python.Function._ALLOW_MARKERS": {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          "_pytest.python.Function.__init__": {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          "_pytest.python.Function.from_parent": {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          "_pytest.python.Function._initrequest": {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          "_pytest.python.Function.function": {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          "_pytest.python.Function._getobj": {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          "_pytest.python.Function._pyfuncitem": {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          "_pytest.python.Function.funcargnames": {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          "_pytest.python.Function.runtest": {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          "_pytest.python.Function.setup": {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          "_pytest.python.Function._prunetraceback": {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition": {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          "_pytest.python.FunctionDefinition.runtest": {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition.setup": {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction": {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.nofuncargs": {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._excinfo": {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._testcase": {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.setup": {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.startTest": {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._addexcinfo": {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addError": {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSkip": {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addExpectedFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.stopTest": {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._expecting_failure": {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._prunetraceback": {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          "_pytest.skipping.evaluate_xfail_marks": {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          }
        }
      }
    }
  ]
}