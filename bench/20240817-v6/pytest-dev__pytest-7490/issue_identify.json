{
    "file_paths": [
        "src/_pytest/skipping.py",
        "src/_pytest/nodes.py"
    ],
    "symbols": [
        "_pytest.skipping.pytest_runtest_makereport",
        "_pytest.nodes.Node.add_marker"
    ],
    "code_spans": {
        "_pytest.fixtures._FixtureFunction": {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
        },
        "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
        },
        "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
        },
        "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
        },
        "_pytest.python.Function": {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
        },
        "_pytest.python.Function._ALLOW_MARKERS": {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
        },
        "_pytest.python.Function.__init__": {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
        },
        "_pytest.python.Function.from_parent": {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
        },
        "_pytest.python.Function._initrequest": {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
        },
        "_pytest.python.Function.function": {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
        },
        "_pytest.python.Function._getobj": {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
        },
        "_pytest.python.Function._pyfuncitem": {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
        },
        "_pytest.python.Function.funcargnames": {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
        },
        "_pytest.python.Function.runtest": {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
        },
        "_pytest.python.Function.setup": {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
        },
        "_pytest.python.Function._prunetraceback": {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
        },
        "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
        },
        "_pytest.python.FunctionDefinition": {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
        },
        "_pytest.python.FunctionDefinition.runtest": {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
        },
        "_pytest.python.FunctionDefinition.setup": {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction": {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
        },
        "_pytest.unittest.TestCaseFunction.nofuncargs": {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction._excinfo": {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction._testcase": {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.setup": {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.startTest": {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction._addexcinfo": {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addError": {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addSkip": {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addExpectedFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.addSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.stopTest": {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction._expecting_failure": {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
        },
        "_pytest.unittest.TestCaseFunction._prunetraceback": {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
        },
        "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
        },
        "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
        },
        "_pytest.skipping.evaluate_xfail_marks": {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
        },
        "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
        },
        "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
        },
        "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
        }
    }
}