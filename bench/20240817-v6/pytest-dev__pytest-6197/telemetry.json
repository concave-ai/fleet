{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-6197",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:46.224035",
        "usage": "1334.4049453735352 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_py_ext_re",
          "_seen",
          "filename_arg",
          "name2fixturedefs",
          "CollectErrorRepr",
          "resultlog",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "_get_marks",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "setns",
          "markname",
          "at_level",
          "notset",
          "astcache",
          "__all__",
          "warning_types",
          "_legal_ranges",
          "get_scope_package",
          "param",
          "BINOP_MAP",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "_get_active_fixturedef",
          "create_new_paste",
          "__getitem__",
          "fix_cache_order",
          "LogXML",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_ensure_basetemp",
          "add_report_section",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "cached_eval",
          "passed",
          "FIXTURE_ARGS_ORDER",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "MarkEvaluator",
          "__repr__",
          "pytest_runtest_call",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "showversion",
          "nodeid",
          "_istrue",
          "collect_one_node",
          "typename",
          "capfdbinary",
          "start",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "putaround",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "_fail_on_non_top_pytest_plugins",
          "own_mark_names",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "PrintHelp",
          "PYTEST_TAG",
          "repr_locals",
          "illegal_xml_re",
          "outcomes",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "_call_assertion_pass",
          "getargs",
          "get_default_arg_names",
          "AssertionState",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "find_spec",
          "pytest_itemcollected",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "safe_text_dupfile",
          "scopename2class",
          "cleanup_numbered_dir",
          "pytest_collection_finish",
          "isinitpath",
          "Node",
          "consider_env",
          "STRING_TYPES",
          "get_open_files",
          "MarkMapping",
          "_typ_map",
          "from_item_and_call",
          "compile_",
          "prog",
          "_recurse",
          "PyobjContext",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "pytest_warning_captured",
          "_resolve_arg_ids",
          "FDCapture",
          "OK",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_stderr_fileno",
          "_get_allow_bytes_flag",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "File",
          "fail_fixturefunc",
          "AssertionRewriter",
          "__next__",
          "_getglobals",
          "PytestAssertRewriteWarning",
          "check_xfail_no_run",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "write_ensure_prefix",
          "_for_parametrize",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "append_error",
          "pytest_unconfigure",
          "mkdir",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "_prunetraceback",
          "pytest_internalerror",
          "_update_message",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "finish",
          "__bool__",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "getfixturedefs",
          "warn",
          "writeorg",
          "_py36_windowsconsoleio_workaround",
          "setitem",
          "findsource",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "deselect_by_mark",
          "_suspend",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "_parse_lsof_output",
          "addError",
          "call_fixture_func",
          "compile",
          "scope2index",
          "emit",
          "_excinfo",
          "matching_platform",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_ellipsize",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_getobj",
          "num_mock_patch_args",
          "PercentStyleMultiline",
          "_check_all_skipped",
          "_ensure_only_one_capture_fixture",
          "_start",
          "runitem",
          "records",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "USAGE_ERROR",
          "find_suffixes",
          "_setoption",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "re_match_lines_random",
          "_format_repr_exception",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_compilecounter",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "_legal_chars",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "gethookrecorder",
          "fromdictargs",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "_assert_expr_to_lineno",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "makepyfile",
          "spawn_pytest",
          "_parse_fixture_args",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "NoMatch",
          "getreports",
          "short_test_summary",
          "_ensure_immutable_ids",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "add_property",
          "ids",
          "warn_about_none_ast",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "_done",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "rex_outcome",
          "addFailure",
          "reportinfo",
          "fixture",
          "_get_pos",
          "try_mkdir",
          "_NodeReporter",
          "patchsysdict",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "_report_kwargs_from_json",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "pytest_assertion_pass",
          "wasvalid",
          "_perform_collect",
          "add_stats",
          "getcall",
          "getstatementrange",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "cache_key",
          "tmpdir",
          "__version__",
          "_E",
          "params",
          "TestReport",
          "Parser",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "last_failed_paths",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "listchain",
          "write_sep",
          "getslaveinfoline",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reorder_items_atscope",
          "Metafunc",
          "main",
          "TYPE_CHECKING",
          "_find_spec",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_runtest_for_main",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "message",
          "reset",
          "summary_warnings",
          "format_session_duration",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "INTERRUPTED",
          "_resolve_arg_value_types",
          "mktemp",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_get_plugin_specs_as_list",
          "_non_printable_ascii_translate_table",
          "NodeMarkers",
          "inline_genitems",
          "_format_args",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "import_plugin",
          "__ne__",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "_bytes_to_ascii",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "relline",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "getfailures",
          "make_numbered_dir",
          "pytest_collectreport",
          "errors",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "_format_assertmsg",
          "names",
          "repr_excinfo",
          "_idvalset",
          "find",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "collect",
          "importorskip",
          "ExitCode",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "parse_setoption",
          "pyobj_property",
          "_test_pytest_function",
          "compat",
          "ishidden",
          "find_prefixed",
          "create_module",
          "_setup_cli_logging",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_handle_skip",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "_assertion_pass",
          "addsection",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "FUNCARGNAMES",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "NO_TESTS_COLLECTED",
          "encoding",
          "ensure_newline",
          "exec_module",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "_getfailureheadline",
          "_read_pyc",
          "value",
          "getexplanation",
          "set_trace",
          "write",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "own_markers",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "istext",
          "_from_json",
          "SubRequest",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "matchmark",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "pytest_itemstart",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "check_strict_xfail",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "isparseable",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "write_line",
          "from_item",
          "_get_runner",
          "matchkeyword",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "getcfg",
          "_get_continue_on_failure",
          "invocation_dir",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "invalidraise",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "exists",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "defaultfuncargprefixmarker",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "notify_exception",
          "_eval_scope_callable",
          "_strtobool",
          "formatrepr",
          "_compare_eq_dict",
          "get_actual_log_level",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "from_exc_info",
          "is_globally_capturing",
          "_visit_filter",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "dir",
          "freeze_includes",
          "kwargs",
          "CollectReport",
          "listnames",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "junitxml",
          "getrawcode",
          "_teardown_yield_fixture",
          "fill_unfilled",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_mk_tmp",
          "FunctionMixin",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "_get_number_flag",
          "re_match_lines",
          "_report_to_json",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "__nonzero__",
          "skip",
          "_check_if_assertion_pass_impl",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "istrue",
          "get",
          "resume_capturing",
          "__delitem__",
          "entrysep",
          "section",
          "get_fslocation_from_item",
          "alias",
          "_match_lines_random",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "is_true",
          "hasopt",
          "UNARY_MAP",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "out",
          "on_rm_rf_error",
          "capture_fixtures",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "PdbTrace",
          "pop",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "_get_assertion_exprs",
          "_opentestcase",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "getdecoded",
          "_getlines",
          "FuncargnamesCompatAttr",
          "visit_Call",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "INTERNAL_ERROR",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "rex_session_duration",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "_exec_lsof",
          "mkpydir",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "stopTest",
          "_matchfactories",
          "get_source",
          "popen",
          "Notset",
          "fail",
          "debugging",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "_write_pyc",
          "safe_isclass",
          "__len__",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "_runtest_for",
          "_format_lines",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "TESTS_FAILED",
          "LoggingPlugin",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "python_keywords_allowed_list",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "InvocationParams",
          "ascii_escaped",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "DEFAULT_MAX_CHARS",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "_legal_xml_re",
          "_checkargnotcontained",
          "_mount_obj_if_needed",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "update",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "plugins",
          "variable",
          "_outrep_summary",
          "_enter_pdb",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "writelines",
          "_finalize",
          "getvalue",
          "resume",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "parse_known_and_unknown_args",
          "CaptureIO",
          "exec_",
          "KeywordMapping",
          "Entry",
          "record_testreport",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "extract_suffixes",
          "TimeoutExpired",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "write_captured_output",
          "get_common_ancestor",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "safeformat",
          "nose",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "cache",
          "Code",
          "Junit",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "generic_visit",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "_setup_collect_fakemodule",
          "__call__",
          "instance",
          "get_optionflags",
          "pytest_doctest_prepare_content",
          "visit_BoolOp",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "_getcapture",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "call_and_report",
          "showfspath",
          "_install_capture_fixture_on_item",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "faulthandler",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "listoutcomes",
          "exprinfo",
          "text",
          "DoctestModule",
          "XFailed",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_get_first_non_fixture_func",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "pytest_collect_file",
          "pytest_collection_modifyitems",
          "pytest_runtest_protocol",
          "pytest_configure",
          "collect",
          "pytest_ignore_collect"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:47.558458",
        "usage": "224.6088981628418 ms"
      },
      "request": {
        "tokens": [
          "pytest_collect_file",
          "pytest_collection_modifyitems",
          "pytest_runtest_protocol",
          "pytest_configure",
          "collect",
          "pytest_ignore_collect"
        ]
      },
      "response": {
        "results": {
          "pytest_configure": [
            "src/_pytest/stepwise.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pastebin.py"
          ],
          "collect": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/reports.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/runner.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/capture.py",
            "src/_pytest/pytester.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:47.783077",
        "usage": "5071.574926376343 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_configure": [
            "src/_pytest/stepwise.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/pastebin.py"
          ],
          "collect": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/nodes.py",
            "src/_pytest/runner.py",
            "src/_pytest/compat.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pytester.py",
            "src/_pytest/reports.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/runner.py",
            "src/_pytest/main.py",
            "src/_pytest/unittest.py",
            "src/_pytest/warnings.py",
            "src/_pytest/capture.py",
            "src/_pytest/pytester.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/faulthandler.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py",
            "src/_pytest/doctest.py"
          ],
          "pytest_ignore_collect": [
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/main.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "To address the reported issue, I need to identify which files in the keyword search results potentially influence the behavior of pytest when it tries to collect and import `__init__.py` files.\n\n1. Keywords related to file collection seem particularly useful:\n   - **pytest_collect_file**: This hook in the search result list could be directly responsible for the collection of files and might contain logic about how files are considered for test collection.\n   - **collect**: This keyword is broad but potentially helpful as it might contribute to handling or modifying which files pytest tries to collect.\n   - **pytest_ignore_collect**: While this might not be causing the regression directly, it could offer a mechanism for preventing certain files from being collected, relevant for understanding how pytest handles file collection.\n\n2. Filtering files based on the relevance to the issue:\n   - From **pytest_collect_file**, files are closely related to file handling and collection logic:\n     - 'src/_pytest/hookspec.py': Primarily contains definitions of hook functions and might define or alter how collection occurs.\n     - 'src/_pytest/python.py': Likely involved in the management and manipulation of Python test files, including collection.\n     - 'src/_pytest/main.py': Central to the main execution and collection process.\n     - 'src/_pytest/doctest.py': Although seems less relevant, it may still influence collection logic if doctests involve module scanning.\n\n3. From **collect**:\n   - Files from this keyword overlap with those already considered from pytest_collect_file. However, additional relevant files might include parts that directly manage nodes or test collection processes.\n\nNow, selecting relevant file paths from these filtered considerations.",
        "file_paths": [
          "src/_pytest/hookspec.py",
          "src/_pytest/python.py",
          "src/_pytest/main.py",
          "src/_pytest/nodes.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:52.854679",
        "usage": "9262.122869491577 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes a regression issue where pytest 5.2.3 attempts to collect and import any `__init__.py` files under the current directory, unlike version 5.2.2 which did not exhibit this behavior. This causes tests to fail if the `__init__.py` files contain code that should not be executed during test collection (like an `assert False`).\n\n1.2 The user provides reproduction steps using a tox configuration to demonstrate the difference in behavior between pytest 5.2.2 and 5.2.3. This issue happens because pytest 5.2.3 wrongly tries to collect `__init__.py` files as test modules.\n\n1.3 The issue seems to have been introduced accidentally in pytest 5.2.3, possibly due to changes in the collection mechanisms which now pick up `__init__.py` files.\n\n1.4 The user's expectation is that pytest should ignore `__init__.py` files unless they specifically contain test cases. The issue is caused by pytest not ignoring these files.\n\n1.6 Possible solutions include adding logic to ignore `__init__.py` during test collection unless they are explicitly test files. Possible hooks that might need adjustments are `pytest_ignore_collect` or `pytest_collect_file`.\n\n\n2. Make file evaluation:\n2.1 The file `hookspec.py` contains multiple hook specifications for pytest plugins, which define the various stages and hooks available in pytest to extend or modify its behavior.\n\n2.2 Critical hooks that might relate to the issue described might include collection hooks like `pytest_ignore_collect`, `pytest_collect_file`, or hooks involving collection of directories and files.\n\n2.3 The `pytest_ignore_collect` hook sounds relevant as it can return True to prevent considering a path for collection. This could be used to ignore `__init__.py` when not relevant.\n\n2.4 Other hooks tied to collection processes and even the infrastructure around `pytest_collect_file` which determines node creation for given file paths are relevant.\n\n2.5 The file appears relevant since it involves collection behavior through hooks that could potentially be manipulated or might need changes to address the issue.\n\n2.6 Considering the extensive setup of managed hooks, the file isn\u2019t the only root cause based on its specification role, potential changes in actual collection logic possibly initiated in the core or collector modules file.\n\n\n3. Output Your Decision:",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/collector.py",
          "src/_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "pytest_ignore_collect",
          "pytest_collect_file",
          "pytest_collection",
          "pytest_collect_directory",
          "pytest_collection_modifyitems"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:02.116814",
        "usage": "8563.780784606934 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "Analyzing the user's issue report:\n\n1. **Issue Description**: The user reports a regression in pytest version 5.2.3, where `__init__.py` files are being collected and causing errors due to their contents being executed or imported, leading to unwanted assertion errors. The minimal example demonstrates that while `pytest 5.2.2` does not collect the `__init__.py`, version 5.2.3 does, resulting in an error.\n\n2. **Reproduction Steps**: The user provides a sequence that involves creating a directory with an `__init__.py` file that contains an assertion. The use of `tox` to run the tests highlights the change in behavior between the two pytest versions.\n\n3. **Root Cause Analysis**: The issue likely arises from a modification in the logic used for collecting test files between versions 5.2.2 and 5.2.3. Specifically, the regression causes `__init__.py` files to be wrongly included for test collection, even if they're supposed to be ignored based on the test discovery patterns.\n\n4. **Expectations and Issue Cause**: The user expects `__init__.py` files to be skipped during test collection unless explicitly specified in patterns. The change in version 5.2.3 seems to have mistakenly allowed these files to be discovered as test candidates.\n\n5. **Possible Solutions**: A solution would involve checking if there's a logic change regarding the handling of default patterns for test discovery, ensuring that `__init__.py` is not implicitly added to test discovery unless specifically configured by the user.\n\n---\n\nFile Evaluation:\n- **Relevance to Issue**: The function `pytest_collect_file()` and the function `pytest_pycollect_makemodule()` in `src/_pytest/python.py` appear to be directly involved in test file collection mechanisms. These functions determine if a file should be collected for testing and how to handle files once collected.\n\n- **Specific Sections**:\n  - `pytest_collect_file(path, parent)`: This function incorporates logic for determining if files should be collected. Either the patterns have been altered or the conditions under which patterns are applied need to be reverted to their previous state.\n  - `path_matches_patterns`: This aids in the logic for matching file paths against configured patterns.\n  - `pytest_pycollect_makemodule`: This function handles special cases, such as how `__init__.py` files are treated (handled as Package modules).\n\n- **File Investigation Result**: Based on the file's content, the likely symbols related to this regression involve the handling logic in `pytest_collect_file()` and related functions `pytest_pycollect_makemodule()` for handling special module files.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "pytest_collect_file",
          "pytest_pycollect_makemodule",
          "path_matches_patterns"
        ],
        "root_cause_symbols": [
          "pytest_collect_file"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:10.680611",
        "usage": "8503.304958343506 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is experiencing an issue with pytest version 5.2.3 where it tries to collect and execute `__init__.py` as a test file, resulting in an error if the `__init__.py` contains any assertions or errors that cause a failure. The issue did not occur with version 5.2.2.\n\n1.2 The user provided reproduction steps using tox to show that when pytest 5.2.3 is run, it errors out when encountering the `__init__.py` file, which contains `assert False`, whereas 5.2.2 does not.\n\n1.3 The issue seems to be caused by a change in file collection logic in pytest version 5.2.3, which now tries to collect `__init__.py` files, treating them as test modules, which was not the case in previous versions.\n\n1.4 The user's expectation is that `__init__.py` should not be collected or treated as a test module unless explicitly indicated. The regression in file collection behavior leads to errors if `__init__.py` files are mistakenly collected.\n\n1.5 Possible solutions could involve adjusting the file collection logic to exclude `__init__.py` files again unless specified or providing a configuration option to ignore certain files or patterns.\n\n2. Make file evaluation:\n2.1 Analyzed the `_pytest/main.py` file, which seems involved in the file collection process.\n2.2 The `Session` class manages the collection of tests, with functions like `perform_collect`, `_collectfile`, which are likely involved in the collection process.\n2.3 Methods such as `pytest_ignore_collect` and `_collect` might have relevance because they are responsible for ignoring or proceeding with collection.\n2.4 The `Session` class' method `_collect` seems directly responsible for collecting `__init__.py` and treating them as testable modules, as indicated by its logic for handling `__init__.py`.\n2.5 There are references to other parts of the codebase, like node handling, but this file contains the root cause of the issue - incorrect file collection behavior for `__init__.py` files starting from the version 5.2.3.\n2.6 The file is quite possibly the root cause considering it handles collection logic, especially looking at `_collect`, `_collectfile`, and the configuration values for ignoring patterns related to ignoring directory paths or patterns which might not be handling `__init__.py` as expected.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Session._collect",
          "Session._collectfile",
          "Session.isinitpath",
          "pytest_ignore_collect",
          "perform_collect"
        ],
        "root_cause_symbols": [
          "Session._collect",
          "Session._collectfile",
          "Session.isinitpath",
          "pytest_ignore_collect",
          "perform_collect"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:19.183929",
        "usage": "7579.577684402466 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is a regression in pytest 5.2.3 where it attempts to import any `__init__.py` file under the current directory, which is not intended behavior. It causes an error if the `__init__.py` has any executable code, like an `assert False` statement in this case.\n1.2 The steps to reproduce involve creating a directory with an `__init__.py` that contains an assert statement, and then running tests with different versions of pytest (5.2.2 vs 5.2.3) which shows the regression.\n1.3 This issue might have been caused by a change in the way pytest collects modules; likely, it erroneously includes `__init__.py` files under certain conditions.\n1.4 The user's expectation is that pytest should not be collecting or attempting to import non-test `__init__.py` files unless explicitly told to do so.\n1.6 Some possible solutions might involve re-evaluating the logic that determines what files are collected as test modules.\n\n2. Make file evaluation:\n2.1 The file includes different classes and methods related to the handling of nodes, collectors, and items for testing.\n2.2 The issue potentially involves changes in how file paths or nodes are handled or collected.\n2.3 Classes such as `Node`, `File`, `Collector`, and especially `FSCollector` might be involved since they deal with file system paths and test collection.\n2.4 The code facilitates conversion between file paths and node identifiers which could influence what is seen as a test file.\n2.5 The `FSCollector` class has logic related to the node id determination and may be relevant as it directly involves file path handling.\n2.6 The file might not explicitly be the root cause but could contribute to the changed behavior in file collection.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/main.py",
          "src/_pytest/config.py",
          "src/_pytest/collect/__init__.py"
        ],
        "relevant_symbols": [
          "Node",
          "FSCollector",
          "File",
          "Collector",
          "Item"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:26.763557",
        "usage": "218.40572357177734 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [
              "pytest_ignore_collect",
              "pytest_collect_file",
              "pytest_collection",
              "pytest_collect_directory",
              "pytest_collection_modifyitems"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "pytest_collect_file",
              "pytest_pycollect_makemodule",
              "path_matches_patterns"
            ],
            "root_cause_symbol_keys": [
              "pytest_collect_file"
            ]
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "Session._collect",
              "Session._collectfile",
              "Session.isinitpath",
              "pytest_ignore_collect",
              "perform_collect"
            ],
            "root_cause_symbol_keys": [
              "Session._collect",
              "Session._collectfile",
              "Session.isinitpath",
              "pytest_ignore_collect",
              "perform_collect"
            ]
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node",
              "FSCollector",
              "File",
              "Collector",
              "Item"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "---------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.mai",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ist of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :",
            "start_line": 168,
            "start_column": 5842,
            "end_line": 4,
            "end_column": 6357,
            "start_byte": 5842,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or None.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    \"\"\" call underlying test function.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str ",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "art. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" implements the runtest_setup/call/teardown protocol for\n    the given test item, including capturing exceptions and calling\n    reporting hooks.\n\n    :arg item: test item for which the runtest protocol is performed.\n\n    :arg nextitem: the scheduled-to-be-next test item (or None if this\n                   is the end my friend).  This argument is passed on to\n                   :py:func:`pytest_runtest_teardown`.\n\n    :return boolean: True if no further hook implementations should be invoked.\n\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logstart(nodeid, location):\n    \"\"\" signal the start ",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True`",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collection(session):\n    \"\"\"Perform the collection protocol for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_modifyitems(session, config, items):\n    \"\"\" called after collection has been performed, may filter or re-order\n    the items in-place.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param _pytest.config.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"",
            "start_line": 181,
            "start_column": 6054,
            "end_line": 0,
            "end_column": 6488,
            "start_byte": 6054,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_directory",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"",
            "start_line": 194,
            "start_column": 6491,
            "end_line": 0,
            "end_column": 6765,
            "start_byte": 6491,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "------\n\n\ndef pytest_report_header(config, startdir):\n    \"\"\" return a string or list of strings to be displayed as header info for terminal reporting.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str argname: the automatic parameter name produced by pytest\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# generic runtest related hooks\n# -----------------------------------------------------",
            "start_line": 282,
            "start_column": 8600,
            "end_line": 0,
            "end_column": 9497,
            "start_byte": 8600,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "-----------------\n\n\n@hookspec(firstresult=True)\ndef pytest_runtestloop(session):\n    \"\"\" called for performing the main runtest loop\n    (after collection finished).\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\ndef pytest_itemstart(item, node):\n    \"\"\"(**Deprecated**) use pytest_runtest_logstart. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" i",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "esult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config obje",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ith ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config obj",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "will require to be re-written.\n\n    :param _pytest.nodes.Item item: pytest item object of current test\n    :param int lineno: line number of the assert statement\n    :param string orig: string with original assertion\n    :param string expl: string with assert explanation\n\n    .. note::\n\n        This hook is **experim",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ":\n    \"\"\" called for internal errors. \"\"\"\n\n\ndef pytest_keyboard_interrupt(excinfo):\n    \"\"\" called for keyboard interrupt. \"\"\"\n\n\ndef pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"\n\n\ndef pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "est_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytes",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "g(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ")\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 179,
            "start_column": 5360,
            "end_line": 0,
            "end_column": 9346,
            "start_byte": 5360,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.DoctestItem.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n     ",
            "start_line": 180,
            "start_column": 5396,
            "end_line": 4,
            "end_column": 5609,
            "start_byte": 5396,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ram marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a",
            "start_line": 187,
            "start_column": 5615,
            "end_line": 4,
            "end_column": 6004,
            "start_byte": 5615,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.runtest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "g or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n     ",
            "start_line": 197,
            "start_column": 6010,
            "end_line": 4,
            "end_column": 6264,
            "start_byte": 6010,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(se",
            "start_line": 205,
            "start_column": 6270,
            "end_line": 4,
            "end_column": 6742,
            "start_byte": 6270,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "tchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                s",
            "start_line": 218,
            "start_column": 6748,
            "end_line": 4,
            "end_column": 9245,
            "start_byte": 6748,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 273,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9346,
            "start_byte": 9251,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Item",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 394,
            "start_column": 12994,
            "end_line": 0,
            "end_column": 14723,
            "start_byte": 12994,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Item.nextitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nextitem = None",
            "start_line": 399,
            "start_column": 13146,
            "end_line": 4,
            "end_column": 13161,
            "start_byte": 13146,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]",
            "start_line": 401,
            "start_column": 13167,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13167,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.add_report_section",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))",
            "start_line": 409,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 14299,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def reportinfo(self):\n        return self.fspath, None, \"\"",
            "start_line": 428,
            "start_column": 14305,
            "end_line": 4,
            "end_column": 14363,
            "start_byte": 14305,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.location",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 431,
            "start_column": 14369,
            "end_line": 4,
            "end_column": 14723,
            "start_byte": 14369,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ue.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.optio",
            "start_line": 168,
            "start_column": 5842,
            "end_line": 4,
            "end_column": 6357,
            "start_byte": 5842,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ame, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.s",
            "start_line": 181,
            "start_column": 6054,
            "end_line": 0,
            "end_column": 6488,
            "start_byte": 6054,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n        return True\n\n    allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n    if not allow_in_venv and _in_venv(path):\n        return True\n\n    return False",
            "start_line": 282,
            "start_column": 8600,
            "end_line": 0,
            "end_column": 9497,
            "start_byte": 8600,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 418,
            "start_column": 12761,
            "end_line": 4,
            "end_column": 12830,
            "start_byte": 12761,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 435,
            "start_column": 13415,
            "end_line": 4,
            "end_column": 13883,
            "start_byte": 13415,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []\n        self._initialparts = []\n        self.items = items = []\n        for arg in args:\n            parts = self._parsearg(arg)\n            self._initialparts.append(parts)\n            initialpaths.append(parts[0])\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n                # XXX: test this\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 448,
            "start_column": 13889,
            "end_line": 4,
            "end_column": 15062,
            "start_byte": 13889,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 494,
            "start_column": 15595,
            "end_line": 4,
            "end_column": 19295,
            "start_byte": 15595,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:26.981973",
        "usage": "15739.172220230103 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "---------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.mai",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ist of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :",
            "start_line": 168,
            "start_column": 5842,
            "end_line": 4,
            "end_column": 6357,
            "start_byte": 5842,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or None.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    \"\"\" call underlying test function.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str ",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "art. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" implements the runtest_setup/call/teardown protocol for\n    the given test item, including capturing exceptions and calling\n    reporting hooks.\n\n    :arg item: test item for which the runtest protocol is performed.\n\n    :arg nextitem: the scheduled-to-be-next test item (or None if this\n                   is the end my friend).  This argument is passed on to\n                   :py:func:`pytest_runtest_teardown`.\n\n    :return boolean: True if no further hook implementations should be invoked.\n\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logstart(nodeid, location):\n    \"\"\" signal the start ",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True`",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collection(session):\n    \"\"\"Perform the collection protocol for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_modifyitems(session, config, items):\n    \"\"\" called after collection has been performed, may filter or re-order\n    the items in-place.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param _pytest.config.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"",
            "start_line": 181,
            "start_column": 6054,
            "end_line": 0,
            "end_column": 6488,
            "start_byte": 6054,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_directory",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"",
            "start_line": 194,
            "start_column": 6491,
            "end_line": 0,
            "end_column": 6765,
            "start_byte": 6491,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "------\n\n\ndef pytest_report_header(config, startdir):\n    \"\"\" return a string or list of strings to be displayed as header info for terminal reporting.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str argname: the automatic parameter name produced by pytest\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# generic runtest related hooks\n# -----------------------------------------------------",
            "start_line": 282,
            "start_column": 8600,
            "end_line": 0,
            "end_column": 9497,
            "start_byte": 8600,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "-----------------\n\n\n@hookspec(firstresult=True)\ndef pytest_runtestloop(session):\n    \"\"\" called for performing the main runtest loop\n    (after collection finished).\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\ndef pytest_itemstart(item, node):\n    \"\"\"(**Deprecated**) use pytest_runtest_logstart. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" i",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "esult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config obje",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ith ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config obj",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "will require to be re-written.\n\n    :param _pytest.nodes.Item item: pytest item object of current test\n    :param int lineno: line number of the assert statement\n    :param string orig: string with original assertion\n    :param string expl: string with assert explanation\n\n    .. note::\n\n        This hook is **experim",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ":\n    \"\"\" called for internal errors. \"\"\"\n\n\ndef pytest_keyboard_interrupt(excinfo):\n    \"\"\" called for keyboard interrupt. \"\"\"\n\n\ndef pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"\n\n\ndef pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "est_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytes",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "g(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ")\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 179,
            "start_column": 5360,
            "end_line": 0,
            "end_column": 9346,
            "start_byte": 5360,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.DoctestItem.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n     ",
            "start_line": 180,
            "start_column": 5396,
            "end_line": 4,
            "end_column": 5609,
            "start_byte": 5396,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ram marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a",
            "start_line": 187,
            "start_column": 5615,
            "end_line": 4,
            "end_column": 6004,
            "start_byte": 5615,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.runtest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "g or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n     ",
            "start_line": 197,
            "start_column": 6010,
            "end_line": 4,
            "end_column": 6264,
            "start_byte": 6010,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(se",
            "start_line": 205,
            "start_column": 6270,
            "end_line": 4,
            "end_column": 6742,
            "start_byte": 6270,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "tchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                s",
            "start_line": 218,
            "start_column": 6748,
            "end_line": 4,
            "end_column": 9245,
            "start_byte": 6748,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 273,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9346,
            "start_byte": 9251,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Item",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 394,
            "start_column": 12994,
            "end_line": 0,
            "end_column": 14723,
            "start_byte": 12994,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Item.nextitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nextitem = None",
            "start_line": 399,
            "start_column": 13146,
            "end_line": 4,
            "end_column": 13161,
            "start_byte": 13146,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]",
            "start_line": 401,
            "start_column": 13167,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13167,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.add_report_section",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))",
            "start_line": 409,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 14299,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def reportinfo(self):\n        return self.fspath, None, \"\"",
            "start_line": 428,
            "start_column": 14305,
            "end_line": 4,
            "end_column": 14363,
            "start_byte": 14305,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.location",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 431,
            "start_column": 14369,
            "end_line": 4,
            "end_column": 14723,
            "start_byte": 14369,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ue.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.optio",
            "start_line": 168,
            "start_column": 5842,
            "end_line": 4,
            "end_column": 6357,
            "start_byte": 5842,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ame, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.s",
            "start_line": 181,
            "start_column": 6054,
            "end_line": 0,
            "end_column": 6488,
            "start_byte": 6054,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n        return True\n\n    allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n    if not allow_in_venv and _in_venv(path):\n        return True\n\n    return False",
            "start_line": 282,
            "start_column": 8600,
            "end_line": 0,
            "end_column": 9497,
            "start_byte": 8600,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 418,
            "start_column": 12761,
            "end_line": 4,
            "end_column": 12830,
            "start_byte": 12761,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 435,
            "start_column": 13415,
            "end_line": 4,
            "end_column": 13883,
            "start_byte": 13415,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []\n        self._initialparts = []\n        self.items = items = []\n        for arg in args:\n            parts = self._parsearg(arg)\n            self._initialparts.append(parts)\n            initialpaths.append(parts[0])\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n                # XXX: test this\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 448,
            "start_column": 13889,
            "end_line": 4,
            "end_column": 15062,
            "start_byte": 13889,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 494,
            "start_column": 15595,
            "end_line": 4,
            "end_column": 19295,
            "start_byte": 15595,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "## Scratch Pad:\n\n### Step 1: Analyze the User Instructions\n\n1.1 **What issue is the user describing?**\n- The user describes a regression issue in pytest version 5.2.3 where `pytest` attempts to collect and execute `__init__.py` files as modules under certain directories, leading to unwanted test runs and errors particularly for package directories not supposed to be tested on certain platforms (e.g., Windows-specific packages).\n\n1.2 **How was this issue caused?**\n- With pytest version 5.2.3, there seems to be a change in how pytest determines which files to collect as potential test files. Specifically, it now includes `__init__.py` files in certain conditions which it didn't in version 5.2.2.\n\n1.3 **What should it be fixed to?**\n- To align with the behavior of version 5.2.2, `pytest` should avoid collecting `__init__.py` files as test files by default unless explicitly configured by the user.\n\n1.4 **If the user did not provide an expected result, what should the expectation be?**\n- pytest should skip or ignore `__init__.py` files during test discovery to prevent platform-specific import errors and maintain backward compatibility.\n\n1.5 **How should the issue be fixed to meet the expectation?**\n- Modify pytest file collection mechanics to exclude `__init__.py` unless specified or part of specific test discovery patterns, matching the behavior of previous versions.\n\n### Step 2: Evaluate the Symbols\n\nI need to translate these issues into concrete considerations about which symbols had changed, particularly around file collection rules in pytest 5.2.3. Let's evaluate the potential relevant symbols affecting file collection.\n\n## Symbols Scratch Pad\n\n#### Symbol: _pytest.python.pytest_collect_file\n- **Reasoning**: Responsible for file collection logic. It directly checks if files should be considered for collection. The behavior of collecting `__init__.py` seems visible here. Changes in the file/match patterns logic here might affect collecting.\n\n#### Symbol: _pytest.main.pytest_ignore_collect\n- **Reasoning**: This function seems related to paths that can be ignored during collection. Ignoring `__init__.py` would be handled in this or similar hooks.\n\n#### Symbol: _pytest.main.Session.isinitpath\n- **Reasoning**: Checks if a path forms part of the initially specified paths for test collection. Relevance here might help ascertain whether `__init__.py` paths should be basic tests.\n\n#### Symbol: _pytest.python.path_matches_patterns\n- **Reasoning**: Checks if a path matches specified patterns. Critical to evaluate if changes target `__init__.py` inclusion.\n\n#### Symbol: _pytest.hookspec.pytest_collect_file\n- **Reasoning**: Hook specification for collecting files; integral to understanding what constitutes a test file.\n\n### Evaluation Strategy:\n\nLook into file collection logic and related patterns, determining if and why `__init__.py` files are newly included in collection and adjusting logic to restore previous behavior.",
        "symbols": [
          {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "reason": "Directly involved in collecting files with logic checking path matches against patterns, including `__init__.py`. Likely root cause of changed behavior in collecting these files."
          }
        ],
        "more_info": [
          {
            "type": "symbol",
            "path": "src/_pytest/main.py",
            "name": "_pytest.main.Session.isinitpath",
            "reason": "Understand how initial paths interact with new collection logic potentially causing the collection of `__init__.py` files."
          },
          {
            "type": "symbol",
            "path": "src/_pytest/python.py",
            "name": "_pytest.python.path_matches_patterns",
            "reason": "This symbol checks patterns against file paths, understanding any modifications here might illuminate pattern matching changes affecting `__init__.py`."
          },
          {
            "type": "symbol",
            "path": "src/_pytest/hookspec.py",
            "name": "_pytest.hookspec.pytest_collect_file",
            "reason": "Evaluate hook mechanics which determine what constitutes a collectible file, especially any changes impacting `__init__.py` files."
          }
        ],
        "is_done": false,
        "symbols_scratch_pad": [
          "Related to file collection, changes here possibly trigger the collection of `__init__.py` files in newer version.",
          "Handles path ignore logic, potential ties to ignoring `__init__.py`.",
          "Determines if a path is an init path, potentially related if init paths are wrongly being tested.",
          "Matches file paths against patterns, critical if `__init__.py` patterns changed lead to regression."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:42.721174",
        "usage": "3.873109817504883 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "---------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.mai",
              "start_line": 93,
              "start_column": 3023,
              "end_line": 0,
              "end_column": 3399,
              "start_byte": 3023,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "ist of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :",
              "start_line": 168,
              "start_column": 5842,
              "end_line": 4,
              "end_column": 6357,
              "start_byte": 5842,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or None.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    \"\"\" call underlying test function.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str ",
              "start_line": 200,
              "start_column": 7163,
              "end_line": 4,
              "end_column": 9267,
              "start_byte": 7163,
              "end_byte": 4
            },
            {
              "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "art. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" implements the runtest_setup/call/teardown protocol for\n    the given test item, including capturing exceptions and calling\n    reporting hooks.\n\n    :arg item: test item for which the runtest protocol is performed.\n\n    :arg nextitem: the scheduled-to-be-next test item (or None if this\n                   is the end my friend).  This argument is passed on to\n                   :py:func:`pytest_runtest_teardown`.\n\n    :return boolean: True if no further hook implementations should be invoked.\n\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logstart(nodeid, location):\n    \"\"\" signal the start ",
              "start_line": 265,
              "start_column": 9886,
              "end_line": 4,
              "end_column": 10614,
              "start_byte": 9886,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True`",
              "start_line": 86,
              "start_column": 2432,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2432,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "",
              "start_line": 1386,
              "start_column": 52212,
              "end_line": 4,
              "end_column": 52338,
              "start_byte": 52212,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "@hookspec(firstresult=True)\ndef pytest_collection(session):\n    \"\"\"Perform the collection protocol for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
              "start_line": 154,
              "start_column": 5249,
              "end_line": 0,
              "end_column": 5507,
              "start_byte": 5249,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_collection_modifyitems(session, config, items):\n    \"\"\" called after collection has been performed, may filter or re-order\n    the items in-place.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param _pytest.config.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"",
              "start_line": 164,
              "start_column": 5510,
              "end_line": 0,
              "end_column": 5869,
              "start_byte": 5510,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collection_finish",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
              "start_line": 174,
              "start_column": 5872,
              "end_line": 0,
              "end_column": 6051,
              "start_byte": 5872,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_ignore_collect",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"",
              "start_line": 181,
              "start_column": 6054,
              "end_line": 0,
              "end_column": 6488,
              "start_byte": 6054,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_directory",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"",
              "start_line": 194,
              "start_column": 6491,
              "end_line": 0,
              "end_column": 6765,
              "start_byte": 6491,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"",
              "start_line": 204,
              "start_column": 6768,
              "end_line": 0,
              "end_column": 7010,
              "start_byte": 6768,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "------\n\n\ndef pytest_report_header(config, startdir):\n    \"\"\" return a string or list of strings to be displayed as header info for terminal reporting.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due",
              "start_line": 512,
              "start_column": 17425,
              "end_line": 4,
              "end_column": 17846,
              "start_byte": 17425,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": " test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult",
              "start_line": 244,
              "start_column": 7329,
              "end_line": 0,
              "end_column": 7397,
              "start_byte": 7329,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_ignore_collect",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str argname: the automatic parameter name produced by pytest\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# generic runtest related hooks\n# -----------------------------------------------------",
              "start_line": 282,
              "start_column": 8600,
              "end_line": 0,
              "end_column": 9497,
              "start_byte": 8600,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "-----------------\n\n\n@hookspec(firstresult=True)\ndef pytest_runtestloop(session):\n    \"\"\" called for performing the main runtest loop\n    (after collection finished).\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\ndef pytest_itemstart(item, node):\n    \"\"\"(**Deprecated**) use pytest_runtest_logstart. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" i",
              "start_line": 310,
              "start_column": 9500,
              "end_line": 0,
              "end_column": 9979,
              "start_byte": 9500,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files",
              "start_line": 142,
              "start_column": 4581,
              "end_line": 0,
              "end_column": 4705,
              "start_byte": 4581,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "esult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config obje",
              "start_line": 175,
              "start_column": 6070,
              "end_line": 0,
              "end_column": 6478,
              "start_byte": 6070,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "ith ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config obj",
              "start_line": 39,
              "start_column": 1034,
              "end_line": 4,
              "end_column": 2112,
              "start_byte": 1034,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "will require to be re-written.\n\n    :param _pytest.nodes.Item item: pytest item object of current test\n    :param int lineno: line number of the assert statement\n    :param string orig: string with original assertion\n    :param string expl: string with assert explanation\n\n    .. note::\n\n        This hook is **experim",
              "start_line": 487,
              "start_column": 16672,
              "end_line": 4,
              "end_column": 16990,
              "start_byte": 16672,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": ":\n    \"\"\" called for internal errors. \"\"\"\n\n\ndef pytest_keyboard_interrupt(excinfo):\n    \"\"\" called for keyboard interrupt. \"\"\"\n\n\ndef pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"\n\n\ndef pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: p",
              "start_line": 594,
              "start_column": 20705,
              "end_line": 4,
              "end_column": 21335,
              "start_byte": 20705,
              "end_byte": 4
            },
            {
              "name": "_pytest.warnings.pytest_collection",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "est_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytes",
              "start_line": 116,
              "start_column": 3619,
              "end_line": 0,
              "end_column": 3851,
              "start_byte": 3619,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_pycollect_makemodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "g(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n",
              "start_line": 243,
              "start_column": 7772,
              "end_line": 0,
              "end_column": 8254,
              "start_byte": 7772,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.path_matches_patterns",
              "file_path": "src/_pytest/python.py",
              "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
              "start_line": 187,
              "start_column": 6481,
              "end_line": 0,
              "end_column": 6690,
              "start_byte": 6481,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_pycollect_makemodule",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
              "start_line": 192,
              "start_column": 6693,
              "end_line": 0,
              "end_column": 6847,
              "start_byte": 6693,
              "end_byte": 0
            },
            {
              "name": "_pytest._argcomplete.FastFilesCompleter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
              "start_line": 61,
              "start_column": 2341,
              "end_line": 0,
              "end_column": 3274,
              "start_byte": 2341,
              "end_byte": 0
            },
            {
              "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
              "start_line": 64,
              "start_column": 2404,
              "end_line": 4,
              "end_column": 2480,
              "start_byte": 2404,
              "end_byte": 4
            },
            {
              "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
              "start_line": 67,
              "start_column": 2486,
              "end_line": 4,
              "end_column": 3274,
              "start_byte": 2486,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprFileLocation",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 997,
              "start_column": 33380,
              "end_line": 0,
              "end_column": 33901,
              "start_byte": 33380,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprFileLocation.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 998,
              "start_column": 33422,
              "end_line": 4,
              "end_column": 33554,
              "start_byte": 33422,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprFileLocation.toterminal",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 1003,
              "start_column": 33560,
              "end_line": 4,
              "end_column": 33901,
              "start_byte": 33560,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 412,
              "start_column": 14331,
              "end_line": 0,
              "end_column": 15203,
              "start_byte": 14331,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.EncodedFile.errors",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " None, \"\"\n\n    @p",
              "start_line": 413,
              "start_column": 14354,
              "end_line": 4,
              "end_column": 14371,
              "start_byte": 14354,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
              "start_line": 415,
              "start_column": 14419,
              "end_line": 4,
              "end_column": 14518,
              "start_byte": 14419,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.write",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 419,
              "start_column": 14524,
              "end_line": 4,
              "end_column": 14803,
              "start_byte": 14524,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.writelines",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 428,
              "start_column": 14809,
              "end_line": 4,
              "end_column": 14898,
              "start_byte": 14809,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.name",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 432,
              "start_column": 14904,
              "end_line": 4,
              "end_column": 15015,
              "start_byte": 14904,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.mode",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 437,
              "start_column": 15021,
              "end_line": 4,
              "end_column": 15099,
              "start_byte": 15021,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.EncodedFile.__getattr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "",
              "start_line": 441,
              "start_column": 15105,
              "end_line": 4,
              "end_column": 15203,
              "start_byte": 15105,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ")\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
              "start_line": 179,
              "start_column": 5360,
              "end_line": 0,
              "end_column": 9346,
              "start_byte": 5360,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.DoctestItem.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n     ",
              "start_line": 180,
              "start_column": 5396,
              "end_line": 4,
              "end_column": 5609,
              "start_byte": 5396,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem.setup",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ram marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a",
              "start_line": 187,
              "start_column": 5615,
              "end_line": 4,
              "end_column": 6004,
              "start_byte": 5615,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem.runtest",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "g or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n     ",
              "start_line": 197,
              "start_column": 6010,
              "end_line": 4,
              "end_column": 6264,
              "start_byte": 6010,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(se",
              "start_line": 205,
              "start_column": 6270,
              "end_line": 4,
              "end_column": 6742,
              "start_byte": 6270,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "tchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                s",
              "start_line": 218,
              "start_column": 6748,
              "end_line": 4,
              "end_column": 9245,
              "start_byte": 6748,
              "end_byte": 4
            },
            {
              "name": "_pytest.doctest.DoctestItem.reportinfo",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
              "start_line": 273,
              "start_column": 9251,
              "end_line": 4,
              "end_column": 9346,
              "start_byte": 9251,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
              "start_line": 83,
              "start_column": 2200,
              "end_line": 0,
              "end_column": 9131,
              "start_byte": 2200,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml._NodeReporter.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
              "start_line": 84,
              "start_column": 2225,
              "end_line": 4,
              "end_column": 2519,
              "start_byte": 2225,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
              "start_line": 95,
              "start_column": 2525,
              "end_line": 4,
              "end_column": 2628,
              "start_byte": 2525,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.add_property",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
              "start_line": 99,
              "start_column": 2634,
              "end_line": 4,
              "end_column": 2737,
              "start_byte": 2634,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.add_attribute",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
              "start_line": 102,
              "start_column": 2743,
              "end_line": 4,
              "end_column": 2834,
              "start_byte": 2743,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.make_properties_node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
              "start_line": 105,
              "start_column": 2840,
              "end_line": 4,
              "end_column": 3199,
              "start_byte": 2840,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.record_testreport",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
              "start_line": 117,
              "start_column": 3205,
              "end_line": 4,
              "end_column": 4372,
              "start_byte": 3205,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.to_xml",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
              "start_line": 148,
              "start_column": 4378,
              "end_line": 4,
              "end_column": 4615,
              "start_byte": 4378,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter._add_simple",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
              "start_line": 155,
              "start_column": 4621,
              "end_line": 4,
              "end_column": 4774,
              "start_byte": 4621,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.write_captured_output",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
              "start_line": 160,
              "start_column": 4780,
              "end_line": 4,
              "end_column": 6736,
              "start_byte": 4780,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_pass",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
              "start_line": 213,
              "start_column": 6742,
              "end_line": 4,
              "end_column": 6805,
              "start_byte": 6742,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
              "start_line": 216,
              "start_column": 6811,
              "end_line": 4,
              "end_column": 7499,
              "start_byte": 6811,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_collect_error",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
              "start_line": 232,
              "start_column": 7505,
              "end_line": 4,
              "end_column": 7723,
              "start_byte": 7505,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
              "start_line": 238,
              "start_column": 7729,
              "end_line": 4,
              "end_column": 7849,
              "start_byte": 7729,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_error",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
              "start_line": 241,
              "start_column": 7855,
              "end_line": 4,
              "end_column": 8079,
              "start_byte": 7855,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.append_skipped",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
              "start_line": 248,
              "start_column": 8085,
              "end_line": 4,
              "end_column": 8982,
              "start_byte": 8085,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml._NodeReporter.finalize",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
              "start_line": 273,
              "start_column": 8988,
              "end_line": 4,
              "end_column": 9131,
              "start_byte": 8988,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
              "start_line": 333,
              "start_column": 11604,
              "end_line": 0,
              "end_column": 12534,
              "start_byte": 11604,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeKeywords.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
              "start_line": 334,
              "start_column": 11644,
              "end_line": 4,
              "end_column": 11770,
              "start_byte": 11644,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__getitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
              "start_line": 339,
              "start_column": 11776,
              "end_line": 4,
              "end_column": 11982,
              "start_byte": 11776,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__setitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
              "start_line": 347,
              "start_column": 11988,
              "end_line": 4,
              "end_column": 12057,
              "start_byte": 11988,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__delitem__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
              "start_line": 350,
              "start_column": 12063,
              "end_line": 4,
              "end_column": 12153,
              "start_byte": 12063,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__iter__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
              "start_line": 353,
              "start_column": 12159,
              "end_line": 4,
              "end_column": 12232,
              "start_byte": 12159,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords._seen",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
              "start_line": 357,
              "start_column": 12238,
              "end_line": 4,
              "end_column": 12390,
              "start_byte": 12238,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__len__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "        name = rel\n            name = name.replace(",
              "start_line": 363,
              "start_column": 12396,
              "end_line": 4,
              "end_column": 12447,
              "start_byte": 12396,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__repr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
              "start_line": 366,
              "start_column": 12453,
              "end_line": 4,
              "end_column": 12534,
              "start_byte": 12453,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
              "start_line": 371,
              "start_column": 12598,
              "end_line": 0,
              "end_column": 13270,
              "start_byte": 12598,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeMarkers.own_markers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
              "start_line": 382,
              "start_column": 12802,
              "end_line": 4,
              "end_column": 12851,
              "start_byte": 12802,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.update",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
              "start_line": 384,
              "start_column": 12857,
              "end_line": 4,
              "end_column": 12978,
              "start_byte": 12857,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.find",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
              "start_line": 389,
              "start_column": 12984,
              "end_line": 4,
              "end_column": 13207,
              "start_byte": 12984,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeMarkers.__iter__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "one, session=None, nodeid=None):\n        super().__init__",
              "start_line": 398,
              "start_column": 13213,
              "end_line": 4,
              "end_column": 13270,
              "start_byte": 13213,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
              "start_line": 66,
              "start_column": 1943,
              "end_line": 0,
              "end_column": 9973,
              "start_byte": 1943,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Node.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
              "start_line": 70,
              "start_column": 2097,
              "end_line": 4,
              "end_column": 3399,
              "start_byte": 2097,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.ihook",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
              "start_line": 108,
              "start_column": 3405,
              "end_line": 4,
              "end_column": 3558,
              "start_byte": 3405,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.__repr__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
              "start_line": 113,
              "start_column": 3564,
              "end_line": 4,
              "end_column": 3669,
              "start_byte": 3564,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.warn",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
              "start_line": 116,
              "start_column": 3675,
              "end_line": 4,
              "end_column": 4757,
              "start_byte": 3675,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.nodeid",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
              "start_line": 150,
              "start_column": 4796,
              "end_line": 4,
              "end_column": 4931,
              "start_byte": 4796,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.__hash__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
              "start_line": 155,
              "start_column": 4937,
              "end_line": 4,
              "end_column": 4989,
              "start_byte": 4937,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.setup",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def setup(self):\n        pass",
              "start_line": 158,
              "start_column": 4995,
              "end_line": 4,
              "end_column": 5024,
              "start_byte": 4995,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.teardown",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def teardown(self):\n        pass",
              "start_line": 161,
              "start_column": 5030,
              "end_line": 4,
              "end_column": 5062,
              "start_byte": 5030,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listchain",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
              "start_line": 164,
              "start_column": 5068,
              "end_line": 4,
              "end_column": 5382,
              "start_byte": 5068,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
              "start_line": 175,
              "start_column": 5388,
              "end_line": 4,
              "end_column": 6218,
              "start_byte": 5388,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
              "start_line": 199,
              "start_column": 6224,
              "end_line": 4,
              "end_column": 6470,
              "start_byte": 6224,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.iter_markers_with_node",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
              "start_line": 207,
              "start_column": 6476,
              "end_line": 4,
              "end_column": 6909,
              "start_byte": 6476,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.get_closest_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
              "start_line": 219,
              "start_column": 6915,
              "end_line": 4,
              "end_column": 7287,
              "start_byte": 6915,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listextrakeywords",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
              "start_line": 228,
              "start_column": 7293,
              "end_line": 4,
              "end_column": 7575,
              "start_byte": 7293,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.listnames",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
              "start_line": 235,
              "start_column": 7581,
              "end_line": 4,
              "end_column": 7651,
              "start_byte": 7581,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.addfinalizer",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
              "start_line": 238,
              "start_column": 7657,
              "end_line": 4,
              "end_column": 7952,
              "start_byte": 7657,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.getparent",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
              "start_line": 246,
              "start_column": 7958,
              "end_line": 4,
              "end_column": 8230,
              "start_byte": 7958,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node._prunetraceback",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _prunetraceback(self, excinfo):\n        pass",
              "start_line": 254,
              "start_column": 8236,
              "end_line": 4,
              "end_column": 8284,
              "start_byte": 8236,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node._repr_failure_py",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
              "start_line": 257,
              "start_column": 8290,
              "end_line": 4,
              "end_column": 9870,
              "start_byte": 8290,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
              "start_line": 301,
              "start_column": 9876,
              "end_line": 4,
              "end_column": 9973,
              "start_byte": 9876,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
              "start_line": 323,
              "start_column": 10562,
              "end_line": 0,
              "end_column": 11863,
              "start_byte": 10562,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Collector.CollectError",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
              "start_line": 328,
              "start_column": 10703,
              "end_line": 4,
              "end_column": 10804,
              "start_byte": 10703,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector.collect",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
              "start_line": 331,
              "start_column": 10810,
              "end_line": 4,
              "end_column": 10986,
              "start_byte": 10810,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
              "start_line": 337,
              "start_column": 10992,
              "end_line": 4,
              "end_column": 11522,
              "start_byte": 10992,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector._prunetraceback",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
              "start_line": 351,
              "start_column": 11528,
              "end_line": 4,
              "end_column": 11863,
              "start_byte": 11528,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.FSCollector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
              "start_line": 366,
              "start_column": 12071,
              "end_line": 0,
              "end_column": 12907,
              "start_byte": 12071,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.FSCollector.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
              "start_line": 367,
              "start_column": 12105,
              "end_line": 4,
              "end_column": 12907,
              "start_byte": 12105,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.File",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
              "start_line": 390,
              "start_column": 12910,
              "end_line": 0,
              "end_column": 12991,
              "start_byte": 12910,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Item",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "class Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
              "start_line": 394,
              "start_column": 12994,
              "end_line": 0,
              "end_column": 14723,
              "start_byte": 12994,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Item.nextitem",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "nextitem = None",
              "start_line": 399,
              "start_column": 13146,
              "end_line": 4,
              "end_column": 13161,
              "start_byte": 13146,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Item.__init__",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]",
              "start_line": 401,
              "start_column": 13167,
              "end_line": 4,
              "end_column": 13575,
              "start_byte": 13167,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Item.add_report_section",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))",
              "start_line": 409,
              "start_column": 13581,
              "end_line": 4,
              "end_column": 14299,
              "start_byte": 13581,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Item.reportinfo",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def reportinfo(self):\n        return self.fspath, None, \"\"",
              "start_line": 428,
              "start_column": 14305,
              "end_line": 4,
              "end_column": 14363,
              "start_byte": 14305,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Item.location",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "@property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
              "start_line": 431,
              "start_column": 14369,
              "end_line": 4,
              "end_column": 14723,
              "start_byte": 14369,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 310,
              "start_column": 10773,
              "end_line": 0,
              "end_column": 15533,
              "start_byte": 10773,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.PyCollector.funcnamefilter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
              "start_line": 311,
              "start_column": 10825,
              "end_line": 4,
              "end_column": 10933,
              "start_byte": 10825,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.isnosetest",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
              "start_line": 314,
              "start_column": 10939,
              "end_line": 4,
              "end_column": 11332,
              "start_byte": 10939,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.classnamefilter",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
              "start_line": 323,
              "start_column": 11338,
              "end_line": 4,
              "end_column": 11445,
              "start_byte": 11338,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.istestfunction",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
              "start_line": 326,
              "start_column": 11451,
              "end_line": 4,
              "end_column": 11894,
              "start_byte": 11451,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.istestclass",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
              "start_line": 338,
              "start_column": 11900,
              "end_line": 4,
              "end_column": 11999,
              "start_byte": 11900,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
              "file_path": "src/_pytest/nodes.py",
              "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
              "start_line": 341,
              "start_column": 12005,
              "end_line": 4,
              "end_column": 12711,
              "start_byte": 12005,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector.collect",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
              "start_line": 358,
              "start_column": 12717,
              "end_line": 4,
              "end_column": 13616,
              "start_byte": 12717,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._makeitem",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
              "start_line": 383,
              "start_column": 13622,
              "end_line": 4,
              "end_column": 13797,
              "start_byte": 13622,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.PyCollector._genfunctions",
              "file_path": "src/_pytest/nodes.py",
              "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
              "start_line": 387,
              "start_column": 13803,
              "end_line": 4,
              "end_column": 15533,
              "start_byte": 13803,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.doctest.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
              "start_line": 86,
              "start_column": 2432,
              "end_line": 0,
              "end_column": 2743,
              "start_byte": 2432,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
              "start_line": 204,
              "start_column": 6768,
              "end_line": 0,
              "end_column": 7010,
              "start_byte": 6768,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
              "start_line": 175,
              "start_column": 6070,
              "end_line": 0,
              "end_column": 6478,
              "start_byte": 6070,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "ue.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.optio",
              "start_line": 168,
              "start_column": 5842,
              "end_line": 4,
              "end_column": 6357,
              "start_byte": 5842,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_ignore_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "ame, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.s",
              "start_line": 181,
              "start_column": 6054,
              "end_line": 0,
              "end_column": 6488,
              "start_byte": 6054,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_ignore_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n        return True\n\n    allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n    if not allow_in_venv and _in_venv(path):\n        return True\n\n    return False",
              "start_line": 282,
              "start_column": 8600,
              "end_line": 0,
              "end_column": 9497,
              "start_byte": 8600,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
              "start_line": 418,
              "start_column": 12761,
              "end_line": 4,
              "end_column": 12830,
              "start_byte": 12761,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 435,
              "start_column": 13415,
              "end_line": 4,
              "end_column": 13883,
              "start_byte": 13415,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []\n        self._initialparts = []\n        self.items = items = []\n        for arg in args:\n            parts = self._parsearg(arg)\n            self._initialparts.append(parts)\n            initialpaths.append(parts[0])\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n                # XXX: test this\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
              "start_line": 448,
              "start_column": 13889,
              "end_line": 4,
              "end_column": 15062,
              "start_byte": 13889,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
              "start_line": 494,
              "start_column": 15595,
              "end_line": 4,
              "end_column": 19295,
              "start_byte": 15595,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collectfile",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
              "start_line": 576,
              "start_column": 19301,
              "end_line": 4,
              "end_column": 20135,
              "start_byte": 19301,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "## Scratch Pad:\n\n### Step 1: Analyze the User Instructions\n\n1.1 **What issue is the user describing?**\n- The user describes a regression issue in pytest version 5.2.3 where `pytest` attempts to collect and execute `__init__.py` files as modules under certain directories, leading to unwanted test runs and errors particularly for package directories not supposed to be tested on certain platforms (e.g., Windows-specific packages).\n\n1.2 **How was this issue caused?**\n- With pytest version 5.2.3, there seems to be a change in how pytest determines which files to collect as potential test files. Specifically, it now includes `__init__.py` files in certain conditions which it didn't in version 5.2.2.\n\n1.3 **What should it be fixed to?**\n- To align with the behavior of version 5.2.2, `pytest` should avoid collecting `__init__.py` files as test files by default unless explicitly configured by the user.\n\n1.4 **If the user did not provide an expected result, what should the expectation be?**\n- pytest should skip or ignore `__init__.py` files during test discovery to prevent platform-specific import errors and maintain backward compatibility.\n\n1.5 **How should the issue be fixed to meet the expectation?**\n- Modify pytest file collection mechanics to exclude `__init__.py` unless specified or part of specific test discovery patterns, matching the behavior of previous versions.\n\n### Step 2: Evaluate the Symbols\n\nI need to translate these issues into concrete considerations about which symbols had changed, particularly around file collection rules in pytest 5.2.3. Let's evaluate the potential relevant symbols affecting file collection.\n\n## Symbols Scratch Pad\n\n#### Symbol: _pytest.python.pytest_collect_file\n- **Reasoning**: Responsible for file collection logic. It directly checks if files should be considered for collection. The behavior of collecting `__init__.py` seems visible here. Changes in the file/match patterns logic here might affect collecting.\n\n#### Symbol: _pytest.main.pytest_ignore_collect\n- **Reasoning**: This function seems related to paths that can be ignored during collection. Ignoring `__init__.py` would be handled in this or similar hooks.\n\n#### Symbol: _pytest.main.Session.isinitpath\n- **Reasoning**: Checks if a path forms part of the initially specified paths for test collection. Relevance here might help ascertain whether `__init__.py` paths should be basic tests.\n\n#### Symbol: _pytest.python.path_matches_patterns\n- **Reasoning**: Checks if a path matches specified patterns. Critical to evaluate if changes target `__init__.py` inclusion.\n\n#### Symbol: _pytest.hookspec.pytest_collect_file\n- **Reasoning**: Hook specification for collecting files; integral to understanding what constitutes a test file.\n\n### Evaluation Strategy:\n\nLook into file collection logic and related patterns, determining if and why `__init__.py` files are newly included in collection and adjusting logic to restore previous behavior.",
          "symbols": [
            {
              "name": "_pytest.python.pytest_collect_file",
              "file_path": "src/_pytest/python.py",
              "reason": "Directly involved in collecting files with logic checking path matches against patterns, including `__init__.py`. Likely root cause of changed behavior in collecting these files."
            }
          ],
          "more_info": [
            {
              "type": "symbol",
              "path": "src/_pytest/main.py",
              "name": "_pytest.main.Session.isinitpath",
              "reason": "Understand how initial paths interact with new collection logic potentially causing the collection of `__init__.py` files."
            },
            {
              "type": "symbol",
              "path": "src/_pytest/python.py",
              "name": "_pytest.python.path_matches_patterns",
              "reason": "This symbol checks patterns against file paths, understanding any modifications here might illuminate pattern matching changes affecting `__init__.py`."
            },
            {
              "type": "symbol",
              "path": "src/_pytest/hookspec.py",
              "name": "_pytest.hookspec.pytest_collect_file",
              "reason": "Evaluate hook mechanics which determine what constitutes a collectible file, especially any changes impacting `__init__.py` files."
            }
          ],
          "is_done": false,
          "symbols_scratch_pad": [
            "Related to file collection, changes here possibly trigger the collection of `__init__.py` files in newer version.",
            "Handles path ignore logic, potential ties to ignoring `__init__.py`.",
            "Determines if a path is an init path, potentially related if init paths are wrongly being tested.",
            "Matches file paths against patterns, critical if `__init__.py` patterns changed lead to regression."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/python.py"
        ],
        "symbols": [
          "_pytest.python.pytest_collect_file"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_collection": {
            "name": "_pytest.assertion.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "---------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.mai",
            "start_line": 93,
            "start_column": 3023,
            "end_line": 0,
            "end_column": 3399,
            "start_byte": 3023,
            "end_byte": 0
          },
          "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect": {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ue.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.optio",
            "start_line": 168,
            "start_column": 5842,
            "end_line": 4,
            "end_column": 6357,
            "start_byte": 5842,
            "end_byte": 4
          },
          "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or None.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pyfunc_call(pyfuncitem):\n    \"\"\" call underlying test function.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_generate_tests(metafunc):\n    \"\"\" generate (multiple) parametrized calls to a test function.\"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_parametrize_id(config, val, argname):\n    \"\"\"Return a user-friendly string representation of the given ``val`` that will be used\n    by @pytest.mark.parametrize calls. Return None if the hook doesn't know about ``val``.\n    The parameter name is available as ``argname``, if required.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    :param val: the parametrized value\n    :param str ",
            "start_line": 200,
            "start_column": 7163,
            "end_line": 4,
            "end_column": 9267,
            "start_byte": 7163,
            "end_byte": 4
          },
          "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems": {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "art. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" implements the runtest_setup/call/teardown protocol for\n    the given test item, including capturing exceptions and calling\n    reporting hooks.\n\n    :arg item: test item for which the runtest protocol is performed.\n\n    :arg nextitem: the scheduled-to-be-next test item (or None if this\n                   is the end my friend).  This argument is passed on to\n                   :py:func:`pytest_runtest_teardown`.\n\n    :return boolean: True if no further hook implementations should be invoked.\n\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logstart(nodeid, location):\n    \"\"\" signal the start ",
            "start_line": 265,
            "start_column": 9886,
            "end_line": 4,
            "end_column": 10614,
            "start_byte": 9886,
            "end_byte": 4
          },
          "_pytest.doctest.pytest_collect_file": {
            "name": "_pytest.doctest.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "patterns for Python test module discovery\",\n    )\n    parser.addini(\n        \"python_classes\",\n        type=\"args\",\n        default=[\"Test\"],\n        help=\"prefixes or glob names for Python test class discovery\",\n    )\n    parser.addini(\n        \"python_functions\",\n        type=\"args\",\n        default=[\"test\"]",
            "start_line": 86,
            "start_column": 2432,
            "end_line": 0,
            "end_column": 2743,
            "start_byte": 2432,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "",
            "start_line": 1386,
            "start_column": 52212,
            "end_line": 4,
            "end_column": 52338,
            "start_byte": 52212,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_collection": {
            "name": "_pytest.hookspec.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collection(session):\n    \"\"\"Perform the collection protocol for the given session.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 154,
            "start_column": 5249,
            "end_line": 0,
            "end_column": 5507,
            "start_byte": 5249,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collection_modifyitems": {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_modifyitems(session, config, items):\n    \"\"\" called after collection has been performed, may filter or re-order\n    the items in-place.\n\n    :param _pytest.main.Session session: the pytest session object\n    :param _pytest.config.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"",
            "start_line": 164,
            "start_column": 5510,
            "end_line": 0,
            "end_column": 5869,
            "start_byte": 5510,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collection_finish": {
            "name": "_pytest.hookspec.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"",
            "start_line": 174,
            "start_column": 5872,
            "end_line": 0,
            "end_column": 6051,
            "start_byte": 5872,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_ignore_collect": {
            "name": "_pytest.hookspec.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "ame, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.s",
            "start_line": 181,
            "start_column": 6054,
            "end_line": 0,
            "end_column": 6488,
            "start_byte": 6054,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_directory": {
            "name": "_pytest.hookspec.pytest_collect_directory",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"",
            "start_line": 194,
            "start_column": 6491,
            "end_line": 0,
            "end_column": 6765,
            "start_byte": 6491,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_collect_file": {
            "name": "_pytest.hookspec.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "nit__.py\":\n        return Package(path, parent)\n    return Module(path, parent)\n\n\n@hookimpl(hookwrapper=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    outcome = yield\n    res = outcome.get_result()\n    if res is not None:\n    ",
            "start_line": 204,
            "start_column": 6768,
            "end_line": 0,
            "end_column": 7010,
            "start_byte": 6768,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_collection": {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "------\n\n\ndef pytest_report_header(config, startdir):\n    \"\"\" return a string or list of strings to be displayed as header info for terminal reporting.\n\n    :param _pytest.config.Config config: pytest config object\n    :param startdir: py.path object with the starting dir\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due",
            "start_line": 512,
            "start_column": 17425,
            "end_line": 4,
            "end_column": 17846,
            "start_byte": 17425,
            "end_byte": 4
          },
          "_pytest.main.pytest_collection": {
            "name": "_pytest.main.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult",
            "start_line": 244,
            "start_column": 7329,
            "end_line": 0,
            "end_column": 7397,
            "start_byte": 7329,
            "end_byte": 0
          },
          "_pytest.main.pytest_ignore_collect": {
            "name": "_pytest.main.pytest_ignore_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_ignore_collect(path, config):\n    ignore_paths = config._getconftest_pathlist(\"collect_ignore\", path=path.dirpath())\n    ignore_paths = ignore_paths or []\n    excludeopt = config.getoption(\"ignore\")\n    if excludeopt:\n        ignore_paths.extend([py.path.local(x) for x in excludeopt])\n\n    if py.path.local(path) in ignore_paths:\n        return True\n\n    ignore_globs = config._getconftest_pathlist(\n        \"collect_ignore_glob\", path=path.dirpath()\n    )\n    ignore_globs = ignore_globs or []\n    excludeglobopt = config.getoption(\"ignore_glob\")\n    if excludeglobopt:\n        ignore_globs.extend([py.path.local(x) for x in excludeglobopt])\n\n    if any(fnmatch.fnmatch(str(path), str(glob)) for glob in ignore_globs):\n        return True\n\n    allow_in_venv = config.getoption(\"collect_in_virtualenv\")\n    if not allow_in_venv and _in_venv(path):\n        return True\n\n    return False",
            "start_line": 282,
            "start_column": 8600,
            "end_line": 0,
            "end_column": 9497,
            "start_byte": 8600,
            "end_byte": 0
          },
          "_pytest.main.pytest_collection_modifyitems": {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "-----------------\n\n\n@hookspec(firstresult=True)\ndef pytest_runtestloop(session):\n    \"\"\" called for performing the main runtest loop\n    (after collection finished).\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\ndef pytest_itemstart(item, node):\n    \"\"\"(**Deprecated**) use pytest_runtest_logstart. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_protocol(item, nextitem):\n    \"\"\" i",
            "start_line": 310,
            "start_column": 9500,
            "end_line": 0,
            "end_column": 9979,
            "start_byte": 9500,
            "end_byte": 0
          },
          "_pytest.mark.pytest_collection_modifyitems": {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files",
            "start_line": 142,
            "start_column": 4581,
            "end_line": 0,
            "end_column": 4705,
            "start_byte": 4581,
            "end_byte": 0
          },
          "_pytest.python.pytest_collect_file": {
            "name": "_pytest.python.pytest_collect_file",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_collect_file(path, parent):\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return\n        ihook = parent.session.gethookproxy(path)\n        return ihook.pytest_pycollect_makemodule(path=path, parent=parent)",
            "start_line": 175,
            "start_column": 6070,
            "end_line": 0,
            "end_column": 6478,
            "start_byte": 6070,
            "end_byte": 0
          },
          "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems": {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ith ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config obj",
            "start_line": 39,
            "start_column": 1034,
            "end_line": 4,
            "end_column": 2112,
            "start_byte": 1034,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "will require to be re-written.\n\n    :param _pytest.nodes.Item item: pytest item object of current test\n    :param int lineno: line number of the assert statement\n    :param string orig: string with original assertion\n    :param string expl: string with assert explanation\n\n    .. note::\n\n        This hook is **experim",
            "start_line": 487,
            "start_column": 16672,
            "end_line": 4,
            "end_column": 16990,
            "start_byte": 16672,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter.pytest_collection_finish": {
            "name": "_pytest.terminal.TerminalReporter.pytest_collection_finish",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ":\n    \"\"\" called for internal errors. \"\"\"\n\n\ndef pytest_keyboard_interrupt(excinfo):\n    \"\"\" called for keyboard interrupt. \"\"\"\n\n\ndef pytest_exception_interact(node, call, report):\n    \"\"\"called when an exception was raised which can potentially be\n    interactively handled.\n\n    This hook is only called if an exception was raised\n    that is not an internal exception like ``skip.Exception``.\n    \"\"\"\n\n\ndef pytest_enter_pdb(config, pdb):\n    \"\"\" called upon pdb.set_trace(), can be used by plugins to take special\n    action just before the python debugger enters in interactive mode.\n\n    :param _pytest.config.Config config: p",
            "start_line": 594,
            "start_column": 20705,
            "end_line": 4,
            "end_column": 21335,
            "start_byte": 20705,
            "end_byte": 4
          },
          "_pytest.warnings.pytest_collection": {
            "name": "_pytest.warnings.pytest_collection",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "est_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytes",
            "start_line": 116,
            "start_column": 3619,
            "end_line": 0,
            "end_column": 3851,
            "start_byte": 3619,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_pycollect_makemodule": {
            "name": "_pytest.hookspec.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "g(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function(name, parent=collector)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n",
            "start_line": 243,
            "start_column": 7772,
            "end_line": 0,
            "end_column": 8254,
            "start_byte": 7772,
            "end_byte": 0
          },
          "_pytest.python.path_matches_patterns": {
            "name": "_pytest.python.path_matches_patterns",
            "file_path": "src/_pytest/python.py",
            "file_content": "def path_matches_patterns(path, patterns):\n    \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)",
            "start_line": 187,
            "start_column": 6481,
            "end_line": 0,
            "end_column": 6690,
            "start_byte": 6481,
            "end_byte": 0
          },
          "_pytest.python.pytest_pycollect_makemodule": {
            "name": "_pytest.python.pytest_pycollect_makemodule",
            "file_path": "src/_pytest/python.py",
            "file_content": "def pytest_pycollect_makemodule(path, parent):\n    if path.basename == \"__init__.py\":\n        return Package(path, parent)\n    return Module(path, parent)",
            "start_line": 192,
            "start_column": 6693,
            "end_line": 0,
            "end_column": 6847,
            "start_byte": 6693,
            "end_byte": 0
          },
          "_pytest._argcomplete.FastFilesCompleter": {
            "name": "_pytest._argcomplete.FastFilesCompleter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 61,
            "start_column": 2341,
            "end_line": 0,
            "end_column": 3274,
            "start_byte": 2341,
            "end_byte": 0
          },
          "_pytest._argcomplete.FastFilesCompleter.__init__": {
            "name": "_pytest._argcomplete.FastFilesCompleter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.config = config or parent.config\n\n        #: the session this node is par",
            "start_line": 64,
            "start_column": 2404,
            "end_line": 4,
            "end_column": 2480,
            "start_byte": 2404,
            "end_byte": 4
          },
          "_pytest._argcomplete.FastFilesCompleter.__call__": {
            "name": "_pytest._argcomplete.FastFilesCompleter.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n   ",
            "start_line": 67,
            "start_column": 2486,
            "end_line": 4,
            "end_column": 3274,
            "start_byte": 2486,
            "end_byte": 4
          },
          "_pytest._code.ReprFileLocation": {
            "name": "_pytest._code.ReprFileLocation",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 997,
            "start_column": 33380,
            "end_line": 0,
            "end_column": 33901,
            "start_byte": 33380,
            "end_byte": 0
          },
          "_pytest._code.ReprFileLocation.__init__": {
            "name": "_pytest._code.ReprFileLocation.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 998,
            "start_column": 33422,
            "end_line": 4,
            "end_column": 33554,
            "start_byte": 33422,
            "end_byte": 4
          },
          "_pytest._code.ReprFileLocation.toterminal": {
            "name": "_pytest._code.ReprFileLocation.toterminal",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 1003,
            "start_column": 33560,
            "end_line": 4,
            "end_column": 33901,
            "start_byte": 33560,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile": {
            "name": "_pytest.capture.EncodedFile",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 412,
            "start_column": 14331,
            "end_line": 0,
            "end_column": 15203,
            "start_byte": 14331,
            "end_byte": 0
          },
          "_pytest.capture.EncodedFile.errors": {
            "name": "_pytest.capture.EncodedFile.errors",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " None, \"\"\n\n    @p",
            "start_line": 413,
            "start_column": 14354,
            "end_line": 4,
            "end_column": 14371,
            "start_byte": 14354,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.__init__": {
            "name": "_pytest.capture.EncodedFile.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "         return self._location\n        except AttributeError:\n            location = self.reportinf",
            "start_line": 415,
            "start_column": 14419,
            "end_line": 4,
            "end_column": 14518,
            "start_byte": 14419,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.write": {
            "name": "_pytest.capture.EncodedFile.write",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 419,
            "start_column": 14524,
            "end_line": 4,
            "end_column": 14803,
            "start_byte": 14524,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.writelines": {
            "name": "_pytest.capture.EncodedFile.writelines",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 428,
            "start_column": 14809,
            "end_line": 4,
            "end_column": 14898,
            "start_byte": 14809,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.name": {
            "name": "_pytest.capture.EncodedFile.name",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 432,
            "start_column": 14904,
            "end_line": 4,
            "end_column": 15015,
            "start_byte": 14904,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.mode": {
            "name": "_pytest.capture.EncodedFile.mode",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 437,
            "start_column": 15021,
            "end_line": 4,
            "end_column": 15099,
            "start_byte": 15021,
            "end_byte": 4
          },
          "_pytest.capture.EncodedFile.__getattr__": {
            "name": "_pytest.capture.EncodedFile.__getattr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "",
            "start_line": 441,
            "start_column": 15105,
            "end_line": 4,
            "end_column": 15203,
            "start_byte": 15105,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem": {
            "name": "_pytest.doctest.DoctestItem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ")\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 179,
            "start_column": 5360,
            "end_line": 0,
            "end_column": 9346,
            "start_byte": 5360,
            "end_byte": 0
          },
          "_pytest.doctest.DoctestItem.__init__": {
            "name": "_pytest.doctest.DoctestItem.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n     ",
            "start_line": 180,
            "start_column": 5396,
            "end_line": 4,
            "end_column": 5609,
            "start_byte": 5396,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem.setup": {
            "name": "_pytest.doctest.DoctestItem.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ram marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a",
            "start_line": 187,
            "start_column": 5615,
            "end_line": 4,
            "end_column": 6004,
            "start_byte": 5615,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem.runtest": {
            "name": "_pytest.doctest.DoctestItem.runtest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "g or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n     ",
            "start_line": 197,
            "start_column": 6010,
            "end_line": 4,
            "end_column": 6264,
            "start_byte": 6010,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin": {
            "name": "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(se",
            "start_line": 205,
            "start_column": 6270,
            "end_line": 4,
            "end_column": 6742,
            "start_byte": 6270,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem.repr_failure": {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "tchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                s",
            "start_line": 218,
            "start_column": 6748,
            "end_line": 4,
            "end_column": 9245,
            "start_byte": 6748,
            "end_byte": 4
          },
          "_pytest.doctest.DoctestItem.reportinfo": {
            "name": "_pytest.doctest.DoctestItem.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"ve",
            "start_line": 273,
            "start_column": 9251,
            "end_line": 4,
            "end_column": 9346,
            "start_byte": 9251,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter": {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 83,
            "start_column": 2200,
            "end_line": 0,
            "end_column": 9131,
            "start_byte": 2200,
            "end_byte": 0
          },
          "_pytest.junitxml._NodeReporter.__init__": {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "me within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or ",
            "start_line": 84,
            "start_column": 2225,
            "end_line": 4,
            "end_column": 2519,
            "start_byte": 2225,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append": {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspa",
            "start_line": 95,
            "start_column": 2525,
            "end_line": 4,
            "end_column": 2628,
            "start_byte": 2525,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.add_property": {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "spath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n       ",
            "start_line": 99,
            "start_column": 2634,
            "end_line": 4,
            "end_column": 2737,
            "start_byte": 2634,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.add_attribute": {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n       ",
            "start_line": 102,
            "start_column": 2743,
            "end_line": 4,
            "end_column": 2834,
            "start_byte": 2743,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.make_properties_node": {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            asse",
            "start_line": 105,
            "start_column": 2840,
            "end_line": 4,
            "end_column": 3199,
            "start_byte": 2840,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.record_testreport": {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format",
            "start_line": 117,
            "start_column": 3205,
            "end_line": 4,
            "end_column": 4372,
            "start_byte": 3205,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.to_xml": {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "                warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n          ",
            "start_line": 148,
            "start_column": 4378,
            "end_line": 4,
            "end_column": 4615,
            "start_byte": 4378,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter._add_simple": {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ing,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods f",
            "start_line": 155,
            "start_column": 4621,
            "end_line": 4,
            "end_column": 4774,
            "start_byte": 4621,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.write_captured_output": {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in rever",
            "start_line": 160,
            "start_column": 4780,
            "end_line": 4,
            "end_column": 6736,
            "start_byte": 4780,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_pass": {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lf.listchain()):\n            for mark in node.own_markers:\n    ",
            "start_line": 213,
            "start_column": 6742,
            "end_line": 4,
            "end_column": 6805,
            "start_byte": 6742,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_failure": {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "      if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            ext",
            "start_line": 216,
            "start_column": 6811,
            "end_line": 4,
            "end_column": 7499,
            "start_byte": 6811,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_collect_error": {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "words.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be",
            "start_line": 232,
            "start_column": 7505,
            "end_line": 4,
            "end_column": 7723,
            "start_byte": 7505,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_collect_skipped": {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "d when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain",
            "start_line": 238,
            "start_column": 7729,
            "end_line": 4,
            "end_column": 7849,
            "start_byte": 7729,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_error": {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the gi",
            "start_line": 241,
            "start_column": 7855,
            "end_line": 4,
            "end_column": 8079,
            "start_byte": 7855,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.append_skipped": {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ass\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.tracebac",
            "start_line": 248,
            "start_column": 8085,
            "end_line": 4,
            "end_column": 8982,
            "start_byte": 8085,
            "end_byte": 4
          },
          "_pytest.junitxml._NodeReporter.finalize": {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process i",
            "start_line": 273,
            "start_column": 8988,
            "end_line": 4,
            "end_column": 9131,
            "start_byte": 8988,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords": {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 333,
            "start_column": 11604,
            "end_line": 0,
            "end_column": 12534,
            "start_byte": 11604,
            "end_byte": 0
          },
          "_pytest.mark.NodeKeywords.__init__": {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = nt",
            "start_line": 334,
            "start_column": 11644,
            "end_line": 4,
            "end_column": 11770,
            "start_byte": 11644,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__getitem__": {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ck.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspa",
            "start_line": 339,
            "start_column": 11776,
            "end_line": 4,
            "end_column": 11982,
            "start_byte": 11776,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__setitem__": {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "mon(initial_path) == initial_path:\n            return fspath.relto(in",
            "start_line": 347,
            "start_column": 11988,
            "end_line": 4,
            "end_column": 12057,
            "start_byte": 11988,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__delitem__": {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=N",
            "start_line": 350,
            "start_column": 12063,
            "end_line": 4,
            "end_column": 12153,
            "start_byte": 12063,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__iter__": {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ession=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx ",
            "start_line": 353,
            "start_column": 12159,
            "end_line": 4,
            "end_column": 12232,
            "start_byte": 12159,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords._seen": {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "or test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n  ",
            "start_line": 357,
            "start_column": 12238,
            "end_line": 4,
            "end_column": 12390,
            "start_byte": 12238,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__len__": {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        name = rel\n            name = name.replace(",
            "start_line": 363,
            "start_column": 12396,
            "end_line": 4,
            "end_column": 12447,
            "start_byte": 12396,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__repr__": {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n",
            "start_line": 366,
            "start_column": 12453,
            "end_line": 4,
            "end_column": 12534,
            "start_byte": 12453,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers": {
            "name": "_pytest.mark.NodeMarkers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "to(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__",
            "start_line": 371,
            "start_column": 12598,
            "end_line": 0,
            "end_column": 13270,
            "start_byte": 12598,
            "end_byte": 0
          },
          "_pytest.mark.NodeMarkers.own_markers": {
            "name": "_pytest.mark.NodeMarkers.own_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "place(os.sep, SEP)\n\n        super().__init__(name",
            "start_line": 382,
            "start_column": 12802,
            "end_line": 4,
            "end_column": 12851,
            "start_byte": 12802,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.update": {
            "name": "_pytest.mark.NodeMarkers.update",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nt, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests fro",
            "start_line": 384,
            "start_column": 12857,
            "end_line": 4,
            "end_column": 12978,
            "start_byte": 12857,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.find": {
            "name": "_pytest.mark.NodeMarkers.find",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "le. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, co",
            "start_line": 389,
            "start_column": 12984,
            "end_line": 4,
            "end_column": 13207,
            "start_byte": 12984,
            "end_byte": 4
          },
          "_pytest.mark.NodeMarkers.__iter__": {
            "name": "_pytest.mark.NodeMarkers.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "one, session=None, nodeid=None):\n        super().__init__",
            "start_line": 398,
            "start_column": 13213,
            "end_line": 4,
            "end_column": 13270,
            "start_byte": 13213,
            "end_byte": 4
          },
          "_pytest.nodes.Node": {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node:\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self):\n        return hash(self.nodeid)\n\n    def setup(self):\n        pass\n\n    def teardown(self):\n        pass\n\n    def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self):\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 66,
            "start_column": 1943,
            "end_line": 0,
            "end_column": 9973,
            "start_byte": 1943,
            "end_byte": 0
          },
          "_pytest.nodes.Node.__init__": {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self, name, parent=None, config=None, session=None, fspath=None, nodeid=None\n    ):\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        self.config = config or parent.config\n\n        #: the session this node is part of\n        self.session = session or parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name",
            "start_line": 70,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 3399,
            "start_byte": 2097,
            "end_byte": 4
          },
          "_pytest.nodes.Node.ihook": {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 108,
            "start_column": 3405,
            "end_line": 4,
            "end_column": 3558,
            "start_byte": 3405,
            "end_byte": 4
          },
          "_pytest.nodes.Node.__repr__": {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self):\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 113,
            "start_column": 3564,
            "end_line": 4,
            "end_column": 3669,
            "start_byte": 3564,
            "end_byte": 4
          },
          "_pytest.nodes.Node.warn": {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning):\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        # Type ignored: https://github.com/python/typeshed/pull/3121\n        warnings.warn_explicit(  # type: ignore\n            warning,\n            category=None,\n            filename=str(path),\n            lineno=lineno + 1 if lineno is not None else None,\n        )",
            "start_line": 116,
            "start_column": 3675,
            "end_line": 4,
            "end_column": 4757,
            "start_byte": 3675,
            "end_byte": 4
          },
          "_pytest.nodes.Node.nodeid": {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self):\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 150,
            "start_column": 4796,
            "end_line": 4,
            "end_column": 4931,
            "start_byte": 4796,
            "end_byte": 4
          },
          "_pytest.nodes.Node.__hash__": {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self):\n        return hash(self.nodeid)",
            "start_line": 155,
            "start_column": 4937,
            "end_line": 4,
            "end_column": 4989,
            "start_byte": 4937,
            "end_byte": 4
          },
          "_pytest.nodes.Node.setup": {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self):\n        pass",
            "start_line": 158,
            "start_column": 4995,
            "end_line": 4,
            "end_column": 5024,
            "start_byte": 4995,
            "end_byte": 4
          },
          "_pytest.nodes.Node.teardown": {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self):\n        pass",
            "start_line": 161,
            "start_column": 5030,
            "end_line": 4,
            "end_column": 5062,
            "start_byte": 5030,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listchain": {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self):\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 164,
            "start_column": 5068,
            "end_line": 4,
            "end_column": 5382,
            "start_byte": 5068,
            "end_byte": 4
          },
          "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 175,
            "start_column": 5388,
            "end_line": 4,
            "end_column": 6218,
            "start_byte": 5388,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers": {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 199,
            "start_column": 6224,
            "end_line": 4,
            "end_column": 6470,
            "start_byte": 6224,
            "end_byte": 4
          },
          "_pytest.nodes.Node.iter_markers_with_node": {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(self, name=None):\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 207,
            "start_column": 6476,
            "end_line": 4,
            "end_column": 6909,
            "start_byte": 6476,
            "end_byte": 4
          },
          "_pytest.nodes.Node.get_closest_marker": {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(self, name, default=None):\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 219,
            "start_column": 6915,
            "end_line": 4,
            "end_column": 7287,
            "start_byte": 6915,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listextrakeywords": {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self):\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 228,
            "start_column": 7293,
            "end_line": 4,
            "end_column": 7575,
            "start_byte": 7293,
            "end_byte": 4
          },
          "_pytest.nodes.Node.listnames": {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self):\n        return [x.name for x in self.listchain()]",
            "start_line": 235,
            "start_column": 7581,
            "end_line": 4,
            "end_column": 7651,
            "start_byte": 7581,
            "end_byte": 4
          },
          "_pytest.nodes.Node.addfinalizer": {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin):\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 238,
            "start_column": 7657,
            "end_line": 4,
            "end_column": 7952,
            "start_byte": 7657,
            "end_byte": 4
          },
          "_pytest.nodes.Node.getparent": {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls):\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self\n        while current and not isinstance(current, cls):\n            current = current.parent\n        return current",
            "start_line": 246,
            "start_column": 7958,
            "end_line": 4,
            "end_column": 8230,
            "start_byte": 7958,
            "end_byte": 4
          },
          "_pytest.nodes.Node._prunetraceback": {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 254,
            "start_column": 8236,
            "end_line": 4,
            "end_column": 8284,
            "start_byte": 8236,
            "end_byte": 4
          },
          "_pytest.nodes.Node._repr_failure_py": {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(self, excinfo, style=None):\n        # Type ignored: see comment where fail.Exception is defined.\n        if excinfo.errisinstance(fail.Exception):  # type: ignore\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        fm = self.session._fixturemanager\n        if excinfo.errisinstance(fm.FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 257,
            "start_column": 8290,
            "end_line": 4,
            "end_column": 9870,
            "start_byte": 8290,
            "end_byte": 4
          },
          "_pytest.nodes.Node.repr_failure": {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo, style=None):\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 301,
            "start_column": 9876,
            "end_line": 4,
            "end_column": 9973,
            "start_byte": 9876,
            "end_byte": 4
          },
          "_pytest.nodes.Collector": {
            "name": "_pytest.nodes.Collector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Collector(Node):\n    \"\"\" Collector instances create children through collect()\n        and thus iteratively build a tree.\n    \"\"\"\n\n    class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 323,
            "start_column": 10562,
            "end_line": 0,
            "end_column": 11863,
            "start_byte": 10562,
            "end_byte": 0
          },
          "_pytest.nodes.Collector.CollectError": {
            "name": "_pytest.nodes.Collector.CollectError",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class CollectError(Exception):\n        \"\"\" an error during collection, contains a custom message. \"\"\"",
            "start_line": 328,
            "start_column": 10703,
            "end_line": 4,
            "end_column": 10804,
            "start_byte": 10703,
            "end_byte": 4
          },
          "_pytest.nodes.Collector.collect": {
            "name": "_pytest.nodes.Collector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")",
            "start_line": 331,
            "start_column": 10810,
            "end_line": 4,
            "end_column": 10986,
            "start_byte": 10810,
            "end_byte": 4
          },
          "_pytest.nodes.Collector.repr_failure": {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)",
            "start_line": 337,
            "start_column": 10992,
            "end_line": 4,
            "end_column": 11522,
            "start_byte": 10992,
            "end_byte": 4
          },
          "_pytest.nodes.Collector._prunetraceback": {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()",
            "start_line": 351,
            "start_column": 11528,
            "end_line": 4,
            "end_column": 11863,
            "start_byte": 11528,
            "end_byte": 4
          },
          "_pytest.nodes.FSCollector": {
            "name": "_pytest.nodes.FSCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 366,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12907,
            "start_byte": 12071,
            "end_byte": 0
          },
          "_pytest.nodes.FSCollector.__init__": {
            "name": "_pytest.nodes.FSCollector.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)",
            "start_line": 367,
            "start_column": 12105,
            "end_line": 4,
            "end_column": 12907,
            "start_byte": 12105,
            "end_byte": 4
          },
          "_pytest.nodes.File": {
            "name": "_pytest.nodes.File",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"",
            "start_line": 390,
            "start_column": 12910,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 12910,
            "end_byte": 0
          },
          "_pytest.nodes.Item": {
            "name": "_pytest.nodes.Item",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 394,
            "start_column": 12994,
            "end_line": 0,
            "end_column": 14723,
            "start_byte": 12994,
            "end_byte": 0
          },
          "_pytest.nodes.Item.nextitem": {
            "name": "_pytest.nodes.Item.nextitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nextitem = None",
            "start_line": 399,
            "start_column": 13146,
            "end_line": 4,
            "end_column": 13161,
            "start_byte": 13146,
            "end_byte": 4
          },
          "_pytest.nodes.Item.__init__": {
            "name": "_pytest.nodes.Item.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]",
            "start_line": 401,
            "start_column": 13167,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13167,
            "end_byte": 4
          },
          "_pytest.nodes.Item.add_report_section": {
            "name": "_pytest.nodes.Item.add_report_section",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))",
            "start_line": 409,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 14299,
            "start_byte": 13581,
            "end_byte": 4
          },
          "_pytest.nodes.Item.reportinfo": {
            "name": "_pytest.nodes.Item.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def reportinfo(self):\n        return self.fspath, None, \"\"",
            "start_line": 428,
            "start_column": 14305,
            "end_line": 4,
            "end_column": 14363,
            "start_byte": 14305,
            "end_byte": 4
          },
          "_pytest.nodes.Item.location": {
            "name": "_pytest.nodes.Item.location",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location",
            "start_line": 431,
            "start_column": 14369,
            "end_line": 4,
            "end_column": 14723,
            "start_byte": 14369,
            "end_byte": 4
          },
          "_pytest.python.PyCollector": {
            "name": "_pytest.python.PyCollector",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " contains a custom message. \"\"\"\n\n    def collect(self):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n        \"\"\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\" option).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tbstyle = \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_relpath(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial_path) == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(session, fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 310,
            "start_column": 10773,
            "end_line": 0,
            "end_column": 15533,
            "start_byte": 10773,
            "end_byte": 0
          },
          "_pytest.python.PyCollector.funcnamefilter": {
            "name": "_pytest.python.PyCollector.funcnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "f):\n        \"\"\" returns a list of children (items and collectors)\n            for this collection node.\n    ",
            "start_line": 311,
            "start_column": 10825,
            "end_line": 4,
            "end_column": 10933,
            "start_byte": 10825,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.isnosetest": {
            "name": "_pytest.python.PyCollector.isnosetest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "\"\n        raise NotImplementedError(\"abstract\")\n\n    def repr_failure(self, excinfo):\n        \"\"\" represent a collection failure. \"\"\"\n        if excinfo.errisinstance(self.CollectError):\n            exc = excinfo.value\n            return str(exc.args[0])\n\n        # Respect explicit tbstyle option, but default to \"short\"\n        # (None._repr_failure_py defaults to \"long\" without \"fulltrace\"",
            "start_line": 314,
            "start_column": 10939,
            "end_line": 4,
            "end_column": 11332,
            "start_byte": 10939,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.classnamefilter": {
            "name": "_pytest.python.PyCollector.classnamefilter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "n).\n        tbstyle = self.config.getoption(\"tbstyle\", \"auto\")\n        if tbstyle == \"auto\":\n            tb",
            "start_line": 323,
            "start_column": 11338,
            "end_line": 4,
            "end_column": 11445,
            "start_byte": 11338,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.istestfunction": {
            "name": "_pytest.python.PyCollector.istestfunction",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "= \"short\"\n\n        return self._repr_failure_py(excinfo, style=tbstyle)\n\n    def _prunetraceback(self, excinfo):\n        if hasattr(self, \"fspath\"):\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=self.fspath)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(excludepath=tracebackcutdir)\n            excinfo.traceback = ntraceback.filter()\n\n\ndef _check_initialpaths_for_",
            "start_line": 326,
            "start_column": 11451,
            "end_line": 4,
            "end_column": 11894,
            "start_byte": 11451,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.istestclass": {
            "name": "_pytest.python.PyCollector.istestclass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "h(session, fspath):\n    for initial_path in session._initialpaths:\n        if fspath.common(initial",
            "start_line": 338,
            "start_column": 11900,
            "end_line": 4,
            "end_column": 11999,
            "start_byte": 11900,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._matches_prefix_or_glob_option": {
            "name": "_pytest.python.PyCollector._matches_prefix_or_glob_option",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " == initial_path:\n            return fspath.relto(initial_path)\n\n\nclass FSCollector(Collector):\n    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n        fspath = py.path.local(fspath)  # xxx only for test_resultlog.py?\n        name = fspath.basename\n        if parent is not None:\n            rel = fspath.relto(parent.fspath)\n            if rel:\n                name = rel\n            name = name.replace(os.sep, SEP)\n        self.fspath = fspath\n\n        session = session or parent.session\n\n        if nodeid is None:\n            nodeid = self.fspath.relto(session.config.rootdir)\n\n            if not nodeid:\n                nodeid = _check_initialpaths_for_relpath(s",
            "start_line": 341,
            "start_column": 12005,
            "end_line": 4,
            "end_column": 12711,
            "start_byte": 12005,
            "end_byte": 4
          },
          "_pytest.python.PyCollector.collect": {
            "name": "_pytest.python.PyCollector.collect",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ", fspath)\n            if nodeid and os.sep != SEP:\n                nodeid = nodeid.replace(os.sep, SEP)\n\n        super().__init__(name, parent, config, session, nodeid=nodeid, fspath=fspath)\n\n\nclass File(FSCollector):\n    \"\"\" base class for collecting tests from a file. \"\"\"\n\n\nclass Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(self, name, parent=None, config=None, session=None, nodeid=None):\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, Any]]\n\n    def add_report_section(self, when: ",
            "start_line": 358,
            "start_column": 12717,
            "end_line": 4,
            "end_column": 13616,
            "start_byte": 12717,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._makeitem": {
            "name": "_pytest.python.PyCollector._makeitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ey: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n          ",
            "start_line": 383,
            "start_column": 13622,
            "end_line": 4,
            "end_column": 13797,
            "start_byte": 13622,
            "end_byte": 4
          },
          "_pytest.python.PyCollector._genfunctions": {
            "name": "_pytest.python.PyCollector._genfunctions",
            "file_path": "src/_pytest/nodes.py",
            "file_content": ".add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self):\n        return self.fspath, None, \"\"\n\n    @property\n    def location(self):\n        try:\n            return self._location\n        except AttributeError:\n            location = self.reportinfo()\n            fspath = self.session._node_location_to_relpath(location[0])\n            location = (fspath, location[1], str(location[2]))\n            self._location = location\n            return location\n",
            "start_line": 387,
            "start_column": 13803,
            "end_line": 4,
            "end_column": 15533,
            "start_byte": 13803,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 418,
            "start_column": 12761,
            "end_line": 4,
            "end_column": 12830,
            "start_byte": 12761,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 435,
            "start_column": 13415,
            "end_line": 4,
            "end_column": 13883,
            "start_byte": 13415,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []\n        self._initialparts = []\n        self.items = items = []\n        for arg in args:\n            parts = self._parsearg(arg)\n            self._initialparts.append(parts)\n            initialpaths.append(parts[0])\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n                # XXX: test this\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 448,
            "start_column": 13889,
            "end_line": 4,
            "end_column": 15062,
            "start_byte": 13889,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, arg):\n        from _pytest.python import Package\n\n        names = self._parsearg(arg)\n        argpath = names.pop(0)\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._node_cache:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._node_cache[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format(arg)\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._pkg_roots[dirpath] = x\n                if dirpath in self._pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._node_cache:\n                        yield self._node_cache[key]\n                    else:\n                        self._node_cache[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._node_cache:\n                col = self._node_cache[argpath]\n            else:\n                collect_root = self._pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._node_cache[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 494,
            "start_column": 15595,
            "end_line": 4,
            "end_column": 19295,
            "start_byte": 15595,
            "end_byte": 4
          },
          "_pytest.main.Session._collectfile": {
            "name": "_pytest.main.Session._collectfile",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collectfile(self, path, handle_dupes=True):\n        assert (\n            path.isfile()\n        ), \"{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})\".format(\n            path, path.isdir(), path.exists(), path.islink()\n        )\n        ihook = self.gethookproxy(path)\n        if not self.isinitpath(path):\n            if ihook.pytest_ignore_collect(path=path, config=self.config):\n                return ()\n\n        if handle_dupes:\n            keepduplicates = self.config.getoption(\"keepduplicates\")\n            if not keepduplicates:\n                duplicate_paths = self.config.pluginmanager._duplicatepaths\n                if path in duplicate_paths:\n                    return ()\n                else:\n                    duplicate_paths.add(path)\n\n        return ihook.pytest_collect_file(path=path, parent=self)",
            "start_line": 576,
            "start_column": 19301,
            "end_line": 4,
            "end_column": 20135,
            "start_byte": 19301,
            "end_byte": 4
          }
        }
      }
    }
  ]
}