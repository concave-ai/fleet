{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5809",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-17T22:37:46.229165",
        "usage": "1115.8978939056396 ms"
      },
      "request": {
        "repo_tokens": [
          "suspend_fixture",
          "visit_Attribute",
          "Function",
          "_py_ext_re",
          "_seen",
          "filename_arg",
          "name2fixturedefs",
          "dummy_context_manager",
          "CollectErrorRepr",
          "resultlog",
          "isfunction",
          "get_unpacked_marks",
          "_locationline",
          "pytest_runtest_teardown",
          "_disable_output_capturing_for_darwin",
          "issequence",
          "_get_marks",
          "getini",
          "DOCTEST_REPORT_CHOICE_NONE",
          "isnosetest",
          "make_hook_recorder",
          "DEFAULT_LOG_FORMAT",
          "_addexcinfo",
          "node_reporter",
          "setns",
          "markname",
          "at_level",
          "notset",
          "is_package",
          "astcache",
          "__all__",
          "warning_types",
          "_legal_ranges",
          "get_scope_package",
          "_imp_find_module",
          "param",
          "getbasetemp",
          "Traceback",
          "post_mortem",
          "_compare_eq_verbose",
          "get_scope_node",
          "deactivate_fixture",
          "BOM_UTF8",
          "_get_active_fixturedef",
          "create_new_paste",
          "RAISES_EXEC",
          "__getitem__",
          "fix_cache_order",
          "PYTEST_LOGWARNING",
          "LogXML",
          "linecomp",
          "_format_boolop",
          "getfuncargnames",
          "pytest_make_parametrize_id",
          "str",
          "_ensure_basetemp",
          "add_report_section",
          "ReprLocals",
          "ihook",
          "approx",
          "Config",
          "iter_markers",
          "setupplan",
          "nodes",
          "tracebackcutdir",
          "set_log_path",
          "pytest_keyboard_interrupt",
          "cached_eval",
          "passed",
          "addhooks",
          "_warn_already_imported",
          "classnamefilter",
          "USAGE_MSG",
          "MarkEvaluator",
          "__repr__",
          "pytest_runtest_call",
          "getpluginversioninfo",
          "recursionindex",
          "_cachedir",
          "setall",
          "showversion",
          "nodeid",
          "_istrue",
          "collect_one_node",
          "typename",
          "capfdbinary",
          "start",
          "format",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "function",
          "putaround",
          "mangle_test_address",
          "getcalls",
          "pytest_exception_interact",
          "own_mark_names",
          "__setattr__",
          "pytest_addhooks",
          "freeze_support",
          "_update_current_test_var",
          "_patched_find_module",
          "PrintHelp",
          "repr_locals",
          "illegal_xml_re",
          "outcomes",
          "_tryconvertpyarg",
          "SysCapture",
          "pytest_runtest_logreport",
          "newinstance",
          "getargs",
          "get_default_arg_names",
          "AssertionState",
          "makedir",
          "set_when",
          "PytestWarning",
          "FixtureFunctionMarker",
          "repr_failure",
          "makeini",
          "_ensure_unconfigure",
          "flow_marker",
          "Instance",
          "build_summary_stats_line",
          "__module__",
          "cache_dir_from_config",
          "FSHookProxy",
          "PytestUnknownMarkWarning",
          "stop_capturing",
          "_colorama_workaround",
          "resume_fixture",
          "get_lines_after",
          "extract_from",
          "tb",
          "LineMatcher_fixture",
          "__hash__",
          "pytest_collection_modifyitems",
          "spawn",
          "_assertion_supported",
          "_notin_text",
          "parts",
          "_getnextfixturedef",
          "getpathnode",
          "CallInfo",
          "Package",
          "pytest_itemcollected",
          "terminal",
          "pytest_collect_file",
          "OptionGroup",
          "addoption",
          "safe_text_dupfile",
          "scopename2class",
          "cleanup_numbered_dir",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "pytest_collection_finish",
          "isinitpath",
          "Node",
          "consider_env",
          "get_open_files",
          "MarkMapping",
          "_typ_map",
          "from_item_and_call",
          "FIXTURE_NAMED_REQUEST",
          "compile_",
          "prog",
          "_recurse",
          "PyobjContext",
          "runpython_c",
          "pytest_pyfunc_call",
          "_teardown_with_finalization",
          "_given_basetemp",
          "pytest_warning_captured",
          "_resolve_arg_ids",
          "FDCapture",
          "_warn_if_env_name_is_not_str",
          "countoutcomes",
          "WarningsChecker",
          "nofuncargs",
          "_get_allow_bytes_flag",
          "close",
          "mode",
          "_get_fixturestack",
          "iter_markers_with_node",
          "with_args",
          "UsageError",
          "delenv",
          "runpytest_inprocess",
          "_argcomplete",
          "File",
          "fail_fixturefunc",
          "AssertionRewriter",
          "__next__",
          "_getglobals",
          "PytestAssertRewriteWarning",
          "check_xfail_no_run",
          "_readline_workaround",
          "initialnames",
          "runtest",
          "cut",
          "mark_rewrite",
          "pytest_sessionfinish",
          "ResultLog",
          "_getreprcrash",
          "DEFAULT_MAX_LINES",
          "_markers",
          "autouse",
          "istestclass",
          "genitems",
          "excinfo",
          "write_ensure_prefix",
          "_for_parametrize",
          "pytest_cmdline_preparse",
          "CaptureResult",
          "addfinalizer",
          "node",
          "append_error",
          "pytest_unconfigure",
          "mkdir",
          "PYTEST_ENSURETEMP",
          "_should_truncate_item",
          "logging",
          "_report_keyboardinterrupt",
          "_processopt",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "capstdout",
          "_issue_warning_captured",
          "resolve_fixture_function",
          "_make_xunit_fixture",
          "_warn_about_missing_assertion",
          "getmodpath",
          "_prunetraceback",
          "pytest_internalerror",
          "GETFUNCARGVALUE",
          "ischildnode",
          "_should_rewrite",
          "print_teardown_sections",
          "visit_Compare",
          "LsofFdLeakChecker",
          "fail_marker",
          "getgroup",
          "safe_getattr",
          "TEST_OUTCOME",
          "_validate_args",
          "parse",
          "_teardown_towards",
          "locals",
          "_matchnodes",
          "syspathinsert",
          "finish",
          "__bool__",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "_check_scope",
          "_should_repr_global_name",
          "RESULT_LOG",
          "Testdir",
          "PdbInvoke",
          "makeconftest",
          "global_and_fixture_disabled",
          "pytest_assertrepr_compare",
          "args",
          "_config_for_test",
          "copy_example",
          "scope2props",
          "getfixturedefs",
          "warn",
          "writeorg",
          "_py36_windowsconsoleio_workaround",
          "setitem",
          "findsource",
          "pop_outerr_to_orig",
          "parametrize",
          "FuncFixtureInfo",
          "getimfunc",
          "parse_num",
          "_recursive_debug",
          "_compare_eq_cls",
          "MoreQuietAction",
          "_assert_start_repr",
          "traceback",
          "deselect_by_mark",
          "_suspend",
          "YIELD_TESTS",
          "_inject_setup_module_fixture",
          "_yield_comparisons",
          "processoption",
          "_main",
          "Source",
          "_getscopeitem",
          "_parse_lsof_output",
          "addError",
          "call_fixture_func",
          "compile",
          "scope2index",
          "emit",
          "_excinfo",
          "matching_platform",
          "_collectfile",
          "_config",
          "repr_instance",
          "path_matches_patterns",
          "_get_report_choice",
          "_inject_setup_function_fixture",
          "matchreport",
          "doctest",
          "DoctestTextfile",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "WARNS_EXEC",
          "teardown_exact",
          "FixtureLookupErrorRepr",
          "getstatement",
          "_ConfigDeprecated",
          "get_public_names",
          "set_location",
          "pytest_plugin_registered",
          "python",
          "_compute_fixture_value",
          "_getobj",
          "num_mock_patch_args",
          "_check_all_skipped",
          "_get_non_fixture_func",
          "_ensure_only_one_capture_fixture",
          "_start",
          "runitem",
          "ensuretemp",
          "binop_map",
          "records",
          "call_runtest_hook",
          "disabled",
          "_postmortem_traceback",
          "helpconfig",
          "default_plugins",
          "ReprFileLocation",
          "find_suffixes",
          "_setoption",
          "clear",
          "_non_numeric_type_error",
          "_get_checker",
          "getcrashentry",
          "REGEX_TYPE",
          "re_match_lines_random",
          "setattr",
          "add_attribute",
          "get_closest_marker",
          "pytest_runtest_setup",
          "eval",
          "finish_recording",
          "DontReadFromInput",
          "report_collect",
          "is_potential_nosetest",
          "getfixturevalue",
          "_find_parametrized_scope",
          "isatty",
          "ReprEntry",
          "_compilecounter",
          "_is_setup_py",
          "pytest_fixture_setup",
          "assertion",
          "pytest_fixture_post_finalizer",
          "_PY3",
          "count_towards_summary",
          "rm_rf",
          "_callfinalizers",
          "for_config",
          "_early_rewrite_bailout",
          "pytest_load_initial_conftests",
          "_init_runner_class",
          "get_records",
          "buffer",
          "Skipped",
          "Frame",
          "_running_on_ci",
          "call_optional",
          "isdict",
          "_genfunctions",
          "context",
          "_legal_chars",
          "head_line",
          "WarningsRecorder",
          "combined_with",
          "append_collect_skipped",
          "strip",
          "reports",
          "_makeitem",
          "MarkGenerator",
          "wrap_session",
          "pytest_runtest_protocol",
          "gethookproxy",
          "deprecated",
          "testdir",
          "pytest_terminal_summary",
          "result",
          "EMPTY_PARAMETERSET_OPTION",
          "names_closure",
          "cookie_re",
          "gethookrecorder",
          "fromdictargs",
          "isattrs",
          "pytest_report_header",
          "pytest_runtestloop",
          "rewrite_asserts",
          "README_CONTENT",
          "builtin",
          "is_rewrite_disabled",
          "finalize",
          "pytest_sessionstart",
          "id",
          "RE_IMPORT_ERROR_NAME",
          "_ensure_removed_sysmodule",
          "yield_fixture",
          "capsys",
          "parseconfig",
          "LEVELNAME_FMT_REGEX",
          "addSkip",
          "_inject_setup_teardown_fixtures",
          "getfailedcollections",
          "_version",
          "prepare",
          "_getpytestargs",
          "_log_text",
          "TracebackEntry",
          "get_direct_param_fixture_func",
          "CaptureManager",
          "saferepr",
          "parsefactories",
          "_call_and_format_exception",
          "get_sections",
          "_log",
          "get_statement_startend2",
          "getoption",
          "getparam",
          "idmaker",
          "makepyfile",
          "_get_xunit_setup_teardown",
          "spawn_pytest",
          "location",
          "pytestPDB",
          "_PLUGGY_DIR",
          "ASCII_IS_DEFAULT_ENCODING",
          "exc_clear",
          "NoMatch",
          "getreports",
          "short_test_summary",
          "_ensure_immutable_ids",
          "cached_result",
          "pytest_leave_pdb",
          "set",
          "add_property",
          "ids",
          "warn_about_none_ast",
          "truncate_if_required",
          "fslocation",
          "version_tuple",
          "_log_cli_enabled",
          "_get_verbose_word",
          "inline_runsource",
          "maybe_delete_a_numbered_dir",
          "_parse_parametrize_parameters",
          "record_testsuite_property",
          "_get_progress_information_message",
          "getsource",
          "conftest_options",
          "fullsource",
          "python_api",
          "_trace",
          "_init_pdb",
          "rex_outcome",
          "addFailure",
          "get_skip_exceptions",
          "format_exception_only",
          "reportinfo",
          "fixture",
          "_get_pos",
          "_NodeReporter",
          "patchsysdict",
          "SysPathsSnapshot",
          "CFG_PYTEST_SECTION",
          "activate_fixture",
          "_fillfixtures",
          "_code",
          "getstatementrange_ast",
          "_testcase",
          "HookRecorder",
          "getitem",
          "_width_of_current_line",
          "getfslineno",
          "filter_traceback",
          "__missing__",
          "to_xml",
          "teardown_nose",
          "_get_global_properties_node",
          "suspend",
          "parseoutcomes",
          "_makepath",
          "getlocation",
          "_is_marked_for_rewrite",
          "_write_report_lines_from_hooks",
          "_sys_snapshot",
          "Failed",
          "item_capture",
          "_idval",
          "_pytest",
          "determine_setup",
          "_getentrysource",
          "format_explanation",
          "reorder_items",
          "suspend_capturing",
          "_pop_and_teardown",
          "catch_warnings_for_item",
          "wasvalid",
          "_perform_collect",
          "add_stats",
          "getcall",
          "getstatementrange",
          "__unicode__",
          "_addoption_instance",
          "_set_opt_strings",
          "_saved",
          "showheader",
          "builtin_plugins",
          "__array_ufunc__",
          "_truncate_by_char_count",
          "ParameterSet",
          "_import_plugin_specs",
          "FixtureManager",
          "tmpdir",
          "__version__",
          "params",
          "TestReport",
          "Parser",
          "TerminalRepr",
          "chain",
          "catching_logs",
          "xfail",
          "addini",
          "getparent",
          "last_failed_paths",
          "frame",
          "ensure_reset_dir",
          "matchnodes",
          "CACHEDIR_TAG_CONTENT",
          "iscoroutinefunction",
          "indent",
          "_folded_skips",
          "DOCTEST_REPORT_CHOICES",
          "listchain",
          "write_sep",
          "getslaveinfoline",
          "FastFilesCompleter",
          "source",
          "_validate_if_using_arg_names",
          "raises",
          "reorder_items_atscope",
          "Metafunc",
          "main",
          "TYPE_CHECKING",
          "resume_global_capture",
          "_report_unserialization_failure",
          "append",
          "chdir",
          "statement",
          "parseconfigure",
          "fixturenames",
          "_runtest_for_main",
          "_is_doctest",
          "Class",
          "type",
          "warning_record_to_str",
          "OutcomeException",
          "message",
          "reset",
          "summary_warnings",
          "_iter_rewritable_modules",
          "readlines",
          "helper",
          "_resolve_arg_value_types",
          "mktemp",
          "SHOW_PYTEST_WARNINGS_ARG",
          "FSCollector",
          "getvalueorskip",
          "_wrapped_pdb_cls",
          "Cache",
          "delitem",
          "explanation_param",
          "get_lock_path",
          "summary_passes",
          "tmp_path_factory",
          "_initrequest",
          "_get_plugin_specs_as_list",
          "_non_printable_ascii_translate_table",
          "NodeMarkers",
          "inline_genitems",
          "_format_args",
          "NFPlugin",
          "failed",
          "getinicfg",
          "CwdSnapshot",
          "UnformattedWarning",
          "import_plugin",
          "__ne__",
          "FDCaptureBinary",
          "makefile",
          "_getconftestmodules",
          "LFPlugin",
          "_approx_scalar",
          "ApproxNumpy",
          "_getini",
          "_mark_plugins_for_rewrite",
          "hookspec",
          "PYC_TAIL",
          "tmp_path",
          "FixtureRequest",
          "capstderr",
          "relline",
          "cls",
          "PYC_EXT",
          "parse_known_args",
          "from_config",
          "CollectError",
          "DEFAULT_LOG_DATE_FORMAT",
          "normalize_mark_list",
          "getfailures",
          "make_numbered_dir",
          "pytest_collectreport",
          "errors",
          "addExpectedFailure",
          "essential_plugins",
          "add_global_property",
          "_match_lines",
          "_remove_ansi_escape_sequences",
          "LogCaptureHandler",
          "_try_load_conftest",
          "_get_override_ini_value",
          "_is_numpy_array",
          "_inject_setup_class_fixture",
          "isset",
          "_is_capturing",
          "Module",
          "exconly",
          "_format_assertmsg",
          "names",
          "PYTEST_CONFIG_GLOBAL",
          "repr_excinfo",
          "_idvalset",
          "find",
          "getlocals",
          "PytestArg",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_attempt_to_close_capture_file",
          "register_cleanup_lock_removal",
          "__take_sys_modules_snapshot",
          "collect",
          "EXIT_INTERNALERROR",
          "importorskip",
          "unary_map",
          "NoCapture",
          "visit_Assert",
          "PytestUnhandledCoroutineWarning",
          "LogCaptureFixture",
          "get_exconly",
          "HelpAction",
          "repr",
          "_addoption",
          "_format_action_invocation",
          "addSuccess",
          "restore",
          "_rewrite_test",
          "parse_setoption",
          "pyobj_property",
          "_test_pytest_function",
          "compat",
          "ishidden",
          "find_prefixed",
          "_cmp_raises_type_error",
          "_setup_cli_logging",
          "SafeRepr",
          "run",
          "MarkDecorator",
          "SetupState",
          "try_cleanup",
          "pytester",
          "add_marker",
          "register_assert_rewrite",
          "_truncate_recursive_traceback",
          "consider_conftest",
          "_handle_skip",
          "_ALLOW_MARKERS",
          "stop",
          "_getindent",
          "showfixtures",
          "_get_direct_parametrize_args",
          "getplugin",
          "funcargs",
          "Exit",
          "read",
          "template",
          "summary_stats",
          "addsection",
          "RUNNER_CLASS",
          "messages",
          "_recursive_list_map",
          "_prepareconfig",
          "_get_flag_lookup",
          "repr_traceback_entry",
          "add_cleanup",
          "_ascii_escaped_by_config",
          "showlocals",
          "_printcollecteditems",
          "LineMatcher",
          "stop_global_capturing",
          "scopeproperty",
          "EXIT_NOTESTSCOLLECTED",
          "pytest_runtest_logfinish",
          "collect_by_name",
          "PytestConfigWarning",
          "_truncate_explanation",
          "PYTESTER_COPY_EXAMPLE",
          "encoding",
          "ensure_newline",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "__init__",
          "pytest_cmdline_main",
          "start_global_capturing",
          "ApproxBase",
          "fillfixtures",
          "ColoredLevelFormatter",
          "exit",
          "read_global_capture",
          "co_equal",
          "_importconftest",
          "_compare_eq_set",
          "_tmppath_factory",
          "teardown",
          "warnings",
          "showlongtestinfo",
          "_validate_usepdb_cls",
          "_getfailureheadline",
          "repr_unicode",
          "_read_pyc",
          "value",
          "getexplanation",
          "find_module",
          "set_trace",
          "write",
          "handler",
          "PyCollector",
          "_show_fixture_action",
          "PyobjMixin",
          "_compare_eq_sequence",
          "repr_args",
          "_ANSI_ESCAPE_SEQ",
          "check_interactive_exception",
          "own_markers",
          "DEFAULT_RELATIVE_TOLERANCE",
          "pytest_cmdline_parse",
          "get_dirs_from_args",
          "_get_allow_unicode_flag",
          "ApproxSequencelike",
          "_node_location_to_relpath",
          "_diff_text",
          "assert_contains",
          "cmdline",
          "istext",
          "_from_json",
          "SubRequest",
          "get_parametrized_fixture_keys",
          "hookimpl",
          "BaseReport",
          "ExceptionRepr",
          "getnode",
          "matchmark",
          "install_importhook",
          "__exit__",
          "pytest_deselected",
          "_split_explanation",
          "fnmatch_lines_random",
          "_consider_importhook",
          "MultipleDoctestFailures",
          "__version_tuple__",
          "runtestprotocol",
          "caplog",
          "pytest_itemstart",
          "Mark",
          "assert_outcomes",
          "ConftestImportFailure",
          "argnames",
          "get_real_func",
          "check_strict_xfail",
          "EXIT_OK",
          "_dump_lines",
          "show_fixtures_per_test",
          "done",
          "ApproxDecimal",
          "pytest_collect_directory",
          "_repr_failure_py",
          "from_current",
          "_setup_fixtures",
          "path",
          "verbosity",
          "errisinstance",
          "get_empty_parameterset_mark",
          "_callhelper",
          "deprecated_call",
          "istestfunction",
          "_matches_prefix_or_glob_option",
          "pytest_report_teststatus",
          "RunResult",
          "listextrakeywords",
          "load_module",
          "isparseable",
          "_checkversion",
          "_resume",
          "for_later",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "consider_module",
          "fixtures",
          "write_line",
          "from_item",
          "_get_runner",
          "matchkeyword",
          "_get_pdb_wrapper_class",
          "when",
          "tbfilter",
          "CaptureFixture",
          "consider_pluginarg",
          "getcfg",
          "_get_continue_on_failure",
          "is_generator",
          "append_skipped",
          "delattr",
          "getitems",
          "RN",
          "funcargnames",
          "_translate_non_printable",
          "scopemismatch",
          "_splitnode",
          "invalidraise",
          "funcnamefilter",
          "syspath_prepend",
          "EMPTY_BUFFER",
          "_reprcompare",
          "MODULE_NOT_FOUND_ERROR",
          "readline",
          "repr_traceback",
          "exists",
          "pytest_pycollect_makemodule",
          "raiseerror",
          "_add_simple",
          "__test__",
          "defaultfuncargprefixmarker",
          "visit_Name",
          "pytest_report_from_serializable",
          "truncate_locals",
          "nextitem",
          "update_testcase_duration",
          "notify_exception",
          "_strtobool",
          "formatrepr",
          "_compare_eq_dict",
          "get_actual_log_level",
          "pytest_collectstart",
          "setuponly",
          "Item",
          "_striptext",
          "_PY_DIR",
          "is_globally_capturing",
          "ReprFailDoctest",
          "tmpdir_factory",
          "_warn_incompatibility_with_xunit2",
          "_getautousenames",
          "StepwisePlugin",
          "freeze_includes",
          "kwargs",
          "CollectReport",
          "listnames",
          "FIXTURE_FUNCTION_CALL",
          "_result",
          "pytest_enter_pdb",
          "_pyfuncitem",
          "name",
          "junitxml",
          "_is_unittest_unexpected_success_a_failure",
          "getrawcode",
          "_teardown_yield_fixture",
          "rewrite",
          "MyOptionParser",
          "_LiveLoggingStreamHandler",
          "list",
          "applymarker",
          "_some_str",
          "_mk_tmp",
          "FunctionMixin",
          "version",
          "_factorytraceback",
          "UnitTestCase",
          "create_terminal_writer",
          "fnmatch_lines",
          "hasplugin",
          "scope",
          "SEP",
          "re_match_lines",
          "runner",
          "_basetemp",
          "append_collect_error",
          "is_capturing",
          "LOCK_TIMEOUT",
          "tolerance",
          "assign",
          "style",
          "_do_configure",
          "showhelp",
          "_create_formatter",
          "_getcrashline",
          "snap",
          "TempdirFactory",
          "PytestCollectionWarning",
          "__nonzero__",
          "skip",
          "_preparse",
          "make_properties_node",
          "hasnew",
          "istrue",
          "get",
          "resume_capturing",
          "__delitem__",
          "entrysep",
          "section",
          "get_fslocation_from_item",
          "alias",
          "_match_lines_random",
          "ReprTraceback",
          "deindent",
          "inline_run",
          "bin_xml_escape",
          "_schedule_finalizers",
          "_bestrelpath_cache",
          "is_true",
          "hasopt",
          "make_numbered_dir_with_cleanup",
          "pytest_collection",
          "EncodedFile",
          "MARK_GEN",
          "unittest",
          "Argument",
          "hasinit",
          "getfixtureinfo",
          "FormattedExcinfo",
          "get_terminal_writer",
          "maketxtfile",
          "resolve",
          "out",
          "on_rm_rf_error",
          "raise_on_kwargs",
          "capture_fixtures",
          "addinivalue_line",
          "TestCaseFunction",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_write_progress_information_filling_space",
          "ReprTracebackNative",
          "_saferepr",
          "PytestDeprecationWarning",
          "BASE_TYPE",
          "_getparser",
          "_PytestWrapper",
          "_showfixtures_main",
          "PdbTrace",
          "pop",
          "set_session",
          "get_option_ini",
          "scopenum_function",
          "RAISES_MESSAGE_PARAMETER",
          "_opentestcase",
          "line",
          "_call_reprcompare",
          "register",
          "recwarn",
          "AssertionRewritingHook",
          "istestfunc",
          "popcall",
          "_ensure_supporting_files",
          "getdecoded",
          "_getlines",
          "FuncargnamesCompatAttr",
          "N",
          "mark",
          "DummyRewriteHook",
          "pytest_report_to_serializable",
          "show_test_item",
          "execute",
          "_check_type",
          "write_fspath_result",
          "REPORT_COLLECTING_RESOLUTION",
          "capture",
          "_force_symlink",
          "undo",
          "config",
          "_exec_lsof",
          "mkpydir",
          "ReprExceptionInfo",
          "get_location",
          "__eq__",
          "_to_json",
          "push_format_context",
          "suspend_global_capture",
          "_fix_spoof_python2",
          "obj",
          "IGNORE_PAM",
          "ensure_deletable",
          "ExceptionInfo",
          "_fix_unittest_skip_decorator",
          "_matchfactories",
          "stopTest",
          "get_source",
          "popen",
          "Notset",
          "fail",
          "RemovedInPytest4Warning",
          "debugging",
          "PY35",
          "TempPathFactory",
          "_determine_show_progress_info",
          "capfd",
          "_repr_style",
          "_get_increasing_order",
          "families",
          "_traceback",
          "record_property",
          "getmodulecol",
          "_check_initialpaths_for_relpath",
          "visit_BinOp",
          "_write_pyc",
          "safe_isclass",
          "__len__",
          "isclass",
          "append_pass",
          "SysCaptureBinary",
          "attrs",
          "_pluginmanager",
          "getrepr",
          "runpytest",
          "setenv",
          "pytest_make_collect_report",
          "__setitem__",
          "__enter__",
          "set_level",
          "_patch_unwrap_mock_aware",
          "ReprEntryNative",
          "record_tuples",
          "store_mark",
          "_runtest_for",
          "_format_lines",
          "_check_record_param_type",
          "filter",
          "NOTSET",
          "addUnexpectedSuccess",
          "Interrupted",
          "__iter__",
          "cleanup_candidates",
          "visit_Call_legacy",
          "LoggingPlugin",
          "write_docstring",
          "isiterable",
          "_in_venv",
          "visit_UnaryOp",
          "PytestPluginManager",
          "ParsedCall",
          "python_keywords_allowed_list",
          "startTest",
          "visit_Starred",
          "MultiCapture",
          "ReprFuncArgs",
          "pytestconfig",
          "merge_family",
          "__str__",
          "set_repr_style",
          "append_failure",
          "LineComp",
          "readouterr",
          "parse_hookspec_opts",
          "get_data",
          "pytest_configure",
          "_import_pdb_cls",
          "pytest_runtest_makereport",
          "display",
          "getfirstlinesource",
          "parse_args",
          "monkeypatch",
          "EXIT_USAGEERROR",
          "ecu",
          "DEFAULT_MAX_CHARS",
          "assertoutcome",
          "_is_mocked",
          "fileno",
          "_legal_xml_re",
          "_checkargnotcontained",
          "parse_hookimpl_opts",
          "start_capturing",
          "_getconftest_pathlist",
          "_rget_with_confmod",
          "pytest_generate_tests",
          "update",
          "NodeKeywords",
          "create_cleanup_lock",
          "summary_errors",
          "variable",
          "_outrep_summary",
          "_enter_pdb",
          "pytest_report_collectionfinish",
          "fspath",
          "FILE_OR_DIR",
          "_importtestmodule",
          "consider_preparse",
          "FixtureDef",
          "TerminalReporter",
          "_plugin_nameversions",
          "longreprtext",
          "FunctionDefinition",
          "PseudoFixtureDef",
          "capsysbinary",
          "pastebin",
          "runpython",
          "_iter_all_modules",
          "DoctestItem",
          "visit_Call_35",
          "writelines",
          "_finalize",
          "getvalue",
          "resume",
          "EXIT_INTERRUPTED",
          "ArgumentError",
          "getfixturemarker",
          "_call_with_optional_argument",
          "parse_known_and_unknown_args",
          "exec_",
          "KeywordMapping",
          "Entry",
          "record_testreport",
          "fnmatch_ex",
          "cwd_relative_nodeid",
          "extract_suffixes",
          "TimeoutExpired",
          "MonkeyPatch",
          "match",
          "_set_initial_conftests",
          "setmulti2",
          "_collect",
          "_io",
          "cacheprovider",
          "from_call",
          "_format_final_exc_line",
          "write_captured_output",
          "get_common_ancestor",
          "getfuncargvalue",
          "PytestCacheWarning",
          "get_user",
          "record_xml_attribute",
          "pop_format_context",
          "CLOSE_STDIN",
          "error",
          "pathlib",
          "skipped",
          "_addfinalizer",
          "ExceptionChainRepr",
          "directory_arg",
          "runpytest_subprocess",
          "CallSpec2",
          "log_outcome",
          "pytest_addoption",
          "PY36",
          "safeformat",
          "nose",
          "copy",
          "_parsearg",
          "pytest_ignore_collect",
          "Session",
          "pytest_pycollect_makeitem",
          "prune_dependency_tree",
          "_PY2",
          "cache",
          "Code",
          "Junit",
          "session",
          "check_testcase_implements_trial_reporter",
          "module",
          "assert_contains_lines",
          "generic_visit",
          "derive_importpath",
          "perform_collect",
          "setup",
          "annotated_getattr",
          "get_plugin_manager",
          "ApproxMapping",
          "_PYTEST_DIR",
          "__array_priority__",
          "EXIT_TESTSFAILED",
          "wrap_function_to_error_out_if_called_directly",
          "get_config",
          "_setup_collect_fakemodule",
          "__call__",
          "instance",
          "get_optionflags",
          "pytest_doctest_prepare_content",
          "visit_BoolOp",
          "simple",
          "getfixtureclosure",
          "skipping",
          "getreportopt",
          "_getcapture",
          "write_log_entry",
          "Collector",
          "add_funcarg_pseudo_fixture_def",
          "_state",
          "isdatacls",
          "doctest_namespace",
          "ApproxScalar",
          "cacheshow",
          "_get_line_with_reprcrash_message",
          "resolve_from_str",
          "WarningReport",
          "summary_failures",
          "__getattr__",
          "call_and_report",
          "showfspath",
          "_install_capture_fixture_on_item",
          "abspath",
          "RaisesContext",
          "_initini",
          "stepwise",
          "_makefile",
          "toterminal",
          "_getvaluepath",
          "warns",
          "SysModulesSnapshot",
          "teardown_all",
          "get_real_method",
          "pytest_logwarning",
          "DropShorterLongHelpFormatter",
          "LOGLEVEL_COLOROPTS",
          "_parse_parametrize_args",
          "listoutcomes",
          "exprinfo",
          "text",
          "DoctestModule",
          "XFailed",
          "category",
          "_inject_setup_method_fixture",
          "PytestExperimentalApiWarning",
          "FixtureLookupError",
          "pytest_runtest_logstart",
          "keywords",
          "assertrepr_compare",
          "scopes",
          "deselect_by_keyword",
          "_compare_eq_iterable",
          "_show_fixtures_per_test"
        ]
      },
      "response": {
        "keywords": [
          "create_new_paste",
          "pastebin"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-17T22:37:47.345093",
        "usage": "149.26981925964355 ms"
      },
      "request": {
        "tokens": [
          "create_new_paste",
          "pastebin"
        ]
      },
      "response": {
        "results": {
          "pastebin": [
            "src/_pytest/terminal.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "create_new_paste": [
            "src/_pytest/pastebin.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-17T22:37:47.494373",
        "usage": "4618.257999420166 ms"
      },
      "request": {
        "keyword_search_results": {
          "pastebin": [
            "src/_pytest/terminal.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/pastebin.py"
          ],
          "create_new_paste": [
            "src/_pytest/pastebin.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "To address the issue, we want to look into files related to the `pastebin` option feature, specifically focusing on how data is handled and sent to `bpaste.net`. The core of the problem seems to be related to the lexer parameter being set to `python3`, causing HTTP 400 errors.\n\n- The search results return the files associated with the keyword `pastebin`. The most likely relevant file for handling the `--pastebin` command would be `src/_pytest/pastebin.py` as it specifically mentions pastebin functionality in its name, indicating that it likely contains code relevant to how data is prepared and pushed to the pastebin service.\n- The presence of `create_new_paste` in `src/_pytest/pastebin.py` further suggests that this file handles creating new pastes, implying it also deals with the settings or parameters being sent, such as `lexer=python3`.\n\nOther files listed under `pastebin` are `src/_pytest/terminal.py` and `src/_pytest/config/__init__.py`, but these seem less likely to directly handle API requests and lexers for pastebin functionality. They might include terminal output configuration or entry points for pastebin settings but are secondary to `src/_pytest/pastebin.py`.\n\nI conclude that `src/_pytest/pastebin.py` is the crucial file to examine first.",
        "file_paths": [
          "src/_pytest/pastebin.py",
          "src/_pytest/terminal.py",
          "src/_pytest/config/__init__.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:52.112658",
        "usage": "4755.933046340942 ms"
      },
      "request": {
        "file_path": "src/_pytest/pastebin.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue**:\n   - The issue is that the `--pastebin` feature in `pytest` causes an HTTP Error 400 when submitting to `bpaste.net` due to using `lexer=python3` for some content.\n   - It is suggested that changing the `lexer` to `text` resolves the problem, as the console output is arbitrary text and not Python code.\n\n2. **Analyze the provided file (`src/_pytest/pastebin.py`)**:\n   - The `create_new_paste()` function is responsible for creating a new paste on `bpaste.net`.\n   - This function sets the `lexer` parameter to `python3` when uploading the paste if the Python version is 3 or higher (`\"lexer\": \"python3\" if sys.version_info[0] >=3 else \"python\"`).\n   - This is the line identified in the issue description causing the problem.\n   - Changing the lexer conditionally based on content type to `text` would likely resolve the issue.\n\n3. **Evaluate Relevance**: \n   - The file directly contains the logic that causes the issue (`create_new_paste` function) and hence is very relevant.\n\n4. **Possible Solution Suggestions**:\n   - Modify or add conditions in `create_new_paste` to change the `lexer` to `text` instead of `python3` when the contents are not Python code (based on user feedback and example scenarios).\n\n5. **Conclusion**:\n   - The `create_new_paste` function is the root cause since it directly handles the request setup, including the problematic `lexer` setting.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "create_new_paste"
        ],
        "root_cause_symbols": [
          "create_new_paste"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:37:56.868623",
        "usage": "6223.160982131958 ms"
      },
      "request": {
        "file_path": "src/_pytest/terminal.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n\n1.1 What issue is the user describing?\n- The issue is that the `--pastebin` feature in pytest when using the lexer `python3` results in HTTP 400 errors for some content submitted to bpaste.net.\n\n1.2 User give a reproduce steps?, if yes, think why this steps cause the issue.\n- The user provided a reproduction step that mimics submitting data to bpaste.net using urllib, which results in an HTTPError indicating a 'Bad Request'.\n\n1.3 How was this issue caused?\n- The issue is likely caused by the submission of data with the lexer set to `python3`, which might not be compatible with certain outputs that aren't valid Python code, leading to an HTTP 400 error.\n\n1.4 Summary the user expectation and why cause the issue.\n- The user expects the `--pastebin` feature to work without errors. The error occurs because the `python3` lexer is being used for arbitrary text outputs that may not conform to Python syntax.\n\n1.6 Some possible solutions to the issue.\n- Change the lexer from `python3` to `text` to ensure all text can be processed without being interpreted as Python code to avoid the HTTP error.\n\n2. Make file evaluation:\n\nAfter reviewing the content of `src/_pytest/terminal.py`, it seems that the file content is related to terminal reporting and the configuration of pytest options. However, it doesn't seem directly related to the handling of the `--pastebin` logic or any HTTP requests. Instead, this functionality is expected to be part of the actual pastebin handling logic, likely in a different file related to network communication or the `--pastebin` feature implementation.\n\nThe current file details terminal reporting, verbosity levels, and configuration hooks, but does not describe network operations or content submission, suggesting that it is not directly the root cause for the `--pastebin` issue.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pastebin.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:03.091801",
        "usage": "4336.1217975616455 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions:\n1.1 The user is describing an issue with the `--pastebin` functionality in pytest, specifically that the use of `lexer=python3` when submitting results to `bpaste.net` can sometimes result in an HTTP 400 Bad Request error.\n1.2 The example provided suggests that submitting data to `bpaste.net` can result in an error unless the `lexer` parameter is changed.\n1.3 This issue is caused because the console output of pytest is not strictly valid Python code, and using the `python3` lexer might not handle all cases of console output correctly, leading to upload issues.\n1.4 The user's expectation is that output should be uploaded to bpaste.net without causing an error. The underlying problem is the mismatch between the actual console output (which is arbitrary text) and the lexer being used.\n1.5 A potential solution is to change the lexer to 'text', which would accommodate diverse outputs without assuming it is Python code. This approach seems to resolve the error.\n\n2. Evaluating File:\n2.1 The file `src/_pytest/config/__init__.py` is being evaluated, which appears to be responsible for configuration including plugin management.\n2.2 Since this file deals with configuring pytest and its plugins, it does not directly relate to the immediate issue, which concerns the handling of the `pastebin` functionality within the pytest codebase.\n2.3 Therefore, the specific issue with the lexer on bpaste.net seems to occur elsewhere, likely within the actual implementation of the `pastebin` plugin or functionality.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/pastebin.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-17T22:38:07.427944",
        "usage": "64.93210792541504 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/pastebin.py",
            "relevant_symbol_keys": [
              "create_new_paste"
            ],
            "root_cause_symbol_keys": [
              "create_new_paste"
            ]
          },
          {
            "file_path": "src/_pytest/terminal.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.pastebin.create_new_paste",
            "file_path": "src/_pytest/pastebin.py",
            "file_content": "def create_new_paste(contents):\n    \"\"\"\n    Creates a new paste using bpaste.net service.\n\n    :contents: paste contents as utf-8 encoded bytes\n    :returns: url to the pasted contents\n    \"\"\"\n    import re\n\n    if sys.version_info < (3, 0):\n        from urllib import urlopen, urlencode\n    else:\n        from urllib.request import urlopen\n        from urllib.parse import urlencode\n\n    params = {\n        \"code\": contents,\n        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n        \"expiry\": \"1week\",\n    }\n    url = \"https://bpaste.net\"\n    response = urlopen(url, data=urlencode(params).encode(\"ascii\")).read()\n    m = re.search(r'href=\"/raw/(\\w+)\"', response.decode(\"utf-8\"))\n    if m:\n        return \"%s/show/%s\" % (url, m.group(1))\n    else:\n        return \"bad response: \" + response",
            "start_line": 64,
            "start_column": 2040,
            "end_line": 0,
            "end_column": 2851,
            "start_byte": 2040,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-17T22:38:07.492882",
        "usage": "6987.104892730713 ms"
      },
      "request": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.pastebin.create_new_paste",
            "file_path": "src/_pytest/pastebin.py",
            "file_content": "def create_new_paste(contents):\n    \"\"\"\n    Creates a new paste using bpaste.net service.\n\n    :contents: paste contents as utf-8 encoded bytes\n    :returns: url to the pasted contents\n    \"\"\"\n    import re\n\n    if sys.version_info < (3, 0):\n        from urllib import urlopen, urlencode\n    else:\n        from urllib.request import urlopen\n        from urllib.parse import urlencode\n\n    params = {\n        \"code\": contents,\n        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n        \"expiry\": \"1week\",\n    }\n    url = \"https://bpaste.net\"\n    response = urlopen(url, data=urlencode(params).encode(\"ascii\")).read()\n    m = re.search(r'href=\"/raw/(\\w+)\"', response.decode(\"utf-8\"))\n    if m:\n        return \"%s/show/%s\" % (url, m.group(1))\n    else:\n        return \"bad response: \" + response",
            "start_line": 64,
            "start_column": 2040,
            "end_line": 0,
            "end_column": 2851,
            "start_byte": 2040,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is experiencing HTTP 400 Bad Request errors when using the `--pastebin` option in pytest, specifically when the output is submitted to bpaste.net with the lexer set to `python3`.\n\n1.2 How was this issue caused?\n- The issue is caused by the inappropriate usage of `lexer='python3'` for the content being pasted, which is not strictly Python code but arbitrary text, leading to a rejection (400 error) from bpaste.net.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result is that pasting should succeed without errors, meaning the lexer should either accommodate arbitrary text or be set to `text` instead of `python3`.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- The expectation is to avoid HTTP 400 errors by using a more suitable lexer setting for the given content.\n\n1.5 How should the issue be fixed to meet the expectation?\n- Change the \"lexer\" value from \"python3\" to \"text\" in the parameters being passed to the pastebin service.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each line in the <symbol> and <symbol> tags.\n2.2. The symbol provided is `create_new_paste`, which constructs a dictionary `params` containing the key `lexer` set to `python3` when Python 3 is detected.\n2.3. The key line is `\"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\"`, determining the lexer based on the Python version, causing issues as described.\n2.4. The current lexer setting does not align with the non-Python-only content expectation, making it the root cause of the problem.\n\n2.5. One symbol needs changing to resolve the issue: `create_new_paste` in file `src/_pytest/pastebin.py`, specifically changing the lexer assignment to `\"text\"`.",
        "symbols": [
          {
            "name": "_pytest.pastebin.create_new_paste",
            "file_path": "src/_pytest/pastebin.py",
            "reason": "The lexer for the pastebin needs to be changed from \"python3\" to \"text\" to prevent HTTP 400 errors when the pasted content is not strictly Python code."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "create_new_paste function uses the lexer set to 'python3' in params, which aligns with the issue reported as causing HTTP 400 errors. To resolve this, the lexer should be changed to 'text' to correctly handle non-Python arbitrary text content consistently without errors."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-17T22:38:14.480000",
        "usage": "0.5440711975097656 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [],
          "root_caused_symbols": [
            {
              "name": "_pytest.pastebin.create_new_paste",
              "file_path": "src/_pytest/pastebin.py",
              "file_content": "def create_new_paste(contents):\n    \"\"\"\n    Creates a new paste using bpaste.net service.\n\n    :contents: paste contents as utf-8 encoded bytes\n    :returns: url to the pasted contents\n    \"\"\"\n    import re\n\n    if sys.version_info < (3, 0):\n        from urllib import urlopen, urlencode\n    else:\n        from urllib.request import urlopen\n        from urllib.parse import urlencode\n\n    params = {\n        \"code\": contents,\n        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n        \"expiry\": \"1week\",\n    }\n    url = \"https://bpaste.net\"\n    response = urlopen(url, data=urlencode(params).encode(\"ascii\")).read()\n    m = re.search(r'href=\"/raw/(\\w+)\"', response.decode(\"utf-8\"))\n    if m:\n        return \"%s/show/%s\" % (url, m.group(1))\n    else:\n        return \"bad response: \" + response",
              "start_line": 64,
              "start_column": 2040,
              "end_line": 0,
              "end_column": 2851,
              "start_byte": 2040,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 What issue is the user describing?\n- The user is experiencing HTTP 400 Bad Request errors when using the `--pastebin` option in pytest, specifically when the output is submitted to bpaste.net with the lexer set to `python3`.\n\n1.2 How was this issue caused?\n- The issue is caused by the inappropriate usage of `lexer='python3'` for the content being pasted, which is not strictly Python code but arbitrary text, leading to a rejection (400 error) from bpaste.net.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result is that pasting should succeed without errors, meaning the lexer should either accommodate arbitrary text or be set to `text` instead of `python3`.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- The expectation is to avoid HTTP 400 errors by using a more suitable lexer setting for the given content.\n\n1.5 How should the issue be fixed to meet the expectation?\n- Change the \"lexer\" value from \"python3\" to \"text\" in the parameters being passed to the pastebin service.\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each line in the <symbol> and <symbol> tags.\n2.2. The symbol provided is `create_new_paste`, which constructs a dictionary `params` containing the key `lexer` set to `python3` when Python 3 is detected.\n2.3. The key line is `\"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\"`, determining the lexer based on the Python version, causing issues as described.\n2.4. The current lexer setting does not align with the non-Python-only content expectation, making it the root cause of the problem.\n\n2.5. One symbol needs changing to resolve the issue: `create_new_paste` in file `src/_pytest/pastebin.py`, specifically changing the lexer assignment to `\"text\"`.",
          "symbols": [
            {
              "name": "_pytest.pastebin.create_new_paste",
              "file_path": "src/_pytest/pastebin.py",
              "reason": "The lexer for the pastebin needs to be changed from \"python3\" to \"text\" to prevent HTTP 400 errors when the pasted content is not strictly Python code."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "create_new_paste function uses the lexer set to 'python3' in params, which aligns with the issue reported as causing HTTP 400 errors. To resolve this, the lexer should be changed to 'text' to correctly handle non-Python arbitrary text content consistently without errors."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/pastebin.py"
        ],
        "symbols": [
          "_pytest.pastebin.create_new_paste"
        ],
        "code_spans": {
          "_pytest.pastebin.create_new_paste": {
            "name": "_pytest.pastebin.create_new_paste",
            "file_path": "src/_pytest/pastebin.py",
            "file_content": "def create_new_paste(contents):\n    \"\"\"\n    Creates a new paste using bpaste.net service.\n\n    :contents: paste contents as utf-8 encoded bytes\n    :returns: url to the pasted contents\n    \"\"\"\n    import re\n\n    if sys.version_info < (3, 0):\n        from urllib import urlopen, urlencode\n    else:\n        from urllib.request import urlopen\n        from urllib.parse import urlencode\n\n    params = {\n        \"code\": contents,\n        \"lexer\": \"python3\" if sys.version_info[0] >= 3 else \"python\",\n        \"expiry\": \"1week\",\n    }\n    url = \"https://bpaste.net\"\n    response = urlopen(url, data=urlencode(params).encode(\"ascii\")).read()\n    m = re.search(r'href=\"/raw/(\\w+)\"', response.decode(\"utf-8\"))\n    if m:\n        return \"%s/show/%s\" % (url, m.group(1))\n    else:\n        return \"bad response: \" + response",
            "start_line": 64,
            "start_column": 2040,
            "end_line": 0,
            "end_column": 2851,
            "start_byte": 2040,
            "end_byte": 0
          }
        }
      }
    }
  ]
}