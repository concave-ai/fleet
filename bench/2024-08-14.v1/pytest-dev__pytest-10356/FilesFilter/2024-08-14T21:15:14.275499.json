{
  "name": "FilesFilter",
  "model": "gpt-4o-2024-08-06",
  "issue": "<description>:Consider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nConsider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nFix missing marks when inheritance from multiple classes\n\r\n<!--\r\nThanks for submitting a PR, your contribution is really appreciated!\r\n\r\nHere is a quick checklist that should be present in PRs.\r\n\r\n- [] Include documentation when adding new features.\r\n- [ ] Include new tests or update existing tests when applicable.\r\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\r\n\r\nIf this change fixes an issue, please:\r\n\r\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\r\n\r\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\r\n\r\n- [x] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\r\n\r\n  Write sentences in the **past or present tense**, examples:\r\n\r\n  * *Improved verbose diff output with sequences.*\r\n  * *Terminal summary statistics now use multiple colors.*\r\n\r\n  Also make sure to end the sentence with a `.`.\r\n\r\n- [x] Add yourself to `AUTHORS` in alphabetical order.\r\n-->\r\n\n\n<hints>:ronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \nronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \n@bluetech \r\n\r\nit deals with\r\n```text\r\nIn [1]: import pytest\r\n\r\nIn [2]: @pytest.mark.a\r\n   ...: class A:\r\n   ...:     pass\r\n   ...: \r\n\r\nIn [3]: @pytest.mark.b\r\n   ...: class B: pass\r\n\r\nIn [6]: @pytest.mark.c\r\n   ...: class C(A,B): pass\r\n\r\nIn [7]: C.pytestmark\r\nOut[7]: [Mark(name='a', args=(), kwargs={}), Mark(name='c', args=(), kwargs={})]\r\n\r\n```\r\n(b is missing)\nRight, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\n> Right, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\r\n\r\n@bluetech \r\nThe solution I want to implement is: \r\n* Go through the items list. \r\n* For each item, I go through the list of classes from which he inherits. The same logic I do for each class until I found the object class.\r\n* I am updating the list of marks only if the mark does not exist in the current list.\r\n \r\nThe existing code is incorrect, and I will now update it to work according to the logic I wrote here\n@RonnyPfannschmidt \r\nThe PR is not ready for review.\r\nI trying to fix all the tests and after that, I'll improve the logic.\n@RonnyPfannschmidt \r\nOnce the PR is approved I'll create one commit with description \n@RonnyPfannschmidt \r\nYou can review the PR.</hints></description>",
  "request": {
    "keyword_search_results": {
      "pytest": [
        "src/pytest/__main__.py",
        "src/_pytest/monkeypatch.py",
        "src/_pytest/pytester_assertions.py",
        "src/_pytest/assertion/rewrite.py",
        "src/_pytest/faulthandler.py",
        "src/_pytest/config/argparsing.py",
        "src/_pytest/doctest.py",
        "src/_pytest/legacypath.py",
        "src/_pytest/stash.py",
        "src/_pytest/stepwise.py",
        "src/_pytest/warning_types.py",
        "src/_pytest/freeze_support.py",
        "src/_pytest/mark/__init__.py",
        "src/_pytest/runner.py",
        "src/_pytest/junitxml.py",
        "src/_pytest/config/exceptions.py",
        "src/_pytest/compat.py",
        "src/_pytest/fixtures.py",
        "src/_pytest/assertion/util.py",
        "src/_pytest/python_path.py",
        "src/_pytest/deprecated.py",
        "src/_pytest/threadexception.py",
        "src/_pytest/helpconfig.py",
        "src/_pytest/config/findpaths.py",
        "src/_pytest/cacheprovider.py",
        "src/_pytest/_code/code.py",
        "src/_pytest/setupplan.py",
        "src/_pytest/mark/expression.py",
        "src/_pytest/tmpdir.py",
        "src/_pytest/assertion/__init__.py",
        "src/_pytest/pastebin.py",
        "src/_pytest/unraisableexception.py",
        "src/_pytest/logging.py",
        "src/_pytest/unittest.py",
        "src/_pytest/debugging.py",
        "src/pytest/__init__.py",
        "src/_pytest/setuponly.py",
        "src/_pytest/recwarn.py",
        "src/_pytest/python.py",
        "src/_pytest/pathlib.py",
        "src/_pytest/hookspec.py",
        "src/_pytest/config/__init__.py",
        "src/_pytest/reports.py",
        "src/_pytest/mark/structures.py",
        "src/_pytest/nodes.py",
        "src/_pytest/main.py",
        "src/_pytest/timing.py",
        "src/_pytest/skipping.py",
        "src/_pytest/scope.py",
        "src/_pytest/python_api.py",
        "src/_pytest/outcomes.py",
        "src/_pytest/capture.py",
        "src/_pytest/pytester.py",
        "src/_pytest/terminal.py",
        "src/_pytest/warnings.py"
      ],
      "markers": [
        "src/_pytest/skipping.py",
        "src/_pytest/deprecated.py",
        "src/_pytest/warnings.py",
        "src/_pytest/helpconfig.py",
        "src/_pytest/python.py",
        "src/_pytest/hookspec.py",
        "src/_pytest/pytester.py",
        "src/_pytest/_code/code.py",
        "src/_pytest/config/__init__.py",
        "src/_pytest/reports.py",
        "src/_pytest/mark/structures.py",
        "src/_pytest/nodes.py",
        "src/_pytest/main.py",
        "src/_pytest/warning_types.py",
        "src/_pytest/fixtures.py",
        "src/_pytest/mark/__init__.py"
      ],
      "attribute": [
        "src/_pytest/unraisableexception.py",
        "src/_pytest/assertion/util.py",
        "src/_pytest/monkeypatch.py",
        "src/_pytest/fixtures.py",
        "src/_pytest/doctest.py",
        "src/_pytest/outcomes.py",
        "src/pytest/__init__.py",
        "src/_pytest/threadexception.py",
        "src/_pytest/python.py",
        "src/_pytest/hookspec.py",
        "src/_pytest/_argcomplete.py",
        "src/_pytest/terminal.py",
        "src/_pytest/config/__init__.py",
        "src/_pytest/config/argparsing.py",
        "src/_pytest/mark/structures.py",
        "src/_pytest/nodes.py",
        "src/_pytest/compat.py",
        "src/_pytest/mark/__init__.py"
      ],
      "pytestmark": [
        "src/_pytest/mark/structures.py",
        "src/_pytest/terminal.py",
        "src/_pytest/config/__init__.py"
      ],
      "metaclass": [
        "src/_pytest/nodes.py"
      ],
      "MRO": [
        "src/_pytest/compat.py",
        "src/_pytest/python.py"
      ]
    }
  },
  "response": {
    "scratch_pad": "The issue is about merging pytest markers from base classes when using multiple inheritance. The metaclass in the provided code snippet addresses this problem by constructing the `pytestmark` attribute to include markers from all base classes according to the method resolution order (MRO).\n\nNow, let's go through the keywords and related files:\n\n1. **pytest**: The issue is related to pytest markers, so files containing core pytest functionality might be relevant, especially those related to test collection and execution.\n\n2. **markers**: Specifically relates to the issue as it involves merging marker values from multiple base classes.\n\n3. **attribute**: This term is relevant because `pytestmark` is an attribute that holds markers in pytest test classes.\n\n4. **pytestmark**: A very relevant keyword since the issue directly involves ensuring multiple markers (`pytestmark`) from different base classes are handled correctly.\n\n5. **metaclass**: The issue includes an implementation using a metaclass to workaround the problem, so files where metaclasses are defined or utilized might have related logic.\n\n6. **MRO**: Crucial because the problem revolves around the method resolution order and how markers from base classes are combined.\n\n### Selected Files:\n1. **src/_pytest/mark/structures.py**: Contains code related to markers, and `pytestmark` is a key element in the issue at hand.\n2. **src/_pytest/mark/__init__.py**: Likely involves initialization or configuration related to marks, it might contain logic acquiring marks.\n3. **src/_pytest/python.py**: Includes `MRO` keyword, which is crucial to address the marker merging issue.\n4. **src/_pytest/compat.py**: Another file mentioning MRO, this could provide support functions or utilities related to compatibility which may affect the marker merging logic.\n5. **src/_pytest/nodes.py**: Mentions `metaclass`, and since the proposed solution employs a metaclass structure, this may be related.\n6. **src/_pytest/config/__init__.py**: Mentions `pytestmark` indicating some configuration or default setups related to markers might be loaded from this file.\n\nThese selected files are sorted by their apparent relevance to understanding and potentially resolving the reported issue.",
    "file_paths": [
      "src/_pytest/mark/structures.py",
      "src/_pytest/mark/__init__.py",
      "src/_pytest/python.py",
      "src/_pytest/compat.py",
      "src/_pytest/nodes.py",
      "src/_pytest/config/__init__.py"
    ]
  },
  "messages": [
    {
      "role": "system",
      "content": "You are an autonomous AI assistant tasked with finding relevant code in an existing codebase based on a reported issue. \nYour task is to find the relative files in the keyword_search_results.\n\n# What You Get:\n\n* <issue>: Has the problem report.\n* <keyword_search_results>: search results for keywords, and their matching files.\n\n# What You Do:\n\n1. Read the Problem:\nCarefully read the reported issue within the <issue> tag.\n\n2. Look at Keyword Search Results:\n2.1. Think about each keyword and its matching files in the <keyword_search_results> tag.\n2.2. Consider if these files are related to the reported problem.\n2.3. Be aware that some unrelated files and keywords may also be in the keyword_search_results. Carefully check each one.\n2.4. The issues will not be complex, meaning the related files and content will not be extensive.  \n\n3. Answer Using the Function:\ngive some file paths that you think are related to the problem report. Sort them by how relevant you think they are.\nlimit the number of files to 6 or less.\n\n\nThink step by step and write down your thoughts in the scratch_pad field.\n"
    },
    {
      "role": "user",
      "content": "<issue><description>:Consider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nConsider MRO when obtaining marks for classes\nWhen using pytest markers in two baseclasses `Foo` and `Bar`, inheriting from both of those baseclasses will lose the markers of one of those classes. This behavior is present in pytest 3-6, and I think it may as well have been intended. I am still filing it as a bug because I am not sure if this edge case was ever explicitly considered.\r\n\r\nIf it is widely understood that all markers are part of a single attribute, I guess you could say that this is just expected behavior as per MRO. However, I'd argue that it would be more intuitive to attempt to merge marker values into one, possibly deduplicating marker names by MRO.\r\n\r\n```python\r\nimport itertools\r\nimport pytest\r\n\r\nclass BaseMeta(type):\r\n    @property\r\n    def pytestmark(self):\r\n        return (\r\n            getattr(self, \"_pytestmark\", []) +\r\n            list(itertools.chain.from_iterable(getattr(x, \"_pytestmark\", []) for x in self.__mro__))\r\n        )\r\n\r\n    @pytestmark.setter\r\n    def pytestmark(self, value):\r\n        self._pytestmark = value\r\n\r\n\r\nclass Base(object):\r\n    # Without this metaclass, foo and bar markers override each other, and test_dings\r\n    # will only have one marker\r\n    # With the metaclass, test_dings will have both\r\n    __metaclass__ = BaseMeta\r\n\r\n@pytest.mark.foo\r\nclass Foo(Base):\r\n    pass\r\n\r\n\r\n@pytest.mark.bar\r\nclass Bar(Base):\r\n    pass\r\n\r\nclass TestDings(Foo, Bar):\r\n    def test_dings(self):\r\n        # This test should have both markers, foo and bar.\r\n        # In practice markers are resolved using MRO (so foo wins), unless the\r\n        # metaclass is applied\r\n        pass\r\n```\r\n\r\nI'd expect `foo` and `bar` to be markers for `test_dings`, but this only actually is the case with this metaclass.\r\n\r\nPlease note that the repro case is Python 2/3 compatible excluding how metaclasses are added to `Base` (this needs to be taken care of to repro this issue on pytest 6)\nFix missing marks when inheritance from multiple classes\n\r\n<!--\r\nThanks for submitting a PR, your contribution is really appreciated!\r\n\r\nHere is a quick checklist that should be present in PRs.\r\n\r\n- [] Include documentation when adding new features.\r\n- [ ] Include new tests or update existing tests when applicable.\r\n- [X] Allow maintainers to push and squash when merging my commits. Please uncheck this if you prefer to squash the commits yourself.\r\n\r\nIf this change fixes an issue, please:\r\n\r\n- [x] Add text like ``closes #XYZW`` to the PR description and/or commits (where ``XYZW`` is the issue number). See the [github docs](https://help.github.com/en/github/managing-your-work-on-github/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword) for more information.\r\n\r\nUnless your change is trivial or a small documentation fix (e.g., a typo or reword of a small section) please:\r\n\r\n- [x] Create a new changelog file in the `changelog` folder, with a name like `<ISSUE NUMBER>.<TYPE>.rst`. See [changelog/README.rst](https://github.com/pytest-dev/pytest/blob/main/changelog/README.rst) for details.\r\n\r\n  Write sentences in the **past or present tense**, examples:\r\n\r\n  * *Improved verbose diff output with sequences.*\r\n  * *Terminal summary statistics now use multiple colors.*\r\n\r\n  Also make sure to end the sentence with a `.`.\r\n\r\n- [x] Add yourself to `AUTHORS` in alphabetical order.\r\n-->\r\n\n\n<hints>:ronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \nronny has already refactored this multiple times iirc, but I wonder if it would make sense to store markers as `pytestmark_foo` and `pytestmark_bar` on the class instead of in one `pytestmark` array, that way you can leverage regular inheritance rules\nThanks for bringing this to attention, pytest show walk the mro of a class to get all markers\n\nIt hadn't done before, but it is a logical conclusion\n\nIt's potentially a breaking change.\n\nCc @nicoddemus @bluetech @asottile \nAs for storing as normal attributes, that has issues when combining same name marks from diamond structures, so it doesn't buy anything that isn't already solved \n>so it doesn't buy anything that isn't already solved\r\n\r\nSo I mean it absolves you from explicitly walking MRO because you just sort of rely on the attributes being propagated by Python to subclasses like pytest currently expects it to.\n> It's potentially a breaking change.\r\n\r\nStrictly yes, so if we were to fix this it should go into 7.0 only.\nAnd are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n@radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\nRe workaround: The way the metaclass is declared needs to be ported from Python 2 to 3 for it to work. \n\nOn Fri, Jun 4, 2021, at 11:15, radkujawa wrote:\n> \n\n> And are there plans to include it to 7.0? The metaclass workaround does not work for me. :/ I use pytest 6.2.4, python 3.7.9\n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/pytest-dev/pytest/issues/7792#issuecomment-854515753>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAGMPRKY3A7P2EBKQN5KHY3TRCKU5ANCNFSM4RYY25OA>.\n\n> @radkujawa Nobody has been working on this so far, and 7.0 has been delayed for a long time (we haven't had a feature release this year yet!) for various reasons. Even if someone worked on this, it'd likely have to wait for 8.0 (at least in my eyes).\r\n\r\nthanks! \nI can not understand the solution proposed by @untitaker. In my opinion, the purpose of test inheritance is that the new test class will contain all tests from parent classes. Also, I do not think it is necessary to mark the tests in the new class with the markers from parent classes. In my opinion, every test in the new class is separate and should be explicitly marked by the user.\r\n\r\nExample:\r\n```python\r\n@pytest.mark.mark1\r\nclass Test1:\r\n    @pytest.mark.mark2\r\n    def test_a(self):\r\n        ...\r\n\r\n    @pytest.mark.mark3\r\n    def test_b(self):\r\n        ...\r\n\r\n\r\n@pytest.mark4\r\nclass Test2:\r\n    @pytest.mark.mark5\r\n    def test_c(self):\r\n        ...\r\n\r\n\r\nclass Test3(Test1, Test):\r\n    def test_d(self):\r\n        ...\r\n```\r\n\r\nPytest will run these tests `Test3`:\r\n* Test3.test_a - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark2\", ...)]\r\n* Test3.test_b - The value of variable `pytestmark` cotians  [Mark(name=\"mark1\", ...), Mark(name=\"mark3\", ...)]\r\n* Test3.test_c - The value of variable `pytestmark` cotians  [Mark(name=\"mark4\", ...), Mark(name=\"mark5\", ...)]\r\n* Test3.test_d - The value of variable `pytestmark` is empty\r\n\r\n@RonnyPfannschmidt What do you think?\r\n\nThe marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance \n> The marks have to transfer with the mro, its a well used feature and its a bug that it doesn't extend to multiple inheritance\r\n\r\nAfter fixing the problem with mro, the goal is that each test will contain all the marks it inherited from parent classes?\r\nAccording to my example,  the marks of `test_d` should be ` [Mark(name=\"mark1\", ...), Mark(name=\"mark4\", ...)]`?\nCorrect \n@bluetech \r\n\r\nit deals with\r\n```text\r\nIn [1]: import pytest\r\n\r\nIn [2]: @pytest.mark.a\r\n   ...: class A:\r\n   ...:     pass\r\n   ...: \r\n\r\nIn [3]: @pytest.mark.b\r\n   ...: class B: pass\r\n\r\nIn [6]: @pytest.mark.c\r\n   ...: class C(A,B): pass\r\n\r\nIn [7]: C.pytestmark\r\nOut[7]: [Mark(name='a', args=(), kwargs={}), Mark(name='c', args=(), kwargs={})]\r\n\r\n```\r\n(b is missing)\nRight, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\n> Right, I understand the problem. What I'd like to see as a description of the proposed solution, it is not very clear to me.\r\n\r\n@bluetech \r\nThe solution I want to implement is: \r\n* Go through the items list. \r\n* For each item, I go through the list of classes from which he inherits. The same logic I do for each class until I found the object class.\r\n* I am updating the list of marks only if the mark does not exist in the current list.\r\n \r\nThe existing code is incorrect, and I will now update it to work according to the logic I wrote here\n@RonnyPfannschmidt \r\nThe PR is not ready for review.\r\nI trying to fix all the tests and after that, I'll improve the logic.\n@RonnyPfannschmidt \r\nOnce the PR is approved I'll create one commit with description \n@RonnyPfannschmidt \r\nYou can review the PR.</hints></description></issue>\n<keyword_search_results>{'pytest': ['src/pytest/__main__.py', 'src/_pytest/monkeypatch.py', 'src/_pytest/pytester_assertions.py', 'src/_pytest/assertion/rewrite.py', 'src/_pytest/faulthandler.py', 'src/_pytest/config/argparsing.py', 'src/_pytest/doctest.py', 'src/_pytest/legacypath.py', 'src/_pytest/stash.py', 'src/_pytest/stepwise.py', 'src/_pytest/warning_types.py', 'src/_pytest/freeze_support.py', 'src/_pytest/mark/__init__.py', 'src/_pytest/runner.py', 'src/_pytest/junitxml.py', 'src/_pytest/config/exceptions.py', 'src/_pytest/compat.py', 'src/_pytest/fixtures.py', 'src/_pytest/assertion/util.py', 'src/_pytest/python_path.py', 'src/_pytest/deprecated.py', 'src/_pytest/threadexception.py', 'src/_pytest/helpconfig.py', 'src/_pytest/config/findpaths.py', 'src/_pytest/cacheprovider.py', 'src/_pytest/_code/code.py', 'src/_pytest/setupplan.py', 'src/_pytest/mark/expression.py', 'src/_pytest/tmpdir.py', 'src/_pytest/assertion/__init__.py', 'src/_pytest/pastebin.py', 'src/_pytest/unraisableexception.py', 'src/_pytest/logging.py', 'src/_pytest/unittest.py', 'src/_pytest/debugging.py', 'src/pytest/__init__.py', 'src/_pytest/setuponly.py', 'src/_pytest/recwarn.py', 'src/_pytest/python.py', 'src/_pytest/pathlib.py', 'src/_pytest/hookspec.py', 'src/_pytest/config/__init__.py', 'src/_pytest/reports.py', 'src/_pytest/mark/structures.py', 'src/_pytest/nodes.py', 'src/_pytest/main.py', 'src/_pytest/timing.py', 'src/_pytest/skipping.py', 'src/_pytest/scope.py', 'src/_pytest/python_api.py', 'src/_pytest/outcomes.py', 'src/_pytest/capture.py', 'src/_pytest/pytester.py', 'src/_pytest/terminal.py', 'src/_pytest/warnings.py'], 'markers': ['src/_pytest/skipping.py', 'src/_pytest/deprecated.py', 'src/_pytest/warnings.py', 'src/_pytest/helpconfig.py', 'src/_pytest/python.py', 'src/_pytest/hookspec.py', 'src/_pytest/pytester.py', 'src/_pytest/_code/code.py', 'src/_pytest/config/__init__.py', 'src/_pytest/reports.py', 'src/_pytest/mark/structures.py', 'src/_pytest/nodes.py', 'src/_pytest/main.py', 'src/_pytest/warning_types.py', 'src/_pytest/fixtures.py', 'src/_pytest/mark/__init__.py'], 'attribute': ['src/_pytest/unraisableexception.py', 'src/_pytest/assertion/util.py', 'src/_pytest/monkeypatch.py', 'src/_pytest/fixtures.py', 'src/_pytest/doctest.py', 'src/_pytest/outcomes.py', 'src/pytest/__init__.py', 'src/_pytest/threadexception.py', 'src/_pytest/python.py', 'src/_pytest/hookspec.py', 'src/_pytest/_argcomplete.py', 'src/_pytest/terminal.py', 'src/_pytest/config/__init__.py', 'src/_pytest/config/argparsing.py', 'src/_pytest/mark/structures.py', 'src/_pytest/nodes.py', 'src/_pytest/compat.py', 'src/_pytest/mark/__init__.py'], 'pytestmark': ['src/_pytest/mark/structures.py', 'src/_pytest/terminal.py', 'src/_pytest/config/__init__.py'], 'metaclass': ['src/_pytest/nodes.py'], 'MRO': ['src/_pytest/compat.py', 'src/_pytest/python.py']}</keyword_search_results>"
    }
  ],
  "completion": {
    "id": "chatcmpl-9wMB9bsxHHE72wE3nCL3kaYkJSGsg",
    "choices": [
      {
        "finish_reason": "stop",
        "index": 0,
        "logprobs": null,
        "message": {
          "content": "{\"scratch_pad\":\"The issue is about merging pytest markers from base classes when using multiple inheritance. The metaclass in the provided code snippet addresses this problem by constructing the `pytestmark` attribute to include markers from all base classes according to the method resolution order (MRO).\\n\\nNow, let's go through the keywords and related files:\\n\\n1. **pytest**: The issue is related to pytest markers, so files containing core pytest functionality might be relevant, especially those related to test collection and execution.\\n\\n2. **markers**: Specifically relates to the issue as it involves merging marker values from multiple base classes.\\n\\n3. **attribute**: This term is relevant because `pytestmark` is an attribute that holds markers in pytest test classes.\\n\\n4. **pytestmark**: A very relevant keyword since the issue directly involves ensuring multiple markers (`pytestmark`) from different base classes are handled correctly.\\n\\n5. **metaclass**: The issue includes an implementation using a metaclass to workaround the problem, so files where metaclasses are defined or utilized might have related logic.\\n\\n6. **MRO**: Crucial because the problem revolves around the method resolution order and how markers from base classes are combined.\\n\\n### Selected Files:\\n1. **src/_pytest/mark/structures.py**: Contains code related to markers, and `pytestmark` is a key element in the issue at hand.\\n2. **src/_pytest/mark/__init__.py**: Likely involves initialization or configuration related to marks, it might contain logic acquiring marks.\\n3. **src/_pytest/python.py**: Includes `MRO` keyword, which is crucial to address the marker merging issue.\\n4. **src/_pytest/compat.py**: Another file mentioning MRO, this could provide support functions or utilities related to compatibility which may affect the marker merging logic.\\n5. **src/_pytest/nodes.py**: Mentions `metaclass`, and since the proposed solution employs a metaclass structure, this may be related.\\n6. **src/_pytest/config/__init__.py**: Mentions `pytestmark` indicating some configuration or default setups related to markers might be loaded from this file.\\n\\nThese selected files are sorted by their apparent relevance to understanding and potentially resolving the reported issue.\",\"file_paths\":[\"src/_pytest/mark/structures.py\",\"src/_pytest/mark/__init__.py\",\"src/_pytest/python.py\",\"src/_pytest/compat.py\",\"src/_pytest/nodes.py\",\"src/_pytest/config/__init__.py\"]}",
          "refusal": null,
          "role": "assistant",
          "function_call": null,
          "tool_calls": [],
          "parsed": {
            "scratch_pad": "The issue is about merging pytest markers from base classes when using multiple inheritance. The metaclass in the provided code snippet addresses this problem by constructing the `pytestmark` attribute to include markers from all base classes according to the method resolution order (MRO).\n\nNow, let's go through the keywords and related files:\n\n1. **pytest**: The issue is related to pytest markers, so files containing core pytest functionality might be relevant, especially those related to test collection and execution.\n\n2. **markers**: Specifically relates to the issue as it involves merging marker values from multiple base classes.\n\n3. **attribute**: This term is relevant because `pytestmark` is an attribute that holds markers in pytest test classes.\n\n4. **pytestmark**: A very relevant keyword since the issue directly involves ensuring multiple markers (`pytestmark`) from different base classes are handled correctly.\n\n5. **metaclass**: The issue includes an implementation using a metaclass to workaround the problem, so files where metaclasses are defined or utilized might have related logic.\n\n6. **MRO**: Crucial because the problem revolves around the method resolution order and how markers from base classes are combined.\n\n### Selected Files:\n1. **src/_pytest/mark/structures.py**: Contains code related to markers, and `pytestmark` is a key element in the issue at hand.\n2. **src/_pytest/mark/__init__.py**: Likely involves initialization or configuration related to marks, it might contain logic acquiring marks.\n3. **src/_pytest/python.py**: Includes `MRO` keyword, which is crucial to address the marker merging issue.\n4. **src/_pytest/compat.py**: Another file mentioning MRO, this could provide support functions or utilities related to compatibility which may affect the marker merging logic.\n5. **src/_pytest/nodes.py**: Mentions `metaclass`, and since the proposed solution employs a metaclass structure, this may be related.\n6. **src/_pytest/config/__init__.py**: Mentions `pytestmark` indicating some configuration or default setups related to markers might be loaded from this file.\n\nThese selected files are sorted by their apparent relevance to understanding and potentially resolving the reported issue.",
            "file_paths": [
              "src/_pytest/mark/structures.py",
              "src/_pytest/mark/__init__.py",
              "src/_pytest/python.py",
              "src/_pytest/compat.py",
              "src/_pytest/nodes.py",
              "src/_pytest/config/__init__.py"
            ]
          }
        }
      }
    ],
    "created": 1723695307,
    "model": "gpt-4o-2024-08-06",
    "object": "chat.completion",
    "service_tier": null,
    "system_fingerprint": "fp_2a322c9ffc",
    "usage": {
      "completion_tokens": 533,
      "prompt_tokens": 4708,
      "total_tokens": 5241
    }
  }
}