{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-9359",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:46:37.816398",
        "usage": "1592.3347473144531 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "try_makedirs",
          "setenv",
          "_IGNORED_WINERRORS",
          "CollectError",
          "FILLFUNCARGS",
          "maketxtfile",
          "duration",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "PytestUnhandledThreadExceptionWarning",
          "_create_formatter",
          "_with_exception",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "wrap_pytest_function_for_tracing",
          "_find_spec",
          "popcall",
          "_CACHE_PREFIX_VALUES",
          "_compare_eq_verbose",
          "evaluate_condition",
          "keywords",
          "_idlist",
          "get_lock_path",
          "PRIVATE",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "UNITTEST_SKIP_DURING_COLLECTION",
          "_compare_approx",
          "visit_BoolOp",
          "next_lower",
          "fillfixtures",
          "PytestRemovedIn8Warning",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "_locationline",
          "copytree",
          "FakeCollectModule",
          "firstlineno",
          "ReprExceptionInfo",
          "getworkerinfoline",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "lex",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "caplog_handler_key",
          "hasplugin",
          "no_re_match_line",
          "debugging",
          "_as_numpy_array",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "getmodulecol",
          "_import_plugin_specs",
          "_get_teardown_reports",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "_validate_ids",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "_pretty_fixture_path",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "dir",
          "_ellipsize",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "prog",
          "_PytestWrapper",
          "mode",
          "repr_locals",
          "_parse_ini_config",
          "pytest_report_to_serializable",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "no_header",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "reprlocals",
          "fslocation",
          "_get_pdb_wrapper_class",
          "ImportPathMismatchError",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "add_color_level",
          "_write_source",
          "showfixtures",
          "NODE_CTOR_FSPATH_ARG",
          "accept",
          "classnamefilter",
          "Skipped",
          "_get_unknown_ini_keys",
          "unset_fixture",
          "fault_handler_stderr_key",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "evaluate_skip_marks",
          "type",
          "_inject_setup_teardown_fixtures",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "AND",
          "FormattedExcinfo",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_is_started",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "xml_key",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "pos",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "deactivate_fixture",
          "getitems",
          "pytest_assertion_pass",
          "_from_json",
          "getplugin",
          "failed",
          "_handle_teardown_sections",
          "is_generator",
          "location",
          "UnitTestCase",
          "_try_repr_or_str",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_args_converter",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "freeze_support",
          "_W",
          "monkeypatch",
          "__bool__",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "__contains__",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "get_stderr_fileno",
          "isnosetest",
          "parse_warning_filter",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "async_warn_and_skip",
          "addini",
          "LegacyTmpdirPlugin",
          "faulthandler",
          "get_lines_after",
          "InstanceDummy",
          "resolve_collection_argument",
          "__take_sys_modules_snapshot",
          "next_higher",
          "getsource",
          "getcall",
          "builtin",
          "CHECKER_CLASS",
          "importlib",
          "fail_fixturefunc",
          "pytest_ignore_collect",
          "_opentestcase",
          "PytestDeprecationWarning",
          "consider_module",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "KNOWN_TYPES",
          "_try_load_conftest",
          "_NodeType",
          "_fail",
          "fault_handler_originally_enabled_key",
          "TempPathFactory",
          "deselect_by_keyword",
          "_FixtureCachedResult",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Config_inifile",
          "Failed",
          "__enter__",
          "istestfunction",
          "filename_arg",
          "recwarn",
          "RecordedHookCall",
          "TerminalReporter_startdir",
          "assertion",
          "write_fspath_result",
          "unraisableexception",
          "code",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "getini",
          "_get_verbose_word",
          "_call_with_optional_argument",
          "check_ispytest",
          "matching_platform",
          "_write_content",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "addSuccess",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "get_terminal_width",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "startpath",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "reprtraceback",
          "CACHEDIR_TAG_CONTENT",
          "_esctable",
          "match",
          "MultipleDoctestFailures",
          "not_expr",
          "MarkDecorator",
          "ColoredLevelFormatter",
          "_report_to_json",
          "_compare_eq_cls",
          "done",
          "CallInfo",
          "pytest_plugins",
          "WarningsChecker",
          "fixture",
          "__attrs_post_init__",
          "_get_raw_skip_reason",
          "MonkeyPatch",
          "getfixturedefs",
          "legacy_path",
          "genitems",
          "timing",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_set_main_color",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "TResult",
          "getstatementrange",
          "newinstance",
          "_params_converter",
          "extraline",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "_validate_config_options",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "fixturenames",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "TESTS_FAILED",
          "_getini_unknown_type",
          "_check_scope",
          "verbosity",
          "absolutepath",
          "LegacyTestdirPlugin",
          "ParameterSet",
          "raises",
          "from_parent",
          "format",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "caplog",
          "Markable",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "CollectReport",
          "from_exc_info",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "__slots__",
          "PYC_EXT",
          "reportinfo",
          "_format_trimmed",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "python_api",
          "linecomp",
          "index",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytest_markeval_namespace",
          "get_last_failed_paths",
          "wcswidth",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "pastebinfile_key",
          "MatcherAdapter",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "set_fixture",
          "ARGUMENT_TYPE_STR",
          "TYPE_CHECKING",
          "pytest_configure",
          "CollectErrorRepr",
          "stepwise",
          "make_hook_recorder",
          "restore",
          "finish_recording",
          "RE_IMPORT_ERROR_NAME",
          "istestfunc",
          "IGNORE_PAM",
          "expression",
          "MARK_GEN",
          "finalize",
          "Pytester",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "pythonpath",
          "findsource",
          "Expression",
          "pytest_runtest_protocol",
          "CaptureResult",
          "T",
          "typename",
          "perform_collect",
          "OR",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "Exception",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "pytest",
          "INTERNAL_ERROR",
          "visit_Assert",
          "resume",
          "NOT",
          "TeeCaptureIO",
          "_do_configure",
          "on_rm_rf_error",
          "exec_module",
          "get_fslocation_from_item",
          "_FileHandler",
          "DummyRewriteHook",
          "_FixtureFunc",
          "parse_num",
          "_is_last_item",
          "unraisable_exception_runtest_hook",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "_add_stats",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "reason",
          "_ignore_error",
          "lines",
          "is_async_function",
          "import_plugin",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "_no_match_line",
          "append_pass",
          "record_xml_attribute",
          "prepend",
          "E",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_fill_fixtures_impl",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "_LiveLoggingNullHandler",
          "getrepr",
          "SysCapture",
          "FixtureLookupError",
          "frame",
          "imply_paths_hooks",
          "names",
          "own_mark_names",
          "EncodedFile",
          "Mark",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "__exit__",
          "get_empty_parameterset_mark",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "Cache_makedir",
          "maybe_wrap_pytest_function_for_tracing",
          "pytest_enter_pdb",
          "store_mark",
          "test_tmproot",
          "_EmptyClass",
          "_bytes_to_ascii",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_assert_state",
          "_show_fixture_action",
          "RaisesContext",
          "__init_subclass__",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "sep",
          "_ALL_SCOPES",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "mkdir",
          "issue_config_time_warning",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "PytestUnraisableExceptionWarning",
          "ParseError",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "_resolve_msg_to_reason",
          "WARNING_CAPTURED_HOOK",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "_check_if_assertion_pass_impl",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_format",
          "_Key",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "rewrite",
          "toterminal",
          "nodes",
          "_in_suspended",
          "LFPluginCollSkipfiles",
          "_get_flag_lookup",
          "_io",
          "pytester_assertions",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "commonpath",
          "old_mark_config_key",
          "addSkip",
          "update",
          "symlink_or_skip",
          "assert_contains",
          "_get_auto_indent",
          "capsysbinary",
          "reject",
          "fullwidth",
          "FastFilesCompleter",
          "RPAREN",
          "append_collect_error",
          "logging",
          "stash",
          "IDENT_PREFIX",
          "setmulti",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "f_globals",
          "_should_truncate_item",
          "indent",
          "parse_args",
          "skipped",
          "_hook",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "legacypath",
          "cwd_relative_nodeid",
          "setuponly",
          "_prepare_content",
          "ishidden",
          "pytest_warning_recorded",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "LFPluginCollWrapper",
          "expr",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "_replace",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "no_summary",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "_parse_expression",
          "SafeRepr",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_write_pyc_fp",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "INSTANCE_COLLECTOR",
          "visit_BinOp",
          "suspend_capturing",
          "_get_maxsize_for_saferepr",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "_parse_parametrize_parameters",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "summary_passes",
          "SubRequest",
          "setup",
          "OK",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "_determine_main_color",
          "_R",
          "LineComp",
          "_striptext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "Config_rootdir",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "_imply_path",
          "clear_cache",
          "deindent",
          "_check_non_top_pytest_plugins",
          "capfdbinary",
          "Function",
          "section",
          "ARGUMENT_PERCENT_DEFAULT",
          "addUnexpectedSuccess",
          "_pformat_dispatch",
          "repr_instance",
          "_compare_eq_any",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "_REPORTCHARS_DEFAULT",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "_report_kwargs_from_json",
          "Config__getini_unknown_type",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "NotSetType",
          "copy_example",
          "assert_contains_lines",
          "_build_normal_summary_stats_line",
          "truncate_locals",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "NodeMeta",
          "parse_known_args",
          "pytest_generate_tests",
          "PYTEST_COLLECT_MODULE",
          "FSHookProxy",
          "kwargs",
          "cache_dir_from_config",
          "Frame",
          "catch_threading_exception",
          "KEYWORD_MSG_ARG",
          "makepyprojecttoml",
          "_is_skipped",
          "IGNORED_ATTRIBUTES",
          "ImportMode",
          "assert_never",
          "head_line",
          "pytest_sessionstart",
          "Testdir",
          "find_prefixed",
          "PathAwareHookProxy",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "_IGNORED_ERRORS",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "USAGE_ERROR",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "reprfuncargs",
          "add_stats",
          "fill_unfilled",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "NO_TESTS_COLLECTED",
          "getfuncargnames",
          "getreportopt",
          "evaluate_xfail_marks",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "_get_assertion_exprs",
          "_non_numeric_type_error",
          "_F",
          "console_main",
          "iter_markers_with_node",
          "PYTEST_TAG",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "threadexception",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "_SCOPE_INDICES",
          "YIELD_FIXTURE",
          "_rget_with_confmod",
          "tracebackcutdir",
          "_consider_importhook",
          "filter_traceback_for_conftest_import_failure",
          "import_path",
          "global_and_fixture_disabled",
          "statement",
          "_AnyPurePath",
          "clear",
          "TokenType",
          "parsefactories",
          "get_extended_length_path_str",
          "BINOP_MAP",
          "create_cleanup_lock",
          "_NodeReporter",
          "from_function",
          "__delitem__",
          "version_tuple",
          "longrepr",
          "bin_xml_escape",
          "_names",
          "_build_collect_only_summary_stats_line",
          "context",
          "short_test_summary",
          "__next__",
          "format_session_duration",
          "FDCapture",
          "name2pseudofixturedef_key",
          "get_option_ini",
          "runtest",
          "D",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "V",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "addError",
          "call_optional",
          "_PluggyPlugin",
          "hasinit",
          "pluralize",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "find_spec",
          "_makepath",
          "_format_action_invocation",
          "_getvaluepath",
          "reprfileloc",
          "compile",
          "getfailures",
          "Node_fspath",
          "Scope",
          "SysPathsSnapshot",
          "_T",
          "_get_global_properties_node",
          "__dir__",
          "getpathnode",
          "_runtest_for",
          "warning_record_to_str",
          "_warn_or_fail_if_strict",
          "token",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "FixtureValue",
          "Exit",
          "FixtureFunction",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_resolve_warning_category",
          "pop_outerr_to_orig",
          "create_module",
          "_assertion_pass",
          "iterparentnodeids",
          "_teardown_yield_fixture",
          "_get_multicapture",
          "stream",
          "close",
          "at_level",
          "inipath",
          "_prepareconfig",
          "PyCollector",
          "Config_invocation_dir",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "and_expr",
          "start",
          "outcome",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "_ET",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "_has_param_ids",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "rm_rf",
          "_WithException",
          "emit",
          "_log",
          "reprentries",
          "pytest_runtest_teardown",
          "add_global_property",
          "_split_lines",
          "ApproxDecimal",
          "getvalue",
          "wcwidth",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "no_fnmatch_line",
          "markup",
          "outcomes",
          "sections",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "Node_fspath_set",
          "_CACHE_PREFIX_DIRS",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "reprcrash",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_fillfuncargs",
          "_get_first_non_fixture_func",
          "PytestArg",
          "Session_stardir",
          "xfail",
          "K",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "locate_config",
          "parseconfig",
          "gethookproxy",
          "STEPWISE_CACHE_DIR",
          "name",
          "StashKey",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "append_collect_skipped",
          "_collectfile",
          "_color_for_type",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "PseudoFixtureDef",
          "_reprcompare",
          "pytest_cmdline_parse",
          "_getcrashline",
          "handler",
          "_get_number_flag",
          "_S",
          "INTERRUPTED",
          "_readline_workaround",
          "WARNS_NONE_ARG",
          "exitstatus",
          "_is_main_py",
          "_ensure_relative_to_basetemp",
          "_check_record_param_type",
          "indices",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "_HandlerType",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_param_ids_generated",
          "_format_args",
          "should_do_markup",
          "Config",
          "pytest_runtestloop",
          "_get_main_color",
          "yield_fixture",
          "_setupstate",
          "_warn_about_skipped_plugins",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "width_of_current_line",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "isnamedtuple",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "_get_allow_unicode_flag",
          "Token",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "HOOK_LEGACY_PATH_ARG",
          "addFailure",
          "setdefault",
          "PyobjMixin",
          "combined_with",
          "_makefile",
          "unittest",
          "lineno",
          "__lt__",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "AlwaysDispatchingPrettyPrinter",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "FixtureRequest_fspath",
          "bestrelpath",
          "runner",
          "Xfail",
          "applymarker",
          "_pytest",
          "PdbInvoke",
          "_diff_text",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "_arg2scope",
          "_create",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "PytestRemovedIn7Warning",
          "LPAREN",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "resolve_package_path",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_param_ids_from",
          "_getnextfixturedef",
          "getfailedcollections",
          "KeywordMatcher",
          "chain",
          "get_timeout_config_value",
          "add_attribute",
          "_repr_compare",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "TerminalWriter",
          "call_and_report",
          "visit_Starred",
          "Stash",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "catch_unraisable_exception",
          "__ne__",
          "InvocationParams",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_get_reports_to_display",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "caplog_records_key",
          "markname",
          "_given_basetemp",
          "popen",
          "module_name_from_path",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "WARNING_CMDLINE_PREPARSE_HOOK",
          "consider_conftest",
          "execute",
          "UNARY_MAP",
          "nextitem",
          "approx",
          "_addoption_instance",
          "_color_for_type_default",
          "LineMatcher_fixture",
          "plugins",
          "_init_checker_class",
          "_excinfo",
          "assertstate_key",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "args",
          "handleError",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "request",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_call_assertion_pass",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "getreports",
          "visit_Name",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "thread_exception_runtest_hook",
          "gethookrecorder",
          "get_log_level_for_setting",
          "strict",
          "repr_excinfo",
          "ExitCode",
          "syspath_prepend",
          "cache_key",
          "insert_missing_modules",
          "is_started",
          "rootpath",
          "HIGH_SCOPES",
          "set_trace",
          "__iter__",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "EOF",
          "MarkMatcher",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "rex_session_duration",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "STRICT_OPTION",
          "call_runtest_hook",
          "Notset",
          "visit",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "_fixturemanager",
          "attrs",
          "traverse_node",
          "snap",
          "undo",
          "ARGUMENT_TYPE_STR_CHOICE",
          "_check_all_skipped",
          "_validate_plugins",
          "_is_mocked",
          "istestclass",
          "f_locals",
          "buffer",
          "validate_basetemp",
          "function",
          "set_repr_style",
          "_addoption",
          "LEGACY_PATH",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "MINUS_K_COLON",
          "FSCOLLECTOR_GETHOOKPROXY_ISINITPATH",
          "append_skipped",
          "wrap_function_to_error_out_if_called_directly",
          "marks",
          "Skip",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "search_pypath",
          "format_explanation",
          "ReprLocals",
          "count",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "evaluate",
          "PytestUnhandledCoroutineWarning",
          "get_cache_dir",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "xfailed_key",
          "_translate_non_printable",
          "apply_warning_filters",
          "_highlight",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "_scope",
          "reports",
          "MINUS_K_DASH",
          "from_user",
          "load_config_dict_from_file",
          "TestReport",
          "SetupState",
          "_surrounding_parens_on_own_lines",
          "flush",
          "pytest_runtest_logstart",
          "_check_path",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "parse_summary_nouns",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "Scanner",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "running_on_ci",
          "IDENT",
          "_eval_scope_callable",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "_format_repr_exception",
          "nose",
          "capfd",
          "ensure_extended_length_path",
          "CwdSnapshot",
          "DEFAULT_REPR_MAX_SIZE",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "_write_entry_lines",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "FILLFUNCARGS",
          "pytest_runtest_makereport",
          "Node",
          "PytestUnhandledThreadExceptionWarning",
          "warn",
          "assertrepr_compare",
          "getini",
          "FixtureManager",
          "getfixtures",
          "pytest",
          "IS_DOCTEST",
          "assert",
          "PytestUnknownMarkWarning"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:46:39.408759",
        "usage": "282.56988525390625 ms"
      },
      "request": {
        "tokens": [
          "FILLFUNCARGS",
          "pytest_runtest_makereport",
          "Node",
          "PytestUnhandledThreadExceptionWarning",
          "warn",
          "assertrepr_compare",
          "getini",
          "FixtureManager",
          "getfixtures",
          "pytest",
          "IS_DOCTEST",
          "assert",
          "PytestUnknownMarkWarning"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/scope.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/pytest/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/recwarn.py",
            "src/pytest/collect.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/timing.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/pythonpath.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/pytest/__main__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/compat.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/stash.py"
          ],
          "assert": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/compat.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "PytestUnknownMarkWarning": [
            "src/_pytest/mark/structures.py",
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py"
          ],
          "PytestUnhandledThreadExceptionWarning": [
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/threadexception.py"
          ],
          "warn": [
            "src/_pytest/deprecated.py",
            "src/_pytest/python.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/recwarn.py",
            "src/pytest/collect.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/runner.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "Node": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/stash.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/runner.py",
            "src/_pytest/skipping.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/unittest.py"
          ],
          "getini": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pythonpath.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "FixtureManager": [
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "FILLFUNCARGS": [
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:46:39.691340",
        "usage": "4002.3272037506104 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/scope.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/pytest/__init__.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/recwarn.py",
            "src/pytest/collect.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/timing.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/pythonpath.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/pytest/__main__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/compat.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/stash.py"
          ],
          "assert": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester_assertions.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/warnings.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/compat.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "PytestUnknownMarkWarning": [
            "src/_pytest/mark/structures.py",
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py"
          ],
          "PytestUnhandledThreadExceptionWarning": [
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/threadexception.py"
          ],
          "warn": [
            "src/_pytest/deprecated.py",
            "src/_pytest/python.py",
            "src/_pytest/config/compat.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/recwarn.py",
            "src/pytest/collect.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/unraisableexception.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/runner.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/threadexception.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "Node": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/legacypath.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/nodes.py",
            "src/_pytest/stash.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/runner.py",
            "src/_pytest/skipping.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/unittest.py"
          ],
          "getini": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/pythonpath.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "FixtureManager": [
            "src/_pytest/main.py",
            "src/_pytest/fixtures.py"
          ],
          "FILLFUNCARGS": [
            "src/_pytest/deprecated.py",
            "src/_pytest/fixtures.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue reported is about error messages printed during pytest runs showing extra decorators or lines when using assert statements in Python 3.9. The keywords from the issue that should be focused on include 'assert', 'pytest', and 'AssertionError'.\n\n1. **pytest**: This issue is directly related to pytest's behavior when using assertions. There are many files associated with this keyword. For error handling and assertion-related functionalities, we should consider files that likely involve assertion rewriting and reporting failures.\n   \n2. **assert**: Files related to assertion in pytest might be where the error messages and the handling of assertions are implemented. Specifically, the file `src/_pytest/assertion/rewrite.py` looks very relevant since it directly mentions assertion rewriting.\n\n3. Other possibly related terms:\n   - `assertion/rewrite`: Modifications or bugs in assertion rewriting could cause additional lines or decorators to be included erroneously in error outputs.\n\nConsidering these factors, focus should be on files related to assertion mechanisms and possibly how pytest formats or captures output messages, possibly tied to assertion errors.",
        "file_paths": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/util.py",
          "src/_pytest/pytester_assertions.py",
          "src/_pytest/python.py",
          "src/_pytest/runner.py",
          "src/_pytest/hookspec.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:43.693682",
        "usage": "7959.920167922974 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "### Analyzing Issue:\n1. **Description Interpretation**: The user reports that when running a pytest, the error output includes extra code when using Python 3.9 as opposed to Python 3.7. This appears as an extra line in the error message during a failed assertion.\n2. **Reproduction**: Yes, the user provided a code snippet that reproduces the issue. The assertion in `test_right_statement(foo)` fails, and the user sees an error message that includes extra elements related to the decorator `t`.\n3. **Cause**: The issue seems to be related to how pytest's error message handling for assertions has changed from Python 3.7 to 3.9. The decorator `t` appears in the error message for Python 3.9, though it's not relevant to the assertion.\n4. **Expectation**: The user expects the output to be consistent between Python versions, avoiding irrelevant extra lines in assertion errors.\n5. **Root Cause**: Likely due to differences in AST (Abstract Syntax Tree) handling and the corresponding assertion message rewriting in pytest when comparing AST in Python 3.9 versus 3.7.\n6. **Solution**: The solution may involve modifying how assert statements and their contexts are rewritten or compiled in pytest for different Python versions, particularly ensuring irrelevant AST nodes (like decorators) don't affect the assertion message.\n\n### Analyzing File Content:\n1. **Module Context**: This file handles AST rewriting for better assertion error messages in pytest.\n2. **Key Components**:\n   - `AssertionRewriter.run(mod)` - Main entry for processing AST modules to find and rewrite assert statements.\n   - `_get_assertion_exprs` - Extracts assertion test expressions for error messages.\n   - `AssertionRewriter.visit_Assert` - Handles rewriting assert nodes, potentially related to the bug since it constructs the failure message and tracks context.\n   - `traverse_node` and other helper methods - Support traversing AST to build error messages.\n3. **Relevance to Issue**:\n   - The methods related to `visit_Assert` likely contribute to the issue since they handle constructing the error output.\n   - The file contains logic that seems to handle different logic based on Python version (`sys.version_info`).\n\nBased on the context provided, this file likely contains the relevant code for the reported issue, as it handles the core assertion-rewriting logic for error messages that are producing the described discrepancies between Python versions. Specifically, the `visit_Assert` method would be closely examined for Python version-specific manipulations that affect its behavior in terms of error output.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "AssertionRewriter.visit_Assert",
          "AssertionRewriter.run",
          "_get_assertion_exprs",
          "rewrite_asserts",
          "AssertionRewritingHook.exec_module",
          "assertstate_key"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:51.653625",
        "usage": "608448.9209651947 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/util.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is about an error message in pytest showing an extra code line when using `assert` in Python 3.9, which did not happen in Python 3.7.\n1.2 The user provides a test function `test_right_statement` which fails at an assertion, and there's extra output related to the 't' decorator.\n1.3 The issue seems to be related to how Python 3.9 handles the bytecode in relation to the decorator, potentially affecting how pytest captures errors.\n1.4 The user expects only the failing assertion error without any extra unrelated code lines in the error message.\n1.5 The root cause might be linked to differences in how Python 3.9 processes assertions and decorators during traceback generation.\n1.6 Potential solutions might include checking updates or changes in Python 3.9 in relation to decorators and bytecode or reviewing pytest's assertion handling code for Python 3.9.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/assertion/util.py` mostly contains utility functions for comparing objects and formatting explanations.\n2.2 Functions like `assertrepr_compare` might be involved since it deals with assertion representations.\n2.3 `format_explanation` and other formatting functions might play a role in determining how assertions and their explanations are processed.\n2.4 The code doesn't directly handle decorators or their line numbers, but any changes in `assertrepr_compare` or `format_explanation` function might indirectly affect the output since they process the explanation for failed assertions.\n2.5 To verify involvement, deeper checks in decorator reflection or pytest's execution context would be needed, potentially outside this specific file.\n\nAfter the analysis, the file may be relevant, but there is no concrete root cause found in this specific file for the stated issue. The issue may originate from elsewhere in the pytest assertion mechanism's interaction with Python 3.9 specifically.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/truncate.py"
        ],
        "relevant_symbols": [
          "format_explanation",
          "assertrepr_compare",
          "_compare_eq_any"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:57:00.102563",
        "usage": "5498.46887588501 ms"
      },
      "request": {
        "file_path": "src/_pytest/pytester_assertions.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue describes that when using \"assert\" in a test with Python 3.9, an error message with extra code lines is printed, particularly involving the decorator usage \"@t\".\n1.2 The user provides a code snippet that fails at an assertion and highlights that the error message in Python 3.9 prints extra code. The extra code shown corresponds to a part of the test that uses decorators. The behavior does not occur in Python 3.7.\n1.3 The issue may be caused by changes in how assertions or decorators are processed in Python 3.9 compared to Python 3.7.\n1.4 The user expects the decorator code not to appear in the assertion error details when a test fails. The issue might be caused by how the pytest or Python 3.9 processes decorators or assertion rewriting.\n1.6 Possible solutions could include verifying whether this is a known issue with pytest or Python 3.9 and looking into fixes or workarounds, like modifying how decorators are used or tested.\n\n2. Make file evaluation:\n2.1 The file contains two assertion helper functions: assertoutcome() and assert_outcomes().\n2.2 These methods handle comparison of test outcomes, asserting if the actual outcomes match expected values.\n2.3 These functions don\u2019t appear to directly process source code files, code lines, or decorators.\n2.4 The functions in this file are related to asserting test results but not related to error message formatting or decorator handling.\n2.5 The issue seems to stem from how assertions or decorators are rewritten or reported, not how test outcomes are asserted.\n2.6 The file is unlikely to be the root cause of the reported issue, as it's focused on reporting test outcomes rather than managing or displaying assertion error messages.\n",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:57:05.601053",
        "usage": "10471.601009368896 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "### Analyzing the Reported Issue\n\n1.1 The issue stated by the user is that an `assert` statement error in one of their tests is printing extra lines of code in the error message when using Python 3.9, compared to previous behavior in Python 3.7.\n\n1.2 There are reproduction steps given by the user, explaining exactly which test causes the issue and the versions of Python where it is observed.\n\n1.3 The issue seems to be caused by how the error traceback or error message is being handled or displayed in Python 3.9 compared to Python 3.7. Specifically, it seems that when the assert statement fails, there is an extra display of surrounding code (specifically a decorator function `t`) when this should not be the case.\n\n1.4 The user's expectation is that only the assertion details should be printed, as these are directly related to where the assertion failed, without additional lines being shown unless relevant. They are concerned that there might be an issue with how line numbers or stack traces are computed in Python 3.9.\n\n1.5 This could be related to changes in Python 3.9 regarding traceback display or how the underlying pytest handles failures.\n\n1.6 Potential solutions might involve examining how pytest collects and formats error messages and exploring differences in traceback or assert failure handling between the two Python versions.\n\n\n### Evaluating the File `src/_pytest/python.py`\n2.1 This file contains logic related to the pytest framework used for collecting and running Python tests, which is likely relevant to issue.\n\n2.2 Functions possibly related to the issue include `pytest_collect_file`, `pytest_pyfunc_call`, `_prunetraceback`, and `repr_failure`. These functions deal with collecting and managing tests, as well as formatting traceback and error representations.\n\n2.3 Functions like `_prunetraceback` and `repr_failure` seem very relevant as they directly handle traceback information and the representation of failure messages.\n\n2.4 `_prunetraceback`, in particular, appears to edit or adjust the traceback when an exception is found, which perfectly aligns with how extra lines may be appearing.\n\n2.5 There is a mention of `filter_traceback` which is linked to how stack frames are filtered to reduce noise. This might be a critical point in understanding why Python 3.9 and 3.7 function differently.\n\n2.6 Based on the logic here, it's plausible that differences in how tracebacks are pruned or formatted could result in discrepancies between Python versions.\n\n### Conclusion\n- The file is relevant to the issue. Especially functions related to traceback and error representation.\n- The root cause might be within `_prunetraceback` and `repr_failure` methods, as they govern how tracebacks are filtered and represented.\n",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "_prunetraceback",
          "repr_failure"
        ],
        "root_cause_symbols": [
          "_prunetraceback",
          "Function.repr_failure"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:57:16.072667",
        "usage": "7682.656049728394 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. **Analyzing User Instructions:**\n   - The issue is about an extra code line printed in the error message when using `assert` in Python 3.9 which did not occur in Python 3.7.10.\n   - Steps to reproduce include using `assert` in a test, which should output an error if the assertion fails. \n   - The issue seems specific to how the error message includes extra context or code lines such as decorators which didn't appear in previous Python versions.\n   - It's likely caused by changes in the traceback or error reporting mechanisms in Python 3.9 with regard to how annotations (like decorators) are reported.\n\n   - Users expect the error to point directly to the assertion line without printing surrounding context like decorators. The problem might be due to a change in how the context is provided in tracebacks in Python 3.9, possibly including decorators or annotations.\n\n2. **Analyzing File Content:**\n   - The file '_pytest/runner.py' seems to include functions dealing with test protocols, setup, call, teardown phases, and reporting failures.\n   - The `call_and_report()` method is key in invoking test call functions and gathering reports about them, where the assertion errors would likely be formatted.\n   - The `CallInfo.from_call()` method is relevant as it wraps function calls, and captures successes or exceptions, including traceback formatting.\n   - There is a logic in `pytest_runtest_makereport()` and `call_runtest_hook()` that determines what is included in test reports, which could affect how errors are reported and how extra lines might be included in Python 3.9.\n   - Any changes in exception handling or traceback reporting in these areas could cause changes in error message display between Python versions.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_code/code.py",
          "src/_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "call_and_report",
          "CallInfo.from_call",
          "pytest_runtest_makereport",
          "call_runtest_hook",
          "Check_interactive_exception"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:57:23.755339",
        "usage": "7088.054180145264 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. **Understand the Issue**: \n   - The issue indicates that when an assert statement fails in Python 3.9 using pytest, extra code lines are printed in the error message.\n   - A comparison between Python 3.9 and Python 3.7 shows that this behavior does not occur in Python 3.7.\n   - The potential cause is related to `pytest` and how it interacts with Python's assert statements, possibly due to changes introduced in Python 3.9.\n\n2. **User Description Analysis**:\n   - The description provided by the user explicitly flags the difference in behavior regarding the assertion output between Python 3.9 and Python 3.7.\n   - Python 3.9 seems to introduce an extra line (from the decorator `t`) in the output, which is not expected.\n   - The user expects consistent behavior regarding assertion without additional lines in the error message for Python 3.9, as seen in 3.7.\n\n3. **Possible Cause**: It could be the line handling of assertions in Python 3.9 or how pytest processes or \"rewrites\" assertions when running tests.\n\n4. **Expectation and Resolution**:\n   - The user seems to expect an error message that does not include extraneous lines like decorators or unrelated code.\n   - Possible solutions might involve examining pytest's assertion rewriting mechanism or determining if it's utilizing any Python specific changes leading to this problem.\n\n5. **Examine Provided File**:\n   - The provided file `src/_pytest/hookspec.py` contains a variety of hook specifications, which suggests its role in extending or modifying pytest behavior.\n   - We should check if any hooks are involved in modifying how assertions are captured or handled.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/truncate.py",
          "src/_pytest/config/__init__.py"
        ],
        "relevant_symbols": [
          "pytest_assertrepr_compare",
          "pytest_assertion_pass",
          "pytest_assertion_pass_hook",
          "pytest_exception_interact"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:57:30.843442",
        "usage": "246.1249828338623 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [
              "AssertionRewriter.visit_Assert",
              "AssertionRewriter.run",
              "_get_assertion_exprs",
              "rewrite_asserts",
              "AssertionRewritingHook.exec_module",
              "assertstate_key"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/util.py",
            "relevant_symbol_keys": [
              "format_explanation",
              "assertrepr_compare",
              "_compare_eq_any"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/pytester_assertions.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "_prunetraceback",
              "repr_failure"
            ],
            "root_cause_symbol_keys": [
              "_prunetraceback",
              "Function.repr_failure"
            ]
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "call_and_report",
              "CallInfo.from_call",
              "pytest_runtest_makereport",
              "call_runtest_hook",
              "Check_interactive_exception"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [
              "pytest_assertrepr_compare",
              "pytest_assertion_pass",
              "pytest_assertion_pass_hook",
              "pytest_exception_interact"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.assertstate_key",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "assertstate_key = StashKey[\"AssertionState\"]()",
            "start_line": 47,
            "start_column": 1169,
            "end_line": 0,
            "end_column": 1215,
            "start_byte": 1169,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)",
            "start_line": 130,
            "start_column": 4293,
            "end_line": 4,
            "end_column": 6165,
            "start_byte": 4293,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(\n    mod: ast.Module,\n    source: bytes,\n    module_path: Optional[str] = None,\n    config: Optional[Config] = None,\n) -> None:\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)",
            "start_line": 418,
            "start_column": 15578,
            "end_line": 0,
            "end_column": 15833,
            "start_byte": 15578,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._get_assertion_exprs",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@functools.lru_cache(maxsize=1)\ndef _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n    ret: Dict[int, str] = {}\n\n    depth = 0\n    lines: List[str] = []\n    assert_lineno: Optional[int] = None\n    seen_lines: Set[int] = set()\n\n    def _write_and_reset() -> None:\n        nonlocal depth, lines, assert_lineno, seen_lines\n        assert assert_lineno is not None\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n        depth = 0\n        lines = []\n        assert_lineno = None\n        seen_lines = set()\n\n    tokens = tokenize.tokenize(io.BytesIO(src).readline)\n    for tp, source, (lineno, offset), _, line in tokens:\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # keep track of depth for the assert-message `,` lookup\n            if tp == tokenize.OP and source in \"([{\":\n                depth += 1\n            elif tp == tokenize.OP and source in \")]}\":\n                depth -= 1\n\n            if not lines:\n                lines.append(line[offset:])\n                seen_lines.add(lineno)\n            # a non-nested comma separates the expression from the message\n            elif depth == 0 and tp == tokenize.OP and source == \",\":\n                # one line assert with message\n                if lineno in seen_lines and len(lines) == 1:\n                    offset_in_trimmed = offset + len(lines[-1]) - len(line)\n                    lines[-1] = lines[-1][:offset_in_trimmed]\n                # multi-line assert with message\n                elif lineno in seen_lines:\n                    lines[-1] = lines[-1][:offset]\n                # multi line assert with escapd newline before message\n                else:\n                    lines.append(line[:offset])\n                _write_and_reset()\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                lines.append(line)\n                seen_lines.add(lineno)\n\n    return ret",
            "start_line": 556,
            "start_column": 19723,
            "end_line": 0,
            "end_column": 21855,
            "start_byte": 19723,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                isinstance(item, ast.ImportFrom)\n                and item.level == 0\n                and item.module == \"__future__\"\n            ):\n                pass\n            else:\n                break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        if sys.version_info >= (3, 10):\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n                ast.alias(\n                    \"_pytest.assertion.rewrite\",\n                    \"@pytest_ar\",\n                    lineno=lineno,\n                    col_offset=0,\n                ),\n            ]\n        else:\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\"),\n                ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n            ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        nodes: List[ast.AST] = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new: List[ast.AST] = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 678,
            "start_column": 24851,
            "end_line": 4,
            "end_column": 28032,
            "start_byte": 24851,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: List[ast.stmt] = []\n        self.variables: List[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: List[str] = []\n\n        self.stack: List[Dict[str, ast.expr]] = []\n        self.expl_stmts: List[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Str(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Str(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Num(assert_.lineno),\n                    ast.Str(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                self.expl_stmts + [hook_call_pass],\n                [],\n            )\n            statements_pass = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.NameConstant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Str(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.NameConstant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                ast.copy_location(node, assert_)\n        return self.statements",
            "start_line": 845,
            "start_column": 31679,
            "end_line": 4,
            "end_column": 36553,
            "start_byte": 31679,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n ",
            "start_line": 177,
            "start_column": 6286,
            "end_line": 0,
            "end_column": 6474,
            "start_byte": 6286,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.format_explanation",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def format_explanation(explanation: str) -> str:\n    r\"\"\"Format an explanation.\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return \"\\n\".join(result)",
            "start_line": 34,
            "start_column": 1123,
            "end_line": 0,
            "end_column": 1684,
            "start_byte": 1123,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands.\"\"\"\n    verbose = config.getoption(\"verbose\")\n    if verbose > 1:\n        left_repr = safeformat(left)\n        right_repr = safeformat(right)\n    else:\n        # XXX: \"15 chars indentation\" is wrong\n        #      (\"E       AssertionError: assert \"); should use term width.\n        maxsize = (\n            80 - 15 - len(op) - 2\n        ) // 2  # 15 chars indentation, 1 space around op\n        left_repr = saferepr(left, maxsize=maxsize)\n        right_repr = saferepr(right, maxsize=maxsize)\n\n    summary = f\"{left_repr} {op} {right_repr}\"\n\n    explanation = None\n    try:\n        if op == \"==\":\n            explanation = _compare_eq_any(left, right, verbose)\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed: {}.\".format(\n                _pytest._code.ExceptionInfo.from_current()._getreprcrash()\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 4125,
            "end_line": 0,
            "end_column": 5490,
            "start_byte": 4125,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._compare_eq_any",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_any(left: Any, right: Any, verbose: int = 0) -> List[str]:\n    explanation = []\n    if istext(left) and istext(right):\n        explanation = _diff_text(left, right, verbose)\n    else:\n        from _pytest.python_api import ApproxBase\n\n        if isinstance(left, ApproxBase) or isinstance(right, ApproxBase):\n            # Although the common order should be obtained == expected, this ensures both ways\n            approx_side = left if isinstance(left, ApproxBase) else right\n            other_side = right if isinstance(left, ApproxBase) else left\n\n            explanation = approx_side._repr_compare(other_side)\n        elif type(left) == type(right) and (\n            isdatacls(left) or isattrs(left) or isnamedtuple(left)\n        ):\n            # Note: unlike dataclasses/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n            # used in older code bases before dataclasses/attrs were available.\n            explanation = _compare_eq_cls(left, right, verbose)\n        elif issequence(left) and issequence(right):\n            explanation = _compare_eq_sequence(left, right, verbose)\n        elif isset(left) and isset(right):\n            explanation = _compare_eq_set(left, right, verbose)\n        elif isdict(left) and isdict(right):\n            explanation = _compare_eq_dict(left, right, verbose)\n        elif verbose > 0:\n            explanation = _compare_eq_verbose(left, right)\n\n        if isiterable(left) and isiterable(right):\n            expl = _compare_eq_iterable(left, right, verbose)\n            explanation.extend(expl)\n\n    return explanation",
            "start_line": 177,
            "start_column": 5493,
            "end_line": 0,
            "end_column": 7215,
            "start_byte": 5493,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 628,
            "start_column": 21725,
            "end_line": 0,
            "end_column": 22273,
            "start_byte": 21725,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "one\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Function marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Get the underlying Python object. May be overwritten by subclasses.\"\"\"\n        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.\n        assert self.parent is not None\n        obj = self.parent.obj  # type: ignore[attr-defined]\n        return getattr(obj, self.name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            name = node.name\n            if isinstance(node, Module):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.PathLike[str]\", str], Optional[int], str]:\n        # XXX caching?\n        obj = self.obj\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[obj.__module__].__file__\n            if file_path.endswith(\".pyc\"):\n                file_path = file_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        assert isinstance(lineno, int)\n        return path, lineno, modpath\n\n\n# As an optimization, these builtin attribute names are pre-ignored when\n# iterating over an object during collection -- the pytest_pycollect_makeitem\n# hook is not called for them.\n# fmt: off\nclass _EmptyClass: pass  # noqa: E701\nIGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file",
            "start_line": 309,
            "start_column": 9828,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 9828,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/python.py",
            "file_content": "assnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_classes\", name)\n\n    def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False\n\n    def istestclass(self, obj: object, name: str) -> bool:\n        return self.classnamefilter(name) or self.isnosetest(obj)\n\n    def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:\n        \"\"\"Check if the given name matches the prefix or glob-pattern defined\n        in ini configuration.\"\"\"\n        for option in self.config.getini(option_name):\n            if name.startswith(option):\n                return True\n            # Check that name looks like a glob-string before calling fnmatch\n            # because this is called for every name in each collected module,\n            # and fnmatch is somewhat expensive to call.\n            elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n                name, option\n            ):\n                return True\n        return False\n\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered. Since Python 3.6,\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name",
            "start_line": 418,
            "start_column": 13319,
            "end_line": 4,
            "end_column": 15575,
            "start_byte": 13319,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n          ",
            "start_line": 473,
            "start_column": 15581,
            "end_line": 4,
            "end_column": 15942,
            "start_byte": 15581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "      methods = []\n        if hasattr(module, \"pytest_generate_tests\"):\n            methods.append(module.pytest_generate_tests)\n        if cls is not None and hasattr(cls, \"pytest_generate_tests\"):\n            methods.append(cls().pytest_generate_tests)\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n\n        if not metafunc._calls:\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n        else:\n            # Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.\n            fm = self.session._fixturemanager\n            fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n\n            # Add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n            # with direct parametrization, ",
            "start_line": 517,
            "start_column": 17165,
            "end_line": 4,
            "end_column": 17949,
            "start_byte": 17165,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ok.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 521,
            "start_column": 18271,
            "end_line": 0,
            "end_column": 18745,
            "start_byte": 18271,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 217,
            "start_column": 6851,
            "end_line": 0,
            "end_column": 7333,
            "start_byte": 6851,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_runtest_hook",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_runtest_hook(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", **kwds\n) -> \"CallInfo[None]\":\n    if when == \"setup\":\n        ihook: Callable[..., None] = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:\n        assert False, f\"Unhandled runtest hook case: {when}\"\n    reraise: Tuple[Type[BaseException], ...] = (Exit,)\n    if not item.config.getoption(\"usepdb\", False):\n        reraise += (KeyboardInterrupt,)\n    return CallInfo.from_call(\n        lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )",
            "start_line": 245,
            "start_column": 7829,
            "end_line": 0,
            "end_column": 8511,
            "start_byte": 7829,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.CallInfo.from_call",
            "file_path": "src/_pytest/runner.py",
            "file_content": "@classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n\n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n            result: Optional[TResult] = func()\n        except BaseException:\n            excinfo = ExceptionInfo.from_current()\n            if reraise is not None and isinstance(excinfo.value, reraise):\n                raise\n            result = None\n        # use the perf counter\n        precise_stop = timing.perf_counter()\n        duration = precise_stop - precise_start\n        stop = timing.time()\n        return cls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )",
            "start_line": 316,
            "start_column": 10263,
            "end_line": 4,
            "end_column": 11679,
            "start_byte": 10263,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)",
            "start_line": 365,
            "start_column": 11897,
            "end_line": 0,
            "end_column": 12028,
            "start_byte": 11897,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "nal[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.\n    duration: float\n    #: The context of invocation: \"collect\", \"setup\", \"call\" or \"teardown\".\n    when: \"Literal['collect', 'setup', 'call', 'teardown']\"\n\n    def __init__(\n        self,\n        result: Optional[TResult],\n        excinfo: Optional[ExceptionInfo[BaseException]],\n        start: float,\n        stop: float,\n        duration: float,\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._result = result\n        self.excinfo = excinfo\n        self.start = start\n        self.stop = stop\n        self.duration = duration\n        self.when = when\n\n    @property\n    def result(self) -> TResult:\n        \"\"\"The return value of the call, if it didn't raise.\n\n        Can only be accessed if ex",
            "start_line": 261,
            "start_column": 8818,
            "end_line": 0,
            "end_column": 9891,
            "start_byte": 8818,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )\n\n    def __repr__(self) -> str:\n        if self.excinfo is None:\n            return f\"<CallInfo when={self.when!r} result: {self._result!r}>\"\n        return f\"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>\"\n\n\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\n\n\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"u",
            "start_line": 332,
            "start_column": 11480,
            "end_line": 0,
            "end_column": 12427,
            "start_byte": 11480,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " will invoke the configure hooks and runtest_mainloop.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"\n\n\nde",
            "start_line": 177,
            "start_column": 6286,
            "end_line": 0,
            "end_column": 6474,
            "start_byte": 6286,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".. versionchanged:: 7.0.0\n        The ``fspath`` parameter was added as a :class:`pathlib.Path`\n        equivalent of the ``path`` parameter. The ``path`` parameter\n        has been deprecated.\n    \"\"\"\n\n\ndef pytest_collect_file(\n    fspath: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n) -> \"Optional[Collector]\":\n    \"\"\"Create a Collector for the given path, or None if not relevant.\n\n    The new node needs to have the specified ``parent`` as a parent.\n\n    ",
            "start_line": 285,
            "start_column": 9713,
            "end_line": 4,
            "end_column": 10175,
            "start_byte": 9713,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :param pytest.Parser parser:\n        To add command line options, call\n        :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.\n        To add ini-f",
            "start_line": 90,
            "start_column": 2953,
            "end_line": 0,
            "end_column": 3186,
            "start_byte": 2953,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:\n    \"\"\"Return explanation for comparisons in failing assert expressions.\n\n    Return None for no custom explanation, otherwise return a list\n    of strings. The strings will be joined by newlines but any newlines\n    *in* a string will be escaped. Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"",
            "start_line": 628,
            "start_column": 21725,
            "end_line": 0,
            "end_column": 22273,
            "start_byte": 21725,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertion_pass",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n    \"\"\"Called whenever an assertion passes.\n\n    .. versionadded:: 5.0\n\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n\n    .. code-block:: ini\n\n        [pytest]\n        enable_assertion_pass_hook=true\n\n    You need to **clean the .pyc** files in your project directory and interpreter libraries\n    when enabling this option, as assertions will require to be re-written.\n\n    :param pytest.Item item: pytest item object of current test.\n    :param int lineno: Line number of the assert statement.\n    :param str orig: String with the original assertion.\n    :param str expl: String with the assert explanation.\n    \"\"\"",
            "start_line": 642,
            "start_column": 22276,
            "end_line": 0,
            "end_column": 23266,
            "start_byte": 22276,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> None:\n    \"\"\"Called when an exception was raised which can potentially be\n    interactively handled.\n\n    May be called during collection (see :py:func:`pytest_make_collect_report`),\n    in which case ``report`` is a :class:`CollectReport`.\n\n    May be called during runtest of an item (see :py:func:`pytest_runtest_protocol`),\n    in which case ``report`` is a :class:`TestReport`.\n\n    This hook is not called if the exception that was raised is an internal\n    exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 889,
            "start_column": 31127,
            "end_line": 0,
            "end_column": 31784,
            "start_byte": 31127,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "on) as test classes.\n        return safe_getattr(obj, \"__test__\", False) is True\n\n    ",
            "start_line": 415,
            "start_column": 13227,
            "end_line": 4,
            "end_column": 13313,
            "start_byte": 13227,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e sure we update what the\n            # function really needs.\n            fixtureinfo.prune_dependency_tree()\n\n            for callspec in metafunc._calls:\n                subname = f\"{name}[{callspec.id}]\"\n                yield Function.from_parent(\n                    self,\n                    name=subname,\n                    callspec=callspec,\n                  ",
            "start_line": 538,
            "start_column": 17955,
            "end_line": 4,
            "end_column": 18324,
            "start_byte": 17955,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code.from_function(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame.\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1713,
            "start_column": 64881,
            "end_line": 4,
            "end_column": 65989,
            "start_byte": 64881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self,\n        excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1735,
            "start_column": 66051,
            "end_line": 4,
            "end_column": 66361,
            "start_byte": 66051,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.",
            "start_line": 321,
            "start_column": 11153,
            "end_line": 4,
            "end_column": 11477,
            "start_byte": 11153,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:57:31.089573",
        "usage": "26998.929977416992 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.assertstate_key",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "assertstate_key = StashKey[\"AssertionState\"]()",
            "start_line": 47,
            "start_column": 1169,
            "end_line": 0,
            "end_column": 1215,
            "start_byte": 1169,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)",
            "start_line": 130,
            "start_column": 4293,
            "end_line": 4,
            "end_column": 6165,
            "start_byte": 4293,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(\n    mod: ast.Module,\n    source: bytes,\n    module_path: Optional[str] = None,\n    config: Optional[Config] = None,\n) -> None:\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)",
            "start_line": 418,
            "start_column": 15578,
            "end_line": 0,
            "end_column": 15833,
            "start_byte": 15578,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._get_assertion_exprs",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@functools.lru_cache(maxsize=1)\ndef _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n    ret: Dict[int, str] = {}\n\n    depth = 0\n    lines: List[str] = []\n    assert_lineno: Optional[int] = None\n    seen_lines: Set[int] = set()\n\n    def _write_and_reset() -> None:\n        nonlocal depth, lines, assert_lineno, seen_lines\n        assert assert_lineno is not None\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n        depth = 0\n        lines = []\n        assert_lineno = None\n        seen_lines = set()\n\n    tokens = tokenize.tokenize(io.BytesIO(src).readline)\n    for tp, source, (lineno, offset), _, line in tokens:\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # keep track of depth for the assert-message `,` lookup\n            if tp == tokenize.OP and source in \"([{\":\n                depth += 1\n            elif tp == tokenize.OP and source in \")]}\":\n                depth -= 1\n\n            if not lines:\n                lines.append(line[offset:])\n                seen_lines.add(lineno)\n            # a non-nested comma separates the expression from the message\n            elif depth == 0 and tp == tokenize.OP and source == \",\":\n                # one line assert with message\n                if lineno in seen_lines and len(lines) == 1:\n                    offset_in_trimmed = offset + len(lines[-1]) - len(line)\n                    lines[-1] = lines[-1][:offset_in_trimmed]\n                # multi-line assert with message\n                elif lineno in seen_lines:\n                    lines[-1] = lines[-1][:offset]\n                # multi line assert with escapd newline before message\n                else:\n                    lines.append(line[:offset])\n                _write_and_reset()\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                lines.append(line)\n                seen_lines.add(lineno)\n\n    return ret",
            "start_line": 556,
            "start_column": 19723,
            "end_line": 0,
            "end_column": 21855,
            "start_byte": 19723,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                isinstance(item, ast.ImportFrom)\n                and item.level == 0\n                and item.module == \"__future__\"\n            ):\n                pass\n            else:\n                break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        if sys.version_info >= (3, 10):\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n                ast.alias(\n                    \"_pytest.assertion.rewrite\",\n                    \"@pytest_ar\",\n                    lineno=lineno,\n                    col_offset=0,\n                ),\n            ]\n        else:\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\"),\n                ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n            ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        nodes: List[ast.AST] = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new: List[ast.AST] = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 678,
            "start_column": 24851,
            "end_line": 4,
            "end_column": 28032,
            "start_byte": 24851,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: List[ast.stmt] = []\n        self.variables: List[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: List[str] = []\n\n        self.stack: List[Dict[str, ast.expr]] = []\n        self.expl_stmts: List[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Str(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Str(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Num(assert_.lineno),\n                    ast.Str(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                self.expl_stmts + [hook_call_pass],\n                [],\n            )\n            statements_pass = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.NameConstant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Str(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.NameConstant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                ast.copy_location(node, assert_)\n        return self.statements",
            "start_line": 845,
            "start_column": 31679,
            "end_line": 4,
            "end_column": 36553,
            "start_byte": 31679,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n ",
            "start_line": 177,
            "start_column": 6286,
            "end_line": 0,
            "end_column": 6474,
            "start_byte": 6286,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.format_explanation",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def format_explanation(explanation: str) -> str:\n    r\"\"\"Format an explanation.\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return \"\\n\".join(result)",
            "start_line": 34,
            "start_column": 1123,
            "end_line": 0,
            "end_column": 1684,
            "start_byte": 1123,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands.\"\"\"\n    verbose = config.getoption(\"verbose\")\n    if verbose > 1:\n        left_repr = safeformat(left)\n        right_repr = safeformat(right)\n    else:\n        # XXX: \"15 chars indentation\" is wrong\n        #      (\"E       AssertionError: assert \"); should use term width.\n        maxsize = (\n            80 - 15 - len(op) - 2\n        ) // 2  # 15 chars indentation, 1 space around op\n        left_repr = saferepr(left, maxsize=maxsize)\n        right_repr = saferepr(right, maxsize=maxsize)\n\n    summary = f\"{left_repr} {op} {right_repr}\"\n\n    explanation = None\n    try:\n        if op == \"==\":\n            explanation = _compare_eq_any(left, right, verbose)\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed: {}.\".format(\n                _pytest._code.ExceptionInfo.from_current()._getreprcrash()\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 4125,
            "end_line": 0,
            "end_column": 5490,
            "start_byte": 4125,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._compare_eq_any",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_any(left: Any, right: Any, verbose: int = 0) -> List[str]:\n    explanation = []\n    if istext(left) and istext(right):\n        explanation = _diff_text(left, right, verbose)\n    else:\n        from _pytest.python_api import ApproxBase\n\n        if isinstance(left, ApproxBase) or isinstance(right, ApproxBase):\n            # Although the common order should be obtained == expected, this ensures both ways\n            approx_side = left if isinstance(left, ApproxBase) else right\n            other_side = right if isinstance(left, ApproxBase) else left\n\n            explanation = approx_side._repr_compare(other_side)\n        elif type(left) == type(right) and (\n            isdatacls(left) or isattrs(left) or isnamedtuple(left)\n        ):\n            # Note: unlike dataclasses/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n            # used in older code bases before dataclasses/attrs were available.\n            explanation = _compare_eq_cls(left, right, verbose)\n        elif issequence(left) and issequence(right):\n            explanation = _compare_eq_sequence(left, right, verbose)\n        elif isset(left) and isset(right):\n            explanation = _compare_eq_set(left, right, verbose)\n        elif isdict(left) and isdict(right):\n            explanation = _compare_eq_dict(left, right, verbose)\n        elif verbose > 0:\n            explanation = _compare_eq_verbose(left, right)\n\n        if isiterable(left) and isiterable(right):\n            expl = _compare_eq_iterable(left, right, verbose)\n            explanation.extend(expl)\n\n    return explanation",
            "start_line": 177,
            "start_column": 5493,
            "end_line": 0,
            "end_column": 7215,
            "start_byte": 5493,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 628,
            "start_column": 21725,
            "end_line": 0,
            "end_column": 22273,
            "start_byte": 21725,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "one\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Function marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Get the underlying Python object. May be overwritten by subclasses.\"\"\"\n        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.\n        assert self.parent is not None\n        obj = self.parent.obj  # type: ignore[attr-defined]\n        return getattr(obj, self.name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            name = node.name\n            if isinstance(node, Module):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.PathLike[str]\", str], Optional[int], str]:\n        # XXX caching?\n        obj = self.obj\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[obj.__module__].__file__\n            if file_path.endswith(\".pyc\"):\n                file_path = file_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        assert isinstance(lineno, int)\n        return path, lineno, modpath\n\n\n# As an optimization, these builtin attribute names are pre-ignored when\n# iterating over an object during collection -- the pytest_pycollect_makeitem\n# hook is not called for them.\n# fmt: off\nclass _EmptyClass: pass  # noqa: E701\nIGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file",
            "start_line": 309,
            "start_column": 9828,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 9828,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/python.py",
            "file_content": "assnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_classes\", name)\n\n    def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False\n\n    def istestclass(self, obj: object, name: str) -> bool:\n        return self.classnamefilter(name) or self.isnosetest(obj)\n\n    def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:\n        \"\"\"Check if the given name matches the prefix or glob-pattern defined\n        in ini configuration.\"\"\"\n        for option in self.config.getini(option_name):\n            if name.startswith(option):\n                return True\n            # Check that name looks like a glob-string before calling fnmatch\n            # because this is called for every name in each collected module,\n            # and fnmatch is somewhat expensive to call.\n            elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n                name, option\n            ):\n                return True\n        return False\n\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered. Since Python 3.6,\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name",
            "start_line": 418,
            "start_column": 13319,
            "end_line": 4,
            "end_column": 15575,
            "start_byte": 13319,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n          ",
            "start_line": 473,
            "start_column": 15581,
            "end_line": 4,
            "end_column": 15942,
            "start_byte": 15581,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "      methods = []\n        if hasattr(module, \"pytest_generate_tests\"):\n            methods.append(module.pytest_generate_tests)\n        if cls is not None and hasattr(cls, \"pytest_generate_tests\"):\n            methods.append(cls().pytest_generate_tests)\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n\n        if not metafunc._calls:\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n        else:\n            # Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.\n            fm = self.session._fixturemanager\n            fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n\n            # Add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n            # with direct parametrization, ",
            "start_line": 517,
            "start_column": 17165,
            "end_line": 4,
            "end_column": 17949,
            "start_byte": 17165,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ok.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 521,
            "start_column": 18271,
            "end_line": 0,
            "end_column": 18745,
            "start_byte": 18271,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 217,
            "start_column": 6851,
            "end_line": 0,
            "end_column": 7333,
            "start_byte": 6851,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_runtest_hook",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_runtest_hook(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", **kwds\n) -> \"CallInfo[None]\":\n    if when == \"setup\":\n        ihook: Callable[..., None] = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:\n        assert False, f\"Unhandled runtest hook case: {when}\"\n    reraise: Tuple[Type[BaseException], ...] = (Exit,)\n    if not item.config.getoption(\"usepdb\", False):\n        reraise += (KeyboardInterrupt,)\n    return CallInfo.from_call(\n        lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )",
            "start_line": 245,
            "start_column": 7829,
            "end_line": 0,
            "end_column": 8511,
            "start_byte": 7829,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.CallInfo.from_call",
            "file_path": "src/_pytest/runner.py",
            "file_content": "@classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n\n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n            result: Optional[TResult] = func()\n        except BaseException:\n            excinfo = ExceptionInfo.from_current()\n            if reraise is not None and isinstance(excinfo.value, reraise):\n                raise\n            result = None\n        # use the perf counter\n        precise_stop = timing.perf_counter()\n        duration = precise_stop - precise_start\n        stop = timing.time()\n        return cls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )",
            "start_line": 316,
            "start_column": 10263,
            "end_line": 4,
            "end_column": 11679,
            "start_byte": 10263,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)",
            "start_line": 365,
            "start_column": 11897,
            "end_line": 0,
            "end_column": 12028,
            "start_byte": 11897,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "nal[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.\n    duration: float\n    #: The context of invocation: \"collect\", \"setup\", \"call\" or \"teardown\".\n    when: \"Literal['collect', 'setup', 'call', 'teardown']\"\n\n    def __init__(\n        self,\n        result: Optional[TResult],\n        excinfo: Optional[ExceptionInfo[BaseException]],\n        start: float,\n        stop: float,\n        duration: float,\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._result = result\n        self.excinfo = excinfo\n        self.start = start\n        self.stop = stop\n        self.duration = duration\n        self.when = when\n\n    @property\n    def result(self) -> TResult:\n        \"\"\"The return value of the call, if it didn't raise.\n\n        Can only be accessed if ex",
            "start_line": 261,
            "start_column": 8818,
            "end_line": 0,
            "end_column": 9891,
            "start_byte": 8818,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )\n\n    def __repr__(self) -> str:\n        if self.excinfo is None:\n            return f\"<CallInfo when={self.when!r} result: {self._result!r}>\"\n        return f\"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>\"\n\n\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\n\n\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"u",
            "start_line": 332,
            "start_column": 11480,
            "end_line": 0,
            "end_column": 12427,
            "start_byte": 11480,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " will invoke the configure hooks and runtest_mainloop.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"\n\n\nde",
            "start_line": 177,
            "start_column": 6286,
            "end_line": 0,
            "end_column": 6474,
            "start_byte": 6286,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".. versionchanged:: 7.0.0\n        The ``fspath`` parameter was added as a :class:`pathlib.Path`\n        equivalent of the ``path`` parameter. The ``path`` parameter\n        has been deprecated.\n    \"\"\"\n\n\ndef pytest_collect_file(\n    fspath: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n) -> \"Optional[Collector]\":\n    \"\"\"Create a Collector for the given path, or None if not relevant.\n\n    The new node needs to have the specified ``parent`` as a parent.\n\n    ",
            "start_line": 285,
            "start_column": 9713,
            "end_line": 4,
            "end_column": 10175,
            "start_byte": 9713,
            "end_byte": 4
          },
          {
            "name": "_pytest.faulthandler.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :param pytest.Parser parser:\n        To add command line options, call\n        :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.\n        To add ini-f",
            "start_line": 90,
            "start_column": 2953,
            "end_line": 0,
            "end_column": 3186,
            "start_byte": 2953,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:\n    \"\"\"Return explanation for comparisons in failing assert expressions.\n\n    Return None for no custom explanation, otherwise return a list\n    of strings. The strings will be joined by newlines but any newlines\n    *in* a string will be escaped. Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"",
            "start_line": 628,
            "start_column": 21725,
            "end_line": 0,
            "end_column": 22273,
            "start_byte": 21725,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertion_pass",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n    \"\"\"Called whenever an assertion passes.\n\n    .. versionadded:: 5.0\n\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n\n    .. code-block:: ini\n\n        [pytest]\n        enable_assertion_pass_hook=true\n\n    You need to **clean the .pyc** files in your project directory and interpreter libraries\n    when enabling this option, as assertions will require to be re-written.\n\n    :param pytest.Item item: pytest item object of current test.\n    :param int lineno: Line number of the assert statement.\n    :param str orig: String with the original assertion.\n    :param str expl: String with the assert explanation.\n    \"\"\"",
            "start_line": 642,
            "start_column": 22276,
            "end_line": 0,
            "end_column": 23266,
            "start_byte": 22276,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> None:\n    \"\"\"Called when an exception was raised which can potentially be\n    interactively handled.\n\n    May be called during collection (see :py:func:`pytest_make_collect_report`),\n    in which case ``report`` is a :class:`CollectReport`.\n\n    May be called during runtest of an item (see :py:func:`pytest_runtest_protocol`),\n    in which case ``report`` is a :class:`TestReport`.\n\n    This hook is not called if the exception that was raised is an internal\n    exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 889,
            "start_column": 31127,
            "end_line": 0,
            "end_column": 31784,
            "start_byte": 31127,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "on) as test classes.\n        return safe_getattr(obj, \"__test__\", False) is True\n\n    ",
            "start_line": 415,
            "start_column": 13227,
            "end_line": 4,
            "end_column": 13313,
            "start_byte": 13227,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e sure we update what the\n            # function really needs.\n            fixtureinfo.prune_dependency_tree()\n\n            for callspec in metafunc._calls:\n                subname = f\"{name}[{callspec.id}]\"\n                yield Function.from_parent(\n                    self,\n                    name=subname,\n                    callspec=callspec,\n                  ",
            "start_line": 538,
            "start_column": 17955,
            "end_line": 4,
            "end_column": 18324,
            "start_byte": 17955,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code.from_function(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame.\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1713,
            "start_column": 64881,
            "end_line": 4,
            "end_column": 65989,
            "start_byte": 64881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self,\n        excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1735,
            "start_column": 66051,
            "end_line": 4,
            "end_column": 66361,
            "start_byte": 66051,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.",
            "start_line": 321,
            "start_column": 11153,
            "end_line": 4,
            "end_column": 11477,
            "start_byte": 11153,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1.1 What issue is the user describing?\nThe issue is about an error message in pytest for Python 3.9 containing extra code lines not present in earlier versions (like Python 3.7).\n\n1.2 How was this issue caused?\nThe issue might be related to the assertion rewriting mechanism in pytest, which seems to behave differently in Python 3.9 compared to 3.7.\n\n1.3 If the user described the expected result, what should it be fixed to?\nThe error message should not include the extra decorator code lines in its output.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\nThe expectation would be an error message showing only relevant assertion failure details without extra code lines.\n\n1.5 How should the issue be fixed to meet the expectation?\nThe pytest assertion rewriting logic might need to be adjusted or fixed to ensure it handles decorators or multiline assertions correctly across Python versions, especially in Python 3.9, matching the behavior in Python 3.7.",
        "symbols": [
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "reason": "Handles traceback pruning, possibly needs adjustment to ensure extra lines aren't included in output."
          },
          {
            "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "Responsible for rewriting asserts, could be introducing changes in Python 3.9."
          },
          {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "Rewrites assert statements, possibly involved in adding extra output in 3.9."
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "Involved in assertion rewriting, could be causing different behavior in test outputs."
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "Handles assert transformations, possibly affecting how assertion errors are displayed."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The symbol '_pytest.nodes.Node._prunetraceback' content is not directly provided, but it likely deals with traceback pruning, which can affect how error messages are displayed. If traceback includes more lines in Python 3.9, this could be involved.",
          "The symbol '_pytest.nodes.Collector._prunetraceback' content is not available, but like Node, it likely deals with pruning traceback and thus related to how error messages might have extra content.",
          "This function '_pytest.python.Function._prunetraceback' already prunes the traceback when 'fulltrace' option is not enabled. Modifying the way tracebacks are cut could adjust the output to avoid extra lines.",
          "The function '_pytest.python.Function.repr_failure' determines the representation of a failure in terms of style, which might indirectly relate if formatting needs adjusting for different Python versions.",
          "The symbol '_pytest.unittest.TestCaseFunction._prunetraceback' content is not provided, but it presumably also manages traceback pruning in a manner that could interact with assert output",
          "The symbol '_pytest.assertion.assertstate_key' is unrelated to the rewriting process; it involves a key for state tracking.",
          "The function '_pytest.assertion.AssertionRewritingHook.exec_module' is responsible for rewriting modules and could be central to changes in output between Python versions.",
          "'The symbol '_pytest.assertion.rewrite_asserts' is directly related to rewriting assert statements, potentially causing or influencing the difference in assert output between Python versions.'",
          "The symbol '_pytest.assertion._get_assertion_exprs' is related to mapping assertion expressions, unlikely to need changes unless expressions themselves are misrepresented.",
          "The function '_pytest.assertion.AssertionRewriter.run' finds and rewrites all assert statements, likely needing investigation for influencing output differences.",
          "The function '_pytest.assertion.AssertionRewriter.visit_Assert' rewrites individual assert statements, which could be modified to ensure they do not introduce extra code lines in errors.",
          "The symbol '_pytest.assertion.pytest_assertrepr_compare' deals with specialized assertion explanation but doesn't relate to rewriting process or output issues.",
          "The function '_pytest.assertion.format_explanation' formats explanations but isn't directly related to inclusion of extra assert expression lines.",
          "The symbol '_pytest.assertion.assertrepr_compare' might be relevant if it affects how assertions are represented during failure, but unrelated to code line output.",
          "The symbol '_pytest.assertion._compare_eq_any' is irrelevant to the rewriting mechanism; it strictly deals with comparing equality for explanations.",
          "The hook '_pytest.hookspec.pytest_assertrepr_compare' offers a mechanism for custom comparison representation, but doesn't participate in the rewriting framework.",
          "The symbol '_pytest.doctest.DoctestItem.repr_failure' relates to doctest failures but isn't relevant to Python 3.9 assertions and their message output.",
          "The symbol '_pytest.nodes.Node._repr_failure_py' would affect test node failure representation but isn't the root cause of different output in Python versions.",
          "The symbol '_pytest.nodes.Node.repr_failure' manages failure representation for arbitrary nodes, but the central issue remains with the assertion system.",
          "The symbol '_pytest.nodes.Collector.repr_failure' covers collector failure representation, unrelated to assertion failure details.",
          "The hook '_pytest.hookspec.pytest_runtest_makereport' processes runtest reports, indirectly related through report accuracy and content.",
          "The function '_pytest.runner.call_and_report' makes reports on test results, interacting with runtest hook, report could receive refined traceback.",
          "The function '_pytest.runner.call_runtest_hook' queries hook setup but is a utility, a background process.",
          "The symbol '_pytest.runner.CallInfo.from_call' manages calling process and lifecycle, indirectly linked to runtime behavior for errors.",
          "The function '_pytest.runner.pytest_runtest_makereport' constructs test report linking CallInfo but it's a structural element not processing errors precision like assertions.",
          "The symbol '_pytest.skipping.pytest_runtest_makereport' expands on test report but doesn't influence rewriting.",
          "The symbol '_pytest.unittest.pytest_runtest_makereport' similar to others in making runtime reports doesn't intervene directly with assertion errors.",
          "The hook '_pytest.hookspec.pytest_assertrepr_compare' in hookspec is structurally same as util's, guides compare configs rather than execution.",
          "The symbol '_pytest.debugging.PdbInvoke.pytest_exception_interact' facilitates exception handling engagement, relationally irrelevant.",
          "The function '_pytest.faulthandler.pytest_exception_interact' noted here works in fault handling interaction.",
          "The hook '_pytest.hookspec.pytest_assertion_pass' involves passing assertion state which doesn't contribute to failures like in the scenario.",
          "The hook '_pytest.hookspec.pytest_exception_interact' allows handling exceptions interactively, not source of expressing or altering assertion outputs."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:57:58.088536",
        "usage": "1.9338130950927734 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.assertstate_key",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "assertstate_key = StashKey[\"AssertionState\"]()",
              "start_line": 47,
              "start_column": 1169,
              "end_line": 0,
              "end_column": 1215,
              "start_byte": 1169,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)",
              "start_line": 130,
              "start_column": 4293,
              "end_line": 4,
              "end_column": 6165,
              "start_byte": 4293,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.rewrite_asserts",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def rewrite_asserts(\n    mod: ast.Module,\n    source: bytes,\n    module_path: Optional[str] = None,\n    config: Optional[Config] = None,\n) -> None:\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)",
              "start_line": 418,
              "start_column": 15578,
              "end_line": 0,
              "end_column": 15833,
              "start_byte": 15578,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._get_assertion_exprs",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "@functools.lru_cache(maxsize=1)\ndef _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n    ret: Dict[int, str] = {}\n\n    depth = 0\n    lines: List[str] = []\n    assert_lineno: Optional[int] = None\n    seen_lines: Set[int] = set()\n\n    def _write_and_reset() -> None:\n        nonlocal depth, lines, assert_lineno, seen_lines\n        assert assert_lineno is not None\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n        depth = 0\n        lines = []\n        assert_lineno = None\n        seen_lines = set()\n\n    tokens = tokenize.tokenize(io.BytesIO(src).readline)\n    for tp, source, (lineno, offset), _, line in tokens:\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # keep track of depth for the assert-message `,` lookup\n            if tp == tokenize.OP and source in \"([{\":\n                depth += 1\n            elif tp == tokenize.OP and source in \")]}\":\n                depth -= 1\n\n            if not lines:\n                lines.append(line[offset:])\n                seen_lines.add(lineno)\n            # a non-nested comma separates the expression from the message\n            elif depth == 0 and tp == tokenize.OP and source == \",\":\n                # one line assert with message\n                if lineno in seen_lines and len(lines) == 1:\n                    offset_in_trimmed = offset + len(lines[-1]) - len(line)\n                    lines[-1] = lines[-1][:offset_in_trimmed]\n                # multi-line assert with message\n                elif lineno in seen_lines:\n                    lines[-1] = lines[-1][:offset]\n                # multi line assert with escapd newline before message\n                else:\n                    lines.append(line[:offset])\n                _write_and_reset()\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                lines.append(line)\n                seen_lines.add(lineno)\n\n    return ret",
              "start_line": 556,
              "start_column": 19723,
              "end_line": 0,
              "end_column": 21855,
              "start_byte": 19723,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.run",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                isinstance(item, ast.ImportFrom)\n                and item.level == 0\n                and item.module == \"__future__\"\n            ):\n                pass\n            else:\n                break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        if sys.version_info >= (3, 10):\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n                ast.alias(\n                    \"_pytest.assertion.rewrite\",\n                    \"@pytest_ar\",\n                    lineno=lineno,\n                    col_offset=0,\n                ),\n            ]\n        else:\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\"),\n                ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n            ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        nodes: List[ast.AST] = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new: List[ast.AST] = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
              "start_line": 678,
              "start_column": 24851,
              "end_line": 4,
              "end_column": 28032,
              "start_byte": 24851,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: List[ast.stmt] = []\n        self.variables: List[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: List[str] = []\n\n        self.stack: List[Dict[str, ast.expr]] = []\n        self.expl_stmts: List[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Str(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Str(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Num(assert_.lineno),\n                    ast.Str(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                self.expl_stmts + [hook_call_pass],\n                [],\n            )\n            statements_pass = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.NameConstant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Str(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.NameConstant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                ast.copy_location(node, assert_)\n        return self.statements",
              "start_line": 845,
              "start_column": 31679,
              "end_line": 4,
              "end_column": 36553,
              "start_byte": 31679,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n ",
              "start_line": 177,
              "start_column": 6286,
              "end_line": 0,
              "end_column": 6474,
              "start_byte": 6286,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.format_explanation",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def format_explanation(explanation: str) -> str:\n    r\"\"\"Format an explanation.\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return \"\\n\".join(result)",
              "start_line": 34,
              "start_column": 1123,
              "end_line": 0,
              "end_column": 1684,
              "start_byte": 1123,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands.\"\"\"\n    verbose = config.getoption(\"verbose\")\n    if verbose > 1:\n        left_repr = safeformat(left)\n        right_repr = safeformat(right)\n    else:\n        # XXX: \"15 chars indentation\" is wrong\n        #      (\"E       AssertionError: assert \"); should use term width.\n        maxsize = (\n            80 - 15 - len(op) - 2\n        ) // 2  # 15 chars indentation, 1 space around op\n        left_repr = saferepr(left, maxsize=maxsize)\n        right_repr = saferepr(right, maxsize=maxsize)\n\n    summary = f\"{left_repr} {op} {right_repr}\"\n\n    explanation = None\n    try:\n        if op == \"==\":\n            explanation = _compare_eq_any(left, right, verbose)\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed: {}.\".format(\n                _pytest._code.ExceptionInfo.from_current()._getreprcrash()\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
              "start_line": 137,
              "start_column": 4125,
              "end_line": 0,
              "end_column": 5490,
              "start_byte": 4125,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._compare_eq_any",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def _compare_eq_any(left: Any, right: Any, verbose: int = 0) -> List[str]:\n    explanation = []\n    if istext(left) and istext(right):\n        explanation = _diff_text(left, right, verbose)\n    else:\n        from _pytest.python_api import ApproxBase\n\n        if isinstance(left, ApproxBase) or isinstance(right, ApproxBase):\n            # Although the common order should be obtained == expected, this ensures both ways\n            approx_side = left if isinstance(left, ApproxBase) else right\n            other_side = right if isinstance(left, ApproxBase) else left\n\n            explanation = approx_side._repr_compare(other_side)\n        elif type(left) == type(right) and (\n            isdatacls(left) or isattrs(left) or isnamedtuple(left)\n        ):\n            # Note: unlike dataclasses/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n            # used in older code bases before dataclasses/attrs were available.\n            explanation = _compare_eq_cls(left, right, verbose)\n        elif issequence(left) and issequence(right):\n            explanation = _compare_eq_sequence(left, right, verbose)\n        elif isset(left) and isset(right):\n            explanation = _compare_eq_set(left, right, verbose)\n        elif isdict(left) and isdict(right):\n            explanation = _compare_eq_dict(left, right, verbose)\n        elif verbose > 0:\n            explanation = _compare_eq_verbose(left, right)\n\n        if isiterable(left) and isiterable(right):\n            expl = _compare_eq_iterable(left, right, verbose)\n            explanation.extend(expl)\n\n    return explanation",
              "start_line": 177,
              "start_column": 5493,
              "end_line": 0,
              "end_column": 7215,
              "start_byte": 5493,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "",
              "start_line": 628,
              "start_column": 21725,
              "end_line": 0,
              "end_column": 22273,
              "start_byte": 21725,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.DoctestItem.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "one\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Function marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Get the underlying Python object. May be overwritten by subclasses.\"\"\"\n        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.\n        assert self.parent is not None\n        obj = self.parent.obj  # type: ignore[attr-defined]\n        return getattr(obj, self.name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            name = node.name\n            if isinstance(node, Module):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.PathLike[str]\", str], Optional[int], str]:\n        # XXX caching?\n        obj = self.obj\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[obj.__module__].__file__\n            if file_path.endswith(\".pyc\"):\n                file_path = file_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        assert isinstance(lineno, int)\n        return path, lineno, modpath\n\n\n# As an optimization, these builtin attribute names are pre-ignored when\n# iterating over an object during collection -- the pytest_pycollect_makeitem\n# hook is not called for them.\n# fmt: off\nclass _EmptyClass: pass  # noqa: E701\nIGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file",
              "start_line": 309,
              "start_column": 9828,
              "end_line": 4,
              "end_column": 12594,
              "start_byte": 9828,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node._repr_failure_py",
              "file_path": "src/_pytest/python.py",
              "file_content": "assnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_classes\", name)\n\n    def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False\n\n    def istestclass(self, obj: object, name: str) -> bool:\n        return self.classnamefilter(name) or self.isnosetest(obj)\n\n    def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:\n        \"\"\"Check if the given name matches the prefix or glob-pattern defined\n        in ini configuration.\"\"\"\n        for option in self.config.getini(option_name):\n            if name.startswith(option):\n                return True\n            # Check that name looks like a glob-string before calling fnmatch\n            # because this is called for every name in each collected module,\n            # and fnmatch is somewhat expensive to call.\n            elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n                name, option\n            ):\n                return True\n        return False\n\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered. Since Python 3.6,\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name",
              "start_line": 418,
              "start_column": 13319,
              "end_line": 4,
              "end_column": 15575,
              "start_byte": 13319,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n          ",
              "start_line": 473,
              "start_column": 15581,
              "end_line": 4,
              "end_column": 15942,
              "start_byte": 15581,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "      methods = []\n        if hasattr(module, \"pytest_generate_tests\"):\n            methods.append(module.pytest_generate_tests)\n        if cls is not None and hasattr(cls, \"pytest_generate_tests\"):\n            methods.append(cls().pytest_generate_tests)\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n\n        if not metafunc._calls:\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n        else:\n            # Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.\n            fm = self.session._fixturemanager\n            fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n\n            # Add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n            # with direct parametrization, ",
              "start_line": 517,
              "start_column": 17165,
              "end_line": 4,
              "end_column": 17949,
              "start_byte": 17165,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_makereport",
              "file_path": "src/_pytest/runner.py",
              "file_content": "ok.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
              "start_line": 521,
              "start_column": 18271,
              "end_line": 0,
              "end_column": 18745,
              "start_byte": 18271,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 217,
              "start_column": 6851,
              "end_line": 0,
              "end_column": 7333,
              "start_byte": 6851,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_runtest_hook",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_runtest_hook(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", **kwds\n) -> \"CallInfo[None]\":\n    if when == \"setup\":\n        ihook: Callable[..., None] = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:\n        assert False, f\"Unhandled runtest hook case: {when}\"\n    reraise: Tuple[Type[BaseException], ...] = (Exit,)\n    if not item.config.getoption(\"usepdb\", False):\n        reraise += (KeyboardInterrupt,)\n    return CallInfo.from_call(\n        lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )",
              "start_line": 245,
              "start_column": 7829,
              "end_line": 0,
              "end_column": 8511,
              "start_byte": 7829,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.CallInfo.from_call",
              "file_path": "src/_pytest/runner.py",
              "file_content": "@classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n\n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n            result: Optional[TResult] = func()\n        except BaseException:\n            excinfo = ExceptionInfo.from_current()\n            if reraise is not None and isinstance(excinfo.value, reraise):\n                raise\n            result = None\n        # use the perf counter\n        precise_stop = timing.perf_counter()\n        duration = precise_stop - precise_start\n        stop = timing.time()\n        return cls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )",
              "start_line": 316,
              "start_column": 10263,
              "end_line": 4,
              "end_column": 11679,
              "start_byte": 10263,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_makereport",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)",
              "start_line": 365,
              "start_column": 11897,
              "end_line": 0,
              "end_column": 12028,
              "start_byte": 11897,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/runner.py",
              "file_content": "nal[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.\n    duration: float\n    #: The context of invocation: \"collect\", \"setup\", \"call\" or \"teardown\".\n    when: \"Literal['collect', 'setup', 'call', 'teardown']\"\n\n    def __init__(\n        self,\n        result: Optional[TResult],\n        excinfo: Optional[ExceptionInfo[BaseException]],\n        start: float,\n        stop: float,\n        duration: float,\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._result = result\n        self.excinfo = excinfo\n        self.start = start\n        self.stop = stop\n        self.duration = duration\n        self.when = when\n\n    @property\n    def result(self) -> TResult:\n        \"\"\"The return value of the call, if it didn't raise.\n\n        Can only be accessed if ex",
              "start_line": 261,
              "start_column": 8818,
              "end_line": 0,
              "end_column": 9891,
              "start_byte": 8818,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.pytest_runtest_makereport",
              "file_path": "src/_pytest/runner.py",
              "file_content": "ls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )\n\n    def __repr__(self) -> str:\n        if self.excinfo is None:\n            return f\"<CallInfo when={self.when!r} result: {self._result!r}>\"\n        return f\"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>\"\n\n\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\n\n\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"u",
              "start_line": 332,
              "start_column": 11480,
              "end_line": 0,
              "end_column": 12427,
              "start_byte": 11480,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": " will invoke the configure hooks and runtest_mainloop.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"\n\n\nde",
              "start_line": 177,
              "start_column": 6286,
              "end_line": 0,
              "end_column": 6474,
              "start_byte": 6286,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": ".. versionchanged:: 7.0.0\n        The ``fspath`` parameter was added as a :class:`pathlib.Path`\n        equivalent of the ``path`` parameter. The ``path`` parameter\n        has been deprecated.\n    \"\"\"\n\n\ndef pytest_collect_file(\n    fspath: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n) -> \"Optional[Collector]\":\n    \"\"\"Create a Collector for the given path, or None if not relevant.\n\n    The new node needs to have the specified ``parent`` as a parent.\n\n    ",
              "start_line": 285,
              "start_column": 9713,
              "end_line": 4,
              "end_column": 10175,
              "start_byte": 9713,
              "end_byte": 4
            },
            {
              "name": "_pytest.faulthandler.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "ytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :param pytest.Parser parser:\n        To add command line options, call\n        :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.\n        To add ini-f",
              "start_line": 90,
              "start_column": 2953,
              "end_line": 0,
              "end_column": 3186,
              "start_byte": 2953,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertrepr_compare",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:\n    \"\"\"Return explanation for comparisons in failing assert expressions.\n\n    Return None for no custom explanation, otherwise return a list\n    of strings. The strings will be joined by newlines but any newlines\n    *in* a string will be escaped. Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"",
              "start_line": 628,
              "start_column": 21725,
              "end_line": 0,
              "end_column": 22273,
              "start_byte": 21725,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertion_pass",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n    \"\"\"Called whenever an assertion passes.\n\n    .. versionadded:: 5.0\n\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n\n    .. code-block:: ini\n\n        [pytest]\n        enable_assertion_pass_hook=true\n\n    You need to **clean the .pyc** files in your project directory and interpreter libraries\n    when enabling this option, as assertions will require to be re-written.\n\n    :param pytest.Item item: pytest item object of current test.\n    :param int lineno: Line number of the assert statement.\n    :param str orig: String with the original assertion.\n    :param str expl: String with the assert explanation.\n    \"\"\"",
              "start_line": 642,
              "start_column": 22276,
              "end_line": 0,
              "end_column": 23266,
              "start_byte": 22276,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_exception_interact",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "def pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> None:\n    \"\"\"Called when an exception was raised which can potentially be\n    interactively handled.\n\n    May be called during collection (see :py:func:`pytest_make_collect_report`),\n    in which case ``report`` is a :class:`CollectReport`.\n\n    May be called during runtest of an item (see :py:func:`pytest_runtest_protocol`),\n    in which case ``report`` is a :class:`TestReport`.\n\n    This hook is not called if the exception that was raised is an internal\n    exception like ``skip.Exception``.\n    \"\"\"",
              "start_line": 889,
              "start_column": 31127,
              "end_line": 0,
              "end_column": 31784,
              "start_byte": 31127,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.nodes.Node._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "on) as test classes.\n        return safe_getattr(obj, \"__test__\", False) is True\n\n    ",
              "start_line": 415,
              "start_column": 13227,
              "end_line": 4,
              "end_column": 13313,
              "start_byte": 13227,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Collector._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "e sure we update what the\n            # function really needs.\n            fixtureinfo.prune_dependency_tree()\n\n            for callspec in metafunc._calls:\n                subname = f\"{name}[{callspec.id}]\"\n                yield Function.from_parent(\n                    self,\n                    name=subname,\n                    callspec=callspec,\n                  ",
              "start_line": 538,
              "start_column": 17955,
              "end_line": 4,
              "end_column": 18324,
              "start_byte": 17955,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code.from_function(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame.\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
              "start_line": 1713,
              "start_column": 64881,
              "end_line": 4,
              "end_column": 65989,
              "start_byte": 64881,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "def repr_failure(  # type: ignore[override]\n        self,\n        excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1735,
              "start_column": 66051,
              "end_line": 4,
              "end_column": 66361,
              "start_byte": 66051,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "e):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.",
              "start_line": 321,
              "start_column": 11153,
              "end_line": 4,
              "end_column": 11477,
              "start_byte": 11153,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1.1 What issue is the user describing?\nThe issue is about an error message in pytest for Python 3.9 containing extra code lines not present in earlier versions (like Python 3.7).\n\n1.2 How was this issue caused?\nThe issue might be related to the assertion rewriting mechanism in pytest, which seems to behave differently in Python 3.9 compared to 3.7.\n\n1.3 If the user described the expected result, what should it be fixed to?\nThe error message should not include the extra decorator code lines in its output.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\nThe expectation would be an error message showing only relevant assertion failure details without extra code lines.\n\n1.5 How should the issue be fixed to meet the expectation?\nThe pytest assertion rewriting logic might need to be adjusted or fixed to ensure it handles decorators or multiline assertions correctly across Python versions, especially in Python 3.9, matching the behavior in Python 3.7.",
          "symbols": [
            {
              "name": "_pytest.python.Function._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "reason": "Handles traceback pruning, possibly needs adjustment to ensure extra lines aren't included in output."
            },
            {
              "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "Responsible for rewriting asserts, could be introducing changes in Python 3.9."
            },
            {
              "name": "_pytest.assertion.rewrite_asserts",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "Rewrites assert statements, possibly involved in adding extra output in 3.9."
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.run",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "Involved in assertion rewriting, could be causing different behavior in test outputs."
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "Handles assert transformations, possibly affecting how assertion errors are displayed."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The symbol '_pytest.nodes.Node._prunetraceback' content is not directly provided, but it likely deals with traceback pruning, which can affect how error messages are displayed. If traceback includes more lines in Python 3.9, this could be involved.",
            "The symbol '_pytest.nodes.Collector._prunetraceback' content is not available, but like Node, it likely deals with pruning traceback and thus related to how error messages might have extra content.",
            "This function '_pytest.python.Function._prunetraceback' already prunes the traceback when 'fulltrace' option is not enabled. Modifying the way tracebacks are cut could adjust the output to avoid extra lines.",
            "The function '_pytest.python.Function.repr_failure' determines the representation of a failure in terms of style, which might indirectly relate if formatting needs adjusting for different Python versions.",
            "The symbol '_pytest.unittest.TestCaseFunction._prunetraceback' content is not provided, but it presumably also manages traceback pruning in a manner that could interact with assert output",
            "The symbol '_pytest.assertion.assertstate_key' is unrelated to the rewriting process; it involves a key for state tracking.",
            "The function '_pytest.assertion.AssertionRewritingHook.exec_module' is responsible for rewriting modules and could be central to changes in output between Python versions.",
            "'The symbol '_pytest.assertion.rewrite_asserts' is directly related to rewriting assert statements, potentially causing or influencing the difference in assert output between Python versions.'",
            "The symbol '_pytest.assertion._get_assertion_exprs' is related to mapping assertion expressions, unlikely to need changes unless expressions themselves are misrepresented.",
            "The function '_pytest.assertion.AssertionRewriter.run' finds and rewrites all assert statements, likely needing investigation for influencing output differences.",
            "The function '_pytest.assertion.AssertionRewriter.visit_Assert' rewrites individual assert statements, which could be modified to ensure they do not introduce extra code lines in errors.",
            "The symbol '_pytest.assertion.pytest_assertrepr_compare' deals with specialized assertion explanation but doesn't relate to rewriting process or output issues.",
            "The function '_pytest.assertion.format_explanation' formats explanations but isn't directly related to inclusion of extra assert expression lines.",
            "The symbol '_pytest.assertion.assertrepr_compare' might be relevant if it affects how assertions are represented during failure, but unrelated to code line output.",
            "The symbol '_pytest.assertion._compare_eq_any' is irrelevant to the rewriting mechanism; it strictly deals with comparing equality for explanations.",
            "The hook '_pytest.hookspec.pytest_assertrepr_compare' offers a mechanism for custom comparison representation, but doesn't participate in the rewriting framework.",
            "The symbol '_pytest.doctest.DoctestItem.repr_failure' relates to doctest failures but isn't relevant to Python 3.9 assertions and their message output.",
            "The symbol '_pytest.nodes.Node._repr_failure_py' would affect test node failure representation but isn't the root cause of different output in Python versions.",
            "The symbol '_pytest.nodes.Node.repr_failure' manages failure representation for arbitrary nodes, but the central issue remains with the assertion system.",
            "The symbol '_pytest.nodes.Collector.repr_failure' covers collector failure representation, unrelated to assertion failure details.",
            "The hook '_pytest.hookspec.pytest_runtest_makereport' processes runtest reports, indirectly related through report accuracy and content.",
            "The function '_pytest.runner.call_and_report' makes reports on test results, interacting with runtest hook, report could receive refined traceback.",
            "The function '_pytest.runner.call_runtest_hook' queries hook setup but is a utility, a background process.",
            "The symbol '_pytest.runner.CallInfo.from_call' manages calling process and lifecycle, indirectly linked to runtime behavior for errors.",
            "The function '_pytest.runner.pytest_runtest_makereport' constructs test report linking CallInfo but it's a structural element not processing errors precision like assertions.",
            "The symbol '_pytest.skipping.pytest_runtest_makereport' expands on test report but doesn't influence rewriting.",
            "The symbol '_pytest.unittest.pytest_runtest_makereport' similar to others in making runtime reports doesn't intervene directly with assertion errors.",
            "The hook '_pytest.hookspec.pytest_assertrepr_compare' in hookspec is structurally same as util's, guides compare configs rather than execution.",
            "The symbol '_pytest.debugging.PdbInvoke.pytest_exception_interact' facilitates exception handling engagement, relationally irrelevant.",
            "The function '_pytest.faulthandler.pytest_exception_interact' noted here works in fault handling interaction.",
            "The hook '_pytest.hookspec.pytest_assertion_pass' involves passing assertion state which doesn't contribute to failures like in the scenario.",
            "The hook '_pytest.hookspec.pytest_exception_interact' allows handling exceptions interactively, not source of expressing or altering assertion outputs."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/python.py",
          "src/_pytest/assertion/rewrite.py"
        ],
        "symbols": [
          "_pytest.python.Function._prunetraceback",
          "_pytest.assertion.AssertionRewritingHook.exec_module",
          "_pytest.assertion.rewrite_asserts",
          "_pytest.assertion.AssertionRewriter.run",
          "_pytest.assertion.AssertionRewriter.visit_Assert"
        ],
        "code_spans": {
          "_pytest.assertion.assertstate_key": {
            "name": "_pytest.assertion.assertstate_key",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "assertstate_key = StashKey[\"AssertionState\"]()",
            "start_line": 47,
            "start_column": 1169,
            "end_line": 0,
            "end_column": 1215,
            "start_byte": 1169,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewritingHook.exec_module": {
            "name": "_pytest.assertion.AssertionRewritingHook.exec_module",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def exec_module(self, module: types.ModuleType) -> None:\n        assert module.__spec__ is not None\n        assert module.__spec__.origin is not None\n        fn = Path(module.__spec__.origin)\n        state = self.config.stash[assertstate_key]\n\n        self._rewritten_names[module.__name__] = fn\n\n        # The requested module looks like a test file, so rewrite it. This is\n        # the most magical part of the process: load the source, rewrite the\n        # asserts, and load the rewritten source. We also cache the rewritten\n        # module code in a special pyc. We must be aware of the possibility of\n        # concurrent pytest processes rewriting and loading pycs. To avoid\n        # tricky race conditions, we maintain the following invariant: The\n        # cached pyc is always a complete, valid pyc. Operations on it must be\n        # atomic. POSIX's atomic rename comes in handy.\n        write = not sys.dont_write_bytecode\n        cache_dir = get_cache_dir(fn)\n        if write:\n            ok = try_makedirs(cache_dir)\n            if not ok:\n                write = False\n                state.trace(f\"read only directory: {cache_dir}\")\n\n        cache_name = fn.name[:-3] + PYC_TAIL\n        pyc = cache_dir / cache_name\n        # Notice that even if we're in a read-only directory, I'm going\n        # to check for a cached pyc. This may not be optimal...\n        co = _read_pyc(fn, pyc, state.trace)\n        if co is None:\n            state.trace(f\"rewriting {fn!r}\")\n            source_stat, co = _rewrite_test(fn, self.config)\n            if write:\n                self._writing_pyc = True\n                try:\n                    _write_pyc(state, co, source_stat, pyc)\n                finally:\n                    self._writing_pyc = False\n        else:\n            state.trace(f\"found cached rewritten pyc for {fn}\")\n        exec(co, module.__dict__)",
            "start_line": 130,
            "start_column": 4293,
            "end_line": 4,
            "end_column": 6165,
            "start_byte": 4293,
            "end_byte": 4
          },
          "_pytest.assertion.rewrite_asserts": {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(\n    mod: ast.Module,\n    source: bytes,\n    module_path: Optional[str] = None,\n    config: Optional[Config] = None,\n) -> None:\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config, source).run(mod)",
            "start_line": 418,
            "start_column": 15578,
            "end_line": 0,
            "end_column": 15833,
            "start_byte": 15578,
            "end_byte": 0
          },
          "_pytest.assertion._get_assertion_exprs": {
            "name": "_pytest.assertion._get_assertion_exprs",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@functools.lru_cache(maxsize=1)\ndef _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n    \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n    ret: Dict[int, str] = {}\n\n    depth = 0\n    lines: List[str] = []\n    assert_lineno: Optional[int] = None\n    seen_lines: Set[int] = set()\n\n    def _write_and_reset() -> None:\n        nonlocal depth, lines, assert_lineno, seen_lines\n        assert assert_lineno is not None\n        ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n        depth = 0\n        lines = []\n        assert_lineno = None\n        seen_lines = set()\n\n    tokens = tokenize.tokenize(io.BytesIO(src).readline)\n    for tp, source, (lineno, offset), _, line in tokens:\n        if tp == tokenize.NAME and source == \"assert\":\n            assert_lineno = lineno\n        elif assert_lineno is not None:\n            # keep track of depth for the assert-message `,` lookup\n            if tp == tokenize.OP and source in \"([{\":\n                depth += 1\n            elif tp == tokenize.OP and source in \")]}\":\n                depth -= 1\n\n            if not lines:\n                lines.append(line[offset:])\n                seen_lines.add(lineno)\n            # a non-nested comma separates the expression from the message\n            elif depth == 0 and tp == tokenize.OP and source == \",\":\n                # one line assert with message\n                if lineno in seen_lines and len(lines) == 1:\n                    offset_in_trimmed = offset + len(lines[-1]) - len(line)\n                    lines[-1] = lines[-1][:offset_in_trimmed]\n                # multi-line assert with message\n                elif lineno in seen_lines:\n                    lines[-1] = lines[-1][:offset]\n                # multi line assert with escapd newline before message\n                else:\n                    lines.append(line[:offset])\n                _write_and_reset()\n            elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n                _write_and_reset()\n            elif lines and lineno not in seen_lines:\n                lines.append(line)\n                seen_lines.add(lineno)\n\n    return ret",
            "start_line": 556,
            "start_column": 19723,
            "end_line": 0,
            "end_column": 21855,
            "start_byte": 19723,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter.run": {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod: ast.Module) -> None:\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n\n        # We'll insert some special imports at the top of the module, but after any\n        # docstrings and __future__ imports, so first figure out where that is.\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                isinstance(item, ast.ImportFrom)\n                and item.level == 0\n                and item.module == \"__future__\"\n            ):\n                pass\n            else:\n                break\n            pos += 1\n        # Special case: for a decorated function, set the lineno to that of the\n        # first decorator, not the `def`. Issue #4984.\n        if isinstance(item, ast.FunctionDef) and item.decorator_list:\n            lineno = item.decorator_list[0].lineno\n        else:\n            lineno = item.lineno\n        # Now actually insert the special imports.\n        if sys.version_info >= (3, 10):\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n                ast.alias(\n                    \"_pytest.assertion.rewrite\",\n                    \"@pytest_ar\",\n                    lineno=lineno,\n                    col_offset=0,\n                ),\n            ]\n        else:\n            aliases = [\n                ast.alias(\"builtins\", \"@py_builtins\"),\n                ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n            ]\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n\n        # Collect asserts.\n        nodes: List[ast.AST] = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new: List[ast.AST] = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 678,
            "start_column": 24851,
            "end_line": 4,
            "end_column": 28032,
            "start_byte": 24851,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Assert": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            # TODO: This assert should not be needed.\n            assert self.module_path is not None\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements: List[ast.stmt] = []\n        self.variables: List[str] = []\n        self.variable_counter = itertools.count()\n\n        if self.enable_assertion_pass_hook:\n            self.format_variables: List[str] = []\n\n        self.stack: List[Dict[str, ast.expr]] = []\n        self.expl_stmts: List[ast.stmt] = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n\n        if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n            msg = self.pop_format_context(ast.Str(explanation))\n\n            # Failed\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                gluestr = \"\\n>assert \"\n            else:\n                assertmsg = ast.Str(\"\")\n                gluestr = \"assert \"\n            err_explanation = ast.BinOp(ast.Str(gluestr), ast.Add(), msg)\n            err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            fmt = self.helper(\"_format_explanation\", err_msg)\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n            statements_fail = []\n            statements_fail.extend(self.expl_stmts)\n            statements_fail.append(raise_)\n\n            # Passed\n            fmt_pass = self.helper(\"_format_explanation\", msg)\n            orig = _get_assertion_exprs(self.source)[assert_.lineno]\n            hook_call_pass = ast.Expr(\n                self.helper(\n                    \"_call_assertion_pass\",\n                    ast.Num(assert_.lineno),\n                    ast.Str(orig),\n                    fmt_pass,\n                )\n            )\n            # If any hooks implement assert_pass hook\n            hook_impl_test = ast.If(\n                self.helper(\"_check_if_assertion_pass_impl\"),\n                self.expl_stmts + [hook_call_pass],\n                [],\n            )\n            statements_pass = [hook_impl_test]\n\n            # Test for assertion condition\n            main_test = ast.If(negation, statements_fail, statements_pass)\n            self.statements.append(main_test)\n            if self.format_variables:\n                variables = [\n                    ast.Name(name, ast.Store()) for name in self.format_variables\n                ]\n                clear_format = ast.Assign(variables, ast.NameConstant(None))\n                self.statements.append(clear_format)\n\n        else:  # Original assertion rewriting\n            # Create failure message.\n            body = self.expl_stmts\n            self.statements.append(ast.If(negation, body, []))\n            if assert_.msg:\n                assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n                explanation = \"\\n>assert \" + explanation\n            else:\n                assertmsg = ast.Str(\"\")\n                explanation = \"assert \" + explanation\n            template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n            msg = self.pop_format_context(template)\n            fmt = self.helper(\"_format_explanation\", msg)\n            err_name = ast.Name(\"AssertionError\", ast.Load())\n            exc = ast.Call(err_name, [fmt], [])\n            raise_ = ast.Raise(exc, None)\n\n            body.append(raise_)\n\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, ast.NameConstant(None))\n            self.statements.append(clear)\n        # Fix locations (line numbers/column offsets).\n        for stmt in self.statements:\n            for node in traverse_node(stmt):\n                ast.copy_location(node, assert_)\n        return self.statements",
            "start_line": 845,
            "start_column": 31679,
            "end_line": 4,
            "end_column": 36553,
            "start_byte": 31679,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_assertrepr_compare": {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " will invoke the configure hooks and runtest_mainloop.\n\n    Stops at first non-None result, see :ref:`firstresult`.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"\n\n\nde",
            "start_line": 177,
            "start_column": 6286,
            "end_line": 0,
            "end_column": 6474,
            "start_byte": 6286,
            "end_byte": 0
          },
          "_pytest.assertion.format_explanation": {
            "name": "_pytest.assertion.format_explanation",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def format_explanation(explanation: str) -> str:\n    r\"\"\"Format an explanation.\n\n    Normally all embedded newlines are escaped, however there are\n    three exceptions: \\n{, \\n} and \\n~.  The first two are intended\n    cover nested explanations, see function and attribute explanations\n    for examples (.visit_Call(), visit_Attribute()).  The last one is\n    for when one explanation needs to span multiple lines, e.g. when\n    displaying diffs.\n    \"\"\"\n    lines = _split_explanation(explanation)\n    result = _format_lines(lines)\n    return \"\\n\".join(result)",
            "start_line": 34,
            "start_column": 1123,
            "end_line": 0,
            "end_column": 1684,
            "start_byte": 1123,
            "end_byte": 0
          },
          "_pytest.assertion.assertrepr_compare": {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op: str, left: Any, right: Any) -> Optional[List[str]]:\n    \"\"\"Return specialised explanations for some operators/operands.\"\"\"\n    verbose = config.getoption(\"verbose\")\n    if verbose > 1:\n        left_repr = safeformat(left)\n        right_repr = safeformat(right)\n    else:\n        # XXX: \"15 chars indentation\" is wrong\n        #      (\"E       AssertionError: assert \"); should use term width.\n        maxsize = (\n            80 - 15 - len(op) - 2\n        ) // 2  # 15 chars indentation, 1 space around op\n        left_repr = saferepr(left, maxsize=maxsize)\n        right_repr = saferepr(right, maxsize=maxsize)\n\n    summary = f\"{left_repr} {op} {right_repr}\"\n\n    explanation = None\n    try:\n        if op == \"==\":\n            explanation = _compare_eq_any(left, right, verbose)\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed: {}.\".format(\n                _pytest._code.ExceptionInfo.from_current()._getreprcrash()\n            ),\n            \" Probably an object has a faulty __repr__.)\",\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 4125,
            "end_line": 0,
            "end_column": 5490,
            "start_byte": 4125,
            "end_byte": 0
          },
          "_pytest.assertion._compare_eq_any": {
            "name": "_pytest.assertion._compare_eq_any",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_any(left: Any, right: Any, verbose: int = 0) -> List[str]:\n    explanation = []\n    if istext(left) and istext(right):\n        explanation = _diff_text(left, right, verbose)\n    else:\n        from _pytest.python_api import ApproxBase\n\n        if isinstance(left, ApproxBase) or isinstance(right, ApproxBase):\n            # Although the common order should be obtained == expected, this ensures both ways\n            approx_side = left if isinstance(left, ApproxBase) else right\n            other_side = right if isinstance(left, ApproxBase) else left\n\n            explanation = approx_side._repr_compare(other_side)\n        elif type(left) == type(right) and (\n            isdatacls(left) or isattrs(left) or isnamedtuple(left)\n        ):\n            # Note: unlike dataclasses/attrs, namedtuples compare only the\n            # field values, not the type or field names. But this branch\n            # intentionally only handles the same-type case, which was often\n            # used in older code bases before dataclasses/attrs were available.\n            explanation = _compare_eq_cls(left, right, verbose)\n        elif issequence(left) and issequence(right):\n            explanation = _compare_eq_sequence(left, right, verbose)\n        elif isset(left) and isset(right):\n            explanation = _compare_eq_set(left, right, verbose)\n        elif isdict(left) and isdict(right):\n            explanation = _compare_eq_dict(left, right, verbose)\n        elif verbose > 0:\n            explanation = _compare_eq_verbose(left, right)\n\n        if isiterable(left) and isiterable(right):\n            expl = _compare_eq_iterable(left, right, verbose)\n            explanation.extend(expl)\n\n    return explanation",
            "start_line": 177,
            "start_column": 5493,
            "end_line": 0,
            "end_column": 7215,
            "start_byte": 5493,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_assertrepr_compare": {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertrepr_compare(\n    config: \"Config\", op: str, left: object, right: object\n) -> Optional[List[str]]:\n    \"\"\"Return explanation for comparisons in failing assert expressions.\n\n    Return None for no custom explanation, otherwise return a list\n    of strings. The strings will be joined by newlines but any newlines\n    *in* a string will be escaped. Note that all but the first line will\n    be indented slightly, the intention is for the first line to be a summary.\n\n    :param pytest.Config config: The pytest config object.\n    \"\"\"",
            "start_line": 628,
            "start_column": 21725,
            "end_line": 0,
            "end_column": 22273,
            "start_byte": 21725,
            "end_byte": 0
          },
          "_pytest.doctest.DoctestItem.repr_failure": {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "one\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Function marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Get the underlying Python object. May be overwritten by subclasses.\"\"\"\n        # TODO: Improve the type of `parent` such that assert/ignore aren't needed.\n        assert self.parent is not None\n        obj = self.parent.obj  # type: ignore[attr-defined]\n        return getattr(obj, self.name)\n\n    def getmodpath(self, stopatmodule: bool = True, includemodule: bool = False) -> str:\n        \"\"\"Return Python path relative to the containing module.\"\"\"\n        chain = self.listchain()\n        chain.reverse()\n        parts = []\n        for node in chain:\n            name = node.name\n            if isinstance(node, Module):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.PathLike[str]\", str], Optional[int], str]:\n        # XXX caching?\n        obj = self.obj\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[obj.__module__].__file__\n            if file_path.endswith(\".pyc\"):\n                file_path = file_path[:-1]\n            path: Union[\"os.PathLike[str]\", str] = file_path\n            lineno = compat_co_firstlineno\n        else:\n            path, lineno = getfslineno(obj)\n        modpath = self.getmodpath()\n        assert isinstance(lineno, int)\n        return path, lineno, modpath\n\n\n# As an optimization, these builtin attribute names are pre-ignored when\n# iterating over an object during collection -- the pytest_pycollect_makeitem\n# hook is not called for them.\n# fmt: off\nclass _EmptyClass: pass  # noqa: E701\nIGNORED_ATTRIBUTES = frozenset.union(  # noqa: E305\n    frozenset(),\n    # Module.\n    dir(types.ModuleType(\"empty_module\")),\n    # Some extra module attributes the above doesn't catch.\n    {\"__builtins__\", \"__file",
            "start_line": 309,
            "start_column": 9828,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 9828,
            "end_byte": 4
          },
          "_pytest.nodes.Node._repr_failure_py": {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/python.py",
            "file_content": "assnamefilter(self, name: str) -> bool:\n        return self._matches_prefix_or_glob_option(\"python_classes\", name)\n\n    def istestfunction(self, obj: object, name: str) -> bool:\n        if self.funcnamefilter(name) or self.isnosetest(obj):\n            if isinstance(obj, staticmethod):\n                # staticmethods need to be unwrapped.\n                obj = safe_getattr(obj, \"__func__\", False)\n            return callable(obj) and fixtures.getfixturemarker(obj) is None\n        else:\n            return False\n\n    def istestclass(self, obj: object, name: str) -> bool:\n        return self.classnamefilter(name) or self.isnosetest(obj)\n\n    def _matches_prefix_or_glob_option(self, option_name: str, name: str) -> bool:\n        \"\"\"Check if the given name matches the prefix or glob-pattern defined\n        in ini configuration.\"\"\"\n        for option in self.config.getini(option_name):\n            if name.startswith(option):\n                return True\n            # Check that name looks like a glob-string before calling fnmatch\n            # because this is called for every name in each collected module,\n            # and fnmatch is somewhat expensive to call.\n            elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n                name, option\n            ):\n                return True\n        return False\n\n    def collect(self) -> Iterable[Union[nodes.Item, nodes.Collector]]:\n        if not getattr(self.obj, \"__test__\", True):\n            return []\n\n        # Avoid random getattrs and peek in the __dict__ instead.\n        dicts = [getattr(self.obj, \"__dict__\", {})]\n        if isinstance(self.obj, type):\n            for basecls in self.obj.__mro__:\n                dicts.append(basecls.__dict__)\n\n        # In each class, nodes should be definition ordered. Since Python 3.6,\n        # __dict__ is definition ordered.\n        seen: Set[str] = set()\n        dict_values: List[List[Union[nodes.Item, nodes.Collector]]] = []\n        ihook = self.ihook\n        for dic in dicts:\n            values: List[Union[nodes.Item, nodes.Collector]] = []\n            # Note: seems like the dict can change during iteration -\n            # be careful not to remove the list() without consideration.\n            for name",
            "start_line": 418,
            "start_column": 13319,
            "end_line": 4,
            "end_column": 15575,
            "start_byte": 13319,
            "end_byte": 4
          },
          "_pytest.nodes.Node.repr_failure": {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "in list(dic.items()):\n                if name in IGNORED_ATTRIBUTES:\n                    continue\n                if name in seen:\n                    continue\n                seen.add(name)\n                res = ihook.pytest_pycollect_makeitem(\n                    collector=self, name=name, obj=obj\n                )\n                if res is None:\n          ",
            "start_line": 473,
            "start_column": 15581,
            "end_line": 4,
            "end_column": 15942,
            "start_byte": 15581,
            "end_byte": 4
          },
          "_pytest.nodes.Collector.repr_failure": {
            "name": "_pytest.nodes.Collector.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "      methods = []\n        if hasattr(module, \"pytest_generate_tests\"):\n            methods.append(module.pytest_generate_tests)\n        if cls is not None and hasattr(cls, \"pytest_generate_tests\"):\n            methods.append(cls().pytest_generate_tests)\n        self.ihook.pytest_generate_tests.call_extra(methods, dict(metafunc=metafunc))\n\n        if not metafunc._calls:\n            yield Function.from_parent(self, name=name, fixtureinfo=fixtureinfo)\n        else:\n            # Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.\n            fm = self.session._fixturemanager\n            fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n\n            # Add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n            # with direct parametrization, ",
            "start_line": 517,
            "start_column": 17165,
            "end_line": 4,
            "end_column": 17949,
            "start_byte": 17165,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ok.pytest_exception_interact(node=collector, call=call, report=rep)\n    return rep\n",
            "start_line": 521,
            "start_column": 18271,
            "end_line": 0,
            "end_column": 18745,
            "start_byte": 18271,
            "end_byte": 0
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report: TestReport = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 217,
            "start_column": 6851,
            "end_line": 0,
            "end_column": 7333,
            "start_byte": 6851,
            "end_byte": 0
          },
          "_pytest.runner.call_runtest_hook": {
            "name": "_pytest.runner.call_runtest_hook",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_runtest_hook(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", **kwds\n) -> \"CallInfo[None]\":\n    if when == \"setup\":\n        ihook: Callable[..., None] = item.ihook.pytest_runtest_setup\n    elif when == \"call\":\n        ihook = item.ihook.pytest_runtest_call\n    elif when == \"teardown\":\n        ihook = item.ihook.pytest_runtest_teardown\n    else:\n        assert False, f\"Unhandled runtest hook case: {when}\"\n    reraise: Tuple[Type[BaseException], ...] = (Exit,)\n    if not item.config.getoption(\"usepdb\", False):\n        reraise += (KeyboardInterrupt,)\n    return CallInfo.from_call(\n        lambda: ihook(item=item, **kwds), when=when, reraise=reraise\n    )",
            "start_line": 245,
            "start_column": 7829,
            "end_line": 0,
            "end_column": 8511,
            "start_byte": 7829,
            "end_byte": 0
          },
          "_pytest.runner.CallInfo.from_call": {
            "name": "_pytest.runner.CallInfo.from_call",
            "file_path": "src/_pytest/runner.py",
            "file_content": "@classmethod\n    def from_call(\n        cls,\n        func: \"Callable[[], TResult]\",\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        reraise: Optional[\n            Union[Type[BaseException], Tuple[Type[BaseException], ...]]\n        ] = None,\n    ) -> \"CallInfo[TResult]\":\n        \"\"\"Call func, wrapping the result in a CallInfo.\n\n        :param func:\n            The function to call. Called without arguments.\n        :param when:\n            The phase in which the function is called.\n        :param reraise:\n            Exception or exceptions that shall propagate if raised by the\n            function, instead of being wrapped in the CallInfo.\n        \"\"\"\n        excinfo = None\n        start = timing.time()\n        precise_start = timing.perf_counter()\n        try:\n            result: Optional[TResult] = func()\n        except BaseException:\n            excinfo = ExceptionInfo.from_current()\n            if reraise is not None and isinstance(excinfo.value, reraise):\n                raise\n            result = None\n        # use the perf counter\n        precise_stop = timing.perf_counter()\n        duration = precise_stop - precise_start\n        stop = timing.time()\n        return cls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )",
            "start_line": 316,
            "start_column": 10263,
            "end_line": 4,
            "end_column": 11679,
            "start_byte": 10263,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)",
            "start_line": 365,
            "start_column": 11897,
            "end_line": 0,
            "end_column": 12028,
            "start_byte": 11897,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "nal[ExceptionInfo[BaseException]]\n    #: The system time when the call started, in seconds since the epoch.\n    start: float\n    #: The system time when the call ended, in seconds since the epoch.\n    stop: float\n    #: The call duration, in seconds.\n    duration: float\n    #: The context of invocation: \"collect\", \"setup\", \"call\" or \"teardown\".\n    when: \"Literal['collect', 'setup', 'call', 'teardown']\"\n\n    def __init__(\n        self,\n        result: Optional[TResult],\n        excinfo: Optional[ExceptionInfo[BaseException]],\n        start: float,\n        stop: float,\n        duration: float,\n        when: \"Literal['collect', 'setup', 'call', 'teardown']\",\n        *,\n        _ispytest: bool = False,\n    ) -> None:\n        check_ispytest(_ispytest)\n        self._result = result\n        self.excinfo = excinfo\n        self.start = start\n        self.stop = stop\n        self.duration = duration\n        self.when = when\n\n    @property\n    def result(self) -> TResult:\n        \"\"\"The return value of the call, if it didn't raise.\n\n        Can only be accessed if ex",
            "start_line": 261,
            "start_column": 8818,
            "end_line": 0,
            "end_column": 9891,
            "start_byte": 8818,
            "end_byte": 0
          },
          "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ls(\n            start=start,\n            stop=stop,\n            duration=duration,\n            when=when,\n            result=result,\n            excinfo=excinfo,\n            _ispytest=True,\n        )\n\n    def __repr__(self) -> str:\n        if self.excinfo is None:\n            return f\"<CallInfo when={self.when!r} result: {self._result!r}>\"\n        return f\"<CallInfo when={self.when!r} excinfo={self.excinfo!r}>\"\n\n\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]) -> TestReport:\n    return TestReport.from_item_and_call(item, call)\n\n\ndef pytest_make_collect_report(collector: Collector) -> CollectReport:\n    call = CallInfo.from_call(lambda: list(collector.collect()), \"collect\")\n    longrepr: Union[None, Tuple[str, int, str], str, TerminalRepr] = None\n    if not call.excinfo:\n        outcome: Literal[\"passed\", \"skipped\", \"failed\"] = \"passed\"\n    else:\n        skip_exceptions = [Skipped]\n        unittest = sys.modules.get(\"u",
            "start_line": 332,
            "start_column": 11480,
            "end_line": 0,
            "end_column": 12427,
            "start_byte": 11480,
            "end_byte": 0
          },
          "_pytest.debugging.PdbInvoke.pytest_exception_interact": {
            "name": "_pytest.debugging.PdbInvoke.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": ".. versionchanged:: 7.0.0\n        The ``fspath`` parameter was added as a :class:`pathlib.Path`\n        equivalent of the ``path`` parameter. The ``path`` parameter\n        has been deprecated.\n    \"\"\"\n\n\ndef pytest_collect_file(\n    fspath: Path, path: \"LEGACY_PATH\", parent: \"Collector\"\n) -> \"Optional[Collector]\":\n    \"\"\"Create a Collector for the given path, or None if not relevant.\n\n    The new node needs to have the specified ``parent`` as a parent.\n\n    ",
            "start_line": 285,
            "start_column": 9713,
            "end_line": 4,
            "end_column": 10175,
            "start_byte": 9713,
            "end_byte": 4
          },
          "_pytest.faulthandler.pytest_exception_interact": {
            "name": "_pytest.faulthandler.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :param pytest.Parser parser:\n        To add command line options, call\n        :py:func:`parser.addoption(...) <pytest.Parser.addoption>`.\n        To add ini-f",
            "start_line": 90,
            "start_column": 2953,
            "end_line": 0,
            "end_column": 3186,
            "start_byte": 2953,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_assertion_pass": {
            "name": "_pytest.hookspec.pytest_assertion_pass",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_assertion_pass(item: \"Item\", lineno: int, orig: str, expl: str) -> None:\n    \"\"\"Called whenever an assertion passes.\n\n    .. versionadded:: 5.0\n\n    Use this hook to do some processing after a passing assertion.\n    The original assertion information is available in the `orig` string\n    and the pytest introspected assertion information is available in the\n    `expl` string.\n\n    This hook must be explicitly enabled by the ``enable_assertion_pass_hook``\n    ini-file option:\n\n    .. code-block:: ini\n\n        [pytest]\n        enable_assertion_pass_hook=true\n\n    You need to **clean the .pyc** files in your project directory and interpreter libraries\n    when enabling this option, as assertions will require to be re-written.\n\n    :param pytest.Item item: pytest item object of current test.\n    :param int lineno: Line number of the assert statement.\n    :param str orig: String with the original assertion.\n    :param str expl: String with the assert explanation.\n    \"\"\"",
            "start_line": 642,
            "start_column": 22276,
            "end_line": 0,
            "end_column": 23266,
            "start_byte": 22276,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_exception_interact": {
            "name": "_pytest.hookspec.pytest_exception_interact",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "def pytest_exception_interact(\n    node: Union[\"Item\", \"Collector\"],\n    call: \"CallInfo[Any]\",\n    report: Union[\"CollectReport\", \"TestReport\"],\n) -> None:\n    \"\"\"Called when an exception was raised which can potentially be\n    interactively handled.\n\n    May be called during collection (see :py:func:`pytest_make_collect_report`),\n    in which case ``report`` is a :class:`CollectReport`.\n\n    May be called during runtest of an item (see :py:func:`pytest_runtest_protocol`),\n    in which case ``report`` is a :class:`TestReport`.\n\n    This hook is not called if the exception that was raised is an internal\n    exception like ``skip.Exception``.\n    \"\"\"",
            "start_line": 889,
            "start_column": 31127,
            "end_line": 0,
            "end_column": 31784,
            "start_byte": 31127,
            "end_byte": 0
          },
          "_pytest.nodes.Node._prunetraceback": {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "on) as test classes.\n        return safe_getattr(obj, \"__test__\", False) is True\n\n    ",
            "start_line": 415,
            "start_column": 13227,
            "end_line": 4,
            "end_column": 13313,
            "start_byte": 13227,
            "end_byte": 4
          },
          "_pytest.nodes.Collector._prunetraceback": {
            "name": "_pytest.nodes.Collector._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e sure we update what the\n            # function really needs.\n            fixtureinfo.prune_dependency_tree()\n\n            for callspec in metafunc._calls:\n                subname = f\"{name}[{callspec.id}]\"\n                yield Function.from_parent(\n                    self,\n                    name=subname,\n                    callspec=callspec,\n                  ",
            "start_line": 538,
            "start_column": 17955,
            "end_line": 4,
            "end_column": 18324,
            "start_byte": 17955,
            "end_byte": 4
          },
          "_pytest.python.Function._prunetraceback": {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo[BaseException]) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code.from_function(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame.\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1713,
            "start_column": 64881,
            "end_line": 4,
            "end_column": 65989,
            "start_byte": 64881,
            "end_byte": 4
          },
          "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self,\n        excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1735,
            "start_column": 66051,
            "end_line": 4,
            "end_column": 66361,
            "start_byte": 66051,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._prunetraceback": {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "e):\n                name = os.path.splitext(name)[0]\n                if stopatmodule:\n                    if includemodule:\n                        parts.append(name)\n                    break\n            parts.append(name)\n        parts.reverse()\n        return \".\".join(parts)\n\n    def reportinfo(self) -> Tuple[Union[\"os.",
            "start_line": 321,
            "start_column": 11153,
            "end_line": 4,
            "end_column": 11477,
            "start_byte": 11153,
            "end_byte": 4
          }
        }
      }
    }
  ]
}