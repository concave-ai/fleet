{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5692",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:22.900036",
        "usage": "1478.0287742614746 ms"
      },
      "request": {
        "repo_tokens": [
          "visit_BinOp",
          "showversion",
          "invalidraise",
          "putaround",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "INTERRUPTED",
          "setenv",
          "fix_cache_order",
          "_readline_workaround",
          "suspend_capturing",
          "_pop_and_teardown",
          "CollectError",
          "Class",
          "Interrupted",
          "set_log_path",
          "_teardown_towards",
          "_postmortem_traceback",
          "_runtest_for_main",
          "getstatementrange",
          "_getpytestargs",
          "newinstance",
          "_set_initial_conftests",
          "re_match_lines_random",
          "iscoroutinefunction",
          "collect",
          "_check_record_param_type",
          "cmdline",
          "maketxtfile",
          "variable",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "_PLUGGY_DIR",
          "capstdout",
          "_getentrysource",
          "run",
          "_py36_windowsconsoleio_workaround",
          "get_default_arg_names",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_runtest_makereport",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "create_new_paste",
          "Module",
          "pytest_make_collect_report",
          "prune_dependency_tree",
          "getparent",
          "_parse_parametrize_parameters",
          "setns",
          "_set_opt_strings",
          "Cache",
          "pytest_unconfigure",
          "LogXML",
          "get_records",
          "_get_increasing_order",
          "_is_numpy_array",
          "from_config",
          "fromdictargs",
          "PYC_TAIL",
          "pytest_assertrepr_compare",
          "NoCapture",
          "_create_formatter",
          "runpytest_inprocess",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "DEFAULT_MAX_LINES",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "_seen",
          "_format_args",
          "Config",
          "isparseable",
          "fixturenames",
          "pytest_runtestloop",
          "Item",
          "summary_passes",
          "yield_fixture",
          "SubRequest",
          "setup",
          "ensure_newline",
          "DontReadFromInput",
          "_is_marked_for_rewrite",
          "text",
          "_colorama_workaround",
          "NodeMarkers",
          "OK",
          "RunResult",
          "out",
          "_log_text",
          "_resolve_arg_ids",
          "matchreport",
          "pytest_runtest_logfinish",
          "Entry",
          "getfixturevalue",
          "showfspath",
          "EMPTY_BUFFER",
          "alias",
          "resolve_from_str",
          "_write_progress_information_filling_space",
          "readlines",
          "_addexcinfo",
          "Metafunc",
          "__getitem__",
          "parse_hookimpl_opts",
          "hasopt",
          "_find_spec",
          "TESTS_FAILED",
          "popcall",
          "verbosity",
          "_check_scope",
          "pytest_collect_directory",
          "fnmatch_ex",
          "_get_allow_unicode_flag",
          "ApproxMapping",
          "_get_active_fixturedef",
          "teardown_all",
          "visit_Call",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "_mk_tmp",
          "_importtestmodule",
          "_update_message",
          "LineComp",
          "_striptext",
          "get_lock_path",
          "isdatacls",
          "SysCaptureBinary",
          "cls",
          "find_suffixes",
          "makeconftest",
          "PyobjContext",
          "recursionindex",
          "write_docstring",
          "LFPlugin",
          "resume_fixture",
          "ParameterSet",
          "autouse",
          "raises",
          "count_towards_summary",
          "pytest_addoption",
          "Junit",
          "CLOSE_STDIN",
          "NoMatch",
          "cached_result",
          "format",
          "summary_errors",
          "addFailure",
          "PytestConfigWarning",
          "mkpydir",
          "_determine_show_progress_info",
          "getimfunc",
          "add_report_section",
          "write",
          "PyobjMixin",
          "flow_marker",
          "StepwisePlugin",
          "pop",
          "warnings",
          "DEFAULT_RELATIVE_TOLERANCE",
          "caplog",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "last_failed_paths",
          "CollectReport",
          "pyobj_property",
          "deindent",
          "_callfinalizers",
          "getstatementrange_ast",
          "_tryconvertpyarg",
          "capfdbinary",
          "Function",
          "pytest_sessionfinish",
          "visit_BoolOp",
          "from_exc_info",
          "section",
          "_fail_on_non_top_pytest_plugins",
          "cacheprovider",
          "check_strict_xfail",
          "_fillfixtures",
          "when",
          "_markers",
          "getfirstlinesource",
          "fillfixtures",
          "_legal_ranges",
          "notset",
          "helpconfig",
          "PytestUnknownMarkWarning",
          "PYC_EXT",
          "assert_outcomes",
          "addUnexpectedSuccess",
          "funcargnames",
          "_locationline",
          "repr_instance",
          "ReprExceptionInfo",
          "reportinfo",
          "scope",
          "scopename2class",
          "ReprEntryNative",
          "ensure_reset_dir",
          "doctest",
          "__call__",
          "_get_direct_parametrize_args",
          "find",
          "_rewrite_test",
          "pytest_exception_interact",
          "_enter_pdb",
          "_get_continue_on_failure",
          "repr_traceback",
          "conftest_options",
          "merge_family",
          "stop",
          "TEST_OUTCOME",
          "_for_parametrize",
          "parse_known_and_unknown_args",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "annotated_getattr",
          "resultlog",
          "_non_printable_ascii_translate_table",
          "essential_plugins",
          "runner",
          "rex_outcome",
          "MultiCapture",
          "pytest_addhooks",
          "tb",
          "post_mortem",
          "pytest_warning_captured",
          "_factorytraceback",
          "get_closest_marker",
          "setupplan",
          "applymarker",
          "countoutcomes",
          "suspend_global_capture",
          "_pytest",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_istrue",
          "hasplugin",
          "helper",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "PdbInvoke",
          "getoption",
          "append_failure",
          "_diff_text",
          "add_property",
          "write_ensure_prefix",
          "co_equal",
          "_makeitem",
          "DropShorterLongHelpFormatter",
          "resume_global_capture",
          "python_api",
          "inline_run",
          "_config_for_test",
          "activate_fixture",
          "linecomp",
          "pytest_cmdline_main",
          "_ensure_immutable_ids",
          "_argcomplete",
          "assertoutcome",
          "teardown_exact",
          "_pluginmanager",
          "_getautousenames",
          "warning_types",
          "repr_failure",
          "__array_ufunc__",
          "delenv",
          "getmodulecol",
          "makedir",
          "showheader",
          "_import_plugin_specs",
          "pytestPDB",
          "copy_example",
          "record_testreport",
          "fullsource",
          "_initini",
          "_import_pdb_cls",
          "_get_fixturestack",
          "pytest_cmdline_preparse",
          "_init_runner_class",
          "formatrepr",
          "FunctionMixin",
          "_E",
          "explanation_param",
          "PytestCacheWarning",
          "_outrep_summary",
          "isiterable",
          "version",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "listextrakeywords",
          "deselect_by_mark",
          "write_sep",
          "listoutcomes",
          "set",
          "push_format_context",
          "pytest_internalerror",
          "pytest_make_parametrize_id",
          "append",
          "line",
          "getinicfg",
          "FSCollector",
          "_approx_scalar",
          "mangle_test_address",
          "terminal",
          "get_open_files",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "reset",
          "ReprTraceback",
          "_yield_comparisons",
          "families",
          "CollectErrorRepr",
          "pytest_configure",
          "stepwise",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "value",
          "ReprFileLocation",
          "exit",
          "finish_recording",
          "restore",
          "pytest_deselected",
          "RE_IMPORT_ERROR_NAME",
          "warn",
          "dir",
          "_PYTEST_DIR",
          "_ellipsize",
          "main",
          "_exec_lsof",
          "istestfunc",
          "TracebackEntry",
          "parse_known_args",
          "IGNORE_PAM",
          "notify_exception",
          "pytest_generate_tests",
          "_getnextfixturedef",
          "FSHookProxy",
          "kwargs",
          "finalize",
          "MARK_GEN",
          "getfailedcollections",
          "cache_dir_from_config",
          "_getconftest_pathlist",
          "_parsearg",
          "runpython_c",
          "Code",
          "directory_arg",
          "Frame",
          "chain",
          "locals",
          "disabled",
          "add_attribute",
          "_get_progress_information_message",
          "capsys",
          "compat",
          "findsource",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "__version_tuple__",
          "set_level",
          "doctest_namespace",
          "pytest_itemstart",
          "call_and_report",
          "prog",
          "visit_Starred",
          "pytest_runtest_protocol",
          "mode",
          "_PytestWrapper",
          "head_line",
          "CaptureResult",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "repr_locals",
          "get_plugin_manager",
          "_basetemp",
          "pytest_report_to_serializable",
          "repr_args",
          "_cachedir",
          "DOCTEST_REPORT_CHOICE_NONE",
          "scope2props",
          "catch_warnings_for_item",
          "_patch_unwrap_mock_aware",
          "typename",
          "perform_collect",
          "make_numbered_dir_with_cleanup",
          "traceback",
          "get_dirs_from_args",
          "_match_lines_random",
          "mktemp",
          "is_capturing",
          "relline",
          "LogCaptureFixture",
          "__ne__",
          "InvocationParams",
          "pytest_collection_finish",
          "MarkGenerator",
          "LogCaptureHandler",
          "try_cleanup",
          "copy",
          "startTest",
          "FixtureManager",
          "pytest_collectstart",
          "fnmatch_lines_random",
          "__test__",
          "NodeKeywords",
          "ApproxNumpy",
          "getcalls",
          "OutcomeException",
          "errisinstance",
          "pytestconfig",
          "capstderr",
          "inline_runsource",
          "names_closure",
          "argnames",
          "CaptureManager",
          "_check_type",
          "_ensure_removed_sysmodule",
          "_state",
          "USAGE_ERROR",
          "writeorg",
          "isinitpath",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "getpluginversioninfo",
          "Node",
          "from_current",
          "add_stats",
          "fill_unfilled",
          "_plugin_nameversions",
          "get_source",
          "isset",
          "INTERNAL_ERROR",
          "ensure_deletable",
          "build_summary_stats_line",
          "getlocation",
          "markname",
          "_compare_eq_iterable",
          "tmpdir_factory",
          "NO_TESTS_COLLECTED",
          "visit_Assert",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "fslocation",
          "resume",
          "pytest_collection_modifyitems",
          "_setoption",
          "AssertionState",
          "_get_verbose_word",
          "_given_basetemp",
          "popen",
          "_get_pdb_wrapper_class",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "_matchnodes",
          "_split_explanation",
          "_do_configure",
          "_get_assertion_exprs",
          "on_rm_rf_error",
          "_ALLOW_MARKERS",
          "_non_numeric_type_error",
          "exec_module",
          "_validate_if_using_arg_names",
          "get_fslocation_from_item",
          "iter_markers_with_node",
          "_assert_start_repr",
          "stop_global_capturing",
          "DummyRewriteHook",
          "HelpAction",
          "parse_num",
          "UnformattedWarning",
          "PYTEST_TAG",
          "consider_conftest",
          "consider_pluginarg",
          "_validate_args",
          "determine_setup",
          "_warn_about_missing_assertion",
          "execute",
          "showfixtures",
          "UNARY_MAP",
          "nextitem",
          "getnode",
          "approx",
          "classnamefilter",
          "Traceback",
          "parse_hookspec_opts",
          "_showfixtures_main",
          "_done",
          "_addoption_instance",
          "iter_markers",
          "getstatement",
          "getbasetemp",
          "Skipped",
          "item_capture",
          "LoggingPlugin",
          "scopes",
          "LineMatcher_fixture",
          "_getcrashline",
          "_suspend",
          "plugins",
          "ExceptionChainRepr",
          "_node_location_to_relpath",
          "safe_getattr",
          "session",
          "_excinfo",
          "_update_current_test_var",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "derive_importpath",
          "instance",
          "type",
          "_testcase",
          "_iter_all_modules",
          "_inject_setup_teardown_fixtures",
          "abspath",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "category",
          "import_plugin",
          "_assert_expr_to_lineno",
          "isatty",
          "PytestCollectionWarning",
          "FormattedExcinfo",
          "_LiveLoggingStreamHandler",
          "pytest_pycollect_makemodule",
          "extract_from",
          "LsofFdLeakChecker",
          "_to_json",
          "stop_capturing",
          "ischildnode",
          "_getcapture",
          "__eq__",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_rget_with_confmod",
          "getrawcode",
          "_notin_text",
          "pytest_report_header",
          "ReprFailDoctest",
          "_recurse",
          "syspathinsert",
          "CallSpec2",
          "append_pass",
          "_checkversion",
          "args",
          "_teardown_with_finalization",
          "writelines",
          "record_xml_attribute",
          "istext",
          "_match_lines",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_consider_importhook",
          "pop_format_context",
          "DEFAULT_MAX_CHARS",
          "_remove_ansi_escape_sequences",
          "tolerance",
          "CFG_PYTEST_SECTION",
          "global_and_fixture_disabled",
          "statement",
          "REGEX_TYPE",
          "getvalueorskip",
          "resolve_fixture_function",
          "from_item",
          "visit_Attribute",
          "clear",
          "_getreprcrash",
          "chdir",
          "listchain",
          "_initrequest",
          "_get_override_ini_value",
          "_should_rewrite",
          "get_terminal_writer",
          "is_true",
          "_format_boolop",
          "_find_parametrized_scope",
          "parsefactories",
          "add_funcarg_pseudo_fixture_def",
          "getrepr",
          "AssertionRewriter",
          "SysCapture",
          "deprecated",
          "exprinfo",
          "_in_venv",
          "BINOP_MAP",
          "TimeoutExpired",
          "scopenum_function",
          "create_cleanup_lock",
          "_call_reprcompare",
          "_resume",
          "_format_lines",
          "FixtureLookupError",
          "frame",
          "_NodeReporter",
          "__missing__",
          "_finalize",
          "_warn_incompatibility_with_xunit2",
          "File",
          "__delitem__",
          "_call_assertion_pass",
          "_matchfactories",
          "names",
          "version_tuple",
          "Mark",
          "EncodedFile",
          "addfinalizer",
          "own_mark_names",
          "_getconftestmodules",
          "getfixturemarker",
          "_splitnode",
          "for_later",
          "ReprTracebackNative",
          "PytestWarning",
          "mark_rewrite",
          "bin_xml_escape",
          "LEVELNAME_FMT_REGEX",
          "_genfunctions",
          "get_empty_parameterset_mark",
          "_check_initialpaths_for_relpath",
          "_idval",
          "__exit__",
          "LineMatcher",
          "_resolve_arg_value_types",
          "template",
          "_log_cli_enabled",
          "context",
          "short_test_summary",
          "__next__",
          "register",
          "get_statement_startend2",
          "_getparser",
          "parse_setoption",
          "_recursive_debug",
          "matchkeyword",
          "listnames",
          "parseoutcomes",
          "FILE_OR_DIR",
          "setall",
          "isattrs",
          "FDCapture",
          "exec_",
          "deactivate_fixture",
          "encoding",
          "_trace",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "EMPTY_PARAMETERSET_OPTION",
          "pytest_enter_pdb",
          "store_mark",
          "readline",
          "getitems",
          "pytest_assertion_pass",
          "_from_json",
          "getplugin",
          "getreports",
          "failed",
          "visit_Name",
          "scopeproperty",
          "is_generator",
          "location",
          "_checkargnotcontained",
          "_get_pos",
          "_setup_fixtures",
          "runtest",
          "get_option_ini",
          "UnitTestCase",
          "_compilecounter",
          "DoctestTextfile",
          "_main",
          "TerminalReporter",
          "__hash__",
          "report_collect",
          "FuncFixtureInfo",
          "_saferepr",
          "consider_env",
          "is_rewrite_disabled",
          "_bytes_to_ascii",
          "call_fixture_func",
          "gethookrecorder",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "consider_preparse",
          "repr_excinfo",
          "is_globally_capturing",
          "ExitCode",
          "_get_report_choice",
          "syspath_prepend",
          "funcargs",
          "get_config",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "get_public_names",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "check_testcase_implements_trial_reporter",
          "assign",
          "_truncate_explanation",
          "_compare_eq_set",
          "assertrepr_compare",
          "MyOptionParser",
          "runpython",
          "tmp_path_factory",
          "addExpectedFailure",
          "ArgumentError",
          "_make_xunit_fixture",
          "set_trace",
          "to_xml",
          "__iter__",
          "get_actual_log_level",
          "getexplanation",
          "XFailed",
          "_show_fixture_action",
          "mark",
          "suspend",
          "_version",
          "get_location",
          "RaisesContext",
          "Argument",
          "hookspec",
          "_idvalset",
          "list",
          "getfixtureclosure",
          "params",
          "pytest_pycollect_makeitem",
          "_matches_prefix_or_glob_option",
          "path",
          "default_plugins",
          "_format_assertmsg",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_py_ext_re",
          "_ensure_basetemp",
          "capture_fixtures",
          "record_testsuite_property",
          "initialnames",
          "addError",
          "makeini",
          "UsageError",
          "freeze_support",
          "_getfailureheadline",
          "warn_about_none_ast",
          "fixtures",
          "own_markers",
          "monkeypatch",
          "add_marker",
          "__bool__",
          "python",
          "PytestExperimentalApiWarning",
          "call_optional",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "_strtobool",
          "_ensure_supporting_files",
          "mkdir",
          "istrue",
          "_getglobals",
          "RESULT_LOG",
          "summary_stats",
          "hasinit",
          "PdbTrace",
          "record_tuples",
          "get_direct_param_fixture_func",
          "get_sections",
          "_dump_lines",
          "_warn_already_imported",
          "_getini",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "re_match_lines",
          "pytest_collectreport",
          "AssertionRewritingHook",
          "_addfinalizer",
          "call_runtest_hook",
          "make_numbered_dir",
          "ReprEntry",
          "Notset",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "find_spec",
          "setattr",
          "cached_eval",
          "register_assert_rewrite",
          "name2fixturedefs",
          "setitem",
          "_makepath",
          "_format_action_invocation",
          "exconly",
          "LOCK_TIMEOUT",
          "ApproxSequencelike",
          "FuncargnamesCompatAttr",
          "_repr_failure_py",
          "_getvaluepath",
          "_schedule_finalizers",
          "compile",
          "getfailures",
          "_getlines",
          "isnosetest",
          "_recursive_list_map",
          "cacheshow",
          "_result",
          "TerminalRepr",
          "_report_keyboardinterrupt",
          "SysPathsSnapshot",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "attrs",
          "_get_global_properties_node",
          "snap",
          "_get_plugin_specs_as_list",
          "DEFAULT_LOG_FORMAT",
          "install_importhook",
          "getpathnode",
          "passed",
          "undo",
          "repr",
          "_check_if_assertion_pass_impl",
          "addini",
          "_check_all_skipped",
          "errors",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "_assertion_supported",
          "pytest_report_teststatus",
          "ApproxBase",
          "_force_symlink",
          "skipping",
          "faulthandler",
          "_is_mocked",
          "get_lines_after",
          "Session",
          "__take_sys_modules_snapshot",
          "istestclass",
          "addinivalue_line",
          "__len__",
          "getsource",
          "_legal_xml_re",
          "getcall",
          "buffer",
          "Exit",
          "catching_logs",
          "style",
          "nofuncargs",
          "builtin",
          "function",
          "eval",
          "fail_fixturefunc",
          "_read_pyc",
          "pytest_ignore_collect",
          "path_matches_patterns",
          "set_repr_style",
          "print_teardown_sections",
          "makepyfile",
          "_addoption",
          "Source",
          "_get_runner",
          "_opentestcase",
          "scope2index",
          "NFPlugin",
          "PercentStyleMultiline",
          "getparam",
          "PytestDeprecationWarning",
          "CaptureIO",
          "__getattr__",
          "PytestPluginManager",
          "hookimpl",
          "ReprFuncArgs",
          "consider_module",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "_visit_filter",
          "_parse_lsof_output",
          "idmaker",
          "pytest_collection",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "rewrite",
          "__array_priority__",
          "toterminal",
          "FUNCARGNAMES",
          "_get_number_flag",
          "__setitem__",
          "__all__",
          "_preparse",
          "nodes",
          "_try_load_conftest",
          "append_skipped",
          "MarkMapping",
          "_get_stderr_fileno",
          "_running_on_ci",
          "TempPathFactory",
          "wrap_function_to_error_out_if_called_directly",
          "pop_outerr_to_orig",
          "create_module",
          "deselect_by_keyword",
          "_get_flag_lookup",
          "_assertion_pass",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "_io",
          "matchnodes",
          "_teardown_yield_fixture",
          "OptionGroup",
          "showhelp",
          "runitem",
          "isdict",
          "collect_one_node",
          "builtin_plugins",
          "summary_failures",
          "close",
          "spawn_pytest",
          "at_level",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "Failed",
          "_parse_parametrize_args",
          "_prepareconfig",
          "getargs",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PyCollector",
          "PytestUnhandledCoroutineWarning",
          "append_error",
          "istestfunction",
          "__enter__",
          "testdir",
          "addSkip",
          "filename_arg",
          "update",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "DoctestModule",
          "_bestrelpath_cache",
          "assert_contains",
          "is_potential_nosetest",
          "_init_pdb",
          "filter_traceback",
          "_truncate_by_char_count",
          "recwarn",
          "capsysbinary",
          "_inject_setup_function_fixture",
          "create_terminal_writer",
          "pytester",
          "FastFilesCompleter",
          "cut",
          "start",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "assertion",
          "pytest_collect_file",
          "write_fspath_result",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "set_when",
          "ResultLog",
          "_processopt",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "longreprtext",
          "_write_report_lines_from_hooks",
          "FunctionDefinition",
          "TempdirFactory",
          "getfslineno",
          "_translate_non_printable",
          "parametrize",
          "BaseReport",
          "get_exconly",
          "__str__",
          "wrap_session",
          "message",
          "_traceback",
          "maybe_delete_a_numbered_dir",
          "write_log_entry",
          "pytest_fixture_setup",
          "getini",
          "records",
          "node",
          "_call_with_optional_argument",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "_disable_output_capturing_for_darwin",
          "_sys_snapshot",
          "ihook",
          "issequence",
          "_issue_warning_captured",
          "suspend_fixture",
          "truncate_if_required",
          "strip",
          "rm_rf",
          "runtestprotocol",
          "_getindent",
          "_should_truncate_item",
          "indent",
          "scopemismatch",
          "matching_platform",
          "filter",
          "_ensure_only_one_capture_fixture",
          "makefile",
          "get_user",
          "parse_args",
          "emit",
          "get_parametrized_fixture_keys",
          "read_global_capture",
          "readouterr",
          "RUNNER_CLASS",
          "_log",
          "processoption",
          "skipped",
          "_early_rewrite_bailout",
          "pytest_runtest_teardown",
          "fspath",
          "getcrashentry",
          "add_global_property",
          "delattr",
          "prepare",
          "fileno",
          "getgroup",
          "id",
          "num_mock_patch_args",
          "getcfg",
          "ApproxDecimal",
          "getvalue",
          "reports",
          "pytest_load_initial_conftests",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "pytest_terminal_summary",
          "spawn",
          "setuponly",
          "_legal_chars",
          "addSuccess",
          "outcomes",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "ishidden",
          "TestReport",
          "SetupState",
          "addoption",
          "result",
          "_compute_fixture_value",
          "defaultfuncargprefixmarker",
          "ApproxScalar",
          "pytest_runtest_logstart",
          "_setup_collect_fakemodule",
          "getmodpath",
          "parseconfigure",
          "from_call",
          "wasvalid",
          "_PY_DIR",
          "_config",
          "matchmark",
          "skip",
          "cleanup_numbered_dir",
          "fnmatch_lines",
          "REPORT_COLLECTING_RESOLUTION",
          "_importconftest",
          "resume_capturing",
          "Collector",
          "_tmppath_factory",
          "module",
          "config",
          "ascii_escaped",
          "saferepr",
          "_printcollecteditems",
          "str",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "_prunetraceback",
          "getdecoded",
          "add_cleanup",
          "reorder_items",
          "getfixtureinfo",
          "set_session",
          "showlocals",
          "_typ_map",
          "error",
          "_getobj",
          "check_xfail_no_run",
          "_ascii_escaped_by_config",
          "start_capturing",
          "_get_allow_bytes_flag",
          "obj",
          "ids",
          "WarningsRecorder",
          "parse",
          "freeze_includes",
          "_should_repr_global_name",
          "pastebin",
          "_test_pytest_function",
          "warns",
          "PytestAssertRewriteWarning",
          "_perform_collect",
          "__version__",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "raiseerror",
          "WarningReport",
          "FixtureRequest",
          "PytestArg",
          "NOTSET",
          "_is_capturing",
          "normalize_mark_list",
          "xfail",
          "_wrapped_pdb_cls",
          "inline_genitems",
          "importorskip",
          "getslaveinfoline",
          "source",
          "node_reporter",
          "CACHEDIR_TAG_CONTENT",
          "set_location",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_compare_eq_dict",
          "tbfilter",
          "_repr_style",
          "with_args",
          "_iter_rewritable_modules",
          "_inject_setup_module_fixture",
          "SafeRepr",
          "stopTest",
          "write_line",
          "MarkEvaluator",
          "match",
          "_handle_skip",
          "compile_",
          "MultipleDoctestFailures",
          "HookRecorder",
          "summary_warnings",
          "MarkDecorator",
          "teardown_nose",
          "__nonzero__",
          "ColoredLevelFormatter",
          "delitem",
          "parseconfig",
          "param",
          "gethookproxy",
          "_compare_eq_cls",
          "name",
          "get_scope_node",
          "__repr__",
          "getitem",
          "README_CONTENT",
          "pytest_itemcollected",
          "_format_repr_exception",
          "_add_simple",
          "safe_text_dupfile",
          "deprecated_call",
          "done",
          "visit_Compare",
          "CallInfo",
          "record_property",
          "resolve",
          "append_collect_skipped",
          "simple",
          "nose",
          "WarningsChecker",
          "capfd",
          "_collectfile",
          "_write_pyc",
          "reorder_items_atscope",
          "fixture",
          "show_test_item",
          "CwdSnapshot",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_plugin_registered",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "pytest_runtest_call",
          "for_config",
          "MonkeyPatch",
          "_is_setup_py",
          "PseudoFixtureDef",
          "read",
          "getfixturedefs",
          "_reprcompare",
          "_validate_usepdb_cls",
          "genitems",
          "_start",
          "_getscopeitem",
          "hasnew",
          "parts",
          "show_fixtures_per_test",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid",
          "fail",
          "pytest_cmdline_parse",
          "get_data",
          "handler",
          "entrysep"
        ]
      },
      "response": {
        "keywords": [
          "LogXML",
          "record_testsuite_property",
          "junitxml",
          "record_xml_attribute",
          "make_properties_node"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:24.378079",
        "usage": "182.58309364318848 ms"
      },
      "request": {
        "tokens": [
          "LogXML",
          "record_testsuite_property",
          "junitxml",
          "record_xml_attribute",
          "make_properties_node"
        ]
      },
      "response": {
        "results": {
          "junitxml": [
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py"
          ],
          "make_properties_node": [
            "src/_pytest/junitxml.py"
          ],
          "record_xml_attribute": [
            "src/_pytest/junitxml.py"
          ],
          "record_testsuite_property": [
            "src/_pytest/junitxml.py"
          ],
          "LogXML": [
            "src/_pytest/junitxml.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:24.560674",
        "usage": "4343.06001663208 ms"
      },
      "request": {
        "keyword_search_results": {
          "junitxml": [
            "src/_pytest/junitxml.py",
            "src/_pytest/config/__init__.py"
          ],
          "make_properties_node": [
            "src/_pytest/junitxml.py"
          ],
          "record_xml_attribute": [
            "src/_pytest/junitxml.py"
          ],
          "record_testsuite_property": [
            "src/_pytest/junitxml.py"
          ],
          "LogXML": [
            "src/_pytest/junitxml.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is about adding 'hostname' and 'timestamp' attributes to the JUnit XML reports generated by pytest. From the search results, multiple keywords point to a particular file: 'src/_pytest/junitxml.py'. Specifically, keywords like 'junitxml', 'make_properties_node', 'record_xml_attribute', 'record_testsuite_property', and 'LogXML' are all related to this file. Given these keywords, this file is likely responsible for generating the JUnit XML reports or handling their configuration.\n\n- The keyword 'junitxml' directly refers to the functionality in question and the corresponding file 'src/_pytest/junitxml.py' is the most relevant,\n- 'make_properties_node', 'record_xml_attribute', and 'record_testsuite_property' suggest methods related to modifying or creating XML nodes and attributes which might be where 'hostname' and 'timestamp' can be set or added.\n- 'LogXML' likely pertains to the logging format of the pytest results. Though it could involve the inclusion of attributes like 'hostname' and 'timestamp', it is slightly less promising than direct node or attribute handling functions.\n\nThe presence of these terms in 'src/_pytest/junitxml.py' makes it the primary file that would likely need to be modified or already supports the requested feature. The second file, 'src/_pytest/config/__init__.py', only appears under the 'junitxml' keyword, suggesting a possible secondary relevance.",
        "file_paths": [
          "src/_pytest/junitxml.py",
          "src/_pytest/config/__init__.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:28.903750",
        "usage": "7775.893926620483 ms"
      },
      "request": {
        "file_path": "src/_pytest/junitxml.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an issue with the generated JUnit XML reports via pytest, specifically that the `hostname` and `timestamp` attributes are missing from the `testsuite` element of the XML reports.\n1.2 The user does not provide specific reproduction steps, but does compare examples of pytest's XML report output with that of a more conventional JUnit XML report.\n1.3 The issue seems to stem from the fact that the pytest JUnit XML generation logic does not include `hostname` and `timestamp` attributes, so they are never added to the `testsuite` tag.\n1.4 The user expects pytest to include these attributes in the generated XML to mimic traditional JUnit XML outputs.\n1.5 The issue is likely a limitation or oversight in the `LogXML` class responsible for generating the XML report.\n1.6 One solution could entail modifying the `LogXML.pytest_sessionfinish` method to add these missing attributes to the `testsuite` XML node.\n\n2. Make file evaluation:\n2.1 The file `src/_pytest/junitxml.py` contains a class `LogXML` responsible for generating JUnit XML reports from pytest output.\n2.2 The `pytest_sessionstart` method marks the start time of the test suite, and `pytest_sessionfinish` calculates the duration and writes the final XML.\n2.3 Currently, there is no functionality to add `hostname` and `timestamp` to the XML. These would need to come from similar methods or additions to the `LogXML` class, likely where the `Junit.testsuite` XML node is created.\n2.4 The `pytest_sessionfinish` method where the XML is finalized doesn't include these attributes. Also, helper methods to get time and hostname should be implemented and used in the `Junit.testsuite` call.\n2.5 No current references or imports provide a timestamp or hostname for the XML.\n2.6 This file is likely the root cause as it is directly responsible for the XML construction and does not include the desired `hostname` and `timestamp` attributes.\n\n3. Output Your Decision:",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "LogXML.pytest_sessionfinish",
          "LogXML"
        ],
        "root_cause_symbols": [
          "LogXML.pytest_sessionfinish",
          "LogXML"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:36.679655",
        "usage": "7334.804058074951 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/__init__.py"
      },
      "response": {
        "scratch_pad": "1. **Issue Analysis**:\n   - The user is reporting a problem where `hostname` and `timestamp` properties are missing from the `testsuite` XML element in the JUnit XML reports generated by pytest. \n   - They wish to know if there is an option to include these properties.\n   - They provide an example XML where these attributes are present in another setup and ask if pytest can achieve similarly.\n\n2. **File Content Analysis**:\n   \n   - The file seems to be setting up initial plugins and configuration for pytest, involving plugins management, configurations loading, etc. but does not directly deal with the generation or manipulation of the JUnit XML reports.\n   - It's noted that `junitxml` is part of a list of default plugins, suggesting that its functionality is likely employed elsewhere either in this file or in another imported module.\n   - The `PluginManager` and various plugins are being configured and used. \n   - Specifically, plugins named \"junitxml\" and plugin-related hooks might be connected with the XML report generation.\n   \n3. **Relation to Issue**:\n   - The relevant parts dealing with XML generation might not be within this file. However, since `default_plugins` includes `junitxml`, the setup or management for JUnit-related functionality might be initialized here without detailed implementation.\n   \n4. **Conclusion**:\n   - The file is related to the issue in terms of initializing relevant plugins (`junitxml`) but does not directly address how to include `hostname` or `timestamp` in the JUnit XML output as there seem to be no related methods or classes for XML manipulation visible in this read.\n   - Therefore, while `default_plugins` indicate potential relevance, further exploration is required to locate where `junitxml` functionality is executed. Likely, another file handling XML report writing should be evaluated.\n   \n5. **Output Decision**:\n   - The file contains a potential reference to a plugin relevant to the issue but doesn't contain the root cause for missing XML elements. I would suggest checking files like `src/_pytest/junitxml.py` if it exists or other parts dealing with XML serialization and plugin execution.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/junitxml.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:45:44.014480",
        "usage": "61.408281326293945 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/junitxml.py",
            "relevant_symbol_keys": [
              "LogXML.pytest_sessionfinish",
              "LogXML"
            ],
            "root_cause_symbol_keys": [
              "LogXML.pytest_sessionfinish",
              "LogXML"
            ]
          },
          {
            "file_path": "src/_pytest/config/__init__.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:44.075895",
        "usage": "8876.860857009888 ms"
      },
      "request": {
        "related_symbols": [],
        "root_caused_symbols": [
          {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The issue describes a situation where JUnit XML reports generated by pytest are missing 'hostname' and 'timestamp' attributes in the 'testsuite' element.\n   - In the example pytest XML report provided, these attributes are indeed missing.\n   - The expected outcome is similar to the JUnit XML report where 'hostname' and 'timestamp' are included.\n2. To resolve this, we need to:\n   - Identify where the XML for the testsuite is generated.\n   - Include 'hostname' and 'timestamp' in the XML output.\n\n3. Analyzing the provided symbols to determine changes:\n   - The constructor (__init__) initializes the LogXML class but doesn't handle XML generation directly.\n   - The pytest_sessionfinish function appears to be responsible for writing the XML report and generating the 'testsuite' node.\n      - This function should be modified to include the 'timestamp' and 'hostname' attributes when creating the suite_node object.\n   - The pytest_sessionstart may be relevant to capturing the timestamp start time.\n   - No other functions appear directly responsible for creating the XML structure where these attributes would be added.\n4. Conclusion:\n   - Modify 'pytest_sessionfinish' to add 'hostname' and 'timestamp' when creating the 'testsuite' node in the XML report.\n   - Ensure timestamp and hostname are captured or accessible when needed during XML generation in this method.",
        "symbols": [
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "reason": "The 'pytest_sessionfinish' method is responsible for generating and writing the testsuite XML element. This is where 'hostname' and 'timestamp' should be added to the testsuite attributes."
          },
          {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "reason": "The 'pytest_sessionstart' method is responsible for capturing the suite start time, which can be used to construct the 'timestamp' for the XML report."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The __init__ function initializes configurations and states but doesn't directly interact with XML generation.\n",
          "The finalize function appears to handle completing reports. It doesn't directly address XML structure needs from the issue.\n",
          "The node_reporter function creates or retrieves reporters for test nodes; not directly relevant for XML attributes.\n",
          "The add_stats function manages test statistics, unrelated to XML structure issues.\n",
          "The _opentestcase function manages a test case lifecycle, but doesn't seem to affect the 'testsuite' level XML attributes.\n",
          "The pytest_runtest_logreport function processes test reports dynamically but not the full 'testsuite' XML structure.\n",
          "The update_testcase_duration function updates the duration of test cases, unrelated to 'testsuite' level info.\n",
          "The pytest_collectreport function handles collection phase reporting, not the summary XML structure.\n",
          "The pytest_internalerror function deals with internal errors, unrelated to the XML 'testsuite' attributes.\n",
          "The pytest_sessionstart function initializes the session timing, which could help generate a timestamp.\n",
          "The pytest_sessionfinish function writes the testsuite element, and is directly responsible for adding attributes like 'hostname' and 'timestamp'.\n",
          "The pytest_terminal_summary function informs terminal output, not XML structure.\n",
          "The add_global_property function aids in storing properties, not directly impacting 'testsuite' attributes.\n",
          "The _get_global_properties_node function creates nodes for properties, but not top-level 'testsuite' attributes.\n"
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:45:52.952777",
        "usage": "1.107931137084961 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [],
          "root_caused_symbols": [
            {
              "name": "_pytest.junitxml.LogXML",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
              "start_line": 465,
              "start_column": 15042,
              "end_line": 0,
              "end_column": 23343,
              "start_byte": 15042,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.LogXML.__init__",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
              "start_line": 466,
              "start_column": 15060,
              "end_line": 4,
              "end_column": 16111,
              "start_byte": 15060,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.finalize",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
              "start_line": 497,
              "start_column": 16117,
              "end_line": 4,
              "end_column": 16424,
              "start_byte": 16117,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.node_reporter",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
              "start_line": 505,
              "start_column": 16430,
              "end_line": 4,
              "end_column": 16945,
              "start_byte": 16430,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.add_stats",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
              "start_line": 523,
              "start_column": 16951,
              "end_line": 4,
              "end_column": 17039,
              "start_byte": 16951,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML._opentestcase",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
              "start_line": 527,
              "start_column": 17045,
              "end_line": 4,
              "end_column": 17190,
              "start_byte": 17045,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
              "start_line": 532,
              "start_column": 17196,
              "end_line": 4,
              "end_column": 20514,
              "start_byte": 17196,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.update_testcase_duration",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
              "start_line": 618,
              "start_column": 20520,
              "end_line": 4,
              "end_column": 20919,
              "start_byte": 20520,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_collectreport",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
              "start_line": 626,
              "start_column": 20925,
              "end_line": 4,
              "end_column": 21202,
              "start_byte": 20925,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_internalerror",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
              "start_line": 634,
              "start_column": 21208,
              "end_line": 4,
              "end_column": 21434,
              "start_byte": 21208,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
              "start_line": 639,
              "start_column": 21440,
              "end_line": 4,
              "end_column": 21514,
              "start_byte": 21440,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
              "start_line": 642,
              "start_column": 21520,
              "end_line": 4,
              "end_column": 22618,
              "start_byte": 21520,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
              "start_line": 672,
              "start_column": 22624,
              "end_line": 4,
              "end_column": 22759,
              "start_byte": 22624,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML.add_global_property",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
              "start_line": 675,
              "start_column": 22765,
              "end_line": 4,
              "end_column": 22957,
              "start_byte": 22765,
              "end_byte": 4
            },
            {
              "name": "_pytest.junitxml.LogXML._get_global_properties_node",
              "file_path": "src/_pytest/junitxml.py",
              "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
              "start_line": 680,
              "start_column": 22963,
              "end_line": 4,
              "end_column": 23343,
              "start_byte": 22963,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The issue describes a situation where JUnit XML reports generated by pytest are missing 'hostname' and 'timestamp' attributes in the 'testsuite' element.\n   - In the example pytest XML report provided, these attributes are indeed missing.\n   - The expected outcome is similar to the JUnit XML report where 'hostname' and 'timestamp' are included.\n2. To resolve this, we need to:\n   - Identify where the XML for the testsuite is generated.\n   - Include 'hostname' and 'timestamp' in the XML output.\n\n3. Analyzing the provided symbols to determine changes:\n   - The constructor (__init__) initializes the LogXML class but doesn't handle XML generation directly.\n   - The pytest_sessionfinish function appears to be responsible for writing the XML report and generating the 'testsuite' node.\n      - This function should be modified to include the 'timestamp' and 'hostname' attributes when creating the suite_node object.\n   - The pytest_sessionstart may be relevant to capturing the timestamp start time.\n   - No other functions appear directly responsible for creating the XML structure where these attributes would be added.\n4. Conclusion:\n   - Modify 'pytest_sessionfinish' to add 'hostname' and 'timestamp' when creating the 'testsuite' node in the XML report.\n   - Ensure timestamp and hostname are captured or accessible when needed during XML generation in this method.",
          "symbols": [
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
              "file_path": "src/_pytest/junitxml.py",
              "reason": "The 'pytest_sessionfinish' method is responsible for generating and writing the testsuite XML element. This is where 'hostname' and 'timestamp' should be added to the testsuite attributes."
            },
            {
              "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
              "file_path": "src/_pytest/junitxml.py",
              "reason": "The 'pytest_sessionstart' method is responsible for capturing the suite start time, which can be used to construct the 'timestamp' for the XML report."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The __init__ function initializes configurations and states but doesn't directly interact with XML generation.\n",
            "The finalize function appears to handle completing reports. It doesn't directly address XML structure needs from the issue.\n",
            "The node_reporter function creates or retrieves reporters for test nodes; not directly relevant for XML attributes.\n",
            "The add_stats function manages test statistics, unrelated to XML structure issues.\n",
            "The _opentestcase function manages a test case lifecycle, but doesn't seem to affect the 'testsuite' level XML attributes.\n",
            "The pytest_runtest_logreport function processes test reports dynamically but not the full 'testsuite' XML structure.\n",
            "The update_testcase_duration function updates the duration of test cases, unrelated to 'testsuite' level info.\n",
            "The pytest_collectreport function handles collection phase reporting, not the summary XML structure.\n",
            "The pytest_internalerror function deals with internal errors, unrelated to the XML 'testsuite' attributes.\n",
            "The pytest_sessionstart function initializes the session timing, which could help generate a timestamp.\n",
            "The pytest_sessionfinish function writes the testsuite element, and is directly responsible for adding attributes like 'hostname' and 'timestamp'.\n",
            "The pytest_terminal_summary function informs terminal output, not XML structure.\n",
            "The add_global_property function aids in storing properties, not directly impacting 'testsuite' attributes.\n",
            "The _get_global_properties_node function creates nodes for properties, but not top-level 'testsuite' attributes.\n"
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/junitxml.py"
        ],
        "symbols": [
          "_pytest.junitxml.LogXML.pytest_sessionfinish",
          "_pytest.junitxml.LogXML.pytest_sessionstart"
        ],
        "code_spans": {
          "_pytest.junitxml.LogXML": {
            "name": "_pytest.junitxml.LogXML",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "class LogXML:\n    def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"\n\n    def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()\n\n    def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter\n\n    def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1\n\n    def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter\n\n    def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)\n\n    def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)\n\n    def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)\n\n    def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)\n\n    def pytest_sessionstart(self):\n        self.suite_start_time = time.time()\n\n    def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()\n\n    def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n\n    def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))\n\n    def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 465,
            "start_column": 15042,
            "end_line": 0,
            "end_column": 23343,
            "start_byte": 15042,
            "end_byte": 0
          },
          "_pytest.junitxml.LogXML.__init__": {
            "name": "_pytest.junitxml.LogXML.__init__",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def __init__(\n        self,\n        logfile,\n        prefix,\n        suite_name=\"pytest\",\n        logging=\"no\",\n        report_duration=\"total\",\n        family=\"xunit1\",\n        log_passing_tests=True,\n    ):\n        logfile = os.path.expanduser(os.path.expandvars(logfile))\n        self.logfile = os.path.normpath(os.path.abspath(logfile))\n        self.prefix = prefix\n        self.suite_name = suite_name\n        self.logging = logging\n        self.log_passing_tests = log_passing_tests\n        self.report_duration = report_duration\n        self.family = family\n        self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n        self.node_reporters = {}  # nodeid -> _NodeReporter\n        self.node_reporters_ordered = []\n        self.global_properties = []\n\n        # List of reports that failed on call but teardown is pending.\n        self.open_reports = []\n        self.cnt_double_fail_tests = 0\n\n        # Replaces convenience family with real family\n        if self.family == \"legacy\":\n            self.family = \"xunit1\"",
            "start_line": 466,
            "start_column": 15060,
            "end_line": 4,
            "end_column": 16111,
            "start_byte": 15060,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.finalize": {
            "name": "_pytest.junitxml.LogXML.finalize",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def finalize(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n        reporter = self.node_reporters.pop((nodeid, slavenode))\n        if reporter is not None:\n            reporter.finalize()",
            "start_line": 497,
            "start_column": 16117,
            "end_line": 4,
            "end_column": 16424,
            "start_byte": 16117,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.node_reporter": {
            "name": "_pytest.junitxml.LogXML.node_reporter",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def node_reporter(self, report):\n        nodeid = getattr(report, \"nodeid\", report)\n        # local hack to handle xdist report order\n        slavenode = getattr(report, \"node\", None)\n\n        key = nodeid, slavenode\n\n        if key in self.node_reporters:\n            # TODO: breasks for --dist=each\n            return self.node_reporters[key]\n\n        reporter = _NodeReporter(nodeid, self)\n\n        self.node_reporters[key] = reporter\n        self.node_reporters_ordered.append(reporter)\n\n        return reporter",
            "start_line": 505,
            "start_column": 16430,
            "end_line": 4,
            "end_column": 16945,
            "start_byte": 16430,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.add_stats": {
            "name": "_pytest.junitxml.LogXML.add_stats",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_stats(self, key):\n        if key in self.stats:\n            self.stats[key] += 1",
            "start_line": 523,
            "start_column": 16951,
            "end_line": 4,
            "end_column": 17039,
            "start_byte": 16951,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML._opentestcase": {
            "name": "_pytest.junitxml.LogXML._opentestcase",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _opentestcase(self, report):\n        reporter = self.node_reporter(report)\n        reporter.record_testreport(report)\n        return reporter",
            "start_line": 527,
            "start_column": 17045,
            "end_line": 4,
            "end_column": 17190,
            "start_byte": 17045,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_runtest_logreport": {
            "name": "_pytest.junitxml.LogXML.pytest_runtest_logreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_runtest_logreport(self, report):\n        \"\"\"handle a setup/call/teardown report, generating the appropriate\n        xml tags as necessary.\n\n        note: due to plugins like xdist, this hook may be called in interlaced\n        order with reports from other nodes. for example:\n\n        usual call order:\n            -> setup node1\n            -> call node1\n            -> teardown node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n\n        possible call order in xdist:\n            -> setup node1\n            -> call node1\n            -> setup node2\n            -> call node2\n            -> teardown node2\n            -> teardown node1\n        \"\"\"\n        close_report = None\n        if report.passed:\n            if report.when == \"call\":  # ignore setup/teardown\n                reporter = self._opentestcase(report)\n                reporter.append_pass(report)\n        elif report.failed:\n            if report.when == \"teardown\":\n                # The following vars are needed when xdist plugin is used\n                report_wid = getattr(report, \"worker_id\", None)\n                report_ii = getattr(report, \"item_index\", None)\n                close_report = next(\n                    (\n                        rep\n                        for rep in self.open_reports\n                        if (\n                            rep.nodeid == report.nodeid\n                            and getattr(rep, \"item_index\", None) == report_ii\n                            and getattr(rep, \"worker_id\", None) == report_wid\n                        )\n                    ),\n                    None,\n                )\n                if close_report:\n                    # We need to open new testcase in case we have failure in\n                    # call and error in teardown in order to follow junit\n                    # schema\n                    self.finalize(close_report)\n                    self.cnt_double_fail_tests += 1\n            reporter = self._opentestcase(report)\n            if report.when == \"call\":\n                reporter.append_failure(report)\n                self.open_reports.append(report)\n            else:\n                reporter.append_error(report)\n        elif report.skipped:\n            reporter = self._opentestcase(report)\n            reporter.append_skipped(report)\n        self.update_testcase_duration(report)\n        if report.when == \"teardown\":\n            reporter = self._opentestcase(report)\n            reporter.write_captured_output(report)\n\n            for propname, propvalue in report.user_properties:\n                reporter.add_property(propname, propvalue)\n\n            self.finalize(report)\n            report_wid = getattr(report, \"worker_id\", None)\n            report_ii = getattr(report, \"item_index\", None)\n            close_report = next(\n                (\n                    rep\n                    for rep in self.open_reports\n                    if (\n                        rep.nodeid == report.nodeid\n                        and getattr(rep, \"item_index\", None) == report_ii\n                        and getattr(rep, \"worker_id\", None) == report_wid\n                    )\n                ),\n                None,\n            )\n            if close_report:\n                self.open_reports.remove(close_report)",
            "start_line": 532,
            "start_column": 17196,
            "end_line": 4,
            "end_column": 20514,
            "start_byte": 17196,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.update_testcase_duration": {
            "name": "_pytest.junitxml.LogXML.update_testcase_duration",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def update_testcase_duration(self, report):\n        \"\"\"accumulates total duration for nodeid from given report and updates\n        the Junit.testcase with the new total if already created.\n        \"\"\"\n        if self.report_duration == \"total\" or report.when == self.report_duration:\n            reporter = self.node_reporter(report)\n            reporter.duration += getattr(report, \"duration\", 0.0)",
            "start_line": 618,
            "start_column": 20520,
            "end_line": 4,
            "end_column": 20919,
            "start_byte": 20520,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_collectreport": {
            "name": "_pytest.junitxml.LogXML.pytest_collectreport",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_collectreport(self, report):\n        if not report.passed:\n            reporter = self._opentestcase(report)\n            if report.failed:\n                reporter.append_collect_error(report)\n            else:\n                reporter.append_collect_skipped(report)",
            "start_line": 626,
            "start_column": 20925,
            "end_line": 4,
            "end_column": 21202,
            "start_byte": 20925,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_internalerror": {
            "name": "_pytest.junitxml.LogXML.pytest_internalerror",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_internalerror(self, excrepr):\n        reporter = self.node_reporter(\"internal\")\n        reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n        reporter._add_simple(Junit.error, \"internal error\", excrepr)",
            "start_line": 634,
            "start_column": 21208,
            "end_line": 4,
            "end_column": 21434,
            "start_byte": 21208,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_sessionstart": {
            "name": "_pytest.junitxml.LogXML.pytest_sessionstart",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionstart(self):\n        self.suite_start_time = time.time()",
            "start_line": 639,
            "start_column": 21440,
            "end_line": 4,
            "end_column": 21514,
            "start_byte": 21440,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_sessionfinish": {
            "name": "_pytest.junitxml.LogXML.pytest_sessionfinish",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_sessionfinish(self):\n        dirname = os.path.dirname(os.path.abspath(self.logfile))\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname)\n        logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n        suite_stop_time = time.time()\n        suite_time_delta = suite_stop_time - self.suite_start_time\n\n        numtests = (\n            self.stats[\"passed\"]\n            + self.stats[\"failure\"]\n            + self.stats[\"skipped\"]\n            + self.stats[\"error\"]\n            - self.cnt_double_fail_tests\n        )\n        logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n\n        suite_node = Junit.testsuite(\n            self._get_global_properties_node(),\n            [x.to_xml() for x in self.node_reporters_ordered],\n            name=self.suite_name,\n            errors=self.stats[\"error\"],\n            failures=self.stats[\"failure\"],\n            skipped=self.stats[\"skipped\"],\n            tests=numtests,\n            time=\"%.3f\" % suite_time_delta,\n        )\n        logfile.write(Junit.testsuites([suite_node]).unicode(indent=0))\n        logfile.close()",
            "start_line": 642,
            "start_column": 21520,
            "end_line": 4,
            "end_column": 22618,
            "start_byte": 21520,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.pytest_terminal_summary": {
            "name": "_pytest.junitxml.LogXML.pytest_terminal_summary",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def pytest_terminal_summary(self, terminalreporter):\n        terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))",
            "start_line": 672,
            "start_column": 22624,
            "end_line": 4,
            "end_column": 22759,
            "start_byte": 22624,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML.add_global_property": {
            "name": "_pytest.junitxml.LogXML.add_global_property",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def add_global_property(self, name, value):\n        __tracebackhide__ = True\n        _check_record_param_type(\"name\", name)\n        self.global_properties.append((name, bin_xml_escape(value)))",
            "start_line": 675,
            "start_column": 22765,
            "end_line": 4,
            "end_column": 22957,
            "start_byte": 22765,
            "end_byte": 4
          },
          "_pytest.junitxml.LogXML._get_global_properties_node": {
            "name": "_pytest.junitxml.LogXML._get_global_properties_node",
            "file_path": "src/_pytest/junitxml.py",
            "file_content": "def _get_global_properties_node(self):\n        \"\"\"Return a Junit node containing custom properties, if any.\n        \"\"\"\n        if self.global_properties:\n            return Junit.properties(\n                [\n                    Junit.property(name=name, value=value)\n                    for name, value in self.global_properties\n                ]\n            )\n        return \"\"",
            "start_line": 680,
            "start_column": 22963,
            "end_line": 4,
            "end_column": 23343,
            "start_byte": 22963,
            "end_byte": 4
          }
        }
      }
    }
  ]
}