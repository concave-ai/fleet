{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5413",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:22.728029",
        "usage": "1501.1649131774902 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "putaround",
          "setenv",
          "CollectError",
          "maketxtfile",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "_create_formatter",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "dummy_context_manager",
          "NodeMarkers",
          "Entry",
          "popcall",
          "pytest_collect_directory",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "visit_BoolOp",
          "check_strict_xfail",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "ReprExceptionInfo",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "FIXTURE_FUNCTION_CALL",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "FunctionMixin",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "pytest_itemstart",
          "prog",
          "_PytestWrapper",
          "mode",
          "PYTEST_ENSURETEMP",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "fslocation",
          "_get_pdb_wrapper_class",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "type",
          "_inject_setup_teardown_fixtures",
          "FormattedExcinfo",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "EXIT_USAGEERROR",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "_from_json",
          "getplugin",
          "failed",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "freeze_support",
          "own_markers",
          "monkeypatch",
          "__bool__",
          "find_module",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "GETFUNCARGVALUE",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "addini",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "fail_fixturefunc",
          "PYTEST_LOGWARNING",
          "pytest_ignore_collect",
          "unary_map",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_visit_filter",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "_try_load_conftest",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "EXIT_NOTESTSCOLLECTED",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "EXIT_INTERRUPTED",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_ConfigDeprecated",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "CACHEDIR_TAG_CONTENT",
          "_repr_style",
          "N",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_compare_eq_cls",
          "safe_text_dupfile",
          "done",
          "CallInfo",
          "WarningsChecker",
          "_write_pyc",
          "fixture",
          "MonkeyPatch",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_callhelper",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "ensuretemp",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "verbosity",
          "_check_scope",
          "_update_message",
          "ParameterSet",
          "raises",
          "Junit",
          "format",
          "_imp_find_module",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "pytest_logwarning",
          "caplog",
          "_cmp_raises_type_error",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "CollectErrorRepr",
          "pytest_configure",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "RemovedInPytest4Warning",
          "PYTEST_CONFIG_GLOBAL",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "_do_configure",
          "get_fslocation_from_item",
          "DummyRewriteHook",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "import_plugin",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "append_pass",
          "writelines",
          "record_xml_attribute",
          "EXIT_OK",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "setall",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "_bytes_to_ascii",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "EXIT_TESTSFAILED",
          "RaisesContext",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "warn_about_none_ast",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "binop_map",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "errors",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_call_and_format_exception",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "exc_clear",
          "rewrite",
          "toterminal",
          "nodes",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "getfuncargvalue",
          "BOM_UTF8",
          "addSkip",
          "update",
          "assert_contains",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "is_package",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "_ensure_only_one_capture_fixture",
          "parse_args",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "_get_xunit_setup_teardown",
          "ishidden",
          "defaultfuncargprefixmarker",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "getdecoded",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "_handle_skip",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "_parse_parametrize_parameters",
          "setns",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "EXIT_INTERNALERROR",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "alias",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "LineComp",
          "_striptext",
          "PyobjContext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "WARNS_EXEC",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "parse_known_args",
          "pytest_generate_tests",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "add_stats",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "FIXTURE_NAMED_REQUEST",
          "_non_numeric_type_error",
          "iter_markers_with_node",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_getcapture",
          "_rget_with_confmod",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_get_non_fixture_func",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "clear",
          "parsefactories",
          "get_skip_exceptions",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "bin_xml_escape",
          "context",
          "short_test_summary",
          "__next__",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "capture_fixtures",
          "addError",
          "call_optional",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "_makepath",
          "_format_action_invocation",
          "FuncargnamesCompatAttr",
          "_getvaluepath",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_get_global_properties_node",
          "getpathnode",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "Exit",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "_teardown_yield_fixture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "emit",
          "RAISES_MESSAGE_PARAMETER",
          "_log",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "outcomes",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_setup_collect_fakemodule",
          "wasvalid",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_test_pytest_function",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "__nonzero__",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "repr_unicode",
          "append_collect_skipped",
          "_collectfile",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "rmtree",
          "PseudoFixtureDef",
          "_reprcompare",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "_readline_workaround",
          "_teardown_towards",
          "_runtest_for_main",
          "_check_record_param_type",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "yield_fixture",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "YIELD_TESTS",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "PyobjMixin",
          "RN",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "last_failed_paths",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "find",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "RAISES_EXEC",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "call_and_report",
          "visit_Starred",
          "isfunction",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "markname",
          "getlocals",
          "_given_basetemp",
          "popen",
          "load_module",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "nextitem",
          "approx",
          "_addoption_instance",
          "LineMatcher_fixture",
          "_excinfo",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "__setattr__",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "cookie_re",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "repr_excinfo",
          "syspath_prepend",
          "set_trace",
          "__iter__",
          "get_actual_log_level",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "istrue",
          "isclass",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "set_repr_style",
          "_addoption",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "MarkMapping",
          "append_skipped",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "nose",
          "addhooks",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "pytest.raises",
          "ExceptionRepr",
          "FixtureRequest",
          "str",
          "raises",
          "ExceptionInfo",
          "context",
          "getvalue",
          "pytest",
          "ReprTraceback"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:24.229211",
        "usage": "254.45914268493652 ms"
      },
      "request": {
        "tokens": [
          "pytest.raises",
          "ExceptionRepr",
          "FixtureRequest",
          "str",
          "raises",
          "ExceptionInfo",
          "context",
          "getvalue",
          "pytest",
          "ReprTraceback"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/pytest.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "raises": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python_api.py",
            "src/pytest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/recwarn.py"
          ],
          "str": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/pytester.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/_version.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "getvalue": [
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/reports.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/compat.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/unittest.py"
          ],
          "context": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/python_api.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/warnings.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/recwarn.py"
          ],
          "pytest.raises": [
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py"
          ],
          "ReprTraceback": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ],
          "FixtureRequest": [
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "ExceptionRepr": [
            "src/_pytest/_code/code.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:24.483683",
        "usage": "5540.124893188477 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/pytest.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "raises": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python_api.py",
            "src/pytest.py",
            "src/_pytest/debugging.py",
            "src/_pytest/recwarn.py"
          ],
          "str": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/python.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/pytester.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/doctest.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/_version.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/python_api.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "getvalue": [
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/reports.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/compat.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py",
            "src/_pytest/_code/__init__.py",
            "src/_pytest/runner.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/unittest.py"
          ],
          "context": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/python_api.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/warnings.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/capture.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/recwarn.py"
          ],
          "pytest.raises": [
            "src/_pytest/recwarn.py",
            "src/_pytest/python_api.py"
          ],
          "ReprTraceback": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ],
          "FixtureRequest": [
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/compat.py",
            "src/_pytest/fixtures.py"
          ],
          "ExceptionRepr": [
            "src/_pytest/_code/code.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue relates to the behavior of `pytest.raises`, which involves the management of exception contexts in pytest. Specifically, the difference in how the context variable behaves when you use `pytest.raises` compared to a traditional try-except block.\n\nGiven this issue, keywords of note are `pytest.raises`, `raises`, `ExceptionInfo`, and `context`.\n\n- **pytest.raises**: The keyword is directly related to the problem since the issue arises from using `pytest.raises` context.\n  - Found in `src/_pytest/python_api.py` and `src/_pytest/recwarn.py`. Of these, `src/_pytest/python_api.py` seems more relevant since `python_api` likely contains the main implementation of `pytest.raises`.\n\n- **raises**: Also key to identifying how exceptions are raised and caught within the testing framework.\n  - Present in multiple files, but overlaps with `pytest.raises`, again pointing to `src/_pytest/python_api.py`.\n\n- **context**: Context management is crucial since the behavior (str of context variable from pytest vs normal exception) is reported.\n  - Appears in `src/_pytest/python_api.py`, suggesting this file extensively involves context management.\n\n- **ExceptionInfo**: This keyword is important as `pytest.raises` returns an `ExceptionInfo` object, which is what has different `str()` behavior compared to a normal exception.\n  - Found in `src/_pytest/_code/code.py`, closely related to how exception information is handled.\n\nTherefore, the most pertinent files appear to be `src/_pytest/python_api.py` for the implementation of the context manager and exception handling mechanism, and `src/_pytest/_code/code.py` for the exception information structure, particularly the `ExceptionInfo` object.",
        "file_paths": [
          "src/_pytest/python_api.py",
          "src/_pytest/_code/code.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:30.023833",
        "usage": "13086.025953292847 ms"
      },
      "request": {
        "file_path": "src/_pytest/python_api.py"
      },
      "response": {
        "scratch_pad": "### Step 1: Analyze User Instructions\n\n1.1 Understanding the Issue:\n- The user reports a discrepancy in how exceptions are captured using a standard Python try-except block versus using the `pytest.raises` context manager.\n- Specifically, the `str()` representation of the context manager `pytest.raises(LookupError) as e` outputs differently compared to using a standard `except LookupError as e` block. The wrapped context manager requires `str(e.value)` to retrieve the full message.\n\n1.2 User provide reproduction steps:\n- Code examples are clear and show the difference in output when using `try-except` and `pytest.raises`.\n\n1.3 Problem Analysis:\n- The discrepancy arises because `pytest.raises` uses an internal class/architecture to capture exceptions, not directly yielding the exception object but wrapped context.\n- The context variable in `pytest.raises` holds an `ExceptionInfo` object, not the exception itself, hence `e.value` is required to access the exception details.\n\n1.4 User Expectation:\n- Users might expect `pytest.raises` to behave similarly to a normal `try-except` block regarding exception handling for consistency and ease of use.\n- Users do not find having to explicitly access `.value` intuitive and it's considered a gotcha.\n\n1.5 Cause of the Issue:\n- The design difference in `pytest` where it uses its `ExceptionInfo` structure inside its raises context manager.\n\n1.6 Possible Solutions:\n- Wrap the `ExceptionInfo` such that when accessing as string, it defaults to `str(e.value)` internally or document this prominently to inform users of the behavior.\n\n### Step 2: Evaluate the Presented File\n\n2.1 Analyzing `python_api.py`\n- The file contains the function `raises` that defines the context manager behavior.\n- There is mention of `ExceptionInfo`, which is pivotal since it is the core of the discrepancy observed.\n\n2.2 Match Symbols or Context\n- The `RaisesContext` class with its `__enter__` and `__exit__` methods are the key symbols. They handle the setup and teardown of the `pytest.raises` context.\n- The `ExceptionInfo` object accessed by `self.excinfo` is directly involved in how exceptions are encapsulated and stringified.\n\n- Several checks in `__exit__` and handling of `self.excinfo` could be adjusted to change string behavior.\n\n2.3 Relevance of the File\n- The file is relevant as it defines the `RaisesContext` and thus the behavior seen in `pytest.raises`.\n\n2.4 Root Cause Determination\n- The issue directly stems from how `RaisesContext.__enter__` and `.__exit__` assigns and retrieves debugging info, primarily responsible for handling exceptions differently, which is the core difficulty users face when expecting typical Python behavior.\n\n2.5 Referenced Code\n- Inside the `raises` function, it creates and returns instances of `RaisesContext`, responsible for deviation, suggesting the root cause lies within handling or documentation of `self.excinfo`.\n\nConclusively, the patterns reviewed primarily indicate necessity for improved documentation or modification in `__str__` conversion.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "raises",
          "RaisesContext",
          "RaisesContext.__enter__",
          "RaisesContext.__exit__"
        ],
        "root_cause_symbols": [
          "RaisesContext",
          "RaisesContext.__enter__",
          "RaisesContext.__exit__"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:43.109871",
        "usage": "8549.636840820312 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "1. Understanding the issue:\n   - The issue describes a difference in behavior between using a traditional try/catch block in Python versus using `pytest.raises` for exception handling.\n   - In a typical exception catch, calling `str(e)` on the exception variable `e` provides the full message, while in `pytest.raises`, calling `str(e)` on the context variable only shows part of it, and the full message requires `str(e.value)`.\n   \n2. Is there an explanation of the cause or reproduction steps?\n   - Reproduction steps are provided.\n   - The issue appears to be with the operation of the `pytest.raises` context manager, specifically how accessing the exception string differs between `pytest.raises()` and the normal try-catch.\n\n3. Cause Analysis:\n   - The cause is likely internal to `pytest` where the wrapper or context manager used by `pytest.raises` returns an object that needs `.value` to access the actual exception.\n   - This functionality might be tied to `ExceptionInfo` class objects which encapsulate the exception details including its traceback.\n\n4. Expectations:\n   - The user expects `str(e)` to behave consistently across normal try-catch and `pytest.raises`.\n   \n5. Possible Solutions:\n   - Modify the `ExceptionInfo` or the context returned by `pytest.raises` to ensure `str()` returns the expected full exception message similar to standard try-catch blocks.\n\n6. Exploring the provided file for relevant symbols and potential causes:\n   - Looking at the file content, the `ExceptionInfo` class appears to be relevant because it wraps exception data.\n   - The `__str__` method in the `ExceptionInfo` class ultimately returns a custom format that may not include the complete exception message; instead, it uses `entry` and `exconly()`.\n   - Check how `exconly()` and `__str__()` are functioning in `ExceptionInfo`. The discrepancy in behavior may lie here.\n\nConclusion:\n- The `ExceptionInfo` class is involved in how exception details are handled and presented in Pytest, potentially being a root cause.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.__str__",
          "ExceptionInfo.exconly"
        ],
        "root_cause_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.__str__",
          "ExceptionInfo.exconly"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:45:51.659559",
        "usage": "113.59596252441406 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/python_api.py",
            "relevant_symbol_keys": [
              "raises",
              "RaisesContext",
              "RaisesContext.__enter__",
              "RaisesContext.__exit__"
            ],
            "root_cause_symbol_keys": [
              "RaisesContext",
              "RaisesContext.__enter__",
              "RaisesContext.__exit__"
            ]
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.__str__",
              "ExceptionInfo.exconly"
            ],
            "root_cause_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.__str__",
              "ExceptionInfo.exconly"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:51.773161",
        "usage": "15679.174184799194 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyzing the reported issue:\n1.1 The user describes an issue with the `str()` function on a `pytest.raises` context variable behaving differently than expected. The expectation is that calling `str()` on the exception from a context managed by `pytest.raises` should behave like a normal exception caught with `try...except`, but it does not. `str(e)` on a normal exception gives the full message, while `pytest.raises`'s variant gives a shorter message.\n1.2 This issue is caused because when using `pytest.raises`, the context variable `e` refers to an `ExceptionInfo` object, rather than the exception itself.\n1.3 The user suggests that `str(e)` should return the complete exception message to align with standard expectations in typical Python exception handling.\n1.4 If the user did not provide an expected result, the result should match Python's standard `str(exception)` behavior, which is to return the complete message of the exception.\n\n2. Evaluation of relevant code:\n2.1 `_pytest.python_api.RaisesContext`: Manages the context of the `raises` block and initializes an `ExceptionInfo` object but does not handle how `str()` is applied to this object.\n2.3 `_pytest._code.ExceptionInfo`: Wraps an exception and provides various properties such as `type`, `value`, and `__str__()`. This class directly impacts what `str()` returns when called on a `pytest.raises` context variable. This class's `__str__` method currently returns a summary instead of a detailed message like a standard exception.\n2.4 To resolve the issue, the `__str__` method of `_pytest._code.ExceptionInfo` needs to be changed to return `str(self.value)` to match standard exception behavior. \n2.5 It appears that tweaking the `__str__` method of the `ExceptionInfo` class to output `str(self.value)` or matching the output akin to a normal caught exception could rectify the described inconsistency.",
        "symbols": [
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "reason": "The `__str__` method of `ExceptionInfo` is responsible for the string representation when `str()` is called. To match standard exception handling, it should be adjusted to return a complete message like a normal exception."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The `RaisesContext` class is responsible for creating the context where exceptions are expected to be raised. It uses `ExceptionInfo` to manage exception information, but the string conversion (problematic for the user) occurs at the `ExceptionInfo` level.",
          "The `__init__` method of `RaisesContext` initializes the context. No changes needed here for the described issue; it's only setting up the expected parameters.",
          "The `__enter__` method of `RaisesContext` creates an `ExceptionInfo` object, which mediates the exception's information. The actual string representation issue lies within `ExceptionInfo`, not the context entry setup.",
          "The `__exit__` method checks exceptions against expectations. The string representation problem doesn't occur here but upon accessing `ExceptionInfo` within the context manager.",
          "This class (`ExceptionInfo`) is key to the issue. Its `__str__` method affects what `str()` outputs when used on a `pytest.raises` context variable.",
          "This attribute is a constant and not directly related to the immediate problem of string conversion.",
          "This attribute represents the exception itself but altering `_excinfo` directly isn't apt for resolving a string representation problem.",
          "This attribute is likely involved in formatting exception output but is not part of the string conversion logic directly.",
          "This deals with the traceback of exceptions, not directly with the string conversion issue.",
          "This method's purpose is unclear from the default method alone regarding the issue; its purpose is more for class instantiation.",
          "Generates an 'empty' ExceptionInfo object; not directly related to the string conversion oversight.",
          "This property fetches the exception class; no direct bearing on the string conversion problem.",
          "This property fetches the exception value; it will be useful for correcting the string conversion output.",
          "This property fetches the traceback object; string conversion isn't impacted here.",
          "Provides the exception type name, useful for representations but not inherently wrong in context.",
          "Fetches an exception traceback; altering here doesn't resolve string outputs.",
          "Sets the traceback; unrelated to direct string conversion issues.",
          "Responsible for generic string output of ExceptionInfo, vital for fixing the user-reported inconsistency.",
          "Return a string of the exception, might be tweaked to ensure `str()` reflects the full message, relevant to the issue.",
          "Returns if the exception is an instance of a specific class, unrelated to string conversion output.",
          "Gets detailed crash report info, unrelated to simple string conversion perspective.",
          "Gets rich representation of exception information, more verbose than simple `str()` concerns.",
          "Current source of the issue as it governs what `str()` yields when used on ExceptionInfo.",
          "Regex matching functionality, not relevant for string conversion.",
          "Deals with representation of exceptions, overlays standard conversion output but balanced elsewhere.",
          "Constructor for the representation; doesn't influence basic string behavior.",
          "Handles terminal outputting, irrelevant to simple `str()` utility.",
          "Deals with error handling for type comparison errors, unrelated to basic string conversion issues.",
          "The primary interface that users interact with for setting up exception expectations.",
          ""
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:46:07.452350",
        "usage": "2.3980140686035156 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.python_api._cmp_raises_type_error",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
              "start_line": 22,
              "start_column": 496,
              "end_line": 0,
              "end_column": 951,
              "start_byte": 496,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.raises",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
              "start_line": 542,
              "start_column": 20241,
              "end_line": 0,
              "end_column": 26789,
              "start_byte": 20241,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.python_api.RaisesContext",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 708,
              "start_column": 26828,
              "end_line": 0,
              "end_column": 27562,
              "start_byte": 26828,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.RaisesContext.__init__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
              "start_line": 709,
              "start_column": 26853,
              "end_line": 4,
              "end_column": 27062,
              "start_byte": 26853,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__enter__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
              "start_line": 715,
              "start_column": 27068,
              "end_line": 4,
              "end_column": 27179,
              "start_byte": 27068,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__exit__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 719,
              "start_column": 27185,
              "end_line": 4,
              "end_column": 27562,
              "start_byte": 27185,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 372,
              "start_column": 11617,
              "end_line": 0,
              "end_column": 17390,
              "start_byte": 11617,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo._assert_start_repr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_assert_start_repr = \"AssertionError('assert \"",
              "start_line": 378,
              "start_column": 11762,
              "end_line": 4,
              "end_column": 11808,
              "start_byte": 11762,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_excinfo = attr.ib()",
              "start_line": 380,
              "start_column": 11814,
              "end_line": 4,
              "end_column": 11834,
              "start_byte": 11814,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._striptext",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_striptext = attr.ib(default=\"\")",
              "start_line": 381,
              "start_column": 11839,
              "end_line": 4,
              "end_column": 11871,
              "start_byte": 11839,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_traceback = attr.ib(default=None)",
              "start_line": 382,
              "start_column": 11876,
              "end_line": 4,
              "end_column": 11910,
              "start_byte": 11876,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_current",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
              "start_line": 384,
              "start_column": 11916,
              "end_line": 4,
              "end_column": 12782,
              "start_byte": 11916,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.for_later",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
              "start_line": 409,
              "start_column": 12788,
              "end_line": 4,
              "end_column": 12905,
              "start_byte": 12788,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.type",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
              "start_line": 415,
              "start_column": 12911,
              "end_line": 4,
              "end_column": 13006,
              "start_byte": 12911,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.value",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
              "start_line": 420,
              "start_column": 13012,
              "end_line": 4,
              "end_column": 13108,
              "start_byte": 13012,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.tb",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
              "start_line": 425,
              "start_column": 13114,
              "end_line": 4,
              "end_column": 13215,
              "start_byte": 13114,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.typename",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
              "start_line": 430,
              "start_column": 13221,
              "end_line": 4,
              "end_column": 13333,
              "start_byte": 13221,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
              "start_line": 435,
              "start_column": 13339,
              "end_line": 4,
              "end_column": 13536,
              "start_byte": 13339,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
              "start_line": 442,
              "start_column": 13542,
              "end_line": 4,
              "end_column": 13623,
              "start_byte": 13542,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__repr__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
              "start_line": 446,
              "start_column": 13629,
              "end_line": 4,
              "end_column": 13829,
              "start_byte": 13629,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.exconly",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
              "start_line": 451,
              "start_column": 13835,
              "end_line": 4,
              "end_column": 14454,
              "start_byte": 13835,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.errisinstance",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
              "start_line": 467,
              "start_column": 14460,
              "end_line": 4,
              "end_column": 14599,
              "start_byte": 14460,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._getreprcrash",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
              "start_line": 471,
              "start_column": 14605,
              "end_line": 4,
              "end_column": 14851,
              "start_byte": 14605,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 477,
              "start_column": 14857,
              "end_line": 4,
              "end_column": 16613,
              "start_byte": 14857,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
              "start_line": 536,
              "start_column": 16619,
              "end_line": 4,
              "end_column": 16837,
              "start_byte": 16619,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.match",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 543,
              "start_column": 16843,
              "end_line": 4,
              "end_column": 17390,
              "start_byte": 16843,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 850,
              "start_column": 28209,
              "end_line": 0,
              "end_column": 28507,
              "start_byte": 28209,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
              "start_line": 851,
              "start_column": 28253,
              "end_line": 4,
              "end_column": 28403,
              "start_byte": 28253,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 856,
              "start_column": 28409,
              "end_line": 4,
              "end_column": 28507,
              "start_byte": 28409,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyzing the reported issue:\n1.1 The user describes an issue with the `str()` function on a `pytest.raises` context variable behaving differently than expected. The expectation is that calling `str()` on the exception from a context managed by `pytest.raises` should behave like a normal exception caught with `try...except`, but it does not. `str(e)` on a normal exception gives the full message, while `pytest.raises`'s variant gives a shorter message.\n1.2 This issue is caused because when using `pytest.raises`, the context variable `e` refers to an `ExceptionInfo` object, rather than the exception itself.\n1.3 The user suggests that `str(e)` should return the complete exception message to align with standard expectations in typical Python exception handling.\n1.4 If the user did not provide an expected result, the result should match Python's standard `str(exception)` behavior, which is to return the complete message of the exception.\n\n2. Evaluation of relevant code:\n2.1 `_pytest.python_api.RaisesContext`: Manages the context of the `raises` block and initializes an `ExceptionInfo` object but does not handle how `str()` is applied to this object.\n2.3 `_pytest._code.ExceptionInfo`: Wraps an exception and provides various properties such as `type`, `value`, and `__str__()`. This class directly impacts what `str()` returns when called on a `pytest.raises` context variable. This class's `__str__` method currently returns a summary instead of a detailed message like a standard exception.\n2.4 To resolve the issue, the `__str__` method of `_pytest._code.ExceptionInfo` needs to be changed to return `str(self.value)` to match standard exception behavior. \n2.5 It appears that tweaking the `__str__` method of the `ExceptionInfo` class to output `str(self.value)` or matching the output akin to a normal caught exception could rectify the described inconsistency.",
          "symbols": [
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "reason": "The `__str__` method of `ExceptionInfo` is responsible for the string representation when `str()` is called. To match standard exception handling, it should be adjusted to return a complete message like a normal exception."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The `RaisesContext` class is responsible for creating the context where exceptions are expected to be raised. It uses `ExceptionInfo` to manage exception information, but the string conversion (problematic for the user) occurs at the `ExceptionInfo` level.",
            "The `__init__` method of `RaisesContext` initializes the context. No changes needed here for the described issue; it's only setting up the expected parameters.",
            "The `__enter__` method of `RaisesContext` creates an `ExceptionInfo` object, which mediates the exception's information. The actual string representation issue lies within `ExceptionInfo`, not the context entry setup.",
            "The `__exit__` method checks exceptions against expectations. The string representation problem doesn't occur here but upon accessing `ExceptionInfo` within the context manager.",
            "This class (`ExceptionInfo`) is key to the issue. Its `__str__` method affects what `str()` outputs when used on a `pytest.raises` context variable.",
            "This attribute is a constant and not directly related to the immediate problem of string conversion.",
            "This attribute represents the exception itself but altering `_excinfo` directly isn't apt for resolving a string representation problem.",
            "This attribute is likely involved in formatting exception output but is not part of the string conversion logic directly.",
            "This deals with the traceback of exceptions, not directly with the string conversion issue.",
            "This method's purpose is unclear from the default method alone regarding the issue; its purpose is more for class instantiation.",
            "Generates an 'empty' ExceptionInfo object; not directly related to the string conversion oversight.",
            "This property fetches the exception class; no direct bearing on the string conversion problem.",
            "This property fetches the exception value; it will be useful for correcting the string conversion output.",
            "This property fetches the traceback object; string conversion isn't impacted here.",
            "Provides the exception type name, useful for representations but not inherently wrong in context.",
            "Fetches an exception traceback; altering here doesn't resolve string outputs.",
            "Sets the traceback; unrelated to direct string conversion issues.",
            "Responsible for generic string output of ExceptionInfo, vital for fixing the user-reported inconsistency.",
            "Return a string of the exception, might be tweaked to ensure `str()` reflects the full message, relevant to the issue.",
            "Returns if the exception is an instance of a specific class, unrelated to string conversion output.",
            "Gets detailed crash report info, unrelated to simple string conversion perspective.",
            "Gets rich representation of exception information, more verbose than simple `str()` concerns.",
            "Current source of the issue as it governs what `str()` yields when used on ExceptionInfo.",
            "Regex matching functionality, not relevant for string conversion.",
            "Deals with representation of exceptions, overlays standard conversion output but balanced elsewhere.",
            "Constructor for the representation; doesn't influence basic string behavior.",
            "Handles terminal outputting, irrelevant to simple `str()` utility.",
            "Deals with error handling for type comparison errors, unrelated to basic string conversion issues.",
            "The primary interface that users interact with for setting up exception expectations.",
            ""
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_code/code.py"
        ],
        "symbols": [
          "_pytest._code.ExceptionInfo.__str__"
        ],
        "code_spans": {
          "_pytest.python_api._cmp_raises_type_error": {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          "_pytest.python_api.raises": {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext": {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext.__init__": {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__enter__": {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__exit__": {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo": {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          "_pytest._code.ExceptionInfo._assert_start_repr": {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._excinfo": {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._striptext": {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._traceback": {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.from_current": {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.for_later": {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.type": {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.value": {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.tb": {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.typename": {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.traceback": {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__repr__": {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.exconly": {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.errisinstance": {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._getreprcrash": {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__str__": {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.match": {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo": {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          "_pytest._code.ReprExceptionInfo.__init__": {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.toterminal": {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        }
      }
    }
  ]
}