{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-6116",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:47.709916",
        "usage": "1328.357219696045 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "try_makedirs",
          "putaround",
          "setenv",
          "CollectError",
          "maketxtfile",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "_create_formatter",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "NodeMarkers",
          "Entry",
          "_find_spec",
          "popcall",
          "pytest_collect_directory",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "visit_BoolOp",
          "check_strict_xfail",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "ReprExceptionInfo",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "no_re_match_line",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "FunctionMixin",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "dir",
          "_ellipsize",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "pytest_itemstart",
          "prog",
          "_PytestWrapper",
          "mode",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "fslocation",
          "_get_pdb_wrapper_class",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "type",
          "_inject_setup_teardown_fixtures",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "FormattedExcinfo",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "pytest_assertion_pass",
          "_from_json",
          "getplugin",
          "failed",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_try_repr_or_str",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "FIXTURE_ARGS_ORDER",
          "freeze_support",
          "_W",
          "own_markers",
          "monkeypatch",
          "__bool__",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "addini",
          "faulthandler",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "CHECKER_CLASS",
          "fail_fixturefunc",
          "pytest_ignore_collect",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_visit_filter",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "_try_load_conftest",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "CACHEDIR_TAG_CONTENT",
          "_write_json_data",
          "_repr_style",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_report_to_json",
          "_compare_eq_cls",
          "safe_text_dupfile",
          "done",
          "CallInfo",
          "WarningsChecker",
          "_write_pyc",
          "fixture",
          "MonkeyPatch",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_make_plural",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "TESTS_FAILED",
          "verbosity",
          "_check_scope",
          "_update_message",
          "ParameterSet",
          "raises",
          "Junit",
          "format",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "caplog",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "from_exc_info",
          "_fail_on_non_top_pytest_plugins",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "CollectErrorRepr",
          "pytest_configure",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "INTERNAL_ERROR",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "_do_configure",
          "on_rm_rf_error",
          "exec_module",
          "get_fslocation_from_item",
          "DummyRewriteHook",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "import_plugin",
          "_assert_expr_to_lineno",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "_no_match_line",
          "append_pass",
          "writelines",
          "record_xml_attribute",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "_bytes_to_ascii",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "RaisesContext",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "warn_about_none_ast",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "_check_if_assertion_pass_impl",
          "errors",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "rewrite",
          "toterminal",
          "nodes",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "addSkip",
          "update",
          "assert_contains",
          "_get_auto_indent",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "_ensure_only_one_capture_fixture",
          "parse_args",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "ishidden",
          "defaultfuncargprefixmarker",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "getdecoded",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "_handle_skip",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "_parse_parametrize_parameters",
          "setns",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "OK",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "alias",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "LineComp",
          "_striptext",
          "PyobjContext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "_report_kwargs_from_json",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "parse_known_args",
          "pytest_generate_tests",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "USAGE_ERROR",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "add_stats",
          "fill_unfilled",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "NO_TESTS_COLLECTED",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "_get_assertion_exprs",
          "_non_numeric_type_error",
          "iter_markers_with_node",
          "PYTEST_TAG",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "_done",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_getcapture",
          "_rget_with_confmod",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "_AnyPurePath",
          "clear",
          "parsefactories",
          "BINOP_MAP",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "longrepr",
          "bin_xml_escape",
          "context",
          "short_test_summary",
          "__next__",
          "format_session_duration",
          "FDCapture",
          "ReportLogPlugin",
          "get_option_ini",
          "runtest",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "capture_fixtures",
          "addError",
          "call_optional",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "find_spec",
          "_makepath",
          "_format_action_invocation",
          "FuncargnamesCompatAttr",
          "_getvaluepath",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_get_global_properties_node",
          "getpathnode",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "_parse_fixture_args",
          "Session",
          "addinivalue_line",
          "Exit",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "create_module",
          "_assertion_pass",
          "_teardown_yield_fixture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "rm_rf",
          "emit",
          "_log",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "no_fnmatch_line",
          "outcomes",
          "sections",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_setup_collect_fakemodule",
          "wasvalid",
          "report_log",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_test_pytest_function",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "__nonzero__",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "append_collect_skipped",
          "_collectfile",
          "_color_for_type",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "PseudoFixtureDef",
          "_reprcompare",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "_get_number_flag",
          "INTERRUPTED",
          "_readline_workaround",
          "_teardown_towards",
          "_runtest_for_main",
          "_check_record_param_type",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "_get_main_color",
          "yield_fixture",
          "_setupstate",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "PyobjMixin",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "last_failed_paths",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "find",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "_E",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "call_and_report",
          "visit_Starred",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "InvocationParams",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "markname",
          "_given_basetemp",
          "popen",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "UNARY_MAP",
          "nextitem",
          "approx",
          "_addoption_instance",
          "_color_for_type_default",
          "LineMatcher_fixture",
          "plugins",
          "_init_checker_class",
          "_excinfo",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_call_assertion_pass",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "repr_excinfo",
          "ExitCode",
          "syspath_prepend",
          "cache_key",
          "set_trace",
          "__iter__",
          "get_actual_log_level",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "rex_session_duration",
          "istrue",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "set_repr_style",
          "_addoption",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "FUNCARGNAMES",
          "MarkMapping",
          "append_skipped",
          "_get_stderr_fileno",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "get_cache_dir",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "_surrounding_parens_on_own_lines",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "_eval_scope_callable",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "_format_repr_exception",
          "nose",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "pytest_collect_file",
          "pytest_collect_directory",
          "pytest_collectstart",
          "pytest_collection",
          "pytest_collection_finish",
          "pytest_collection_modifyitems",
          "pytest_collection_modifyitems",
          "pytest_itemcollected",
          "pytest_addoption",
          "addoption"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:49.038293",
        "usage": "235.7161045074463 ms"
      },
      "request": {
        "tokens": [
          "pytest_collect_file",
          "pytest_collect_directory",
          "pytest_collectstart",
          "pytest_collection",
          "pytest_collection_finish",
          "pytest_collection_modifyitems",
          "pytest_collection_modifyitems",
          "pytest_itemcollected",
          "pytest_addoption",
          "addoption"
        ]
      },
      "response": {
        "results": {
          "pytest_addoption": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/report_log.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/debugging.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py"
          ],
          "pytest_collection_finish": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py"
          ],
          "addoption": [
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/report_log.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_collectstart": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_itemcollected": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py"
          ],
          "pytest_collect_directory": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:49.274019",
        "usage": "5411.29994392395 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_addoption": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/report_log.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/debugging.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_collection": [
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py"
          ],
          "pytest_collection_finish": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py"
          ],
          "addoption": [
            "src/_pytest/logging.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/report_log.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/main.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_collectstart": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/runner.py"
          ],
          "pytest_collection_modifyitems": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_itemcollected": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/pytester.py"
          ],
          "pytest_collect_file": [
            "src/_pytest/doctest.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py"
          ],
          "pytest_collect_directory": [
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/python.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is about adding a shortcut command for the `--collect-only` option in pytest. This involves identifying where the command line options are defined and managed within the pytest codebase.\n\nFirst, looking at the keywords available in `keyword_search_results`:\n\n1. **pytest_addoption**: This keyword is relevant because adding a command-line option typically involves modifying where options are added. Among the files listed, `src/_pytest/main.py` seems particularly relevant since it's common for main or core files to handle command-line arguments.\n\n2. **pytest_collection**: Although relevant to collecting tests, the `--collect-only` option is a command-line interface feature, so `pytest_addoption` is more directly relevant.\n\n3. **addoption**: This is directly related to adding options to the pytest command. Again, `src/_pytest/main.py` and potentially `src/_pytest/config/argparsing.py` are relevant because they relate to configuration and argument parsing, key aspects of managing command-line options.\n\n4. **pytest_collectstart/pytest_itemcollected**: These are more about the collection process itself rather than the command-line argument that triggers it.\n\nThe most relevant files to inspect for adding a shortcut to the `--collect-only` argument would be those handling the addition and parsing of command-line options.",
        "file_paths": [
          "src/_pytest/main.py",
          "src/_pytest/config/argparsing.py",
          "src/_pytest/hookspec.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:54.685340",
        "usage": "5643.171072006226 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing user instructions:\n- The user wants a shortcut for the `--collect-only` pytest argument as it is long to type.\n- The issue is about ease of use and convenience when running pytest commands frequently.\n- The solution could involve adding a single-character option to trigger the same functionality as `--collect-only`.\n\n2. Evaluating the relevant file:\n- The method `pytest_addoption()` is responsible for adding command-line options in pytest.\n- This method calls `group.addoption()` which could be used to add a new short command-line argument.\n- The `--collect-only` option is already implemented in this method.\n- To comply with user requests, adding a single-character complement to this option would be straightforward by adding an extra call to `group.addoption()` within the same block where `--collectonly` is defined.\n\n- Upon review, the `pytest_addoption` function provides an appropriate location to add a new character option to serve the user needs.\n\n3. Relevant symbols: The file is relevant because it contains the logic for adding CLI options to pytest, and the `pytest_addoption` function contains the existing `--collectonly` option which is at the core of this issue.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "pytest_addoption"
        ],
        "root_cause_symbols": [
          "pytest_addoption"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:00.328524",
        "usage": "7241.787910461426 ms"
      },
      "request": {
        "file_path": "src/_pytest/config/argparsing.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n\n1.1 The user is describing an issue where they frequently use the `--collect-only` command in pytest, and they find the command too lengthy to type repeatedly. They suggest assigning it a single-character shortcut to reduce typing effort.\n\n1.2 The user provided their usage scenario, but no specific reproduction steps as the issue is more about convenience of use rather than a malfunction.\n\n1.3 The issue is caused by the lack of a shortcut for a frequently used command `--collect-only` in pytest. This is not a bug but rather a feature request to enhance usability.\n\n1.4 The user expects that a single-character shortcut would be implemented for the `--collect-only` command in pytest. The issue is primarily a user experience concern, aiming to make command usage more efficient.\n\n1.6 Possible solutions could include introducing a one-character alias for `--collect-only`, updating the documentation to include this new alias, and ensuring backward compatibility if possible.\n\n\n2. Make file evaluation:\n\nThe file `src/_pytest/config/argparsing.py` contains code related to argument parsing in pytest.\n\n2.1 The file defines multiple classes and methods related to argument parsing, including `Parser`, `Argument`, `OptionGroup`, and `MyOptionParser`. These classes manage command-line arguments and options for pytest.\n\n2.2 & 2.3 The `addoption` method in the `Parser` class is relevant as it is used to register command-line options. The `Argument` class helps in managing such options.\n\n2.4 The `addoption` method could be where the shortcut logic for the `--collect-only` command is implemented, by introducing a new short option.\n\n2.5 The method `addoption` would likely have interaction points with other parts of pytest dealing with command-line arguments.\n\n2.6 This file appears to be central to managing command-line options and is likely related to implementing the shortcut feature, but we need to add the actual shortcut to `--collect-only`. \n\n3. Output your decisions:\n\nGiven the content and role of this file, it is highly relevant to the feature request as it handles the registration and parsing of command-line options and could be the root cause if the shortcut isn't implemented or isn't working correctly.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Parser.addoption",
          "Argument",
          "OptionGroup.addoption",
          "MyOptionParser._parse_optional"
        ],
        "root_cause_symbols": [
          "Parser.addoption"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:07.570327",
        "usage": "7640.96474647522 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing User Instructions:\n\n1.1 What issue is the user describing?\nThe user is requesting a shortcut for the pytest `--collect-only` command-line argument as it is deemed too lengthy to type frequently.\n\n1.2 User give a reproduce steps?, if yes, think why these steps cause the issue.\nThe user did not provide reproduction steps, but the issue is related to the necessity to frequently use `--collect-only`, which is cumbersome to type repeatedly.\n\n1.3 How was this issue caused?\nThere was no shortcut or alias assigned to the `--collect-only` command in pytest, which makes it inconvenient for frequent users.\n\n1.4 Summary of the user expectation and why it causes the issue.\nThe expectation is to have a single character shortcut for `--collect-only` to simplify the command input. The absence of such a shortcut results in inefficiency for end users.\n\n1.5 Some possible solutions to the issue.\n- Define a new single-character alias for the `--collect-only` option in the command-line options configuration.\n- Ensure this change is backward-compatible and does not conflict with existing shortcuts.\n\n2. Make File Evaluation:\n\n2.1 Thoroughly analyze each line in the <file_content>.\nThe file consists mostly of hooks specified for pytest plugins and configurations.\n\n2.2 Match the symbol with the key elements, functions, variables, or patterns identified in the reported issue.\nThe symbol that seems relevant to modifying the command-line options is `pytest_addoption`.\n\n2.3 Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n`pytest_addoption` is pertinent because it deals with registering argparse-style options, which aligns with the resolution of adding a command-line shortcut.\n\n2.4 Review entire sections of code, not just isolated symbols, to ensure a complete understanding before making a decision.\nThe section with `pytest_addoption` explains how to add command-line options, suggesting this is the correct place to address shortcut addition.\n\n2.6 Determine if the file is the root cause of the issue or if it's related to the root cause.\nThe file defines hooks but isn\u2019t the root cause. However, it may offer the utility function needed to potentially resolve the issue by adding a command-line option shortcut.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config.py",
          "src/_pytest/terminal.py"
        ],
        "relevant_symbols": [
          "pytest_addoption"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:46:15.211320",
        "usage": "136.13080978393555 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "pytest_addoption"
            ],
            "root_cause_symbol_keys": [
              "pytest_addoption"
            ]
          },
          {
            "file_path": "src/_pytest/config/argparsing.py",
            "relevant_symbol_keys": [
              "Parser.addoption",
              "Argument",
              "OptionGroup.addoption",
              "MyOptionParser._parse_optional"
            ],
            "root_cause_symbol_keys": [
              "Parser.addoption"
            ]
          },
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [
              "pytest_addoption"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.config.ArgumentError",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class ArgumentError(Exception):\n    \"\"\"\n    Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\n    \"\"\"\n\n    def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)\n\n    def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 145,
            "start_column": 5419,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 5419,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ArgumentError.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)",
            "start_line": 151,
            "start_column": 5562,
            "end_line": 4,
            "end_column": 5654,
            "start_byte": 5562,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.ArgumentError.__str__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 155,
            "start_column": 5660,
            "end_line": 4,
            "end_column": 5815,
            "start_byte": 5660,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class Argument:\n    \"\"\"class that mimics the necessary behaviour of optparse.Option\n\n    it's currently a least effort implementation\n    and ignoring choices and integer prefixes\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n\n    def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)\n\n    def names(self):\n        return self._short_opts + self._long_opts\n\n    def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs\n\n    def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)\n\n    def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 162,
            "start_column": 5818,
            "end_line": 0,
            "end_column": 10992,
            "start_byte": 5818,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.Argument._typ_map",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "_typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}",
            "start_line": 170,
            "start_column": 6094,
            "end_line": 4,
            "end_column": 6168,
            "start_byte": 6094,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)",
            "start_line": 172,
            "start_column": 6174,
            "end_line": 4,
            "end_column": 8718,
            "start_byte": 6174,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.names",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def names(self):\n        return self._short_opts + self._long_opts",
            "start_line": 232,
            "start_column": 8724,
            "end_line": 4,
            "end_column": 8790,
            "start_byte": 8724,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.attrs",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs",
            "start_line": 235,
            "start_column": 8796,
            "end_line": 4,
            "end_column": 9357,
            "start_byte": 8796,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument._set_opt_strings",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)",
            "start_line": 252,
            "start_column": 9363,
            "end_line": 4,
            "end_column": 10468,
            "start_byte": 9363,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.__repr__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 280,
            "start_column": 10474,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10474,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.OptionGroup.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *optnames, **attrs):\n        \"\"\" add an option to this group.\n\n        if a shortened version of a long option is specified it will\n        be suppressed in the help. addoption('--twowords', '--two-words')\n        results in help showing '--two-words' only, but --twowords gets\n        accepted **and** the automatic destination is in args.twowords\n        \"\"\"\n        conflict = set(optnames).intersection(\n            name for opt in self.options for name in opt.names()\n        )\n        if conflict:\n            raise ValueError(\"option names %s already added\" % conflict)\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=False)",
            "start_line": 301,
            "start_column": 11221,
            "end_line": 4,
            "end_column": 11922,
            "start_byte": 11221,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "----------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
            "start_line": 11,
            "start_column": 229,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 229,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytes",
            "start_line": 301,
            "start_column": 11226,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 11226,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "-----------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a n",
            "start_line": 19,
            "start_column": 345,
            "end_line": 0,
            "end_column": 824,
            "start_byte": 345,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginn",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "t directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and ",
            "start_line": 50,
            "start_column": 1390,
            "end_line": 0,
            "end_column": 2808,
            "start_byte": 1390,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# --------------",
            "start_line": 7,
            "start_column": 48,
            "end_line": 0,
            "end_column": 303,
            "start_byte": 48,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "",
            "start_line": 1190,
            "start_column": 44317,
            "end_line": 0,
            "end_column": 44505,
            "start_byte": 44317,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "le options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attr",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2482,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"",
            "start_line": 36,
            "start_column": 1070,
            "end_line": 0,
            "end_column": 2624,
            "start_byte": 1070,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "elating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\" called after fixture teardown, but before the cache is cleared so\n    the fixture result cache ``fixturedef.cached_result`` can\n    still be accessed.\"\"\"\n\n\n# -------------------------------------------------",
            "start_line": 382,
            "start_column": 12558,
            "end_line": 0,
            "end_column": 13941,
            "start_byte": 12558,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "onfig.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or N",
            "start_line": 171,
            "start_column": 6052,
            "end_line": 0,
            "end_column": 8708,
            "start_byte": 6052,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not ",
            "start_line": 45,
            "start_column": 969,
            "end_line": 0,
            "end_column": 5086,
            "start_byte": 969,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "on should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after comma",
            "start_line": 36,
            "start_column": 1291,
            "end_line": 0,
            "end_column": 2845,
            "start_byte": 1291,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"ca",
            "start_line": 6,
            "start_column": 107,
            "end_line": 0,
            "end_column": 435,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_p",
            "start_line": 46,
            "start_column": 1098,
            "end_line": 0,
            "end_column": 1709,
            "start_byte": 1098,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "t.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult",
            "start_line": 56,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3388,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPlugin",
            "start_line": 29,
            "start_column": 633,
            "end_line": 0,
            "end_column": 945,
            "start_byte": 633,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(plugi",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 415,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ----",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "nitialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
            "start_line": 8,
            "start_column": 243,
            "end_line": 0,
            "end_column": 723,
            "start_byte": 243,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow ad",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecate",
            "start_line": 56,
            "start_column": 1402,
            "end_line": 0,
            "end_column": 4066,
            "start_byte": 1402,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "lugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plug",
            "start_line": 31,
            "start_column": 870,
            "end_line": 0,
            "end_column": 1328,
            "start_byte": 870,
            "end_byte": 0
          },
          {
            "name": "_pytest.report_log.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "om main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ------------------------------------------------------------------",
            "start_line": 6,
            "start_column": 54,
            "end_line": 0,
            "end_column": 355,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager",
            "start_line": 8,
            "start_column": 107,
            "end_line": 0,
            "end_column": 423,
            "start_byte": 107,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"",
            "start_line": 11,
            "start_column": 229,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 229,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep",
            "start_line": 301,
            "start_column": 11226,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 11226,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go",
            "start_line": 19,
            "start_column": 345,
            "end_line": 0,
            "end_column": 824,
            "start_byte": 345,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol",
            "start_line": 50,
            "start_column": 1390,
            "end_line": 0,
            "end_column": 2808,
            "start_byte": 1390,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": ", session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py",
            "start_line": 7,
            "start_column": 48,
            "end_line": 0,
            "end_column": 303,
            "start_byte": 48,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1190,
            "start_column": 44317,
            "end_line": 0,
            "end_column": 44505,
            "start_byte": 44317,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2482,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n",
            "start_line": 36,
            "start_column": 1070,
            "end_line": 0,
            "end_column": 2624,
            "start_byte": 1070,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  ",
            "start_line": 382,
            "start_column": 12558,
            "end_line": 0,
            "end_column": 13941,
            "start_byte": 12558,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo",
            "start_line": 171,
            "start_column": 6052,
            "end_line": 0,
            "end_column": 8708,
            "start_byte": 6052,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )",
            "start_line": 45,
            "start_column": 969,
            "end_line": 0,
            "end_column": 5086,
            "start_byte": 969,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path",
            "start_line": 36,
            "start_column": 1291,
            "end_line": 0,
            "end_column": 2845,
            "start_byte": 1291,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle",
            "start_line": 6,
            "start_column": 107,
            "end_line": 0,
            "end_column": 435,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       ",
            "start_line": 46,
            "start_column": 1098,
            "end_line": 0,
            "end_column": 1709,
            "start_byte": 1098,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle",
            "start_line": 56,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3388,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N",
            "start_line": 29,
            "start_column": 633,
            "end_line": 0,
            "end_column": 945,
            "start_byte": 633,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 415,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail",
            "start_line": 8,
            "start_column": 243,
            "end_line": 0,
            "end_column": 723,
            "start_byte": 243,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel",
            "start_line": 56,
            "start_column": 1402,
            "end_line": 0,
            "end_column": 4066,
            "start_byte": 1402,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given ",
            "start_line": 31,
            "start_column": 870,
            "end_line": 0,
            "end_column": 1328,
            "start_byte": 870,
            "end_byte": 0
          },
          {
            "name": "_pytest.report_log.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo",
            "start_line": 6,
            "start_column": 54,
            "end_line": 0,
            "end_column": 355,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner ",
            "start_line": 8,
            "start_column": 107,
            "end_line": 0,
            "end_column": 423,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.Parser.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *opts, **attrs):\n        \"\"\" register a command line option.\n\n        :opts: option names, can be short or long options.\n        :attrs: same attributes which the ``add_option()`` function of the\n           `argparse library\n           <http://docs.python.org/2/library/argparse.html>`_\n           accepts.\n\n        After command line parsing options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption(\"--long\", dest=\"NAME\", ...)``.\n        \"\"\"\n        self._anonymous.addoption(*opts, **attrs)",
            "start_line": 63,
            "start_column": 1972,
            "end_line": 4,
            "end_column": 2615,
            "start_byte": 1972,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:15.347458",
        "usage": "20569.827795028687 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.config.ArgumentError",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class ArgumentError(Exception):\n    \"\"\"\n    Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\n    \"\"\"\n\n    def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)\n\n    def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 145,
            "start_column": 5419,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 5419,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.ArgumentError.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)",
            "start_line": 151,
            "start_column": 5562,
            "end_line": 4,
            "end_column": 5654,
            "start_byte": 5562,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.ArgumentError.__str__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 155,
            "start_column": 5660,
            "end_line": 4,
            "end_column": 5815,
            "start_byte": 5660,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class Argument:\n    \"\"\"class that mimics the necessary behaviour of optparse.Option\n\n    it's currently a least effort implementation\n    and ignoring choices and integer prefixes\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n\n    def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)\n\n    def names(self):\n        return self._short_opts + self._long_opts\n\n    def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs\n\n    def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)\n\n    def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 162,
            "start_column": 5818,
            "end_line": 0,
            "end_column": 10992,
            "start_byte": 5818,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.Argument._typ_map",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "_typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}",
            "start_line": 170,
            "start_column": 6094,
            "end_line": 4,
            "end_column": 6168,
            "start_byte": 6094,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)",
            "start_line": 172,
            "start_column": 6174,
            "end_line": 4,
            "end_column": 8718,
            "start_byte": 6174,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.names",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def names(self):\n        return self._short_opts + self._long_opts",
            "start_line": 232,
            "start_column": 8724,
            "end_line": 4,
            "end_column": 8790,
            "start_byte": 8724,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.attrs",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs",
            "start_line": 235,
            "start_column": 8796,
            "end_line": 4,
            "end_column": 9357,
            "start_byte": 8796,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument._set_opt_strings",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)",
            "start_line": 252,
            "start_column": 9363,
            "end_line": 4,
            "end_column": 10468,
            "start_byte": 9363,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.Argument.__repr__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 280,
            "start_column": 10474,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10474,
            "end_byte": 4
          },
          {
            "name": "_pytest.config.OptionGroup.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *optnames, **attrs):\n        \"\"\" add an option to this group.\n\n        if a shortened version of a long option is specified it will\n        be suppressed in the help. addoption('--twowords', '--two-words')\n        results in help showing '--two-words' only, but --twowords gets\n        accepted **and** the automatic destination is in args.twowords\n        \"\"\"\n        conflict = set(optnames).intersection(\n            name for opt in self.options for name in opt.names()\n        )\n        if conflict:\n            raise ValueError(\"option names %s already added\" % conflict)\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=False)",
            "start_line": 301,
            "start_column": 11221,
            "end_line": 4,
            "end_column": 11922,
            "start_byte": 11221,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "----------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
            "start_line": 11,
            "start_column": 229,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 229,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytes",
            "start_line": 301,
            "start_column": 11226,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 11226,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "-----------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a n",
            "start_line": 19,
            "start_column": 345,
            "end_line": 0,
            "end_column": 824,
            "start_byte": 345,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginn",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "t directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and ",
            "start_line": 50,
            "start_column": 1390,
            "end_line": 0,
            "end_column": 2808,
            "start_byte": 1390,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "ked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# --------------",
            "start_line": 7,
            "start_column": 48,
            "end_line": 0,
            "end_column": 303,
            "start_byte": 48,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "",
            "start_line": 1190,
            "start_column": 44317,
            "end_line": 0,
            "end_column": 44505,
            "start_byte": 44317,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "le options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attr",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2482,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"",
            "start_line": 36,
            "start_column": 1070,
            "end_line": 0,
            "end_column": 2624,
            "start_byte": 1070,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "elating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\" called after fixture teardown, but before the cache is cleared so\n    the fixture result cache ``fixturedef.cached_result`` can\n    still be accessed.\"\"\"\n\n\n# -------------------------------------------------",
            "start_line": 382,
            "start_column": 12558,
            "end_line": 0,
            "end_column": 13941,
            "start_byte": 12558,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "onfig.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or N",
            "start_line": 171,
            "start_column": 6052,
            "end_line": 0,
            "end_column": 8708,
            "start_byte": 6052,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not ",
            "start_line": 45,
            "start_column": 969,
            "end_line": 0,
            "end_column": 5086,
            "start_byte": 969,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "on should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after comma",
            "start_line": 36,
            "start_column": 1291,
            "end_line": 0,
            "end_column": 2845,
            "start_byte": 1291,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"ca",
            "start_line": 6,
            "start_column": 107,
            "end_line": 0,
            "end_column": 435,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": " pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_p",
            "start_line": 46,
            "start_column": 1098,
            "end_line": 0,
            "end_column": 1709,
            "start_byte": 1098,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "t.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult",
            "start_line": 56,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3388,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPlugin",
            "start_line": 29,
            "start_column": 633,
            "end_line": 0,
            "end_column": 945,
            "start_byte": 633,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(plugi",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 415,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ----",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "nitialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
            "start_line": 8,
            "start_column": 243,
            "end_line": 0,
            "end_column": 723,
            "start_byte": 243,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow ad",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecate",
            "start_line": 56,
            "start_column": 1402,
            "end_line": 0,
            "end_column": 4066,
            "start_byte": 1402,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "lugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plug",
            "start_line": 31,
            "start_column": 870,
            "end_line": 0,
            "end_column": 1328,
            "start_byte": 870,
            "end_byte": 0
          },
          {
            "name": "_pytest.report_log.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "om main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ------------------------------------------------------------------",
            "start_line": 6,
            "start_column": 54,
            "end_line": 0,
            "end_column": 355,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/hookspec.py",
            "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager",
            "start_line": 8,
            "start_column": 107,
            "end_line": 0,
            "end_column": 423,
            "start_byte": 107,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"",
            "start_line": 11,
            "start_column": 229,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 229,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep",
            "start_line": 301,
            "start_column": 11226,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 11226,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go",
            "start_line": 19,
            "start_column": 345,
            "end_line": 0,
            "end_column": 824,
            "start_byte": 345,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol",
            "start_line": 50,
            "start_column": 1390,
            "end_line": 0,
            "end_column": 2808,
            "start_byte": 1390,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": ", session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py",
            "start_line": 7,
            "start_column": 48,
            "end_line": 0,
            "end_column": 303,
            "start_byte": 48,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1190,
            "start_column": 44317,
            "end_line": 0,
            "end_column": 44505,
            "start_byte": 44317,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2482,
            "start_byte": 1168,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n",
            "start_line": 36,
            "start_column": 1070,
            "end_line": 0,
            "end_column": 2624,
            "start_byte": 1070,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  ",
            "start_line": 382,
            "start_column": 12558,
            "end_line": 0,
            "end_column": 13941,
            "start_byte": 12558,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo",
            "start_line": 171,
            "start_column": 6052,
            "end_line": 0,
            "end_column": 8708,
            "start_byte": 6052,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )",
            "start_line": 45,
            "start_column": 969,
            "end_line": 0,
            "end_column": 5086,
            "start_byte": 969,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path",
            "start_line": 36,
            "start_column": 1291,
            "end_line": 0,
            "end_column": 2845,
            "start_byte": 1291,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle",
            "start_line": 6,
            "start_column": 107,
            "end_line": 0,
            "end_column": 435,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       ",
            "start_line": 46,
            "start_column": 1098,
            "end_line": 0,
            "end_column": 1709,
            "start_byte": 1098,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle",
            "start_line": 56,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3388,
            "start_byte": 1713,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N",
            "start_line": 29,
            "start_column": 633,
            "end_line": 0,
            "end_column": 945,
            "start_byte": 633,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 415,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail",
            "start_line": 8,
            "start_column": 243,
            "end_line": 0,
            "end_column": 723,
            "start_byte": 243,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel",
            "start_line": 56,
            "start_column": 1402,
            "end_line": 0,
            "end_column": 4066,
            "start_byte": 1402,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given ",
            "start_line": 31,
            "start_column": 870,
            "end_line": 0,
            "end_column": 1328,
            "start_byte": 870,
            "end_byte": 0
          },
          {
            "name": "_pytest.report_log.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo",
            "start_line": 6,
            "start_column": 54,
            "end_line": 0,
            "end_column": 355,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner ",
            "start_line": 8,
            "start_column": 107,
            "end_line": 0,
            "end_column": 423,
            "start_byte": 107,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.Parser.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *opts, **attrs):\n        \"\"\" register a command line option.\n\n        :opts: option names, can be short or long options.\n        :attrs: same attributes which the ``add_option()`` function of the\n           `argparse library\n           <http://docs.python.org/2/library/argparse.html>`_\n           accepts.\n\n        After command line parsing options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption(\"--long\", dest=\"NAME\", ...)``.\n        \"\"\"\n        self._anonymous.addoption(*opts, **attrs)",
            "start_line": 63,
            "start_column": 1972,
            "end_line": 4,
            "end_column": 2615,
            "start_byte": 1972,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing the need for a shorter command-line option for a frequently used pytest argument, `--collect-only`. \n1.2 This issue arises because current command is too lengthy to type frequently.\n1.3 The user indicates a desire to add a single-character shortcut that has the same effect as `--collect-only`.\n1.4 The expected result should be a single-character option that performs the same function as `--collect-only` when used with the pytest command line.\n1.5 To fix this issue, we should introduce a new single-character option that serves the same function as `--collect-only`. We might need to update the argument registration to include this new short option.\n\n2. Make the evaluate:\n2.1 I need to go through each symbol provided to see which, if any, are related to command-line options.\n2.2 The related symbols I should look for might involve argument parsing, command registration, or handling of `--collect-only` specifically.\n2.3 From the symbols given I need to determine where `--collect-only` is implemented or defined and see if it includes the capacity for a short alias.\n2.4 If not explicitly provided, I may need to locate where command line options are configured and ensure a single character option is set.\n2.5 If none of these symbols provide enough insight into how options are registered, I may need additional information from the user.\n\n\n",
        "symbols": [
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "reason": "This symbol contains the implementation for adding options, including '--collect-only'. A new single character shortcut should be added here."
          },
          {
            "name": "_pytest.config.Parser.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "reason": "This method registers the command line options, therefore, it is where the new shortcut should be implemented."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The symbol seems to contain import statements and an ExitCode class for encoding pytest exit codes. There's partial content of the pytest_addoption which might indicate this is where options are added, but this doesn't specifically relate to handling command-line argument --collect-only yet. I need to further verify this relevance.",
          "The symbol content is lacking actual implementation of pytest_addoption but is related more to test failures, stopping test execution, and statuses. It seems unlikely this is where the argparse option for --collect-only would be managed.",
          "This snippet shows arbitrated imports and might relate to testing states. However, there seems to be little connection to where command line options are parsed or added such as --collect-only.",
          "The symbol indicates part of imports and definitions related to runner setups etc., but not specific to option parsing. Unless it's within the partially present pytest_addoption function, I would need to ignore it.",
          "The partial defines fixtures that offer test configuration and execution methods rather than pointing towards argparse or option handling relevant for --collect-only.",
          "The snippet seems incomplete and only vaguely related to path specifications and argument options. Not distinctly related to command-line arguments like --collect-only as visible so far.",
          "Incomplete snippet regarding enum exit codes, not specific to the handling or arrangement of command-line arguments.",
          "Help functionality and option parsing might be tackled here, though the snippet does not point at command option adjustments or inline with argparse command-line parsing.",
          "This is a class command, it doesn't give insights into the handling of a specific --collect-only shortcut. Nevertheless, it's related since parsing options is crucial to implementing command-line arguments.",
          "Pertains to managing Argument errors and existing classes involving Argument interfaces. Related more to error handling than to defining shortcuts or command options directly.",
          "Initializes the ArgumentError, not connected directly to command line argument parsing or setup options.",
          "Contributes to stringification of errors in argument handling rather than option parsing.",
          "Argument instantiation manages short and long-form options but unless more content focuses on practical applications of pytest arguments, its relation to --collect-only isn't explicit.",
          "Typ map refers to type conversion associated with parsing, indirectly related if type adjustments needed.",
          "Argument class init handles option short and long form storage, potential direct relevance requires more context on how the parsing is involved in storing --collect-only identifiers.",
          "Deals with returning arg names not direct to parsing or `--collect-only` manipulation currently.",
          "Attr list-updates seem related to storing attributes for parsing, might be where a new option is given attributes, need broader context to connect to `--collect-only`.",
          "Handles strings for options, thus related as might regulate the form `--collect-only` is kept or modified, guaranteeing formatted correctly.",
          "The representation method primarily deals with configuration displays of options.",
          "The addoption function defines options relevant in context, potentially highly related means should add the character shortcut for --collect-only here.",
          "Discusses plugin registration under hookspec without regard to command line directly.",
          "Commands are meant to signal state conclusions in testing, not aligning to --collect-only yet.",
          "Part of hookspec structure, indicating configs, yet lacking focus on actual argument parsing in current snippet.",
          "Print messages capture hook registrations without direct relevance to command line argument sequences presently.",
          "Documentation part of command parsing init, however not elucidating placeholders or options closely correlated to `--collect-only`.",
          "Initially dealing hooks, without clear relation to `--collect-only` option generation.",
          "Discusses directive plugin registration, not aligning to individual hook registrations yet.",
          "These sections detail plugin hook registration in a way mostly orthogonal to parsing command line options so far seen.",
          "Describes another hook-based script setting, instead of registering through command line arguments.",
          "",
          "Details registering type specs, rather than command options in this form.",
          "Specifies system-level hookstarts but drops off before relating to command line usage.",
          "Snippet involves plugin manager annotation not directly useful for argument shortcuts.",
          "Given as plugins marking, its focus isn't on internal command selection.",
          ""
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:46:35.917328",
        "usage": "2.32696533203125 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.config.ArgumentError",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "class ArgumentError(Exception):\n    \"\"\"\n    Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\n    \"\"\"\n\n    def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)\n\n    def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
              "start_line": 145,
              "start_column": 5419,
              "end_line": 0,
              "end_column": 5815,
              "start_byte": 5419,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.ArgumentError.__init__",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)",
              "start_line": 151,
              "start_column": 5562,
              "end_line": 4,
              "end_column": 5654,
              "start_byte": 5562,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.ArgumentError.__str__",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
              "start_line": 155,
              "start_column": 5660,
              "end_line": 4,
              "end_column": 5815,
              "start_byte": 5660,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "class Argument:\n    \"\"\"class that mimics the necessary behaviour of optparse.Option\n\n    it's currently a least effort implementation\n    and ignoring choices and integer prefixes\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n\n    def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)\n\n    def names(self):\n        return self._short_opts + self._long_opts\n\n    def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs\n\n    def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)\n\n    def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
              "start_line": 162,
              "start_column": 5818,
              "end_line": 0,
              "end_column": 10992,
              "start_byte": 5818,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.Argument._typ_map",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "_typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}",
              "start_line": 170,
              "start_column": 6094,
              "end_line": 4,
              "end_column": 6168,
              "start_byte": 6094,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument.__init__",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)",
              "start_line": 172,
              "start_column": 6174,
              "end_line": 4,
              "end_column": 8718,
              "start_byte": 6174,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument.names",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def names(self):\n        return self._short_opts + self._long_opts",
              "start_line": 232,
              "start_column": 8724,
              "end_line": 4,
              "end_column": 8790,
              "start_byte": 8724,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument.attrs",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs",
              "start_line": 235,
              "start_column": 8796,
              "end_line": 4,
              "end_column": 9357,
              "start_byte": 8796,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument._set_opt_strings",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)",
              "start_line": 252,
              "start_column": 9363,
              "end_line": 4,
              "end_column": 10468,
              "start_byte": 9363,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.Argument.__repr__",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
              "start_line": 280,
              "start_column": 10474,
              "end_line": 4,
              "end_column": 10992,
              "start_byte": 10474,
              "end_byte": 4
            },
            {
              "name": "_pytest.config.OptionGroup.addoption",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def addoption(self, *optnames, **attrs):\n        \"\"\" add an option to this group.\n\n        if a shortened version of a long option is specified it will\n        be suppressed in the help. addoption('--twowords', '--two-words')\n        results in help showing '--two-words' only, but --twowords gets\n        accepted **and** the automatic destination is in args.twowords\n        \"\"\"\n        conflict = set(optnames).intersection(\n            name for opt in self.options for name in opt.names()\n        )\n        if conflict:\n            raise ValueError(\"option names %s already added\" % conflict)\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=False)",
              "start_line": 301,
              "start_column": 11221,
              "end_line": 4,
              "end_column": 11922,
              "start_byte": 11221,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "----------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
              "start_line": 11,
              "start_column": 229,
              "end_line": 0,
              "end_column": 1052,
              "start_byte": 229,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytes",
              "start_line": 301,
              "start_column": 11226,
              "end_line": 0,
              "end_column": 12991,
              "start_byte": 11226,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "-----------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a n",
              "start_line": 19,
              "start_column": 345,
              "end_line": 0,
              "end_column": 824,
              "start_byte": 345,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "cs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginn",
              "start_line": 21,
              "start_column": 539,
              "end_line": 0,
              "end_column": 1237,
              "start_byte": 539,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "t directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and ",
              "start_line": 50,
              "start_column": 1390,
              "end_line": 0,
              "end_column": 2808,
              "start_byte": 1390,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "ked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# --------------",
              "start_line": 7,
              "start_column": 48,
              "end_line": 0,
              "end_column": 303,
              "start_byte": 48,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "",
              "start_line": 1190,
              "start_column": 44317,
              "end_line": 0,
              "end_column": 44505,
              "start_byte": 44317,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "le options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attr",
              "start_line": 38,
              "start_column": 1168,
              "end_line": 0,
              "end_column": 2482,
              "start_byte": 1168,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"",
              "start_line": 36,
              "start_column": 1070,
              "end_line": 0,
              "end_column": 2624,
              "start_byte": 1070,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "elating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\" called after fixture teardown, but before the cache is cleared so\n    the fixture result cache ``fixturedef.cached_result`` can\n    still be accessed.\"\"\"\n\n\n# -------------------------------------------------",
              "start_line": 382,
              "start_column": 12558,
              "end_line": 0,
              "end_column": 13941,
              "start_byte": 12558,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "onfig.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or N",
              "start_line": 171,
              "start_column": 6052,
              "end_line": 0,
              "end_column": 8708,
              "start_byte": 6052,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not ",
              "start_line": 45,
              "start_column": 969,
              "end_line": 0,
              "end_column": 5086,
              "start_byte": 969,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "on should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after comma",
              "start_line": 36,
              "start_column": 1291,
              "end_line": 0,
              "end_column": 2845,
              "start_byte": 1291,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"ca",
              "start_line": 6,
              "start_column": 107,
              "end_line": 0,
              "end_column": 435,
              "start_byte": 107,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": " pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_p",
              "start_line": 46,
              "start_column": 1098,
              "end_line": 0,
              "end_column": 1709,
              "start_byte": 1098,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "t.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult",
              "start_line": 56,
              "start_column": 1713,
              "end_line": 0,
              "end_column": 3388,
              "start_byte": 1713,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPlugin",
              "start_line": 29,
              "start_column": 633,
              "end_line": 0,
              "end_column": 945,
              "start_byte": 633,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(plugi",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 415,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ----",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 293,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "nitialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
              "start_line": 8,
              "start_column": 243,
              "end_line": 0,
              "end_column": 723,
              "start_byte": 243,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow ad",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 479,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecate",
              "start_line": 56,
              "start_column": 1402,
              "end_line": 0,
              "end_column": 4066,
              "start_byte": 1402,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "lugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plug",
              "start_line": 31,
              "start_column": 870,
              "end_line": 0,
              "end_column": 1328,
              "start_byte": 870,
              "end_byte": 0
            },
            {
              "name": "_pytest.report_log.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "om main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ------------------------------------------------------------------",
              "start_line": 6,
              "start_column": 54,
              "end_line": 0,
              "end_column": 355,
              "start_byte": 54,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/hookspec.py",
              "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager",
              "start_line": 8,
              "start_column": 107,
              "end_line": 0,
              "end_column": 423,
              "start_byte": 107,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"",
              "start_line": 11,
              "start_column": 229,
              "end_line": 0,
              "end_column": 1052,
              "start_byte": 229,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep",
              "start_line": 301,
              "start_column": 11226,
              "end_line": 0,
              "end_column": 12991,
              "start_byte": 11226,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go",
              "start_line": 19,
              "start_column": 345,
              "end_line": 0,
              "end_column": 824,
              "start_byte": 345,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t",
              "start_line": 21,
              "start_column": 539,
              "end_line": 0,
              "end_column": 1237,
              "start_byte": 539,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": " default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol",
              "start_line": 50,
              "start_column": 1390,
              "end_line": 0,
              "end_column": 2808,
              "start_byte": 1390,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": ", session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py",
              "start_line": 7,
              "start_column": 48,
              "end_line": 0,
              "end_column": 303,
              "start_byte": 48,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1190,
              "start_column": 44317,
              "end_line": 0,
              "end_column": 44505,
              "start_byte": 44317,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_",
              "start_line": 38,
              "start_column": 1168,
              "end_line": 0,
              "end_column": 2482,
              "start_byte": 1168,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": " to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n",
              "start_line": 36,
              "start_column": 1070,
              "end_line": 0,
              "end_column": 2624,
              "start_byte": 1070,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  ",
              "start_line": 382,
              "start_column": 12558,
              "end_line": 0,
              "end_column": 13941,
              "start_byte": 12558,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo",
              "start_line": 171,
              "start_column": 6052,
              "end_line": 0,
              "end_column": 8708,
              "start_byte": 6052,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )",
              "start_line": 45,
              "start_column": 969,
              "end_line": 0,
              "end_column": 5086,
              "start_byte": 969,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path",
              "start_line": 36,
              "start_column": 1291,
              "end_line": 0,
              "end_column": 2845,
              "start_byte": 1291,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle",
              "start_line": 6,
              "start_column": 107,
              "end_line": 0,
              "end_column": 435,
              "start_byte": 107,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       ",
              "start_line": 46,
              "start_column": 1098,
              "end_line": 0,
              "end_column": 1709,
              "start_byte": 1098,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle",
              "start_line": 56,
              "start_column": 1713,
              "end_line": 0,
              "end_column": 3388,
              "start_byte": 1713,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N",
              "start_line": 29,
              "start_column": 633,
              "end_line": 0,
              "end_column": 945,
              "start_byte": 633,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 415,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 293,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail",
              "start_line": 8,
              "start_column": 243,
              "end_line": 0,
              "end_column": 723,
              "start_byte": 243,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 479,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel",
              "start_line": 56,
              "start_column": 1402,
              "end_line": 0,
              "end_column": 4066,
              "start_byte": 1402,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given ",
              "start_line": 31,
              "start_column": 870,
              "end_line": 0,
              "end_column": 1328,
              "start_byte": 870,
              "end_byte": 0
            },
            {
              "name": "_pytest.report_log.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo",
              "start_line": 6,
              "start_column": 54,
              "end_line": 0,
              "end_column": 355,
              "start_byte": 54,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner ",
              "start_line": 8,
              "start_column": 107,
              "end_line": 0,
              "end_column": 423,
              "start_byte": 107,
              "end_byte": 0
            },
            {
              "name": "_pytest.config.Parser.addoption",
              "file_path": "src/_pytest/config/argparsing.py",
              "file_content": "def addoption(self, *opts, **attrs):\n        \"\"\" register a command line option.\n\n        :opts: option names, can be short or long options.\n        :attrs: same attributes which the ``add_option()`` function of the\n           `argparse library\n           <http://docs.python.org/2/library/argparse.html>`_\n           accepts.\n\n        After command line parsing options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption(\"--long\", dest=\"NAME\", ...)``.\n        \"\"\"\n        self._anonymous.addoption(*opts, **attrs)",
              "start_line": 63,
              "start_column": 1972,
              "end_line": 4,
              "end_column": 2615,
              "start_byte": 1972,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing the need for a shorter command-line option for a frequently used pytest argument, `--collect-only`. \n1.2 This issue arises because current command is too lengthy to type frequently.\n1.3 The user indicates a desire to add a single-character shortcut that has the same effect as `--collect-only`.\n1.4 The expected result should be a single-character option that performs the same function as `--collect-only` when used with the pytest command line.\n1.5 To fix this issue, we should introduce a new single-character option that serves the same function as `--collect-only`. We might need to update the argument registration to include this new short option.\n\n2. Make the evaluate:\n2.1 I need to go through each symbol provided to see which, if any, are related to command-line options.\n2.2 The related symbols I should look for might involve argument parsing, command registration, or handling of `--collect-only` specifically.\n2.3 From the symbols given I need to determine where `--collect-only` is implemented or defined and see if it includes the capacity for a short alias.\n2.4 If not explicitly provided, I may need to locate where command line options are configured and ensure a single character option is set.\n2.5 If none of these symbols provide enough insight into how options are registered, I may need additional information from the user.\n\n\n",
          "symbols": [
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/main.py",
              "reason": "This symbol contains the implementation for adding options, including '--collect-only'. A new single character shortcut should be added here."
            },
            {
              "name": "_pytest.config.Parser.addoption",
              "file_path": "src/_pytest/config/argparsing.py",
              "reason": "This method registers the command line options, therefore, it is where the new shortcut should be implemented."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The symbol seems to contain import statements and an ExitCode class for encoding pytest exit codes. There's partial content of the pytest_addoption which might indicate this is where options are added, but this doesn't specifically relate to handling command-line argument --collect-only yet. I need to further verify this relevance.",
            "The symbol content is lacking actual implementation of pytest_addoption but is related more to test failures, stopping test execution, and statuses. It seems unlikely this is where the argparse option for --collect-only would be managed.",
            "This snippet shows arbitrated imports and might relate to testing states. However, there seems to be little connection to where command line options are parsed or added such as --collect-only.",
            "The symbol indicates part of imports and definitions related to runner setups etc., but not specific to option parsing. Unless it's within the partially present pytest_addoption function, I would need to ignore it.",
            "The partial defines fixtures that offer test configuration and execution methods rather than pointing towards argparse or option handling relevant for --collect-only.",
            "The snippet seems incomplete and only vaguely related to path specifications and argument options. Not distinctly related to command-line arguments like --collect-only as visible so far.",
            "Incomplete snippet regarding enum exit codes, not specific to the handling or arrangement of command-line arguments.",
            "Help functionality and option parsing might be tackled here, though the snippet does not point at command option adjustments or inline with argparse command-line parsing.",
            "This is a class command, it doesn't give insights into the handling of a specific --collect-only shortcut. Nevertheless, it's related since parsing options is crucial to implementing command-line arguments.",
            "Pertains to managing Argument errors and existing classes involving Argument interfaces. Related more to error handling than to defining shortcuts or command options directly.",
            "Initializes the ArgumentError, not connected directly to command line argument parsing or setup options.",
            "Contributes to stringification of errors in argument handling rather than option parsing.",
            "Argument instantiation manages short and long-form options but unless more content focuses on practical applications of pytest arguments, its relation to --collect-only isn't explicit.",
            "Typ map refers to type conversion associated with parsing, indirectly related if type adjustments needed.",
            "Argument class init handles option short and long form storage, potential direct relevance requires more context on how the parsing is involved in storing --collect-only identifiers.",
            "Deals with returning arg names not direct to parsing or `--collect-only` manipulation currently.",
            "Attr list-updates seem related to storing attributes for parsing, might be where a new option is given attributes, need broader context to connect to `--collect-only`.",
            "Handles strings for options, thus related as might regulate the form `--collect-only` is kept or modified, guaranteeing formatted correctly.",
            "The representation method primarily deals with configuration displays of options.",
            "The addoption function defines options relevant in context, potentially highly related means should add the character shortcut for --collect-only here.",
            "Discusses plugin registration under hookspec without regard to command line directly.",
            "Commands are meant to signal state conclusions in testing, not aligning to --collect-only yet.",
            "Part of hookspec structure, indicating configs, yet lacking focus on actual argument parsing in current snippet.",
            "Print messages capture hook registrations without direct relevance to command line argument sequences presently.",
            "Documentation part of command parsing init, however not elucidating placeholders or options closely correlated to `--collect-only`.",
            "Initially dealing hooks, without clear relation to `--collect-only` option generation.",
            "Discusses directive plugin registration, not aligning to individual hook registrations yet.",
            "These sections detail plugin hook registration in a way mostly orthogonal to parsing command line options so far seen.",
            "Describes another hook-based script setting, instead of registering through command line arguments.",
            "",
            "Details registering type specs, rather than command options in this form.",
            "Specifies system-level hookstarts but drops off before relating to command line usage.",
            "Snippet involves plugin manager annotation not directly useful for argument shortcuts.",
            "Given as plugins marking, its focus isn't on internal command selection.",
            ""
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/main.py",
          "src/_pytest/config/argparsing.py"
        ],
        "symbols": [
          "_pytest.main.pytest_addoption",
          "_pytest.config.Parser.addoption"
        ],
        "code_spans": {
          "_pytest.config.ArgumentError": {
            "name": "_pytest.config.ArgumentError",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class ArgumentError(Exception):\n    \"\"\"\n    Raised if an Argument instance is created with invalid or\n    inconsistent arguments.\n    \"\"\"\n\n    def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)\n\n    def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 145,
            "start_column": 5419,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 5419,
            "end_byte": 0
          },
          "_pytest.config.ArgumentError.__init__": {
            "name": "_pytest.config.ArgumentError.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, msg, option):\n        self.msg = msg\n        self.option_id = str(option)",
            "start_line": 151,
            "start_column": 5562,
            "end_line": 4,
            "end_column": 5654,
            "start_byte": 5562,
            "end_byte": 4
          },
          "_pytest.config.ArgumentError.__str__": {
            "name": "_pytest.config.ArgumentError.__str__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __str__(self):\n        if self.option_id:\n            return \"option {}: {}\".format(self.option_id, self.msg)\n        else:\n            return self.msg",
            "start_line": 155,
            "start_column": 5660,
            "end_line": 4,
            "end_column": 5815,
            "start_byte": 5660,
            "end_byte": 4
          },
          "_pytest.config.Argument": {
            "name": "_pytest.config.Argument",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "class Argument:\n    \"\"\"class that mimics the necessary behaviour of optparse.Option\n\n    it's currently a least effort implementation\n    and ignoring choices and integer prefixes\n    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types\n    \"\"\"\n\n    _typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}\n\n    def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)\n\n    def names(self):\n        return self._short_opts + self._long_opts\n\n    def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs\n\n    def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)\n\n    def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 162,
            "start_column": 5818,
            "end_line": 0,
            "end_column": 10992,
            "start_byte": 5818,
            "end_byte": 0
          },
          "_pytest.config.Argument._typ_map": {
            "name": "_pytest.config.Argument._typ_map",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "_typ_map = {\"int\": int, \"string\": str, \"float\": float, \"complex\": complex}",
            "start_line": 170,
            "start_column": 6094,
            "end_line": 4,
            "end_column": 6168,
            "start_byte": 6094,
            "end_byte": 4
          },
          "_pytest.config.Argument.__init__": {
            "name": "_pytest.config.Argument.__init__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __init__(self, *names, **attrs):\n        \"\"\"store parms in private vars for use in add_argument\"\"\"\n        self._attrs = attrs\n        self._short_opts = []  # type: List[str]\n        self._long_opts = []  # type: List[str]\n        self.dest = attrs.get(\"dest\")\n        if \"%default\" in (attrs.get(\"help\") or \"\"):\n            warnings.warn(\n                'pytest now uses argparse. \"%default\" should be'\n                ' changed to \"%(default)s\" ',\n                DeprecationWarning,\n                stacklevel=3,\n            )\n        try:\n            typ = attrs[\"type\"]\n        except KeyError:\n            pass\n        else:\n            # this might raise a keyerror as well, don't want to catch that\n            if isinstance(typ, str):\n                if typ == \"choice\":\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r.\"\n                        \" For choices this is optional and can be omitted, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    # argparse expects a type here take it from\n                    # the type of the first element\n                    attrs[\"type\"] = type(attrs[\"choices\"][0])\n                else:\n                    warnings.warn(\n                        \"`type` argument to addoption() is the string %r, \"\n                        \" but when supplied should be a type (for example `str` or `int`).\"\n                        \" (options: %s)\" % (typ, names),\n                        DeprecationWarning,\n                        stacklevel=4,\n                    )\n                    attrs[\"type\"] = Argument._typ_map[typ]\n                # used in test_parseopt -> test_parse_defaultgetter\n                self.type = attrs[\"type\"]\n            else:\n                self.type = typ\n        try:\n            # attribute existence is tested in Config._processopt\n            self.default = attrs[\"default\"]\n        except KeyError:\n            pass\n        self._set_opt_strings(names)\n        if not self.dest:\n            if self._long_opts:\n                self.dest = self._long_opts[0][2:].replace(\"-\", \"_\")\n            else:\n                try:\n                    self.dest = self._short_opts[0][1:]\n                except IndexError:\n                    raise ArgumentError(\"need a long or short option\", self)",
            "start_line": 172,
            "start_column": 6174,
            "end_line": 4,
            "end_column": 8718,
            "start_byte": 6174,
            "end_byte": 4
          },
          "_pytest.config.Argument.names": {
            "name": "_pytest.config.Argument.names",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def names(self):\n        return self._short_opts + self._long_opts",
            "start_line": 232,
            "start_column": 8724,
            "end_line": 4,
            "end_column": 8790,
            "start_byte": 8724,
            "end_byte": 4
          },
          "_pytest.config.Argument.attrs": {
            "name": "_pytest.config.Argument.attrs",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def attrs(self):\n        # update any attributes set by processopt\n        attrs = \"default dest help\".split()\n        if self.dest:\n            attrs.append(self.dest)\n        for attr in attrs:\n            try:\n                self._attrs[attr] = getattr(self, attr)\n            except AttributeError:\n                pass\n        if self._attrs.get(\"help\"):\n            a = self._attrs[\"help\"]\n            a = a.replace(\"%default\", \"%(default)s\")\n            # a = a.replace('%prog', '%(prog)s')\n            self._attrs[\"help\"] = a\n        return self._attrs",
            "start_line": 235,
            "start_column": 8796,
            "end_line": 4,
            "end_column": 9357,
            "start_byte": 8796,
            "end_byte": 4
          },
          "_pytest.config.Argument._set_opt_strings": {
            "name": "_pytest.config.Argument._set_opt_strings",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def _set_opt_strings(self, opts):\n        \"\"\"directly from optparse\n\n        might not be necessary as this is passed to argparse later on\"\"\"\n        for opt in opts:\n            if len(opt) < 2:\n                raise ArgumentError(\n                    \"invalid option string %r: \"\n                    \"must be at least two characters long\" % opt,\n                    self,\n                )\n            elif len(opt) == 2:\n                if not (opt[0] == \"-\" and opt[1] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid short option string %r: \"\n                        \"must be of the form -x, (x any non-dash char)\" % opt,\n                        self,\n                    )\n                self._short_opts.append(opt)\n            else:\n                if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n                    raise ArgumentError(\n                        \"invalid long option string %r: \"\n                        \"must start with --, followed by non-dash\" % opt,\n                        self,\n                    )\n                self._long_opts.append(opt)",
            "start_line": 252,
            "start_column": 9363,
            "end_line": 4,
            "end_column": 10468,
            "start_byte": 9363,
            "end_byte": 4
          },
          "_pytest.config.Argument.__repr__": {
            "name": "_pytest.config.Argument.__repr__",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def __repr__(self) -> str:\n        args = []  # type: List[str]\n        if self._short_opts:\n            args += [\"_short_opts: \" + repr(self._short_opts)]\n        if self._long_opts:\n            args += [\"_long_opts: \" + repr(self._long_opts)]\n        args += [\"dest: \" + repr(self.dest)]\n        if hasattr(self, \"type\"):\n            args += [\"type: \" + repr(self.type)]\n        if hasattr(self, \"default\"):\n            args += [\"default: \" + repr(self.default)]\n        return \"Argument({})\".format(\", \".join(args))",
            "start_line": 280,
            "start_column": 10474,
            "end_line": 4,
            "end_column": 10992,
            "start_byte": 10474,
            "end_byte": 4
          },
          "_pytest.config.OptionGroup.addoption": {
            "name": "_pytest.config.OptionGroup.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *optnames, **attrs):\n        \"\"\" add an option to this group.\n\n        if a shortened version of a long option is specified it will\n        be suppressed in the help. addoption('--twowords', '--two-words')\n        results in help showing '--two-words' only, but --twowords gets\n        accepted **and** the automatic destination is in args.twowords\n        \"\"\"\n        conflict = set(optnames).intersection(\n            name for opt in self.options for name in opt.names()\n        )\n        if conflict:\n            raise ValueError(\"option names %s already added\" % conflict)\n        option = Argument(*optnames, **attrs)\n        self._addoption_instance(option, shortupper=False)",
            "start_line": 301,
            "start_column": 11221,
            "end_line": 4,
            "end_column": 11922,
            "start_byte": 11221,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"",
            "start_line": 11,
            "start_column": 229,
            "end_line": 0,
            "end_column": 1052,
            "start_byte": 229,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep",
            "start_line": 301,
            "start_column": 11226,
            "end_line": 0,
            "end_column": 12991,
            "start_byte": 11226,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go",
            "start_line": 19,
            "start_column": 345,
            "end_line": 0,
            "end_column": 824,
            "start_byte": 345,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t",
            "start_line": 21,
            "start_column": 539,
            "end_line": 0,
            "end_column": 1237,
            "start_byte": 539,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol",
            "start_line": 50,
            "start_column": 1390,
            "end_line": 0,
            "end_column": 2808,
            "start_byte": 1390,
            "end_byte": 0
          },
          "_pytest.faulthandler.pytest_addoption": {
            "name": "_pytest.faulthandler.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": ", session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py",
            "start_line": 7,
            "start_column": 48,
            "end_line": 0,
            "end_column": 303,
            "start_byte": 48,
            "end_byte": 0
          },
          "_pytest.fixtures.pytest_addoption": {
            "name": "_pytest.fixtures.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1190,
            "start_column": 44317,
            "end_line": 0,
            "end_column": 44505,
            "start_byte": 44317,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_",
            "start_line": 38,
            "start_column": 1168,
            "end_line": 0,
            "end_column": 2482,
            "start_byte": 1168,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": " to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n",
            "start_line": 36,
            "start_column": 1070,
            "end_line": 0,
            "end_column": 2624,
            "start_byte": 1070,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  ",
            "start_line": 382,
            "start_column": 12558,
            "end_line": 0,
            "end_column": 13941,
            "start_byte": 12558,
            "end_byte": 0
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo",
            "start_line": 171,
            "start_column": 6052,
            "end_line": 0,
            "end_column": 8708,
            "start_byte": 6052,
            "end_byte": 0
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )",
            "start_line": 45,
            "start_column": 969,
            "end_line": 0,
            "end_column": 5086,
            "start_byte": 969,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path",
            "start_line": 36,
            "start_column": 1291,
            "end_line": 0,
            "end_column": 2845,
            "start_byte": 1291,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle",
            "start_line": 6,
            "start_column": 107,
            "end_line": 0,
            "end_column": 435,
            "start_byte": 107,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       ",
            "start_line": 46,
            "start_column": 1098,
            "end_line": 0,
            "end_column": 1709,
            "start_byte": 1098,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle",
            "start_line": 56,
            "start_column": 1713,
            "end_line": 0,
            "end_column": 3388,
            "start_byte": 1713,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N",
            "start_line": 29,
            "start_column": 633,
            "end_line": 0,
            "end_column": 945,
            "start_byte": 633,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 415,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 293,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail",
            "start_line": 8,
            "start_column": 243,
            "end_line": 0,
            "end_column": 723,
            "start_byte": 243,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel",
            "start_line": 56,
            "start_column": 1402,
            "end_line": 0,
            "end_column": 4066,
            "start_byte": 1402,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given ",
            "start_line": 31,
            "start_column": 870,
            "end_line": 0,
            "end_column": 1328,
            "start_byte": 870,
            "end_byte": 0
          },
          "_pytest.report_log.pytest_addoption": {
            "name": "_pytest.report_log.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo",
            "start_line": 6,
            "start_column": 54,
            "end_line": 0,
            "end_column": 355,
            "start_byte": 54,
            "end_byte": 0
          },
          "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/main.py",
            "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner ",
            "start_line": 8,
            "start_column": 107,
            "end_line": 0,
            "end_column": 423,
            "start_byte": 107,
            "end_byte": 0
          },
          "_pytest.config.Parser.addoption": {
            "name": "_pytest.config.Parser.addoption",
            "file_path": "src/_pytest/config/argparsing.py",
            "file_content": "def addoption(self, *opts, **attrs):\n        \"\"\" register a command line option.\n\n        :opts: option names, can be short or long options.\n        :attrs: same attributes which the ``add_option()`` function of the\n           `argparse library\n           <http://docs.python.org/2/library/argparse.html>`_\n           accepts.\n\n        After command line parsing options are available on the pytest config\n        object via ``config.option.NAME`` where ``NAME`` is usually set\n        by passing a ``dest`` attribute, for example\n        ``addoption(\"--long\", dest=\"NAME\", ...)``.\n        \"\"\"\n        self._anonymous.addoption(*opts, **attrs)",
            "start_line": 63,
            "start_column": 1972,
            "end_line": 4,
            "end_column": 2615,
            "start_byte": 1972,
            "end_byte": 4
          }
        }
      }
    }
  ]
}