{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5495",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:22.974462",
        "usage": "1682.6417446136475 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "putaround",
          "setenv",
          "CollectError",
          "maketxtfile",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "_create_formatter",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "NodeMarkers",
          "Entry",
          "_find_spec",
          "popcall",
          "pytest_collect_directory",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "visit_BoolOp",
          "check_strict_xfail",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "ReprExceptionInfo",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "FIXTURE_FUNCTION_CALL",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "FunctionMixin",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "pytest_itemstart",
          "prog",
          "_PytestWrapper",
          "mode",
          "PYTEST_ENSURETEMP",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "fslocation",
          "_get_pdb_wrapper_class",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "type",
          "_inject_setup_teardown_fixtures",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "FormattedExcinfo",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "_from_json",
          "getplugin",
          "failed",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "freeze_support",
          "own_markers",
          "monkeypatch",
          "__bool__",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "GETFUNCARGVALUE",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "addini",
          "faulthandler",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "fail_fixturefunc",
          "PYTEST_LOGWARNING",
          "pytest_ignore_collect",
          "unary_map",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_visit_filter",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "_try_load_conftest",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_ConfigDeprecated",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "CACHEDIR_TAG_CONTENT",
          "_repr_style",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_compare_eq_cls",
          "safe_text_dupfile",
          "done",
          "CallInfo",
          "WarningsChecker",
          "_write_pyc",
          "fixture",
          "MonkeyPatch",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_callhelper",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "ensuretemp",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "TESTS_FAILED",
          "verbosity",
          "_check_scope",
          "_update_message",
          "ParameterSet",
          "raises",
          "Junit",
          "format",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "pytest_logwarning",
          "caplog",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "CollectErrorRepr",
          "pytest_configure",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "RemovedInPytest4Warning",
          "PYTEST_CONFIG_GLOBAL",
          "INTERNAL_ERROR",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "_do_configure",
          "exec_module",
          "get_fslocation_from_item",
          "DummyRewriteHook",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "import_plugin",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "append_pass",
          "writelines",
          "record_xml_attribute",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "setall",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "_bytes_to_ascii",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "RaisesContext",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "warn_about_none_ast",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "binop_map",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "errors",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_call_and_format_exception",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "rewrite",
          "toterminal",
          "nodes",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "getfuncargvalue",
          "addSkip",
          "update",
          "assert_contains",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "_ensure_only_one_capture_fixture",
          "parse_args",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "_get_xunit_setup_teardown",
          "ishidden",
          "defaultfuncargprefixmarker",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "getdecoded",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "_handle_skip",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "_parse_parametrize_parameters",
          "setns",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "OK",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "alias",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "LineComp",
          "_striptext",
          "PyobjContext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "WARNS_EXEC",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "parse_known_args",
          "pytest_generate_tests",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "USAGE_ERROR",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "add_stats",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "NO_TESTS_COLLECTED",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "FIXTURE_NAMED_REQUEST",
          "_non_numeric_type_error",
          "iter_markers_with_node",
          "PYTEST_TAG",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_getcapture",
          "_rget_with_confmod",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_get_non_fixture_func",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "clear",
          "parsefactories",
          "get_skip_exceptions",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "bin_xml_escape",
          "context",
          "short_test_summary",
          "__next__",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "capture_fixtures",
          "addError",
          "call_optional",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "find_spec",
          "_makepath",
          "_format_action_invocation",
          "FuncargnamesCompatAttr",
          "_getvaluepath",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_get_global_properties_node",
          "getpathnode",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "Exit",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "create_module",
          "_teardown_yield_fixture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "emit",
          "RAISES_MESSAGE_PARAMETER",
          "_log",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "outcomes",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_setup_collect_fakemodule",
          "wasvalid",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_test_pytest_function",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "__nonzero__",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "repr_unicode",
          "append_collect_skipped",
          "_collectfile",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "rmtree",
          "PseudoFixtureDef",
          "_reprcompare",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "INTERRUPTED",
          "_readline_workaround",
          "_teardown_towards",
          "_runtest_for_main",
          "_check_record_param_type",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "yield_fixture",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "YIELD_TESTS",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "PyobjMixin",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "last_failed_paths",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "find",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "RAISES_EXEC",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "call_and_report",
          "visit_Starred",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "markname",
          "getlocals",
          "_given_basetemp",
          "popen",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "nextitem",
          "approx",
          "_addoption_instance",
          "LineMatcher_fixture",
          "_excinfo",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "__setattr__",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "repr_excinfo",
          "ExitCode",
          "syspath_prepend",
          "set_trace",
          "__iter__",
          "get_actual_log_level",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "istrue",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "set_repr_style",
          "_addoption",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "MarkMapping",
          "append_skipped",
          "_get_stderr_fileno",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "nose",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "assertion",
          "AssertionRewriter",
          "_rewrite_test",
          "saferepr",
          "saferepr",
          "_saferepr",
          "_compare_eq_verbose",
          "_compare_eq_sequence",
          "_compare_eq_iterable",
          "assertrepr_compare"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:24.657116",
        "usage": "209.913969039917 ms"
      },
      "request": {
        "tokens": [
          "assertion",
          "AssertionRewriter",
          "_rewrite_test",
          "saferepr",
          "saferepr",
          "_saferepr",
          "_compare_eq_verbose",
          "_compare_eq_sequence",
          "_compare_eq_iterable",
          "assertrepr_compare"
        ]
      },
      "response": {
        "results": {
          "saferepr": [
            "src/_pytest/pytester.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_io/saferepr.py"
          ],
          "assertion": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/source.py",
            "src/pytest.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_sequence": [
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_verbose": [
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_iterable": [
            "src/_pytest/assertion/util.py"
          ],
          "_rewrite_test": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "_saferepr": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:24.867041",
        "usage": "6131.676912307739 ms"
      },
      "request": {
        "keyword_search_results": {
          "saferepr": [
            "src/_pytest/pytester.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_io/saferepr.py"
          ],
          "assertion": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/_code/source.py",
            "src/pytest.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_sequence": [
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_verbose": [
            "src/_pytest/assertion/util.py"
          ],
          "_compare_eq_iterable": [
            "src/_pytest/assertion/util.py"
          ],
          "_rewrite_test": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "_saferepr": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue pertains to confusing messages generated by assertion rewriting, particularly related to byte strings. The message reflects the ASCII ordinals of differing bytes, which are causing confusion because the current representation isn't clear enough for easy understanding by users.\n\nWe need to find files dealing with assertion rewriting, especially those handling comparisons, representation, or specifically byte string handling.\n\n1. **saferepr** - This keyword relates to creating safe representations of objects, which can be critical when representing differences in byte strings. Files like 'src/_pytest/assertion/rewrite.py' and 'src/_pytest/assertion/util.py' which appear under this search might include code for handling such representations.\n   - **'src/_pytest/assertion/rewrite.py'** appears crucial as its name directly indicates it deals with rewriting assertions. Its involvement in assertion rewriting suggests it might be involved in generating the messages that need improvement.\n   - **'src/_pytest/_io/saferepr.py'** - This could house general safe representation logic useful for assertions.\n\n2. **assertion** - Relevant files here would include assertion message construction or assertion logic handling such as:\n   - **'src/_pytest/assertion/util.py'** - This path appears under multiple search terms and seems to be a utility file handling various assertion functionalities, potentially including comparisons handling and message formatting.\n   - **'src/_pytest/assertion/truncate.py'** - Can be related if truncation is affecting how messages are being presented, though less likely impactful towards resolving representation logic of byte comparisons.\n\n3. **assertrepr_compare** - This might involve how assertion comparisons are represented, which seems critical in message formatting. Again, it punts towards:\n   - **'src/_pytest/assertion/util.py'** - Indicates that it handles the comparison logic perhaps including message formatting related to the issue described.",
        "file_paths": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/util.py",
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/assertion/truncate.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:30.998745",
        "usage": "6254.687786102295 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is reporting an issue with the assertion rewriting message in pytest when dealing with byte strings. \n1.2 Apparently, when comparing byte strings, pytest outputs the numeric ASCII value instead of a character representation, which may be confusing. \n1.3 The user has not provided specific steps to reproduce but has given examples of the problematic messages when an assertion with byte strings fails.\n1.4 The issue is likely due to the way the assertion messages are formatted in pytest. Specifically, the message seems to give ASCII values for mismatched bytes instead of showing the byte characters themselves. \n\n2. Make File Evaluation:\n2.1 The file `rewrite.py` is likely involved, as it handles rewriting assertion error messages.\n2.2 The `AssertionRewriter` class, especially the `visit_Assert` method, is responsible for transforming assertions to produce detailed error messages.\n2.3 This class's `visit_Compare` and `visit_BinOp` methods are also relevant because they handle binary operations and comparisons, which are crucial in assertion error messaging.\n2.4 The `_saferepr` and `_format_explanation` functions, imported from `util`, are potentially involved in formatting the message.\n\n3. Output Your Decision",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "AssertionRewriter.visit_Assert",
          "AssertionRewriter.visit_Compare",
          "AssertionRewriter.visit_BinOp",
          "_saferepr",
          "_format_assertmsg",
          "_call_reprcompare"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:37.253458",
        "usage": "8670.514106750488 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/util.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue with the assertion rewriting message when comparing byte strings in pytest. The error message shown upon assertion failure isn't clear in terms of the representation of the differing items, specifically showing ASCII values instead of directly indicating what those values correspond to in terms of the strings being compared. It causes confusion for users trying to understand the assertion error output.\n1.2 The user provides a reproduction step using two examples where `assert b\"\" == b\"42\"` and `assert b\"\" == b\"1\"` fail and produce a message showing ASCII ordinal values instead of more meaningful information.\n1.3 The issue likely arises because, in the `format_explanation` or `assertrepr_compare` methods, byte strings are converted or represented in such a way that ASCII values are shown as part of the assertion error output, rather than the expected byte string representations.\n1.4 Users expect the assertion message to indicate what exactly the byte strings contain that are different, using an understandable format rather than ASCII codes.\n1.6 A potential solution involves modifying the representation or explanation formatting functions to better handle byte strings, ensuring that the user sees a clear and direct comparison of byte strings instead of indirect byte/ASCII values.\n\n2. Make file evaluation:\n2.1 The relevant function for handling assertion explanations appears to be `assertrepr_compare`, which now includes a case for '==' operator where byte sequences are compared.\n2.2 The function `_diff_text` is responsible for explaining differences between \"text or bytes\", aligning directly with the user's issue, particularly as it attempts to convert bytes into a readable form - which could be responsible for the confusion.\n2.3 The use of `escape_for_readable_diff` within `_diff_text` suggests where the representation may be changing byte sequences into ASCII explanations, rather than raw byte string differences.\n2.4 The error message indicates byte strings are being processed in a particular way, likely within `_diff_text`, where representations could be altered by `escape_for_readable_diff` or nearby handling.\n2.5 The relevant part of the codebase seems localized to `assertrepr_compare`, `_diff_text`, and possibly `escape_for_readable_diff` with respect to byte handling.\n2.6 This file appears strongly related to the root cause due to these functions dealing with the representation aspects of assertion failures for byte strings.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "assertrepr_compare",
          "_diff_text",
          "escape_for_readable_diff"
        ],
        "root_cause_symbols": [
          "assertrepr_compare",
          "_diff_text",
          "escape_for_readable_diff"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:45.923993",
        "usage": "9553.676128387451 ms"
      },
      "request": {
        "file_path": "src/_pytest/_io/saferepr.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue revolves around confusing messages returned during assertion rewriting when using byte strings in tests. The ASCII ordinal numbers appear in the message, which is confusing for users.\n1.2 Examples with reproduction are provided, showcasing the issue with byte string comparisons in assertions.\n1.3 The confusion seems to arise from the way byte strings are represented or compared in the assertion failure messages, where ordinal values of bytes are displayed instead of byte values.\n1.4 The user's expectation is likely that assertion messages should be clear and reflect the byte string differences directly rather than using ASCII ordinals. This lack of clarity in representation leads to confusion.\n1.5 A possible solution could involve improving the representation of byte strings within the assertion failure messages, ensuring the output is human-readable and directly reflects byte string differences without ASCII conversion.\n\n2. Make file evaluation:\n2.1 The file `saferepr.py` appears to deal with safe representation of objects, particularly handling exceptions during representation.\n2.2 The core function seems to be `saferepr`, which returns a size-limited safe representation of an object. This function utilizes the `SafeRepr` class to achieve this.\n2.3 The `SafeRepr` class is a subclass of `reprlib.Repr` and uses a custom `_callhelper` function to handle exceptions and possibly truncate long representations.\n2.4 There may be some logic in this file that contributes to how byte strings are represented, especially within the `SafeRepr` class or the `_call_and_format_exception` function.\n2.5 The `repr` method of `SafeRepr` could be responsible for how byte strings appear in assertion messages. Modifications here might be needed to ensure byte string differences are denoted clearly.\n2.6 It's unclear if this file alone is the root cause, as the mismatch in string representation might also involve other parts of the test running or assertion mechanism, possibly outside this file.\n2.7 The file is relevant for the issue, as it handles object representation, which directly relates to how differences are displayed in assertion failure messages. However, the root cause might involve other mechanisms handling assertion logic combined with this representation logic.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py"
        ],
        "relevant_symbols": [
          "SafeRepr.repr",
          "SafeRepr._callhelper",
          "_call_and_format_exception",
          "saferepr"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:55.477686",
        "usage": "6685.666084289551 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/truncate.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user's issue is with assertion rewrite messages that display confusing information for byte strings. The issue arises when asserting that two byte strings are equal, and the message gives ASCII ordinal numbers instead of a straightforward diff or mismatch explanation.\n1.2 The user provided reproduction steps show an assertion failure between byte strings that include ASCII ordinal mentions in the error output.\n1.3 The issue might be caused by the way assertion explanations are generated, particularly how diff and mismatch information is presented.\n1.4 The user expects a clear and understandable message when assertions fail. The current message (e.g., concerning ASCII ordinal) can be confusing for users as it does not provide an intuitive differentiation between the bytes.\n1.5 A potential solution could focus on improving the message formatting by avoiding ASCII ordinal references for byte string comparisons and providing a clearer diff.\n\n2. Make file evaluation:\n2.1 Analyze each line of code in the file content above. The file seems to deal with truncating output messages, especially for assertions.\n2.2 The file includes functions for handling truncation logic based on terminal conditions, verbose mode, or CI environments. The specific concern about how bytes and diffs are presented does not appear to be addressed directly in this file.\n2.3 The functions in this file (like 'truncate_if_required', '_should_truncate_item', and '_truncate_explanation') focus on whether to truncate and how to format lengthy output, but do not appear to address or change the structure of assertions regarding ASCII character explanations.\n2.4 Thus, these functions and their workings are indeed relevant to how messages are formatted, but may not be directly responsible for the confusing message structure in the byte order case. However, understanding their logic is crucial if we want to integrate a check for specific handling of byte string assertions.\n2.5 This file does not seem to directly create or format the content of the assertion message beyond determining whether it gets truncated.\n\nConclusion: \n- The issue might not originate solely from this file as the problem seems more rooted in how assertion differences are constructed rather than merely their truncation.\n- However, enhancements or checks could be added to the truncation logic to handle specific cases of difference display, particularly for byte strings.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py"
        ],
        "relevant_symbols": [
          "truncate_if_required",
          "_truncate_explanation",
          "_truncate_by_char_count"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:46:02.163373",
        "usage": "181.77008628845215 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [
              "AssertionRewriter.visit_Assert",
              "AssertionRewriter.visit_Compare",
              "AssertionRewriter.visit_BinOp",
              "_saferepr",
              "_format_assertmsg",
              "_call_reprcompare"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/util.py",
            "relevant_symbol_keys": [
              "assertrepr_compare",
              "_diff_text",
              "escape_for_readable_diff"
            ],
            "root_cause_symbol_keys": [
              "assertrepr_compare",
              "_diff_text",
              "escape_for_readable_diff"
            ]
          },
          {
            "file_path": "src/_pytest/_io/saferepr.py",
            "relevant_symbol_keys": [
              "SafeRepr.repr",
              "SafeRepr._callhelper",
              "_call_and_format_exception",
              "saferepr"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/truncate.py",
            "relevant_symbol_keys": [
              "truncate_if_required",
              "_truncate_explanation",
              "_truncate_by_char_count"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _saferepr(obj):\n    \"\"\"Get a safe repr of an object for assertion error messages.\n\n    The assertion formatting (util.format_explanation()) requires\n    newlines to be escaped since they are a special character for it.\n    Normally assertion.util.format_explanation() does this but for a\n    custom repr it is possible to contain one of the special escape\n    sequences, especially '\\n{' and '\\n}' are likely to be present in\n    JSON reprs.\n\n    \"\"\"\n    return saferepr(obj).replace(\"\\n\", \"\\\\n\")",
            "start_line": 331,
            "start_column": 12599,
            "end_line": 0,
            "end_column": 13099,
            "start_byte": 12599,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._format_assertmsg",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _format_assertmsg(obj):\n    \"\"\"Format the custom assertion message given.\n\n    For strings this simply replaces newlines with '\\n~' so that\n    util.format_explanation() will preserve them instead of escaping\n    newlines.  For other objects saferepr() is used first.\n\n    \"\"\"\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n    if not isinstance(obj, str):\n        obj = saferepr(obj)\n        replaces.append((\"\\\\n\", \"\\n~\"))\n\n    for r1, r2 in replaces:\n        obj = obj.replace(r1, r2)\n\n    return obj",
            "start_line": 345,
            "start_column": 13102,
            "end_line": 0,
            "end_column": 13869,
            "start_byte": 13102,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"({} {} {})\".format(left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 805,
            "start_column": 30312,
            "end_line": 4,
            "end_column": 30674,
            "start_byte": 30312,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          {
            "name": "_pytest._io._call_and_format_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _call_and_format_exception(call, x, *args):\n    try:\n        # Try the vanilla repr and make sure that the result is a string\n        return call(x, *args)\n    except Exception as exc:\n        exc_name = type(exc).__name__\n        try:\n            exc_info = str(exc)\n        except Exception:\n            exc_info = \"unknown\"\n        return '<[{}(\"{}\") raised in repr()] {} object at 0x{:x}>'.format(\n            exc_name, exc_info, x.__class__.__name__, id(x)\n        )",
            "start_line": 4,
            "start_column": 31,
            "end_line": 0,
            "end_column": 506,
            "start_byte": 31,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x):\n        return self._callhelper(reprlib.Repr.repr, self, x)",
            "start_line": 24,
            "start_column": 689,
            "end_line": 4,
            "end_column": 767,
            "start_byte": 689,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_unicode",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_unicode(self, x, level):\n        # Strictly speaking wrong on narrow builds\n        def repr(u):\n            if \"'\" not in u:\n                return \"'%s'\" % u\n            elif '\"' not in u:\n                return '\"%s\"' % u\n            else:\n                return \"'%s'\" % u.replace(\"'\", r\"\\'\")\n\n        s = repr(x[: self.maxstring])\n        if len(s) > self.maxstring:\n            i = max(0, (self.maxstring - 3) // 2)\n            j = max(0, self.maxstring - 3 - i)\n            s = repr(x[:i] + x[len(x) - j :])\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 27,
            "start_column": 773,
            "end_line": 4,
            "end_column": 1361,
            "start_byte": 773,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x, level):\n        return self._callhelper(repr, x)",
            "start_line": 45,
            "start_column": 1367,
            "end_line": 4,
            "end_column": 1442,
            "start_byte": 1367,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr._callhelper",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _callhelper(self, call, x, *args):\n        s = _call_and_format_exception(call, x, *args)\n        if len(s) > self.maxsize:\n            i = max(0, (self.maxsize - 3) // 2)\n            j = max(0, self.maxsize - 3 - i)\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 48,
            "start_column": 1448,
            "end_line": 4,
            "end_column": 1733,
            "start_byte": 1448,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj, maxsize=240):\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    # review exception handling\n    srepr = SafeRepr()\n    srepr.maxstring = maxsize\n    srepr.maxsize = maxsize\n    srepr.maxother = 160\n    return srepr.repr(obj)",
            "start_line": 65,
            "start_column": 1988,
            "end_line": 0,
            "end_column": 2530,
            "start_byte": 1988,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 331,
            "start_column": 12599,
            "end_line": 0,
            "end_column": 13099,
            "start_byte": 12599,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.truncate_if_required",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def truncate_if_required(explanation, item, max_length=None):\n    \"\"\"\n    Truncate this assertion explanation if the given test item is eligible.\n    \"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation",
            "start_line": 13,
            "start_column": 279,
            "end_line": 0,
            "end_column": 541,
            "start_byte": 279,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._truncate_explanation",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_explanation(input_lines, max_lines=None, max_chars=None):\n    \"\"\"\n    Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first. The remaining lines will be replaced by a usage message.\n    \"\"\"\n\n    if max_lines is None:\n        max_lines = DEFAULT_MAX_LINES\n    if max_chars is None:\n        max_chars = DEFAULT_MAX_CHARS\n\n    # Check if truncation required\n    input_char_count = len(\"\".join(input_lines))\n    if len(input_lines) <= max_lines and input_char_count <= max_chars:\n        return input_lines\n\n    # Truncate first to max_lines, and then truncate to max_chars if max_chars\n    # is exceeded.\n    truncated_explanation = input_lines[:max_lines]\n    truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)\n\n    # Add ellipsis to final line\n    truncated_explanation[-1] = truncated_explanation[-1] + \"...\"\n\n    # Append useful message to explanation\n    truncated_line_count = len(input_lines) - len(truncated_explanation)\n    truncated_line_count += 1  # Account for the part-truncated final line\n    msg = \"...Full output truncated\"\n    if truncated_line_count == 1:\n        msg += \" ({} line hidden)\".format(truncated_line_count)\n    else:\n        msg += \" ({} lines hidden)\".format(truncated_line_count)\n    msg += \", {}\".format(USAGE_MSG)\n    truncated_explanation.extend([\"\", str(msg)])\n    return truncated_explanation",
            "start_line": 36,
            "start_column": 921,
            "end_line": 0,
            "end_column": 2404,
            "start_byte": 921,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._truncate_by_char_count",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_by_char_count(input_lines, max_chars):\n    # Check if truncation required\n    if len(\"\".join(input_lines)) <= max_chars:\n        return input_lines\n\n    # Find point at which input length exceeds total allowed length\n    iterated_char_count = 0\n    for iterated_index, input_line in enumerate(input_lines):\n        if iterated_char_count + len(input_line) > max_chars:\n            break\n        iterated_char_count += len(input_line)\n\n    # Create truncated explanation with modified final line\n    truncated_result = input_lines[:iterated_index]\n    final_line = input_lines[iterated_index]\n    if final_line:\n        final_line_truncate_point = max_chars - iterated_char_count\n        final_line = final_line[:final_line_truncate_point]\n    truncated_result.append(final_line)\n    return truncated_result",
            "start_line": 75,
            "start_column": 2407,
            "end_line": 0,
            "end_column": 3227,
            "start_byte": 2407,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:02.345150",
        "usage": "16900.45213699341 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _saferepr(obj):\n    \"\"\"Get a safe repr of an object for assertion error messages.\n\n    The assertion formatting (util.format_explanation()) requires\n    newlines to be escaped since they are a special character for it.\n    Normally assertion.util.format_explanation() does this but for a\n    custom repr it is possible to contain one of the special escape\n    sequences, especially '\\n{' and '\\n}' are likely to be present in\n    JSON reprs.\n\n    \"\"\"\n    return saferepr(obj).replace(\"\\n\", \"\\\\n\")",
            "start_line": 331,
            "start_column": 12599,
            "end_line": 0,
            "end_column": 13099,
            "start_byte": 12599,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._format_assertmsg",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _format_assertmsg(obj):\n    \"\"\"Format the custom assertion message given.\n\n    For strings this simply replaces newlines with '\\n~' so that\n    util.format_explanation() will preserve them instead of escaping\n    newlines.  For other objects saferepr() is used first.\n\n    \"\"\"\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n    if not isinstance(obj, str):\n        obj = saferepr(obj)\n        replaces.append((\"\\\\n\", \"\\n~\"))\n\n    for r1, r2 in replaces:\n        obj = obj.replace(r1, r2)\n\n    return obj",
            "start_line": 345,
            "start_column": 13102,
            "end_line": 0,
            "end_column": 13869,
            "start_byte": 13102,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"({} {} {})\".format(left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 805,
            "start_column": 30312,
            "end_line": 4,
            "end_column": 30674,
            "start_byte": 30312,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          {
            "name": "_pytest._io._call_and_format_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _call_and_format_exception(call, x, *args):\n    try:\n        # Try the vanilla repr and make sure that the result is a string\n        return call(x, *args)\n    except Exception as exc:\n        exc_name = type(exc).__name__\n        try:\n            exc_info = str(exc)\n        except Exception:\n            exc_info = \"unknown\"\n        return '<[{}(\"{}\") raised in repr()] {} object at 0x{:x}>'.format(\n            exc_name, exc_info, x.__class__.__name__, id(x)\n        )",
            "start_line": 4,
            "start_column": 31,
            "end_line": 0,
            "end_column": 506,
            "start_byte": 31,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x):\n        return self._callhelper(reprlib.Repr.repr, self, x)",
            "start_line": 24,
            "start_column": 689,
            "end_line": 4,
            "end_column": 767,
            "start_byte": 689,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_unicode",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_unicode(self, x, level):\n        # Strictly speaking wrong on narrow builds\n        def repr(u):\n            if \"'\" not in u:\n                return \"'%s'\" % u\n            elif '\"' not in u:\n                return '\"%s\"' % u\n            else:\n                return \"'%s'\" % u.replace(\"'\", r\"\\'\")\n\n        s = repr(x[: self.maxstring])\n        if len(s) > self.maxstring:\n            i = max(0, (self.maxstring - 3) // 2)\n            j = max(0, self.maxstring - 3 - i)\n            s = repr(x[:i] + x[len(x) - j :])\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 27,
            "start_column": 773,
            "end_line": 4,
            "end_column": 1361,
            "start_byte": 773,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x, level):\n        return self._callhelper(repr, x)",
            "start_line": 45,
            "start_column": 1367,
            "end_line": 4,
            "end_column": 1442,
            "start_byte": 1367,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr._callhelper",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _callhelper(self, call, x, *args):\n        s = _call_and_format_exception(call, x, *args)\n        if len(s) > self.maxsize:\n            i = max(0, (self.maxsize - 3) // 2)\n            j = max(0, self.maxsize - 3 - i)\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 48,
            "start_column": 1448,
            "end_line": 4,
            "end_column": 1733,
            "start_byte": 1448,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj, maxsize=240):\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    # review exception handling\n    srepr = SafeRepr()\n    srepr.maxstring = maxsize\n    srepr.maxsize = maxsize\n    srepr.maxother = 160\n    return srepr.repr(obj)",
            "start_line": 65,
            "start_column": 1988,
            "end_line": 0,
            "end_column": 2530,
            "start_byte": 1988,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 331,
            "start_column": 12599,
            "end_line": 0,
            "end_column": 13099,
            "start_byte": 12599,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.truncate_if_required",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def truncate_if_required(explanation, item, max_length=None):\n    \"\"\"\n    Truncate this assertion explanation if the given test item is eligible.\n    \"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation",
            "start_line": 13,
            "start_column": 279,
            "end_line": 0,
            "end_column": 541,
            "start_byte": 279,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._truncate_explanation",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_explanation(input_lines, max_lines=None, max_chars=None):\n    \"\"\"\n    Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first. The remaining lines will be replaced by a usage message.\n    \"\"\"\n\n    if max_lines is None:\n        max_lines = DEFAULT_MAX_LINES\n    if max_chars is None:\n        max_chars = DEFAULT_MAX_CHARS\n\n    # Check if truncation required\n    input_char_count = len(\"\".join(input_lines))\n    if len(input_lines) <= max_lines and input_char_count <= max_chars:\n        return input_lines\n\n    # Truncate first to max_lines, and then truncate to max_chars if max_chars\n    # is exceeded.\n    truncated_explanation = input_lines[:max_lines]\n    truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)\n\n    # Add ellipsis to final line\n    truncated_explanation[-1] = truncated_explanation[-1] + \"...\"\n\n    # Append useful message to explanation\n    truncated_line_count = len(input_lines) - len(truncated_explanation)\n    truncated_line_count += 1  # Account for the part-truncated final line\n    msg = \"...Full output truncated\"\n    if truncated_line_count == 1:\n        msg += \" ({} line hidden)\".format(truncated_line_count)\n    else:\n        msg += \" ({} lines hidden)\".format(truncated_line_count)\n    msg += \", {}\".format(USAGE_MSG)\n    truncated_explanation.extend([\"\", str(msg)])\n    return truncated_explanation",
            "start_line": 36,
            "start_column": 921,
            "end_line": 0,
            "end_column": 2404,
            "start_byte": 921,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._truncate_by_char_count",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_by_char_count(input_lines, max_chars):\n    # Check if truncation required\n    if len(\"\".join(input_lines)) <= max_chars:\n        return input_lines\n\n    # Find point at which input length exceeds total allowed length\n    iterated_char_count = 0\n    for iterated_index, input_line in enumerate(input_lines):\n        if iterated_char_count + len(input_line) > max_chars:\n            break\n        iterated_char_count += len(input_line)\n\n    # Create truncated explanation with modified final line\n    truncated_result = input_lines[:iterated_index]\n    final_line = input_lines[iterated_index]\n    if final_line:\n        final_line_truncate_point = max_chars - iterated_char_count\n        final_line = final_line[:final_line_truncate_point]\n    truncated_result.append(final_line)\n    return truncated_result",
            "start_line": 75,
            "start_column": 2407,
            "end_line": 0,
            "end_column": 3227,
            "start_byte": 2407,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "Step 1: Analyze User Instructions:\n1.1 The user reports an issue with confusing assertion messages when comparing byte strings in tests. Specifically, the assertion does not clearly communicate the nature of the difference between the byte strings.\n1.2 The problem is manifested during the comparison output of byte strings, showing ASCII values rather than the string itself which is leading to confusion.\n1.3 The expected result should be a clearer explanation that directly shows the differences between byte strings themselves, rather than focusing on their ASCII values. \n1.4 Expectations from the user, implied or otherwise, would be that the diff should correctly highlight the exact nature of string differences without defaulting to a character encoding that might be unclear, like ASCII values.\n1.5 To fix the issue, the code should directly compare byte strings and output meaningful differences without relying on ASCII equivalents that might confuse users.\n\nStep 2: Make the evaluate:\nLooking through given symbols for potentially relevant points of modification:\n2.1 From a brief look at the code snippets provided, areas related to byte string comparison might involve `_pytest.assertion.pytest_assertrepr_compare` and its associated methods like `_diff_text` that handle differences between texts and bytes.\n2.2 Particularly the code in `_diff_text` where it processes byte inputs by converting them to text and potentially misrepresents their differences could be a root cause.\n2.3 Thus, emphasizing/clearing out this part might pave the way to an improvement that addresses the confusion.\n2.4 We may need to alter how byte strings differences are exhibited by the function `_diff_text` for clarity.\n2.5 Clarification on the byte string processing in `assertrepr_compare` as well addresses potential conversion clarity issues ensuring there is no ASCII confusion.\n\nAsk for More Info:\n2.6 It would be beneficial to further review if there are any test cases or expected results whose content we could use to anchor the expected behavior. Or, perhaps more detail on how the `saferepr` is expected to integrate with byte strings.",
        "symbols": [
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "reason": "Handles the comparison of strings (bytes/text). This symbol directly impacts how byte strings are compared and explained, which is the core issue the user is facing."
          },
          {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "reason": "Function responsible for detailing the differences between text/bytes. This is where the ASCII numbers are being introduced and should be revised to reflect more intuitive difference explanations without relying on numerical ASCII representations."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "The symbol seems incomplete, but it is related to the function `assertrepr_compare` which produces explanations for operand comparisons during assertions. The confusion may originate from how text comparisons are currently handled, notably when byte-specific comparisons are done.",
          "This function `assertrepr_compare` likely produces custom comparison explanations for assertions. Since it handles matchmaking of left/right objects and attempts to yield added clarification via explanations lists, a part of this could deal with byte comparisons when text-based explanations are sought.\n",
          "Exploration suggests the `_diff_text` function handles diff computation between text/byte structures. The conversion of bytes into text for diffs is tangible here, which suggests where ASCII interpretations are coming into play, a restructuring to avoid ASCII during processing might be necessary while ensuring bytes are accurately represented.",
          "This symbol seems to describe a hook or a placeholder without practical content offered, but defining how comparison explanation might typically be prepared, which the other symbols act upon. Potentially would need to check if the comparison explainer invocation translates to the `assertrepr_compare` methodology.\n",
          "Seems mostly about getting a safe repr for objects; does not directly handle byte vs. string assertions. More so, aiding related representations especially for assertion messages. Not a direct line to the issue being faced.\n",
          "Handles reformatting of errors, more about message arrangement than addressing specific output details in assertions. Likely involved with output post-assertion details visually, not at the assertion logic.",
          "This function performs comparison checks implemented directly within rewritten assert structures. The significance is largely internal, considering it likely runs checks rather than affects output presentation. It allows custom comparison representations, apparently relevant to byte comparisons.",
          "May relate to the rewriting mechanisms for assertions, but practically speaking doesn't dictate presentations or handle explicit byte string differences. More ambient, given it generally sets up AST conditions for checks.",
          "As with above symbolic visitation functions, runs processing relevant to such assertions but isn't specifying byte outputs. It treats comparative analysis at logic level; not addressing practical output differences with byte-specific facets as outlined by the user.",
          "A safe repr utility, relies on well-processing structures within it to aid safe-to-use representations facilitating assertion message preparation, but more indirectly concerned with byte casting differences.",
          "This calls upon standard representation challenges and manages complex representations involved in Saferepr. Addressing object failure scenarios in repr attempts, not however altering byte comparisons or diff outputs directly.",
          "A SafeRepr aspect resolving user-facing string representations, seemingly limits to object representations in assertion contexts over logical differences. Handles user-defined object outputs partially, but more related to the results than differences.",
          "Like the above, invokes `SafeRepr` and is thereupon handling potential exechelp scenarios built for safe repr generation with exceptions handles properly. Helps safe output creation but not aligned exactly with byte confusion resolutions.",
          "Embedded within the SafeRepr file, acting to appropriately prepare reps over misaligned inputs. It integrates within broader saferepr notion ensuring representation safety, complexity wise."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:46:19.245632",
        "usage": "1.3132095336914062 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def _saferepr(obj):\n    \"\"\"Get a safe repr of an object for assertion error messages.\n\n    The assertion formatting (util.format_explanation()) requires\n    newlines to be escaped since they are a special character for it.\n    Normally assertion.util.format_explanation() does this but for a\n    custom repr it is possible to contain one of the special escape\n    sequences, especially '\\n{' and '\\n}' are likely to be present in\n    JSON reprs.\n\n    \"\"\"\n    return saferepr(obj).replace(\"\\n\", \"\\\\n\")",
              "start_line": 331,
              "start_column": 12599,
              "end_line": 0,
              "end_column": 13099,
              "start_byte": 12599,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._format_assertmsg",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def _format_assertmsg(obj):\n    \"\"\"Format the custom assertion message given.\n\n    For strings this simply replaces newlines with '\\n~' so that\n    util.format_explanation() will preserve them instead of escaping\n    newlines.  For other objects saferepr() is used first.\n\n    \"\"\"\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n    if not isinstance(obj, str):\n        obj = saferepr(obj)\n        replaces.append((\"\\\\n\", \"\\n~\"))\n\n    for r1, r2 in replaces:\n        obj = obj.replace(r1, r2)\n\n    return obj",
              "start_line": 345,
              "start_column": 13102,
              "end_line": 0,
              "end_column": 13869,
              "start_byte": 13102,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._call_reprcompare",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
              "start_line": 386,
              "start_column": 14311,
              "end_line": 0,
              "end_column": 14735,
              "start_byte": 14311,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
              "start_line": 662,
              "start_column": 24275,
              "end_line": 4,
              "end_column": 26963,
              "start_byte": 24275,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"({} {} {})\".format(left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
              "start_line": 805,
              "start_column": 30312,
              "end_line": 4,
              "end_column": 30674,
              "start_byte": 30312,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
              "start_line": 856,
              "start_column": 32390,
              "end_line": 4,
              "end_column": 34123,
              "start_byte": 32390,
              "end_byte": 4
            },
            {
              "name": "_pytest._io._call_and_format_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _call_and_format_exception(call, x, *args):\n    try:\n        # Try the vanilla repr and make sure that the result is a string\n        return call(x, *args)\n    except Exception as exc:\n        exc_name = type(exc).__name__\n        try:\n            exc_info = str(exc)\n        except Exception:\n            exc_info = \"unknown\"\n        return '<[{}(\"{}\") raised in repr()] {} object at 0x{:x}>'.format(\n            exc_name, exc_info, x.__class__.__name__, id(x)\n        )",
              "start_line": 4,
              "start_column": 31,
              "end_line": 0,
              "end_column": 506,
              "start_byte": 31,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr(self, x):\n        return self._callhelper(reprlib.Repr.repr, self, x)",
              "start_line": 24,
              "start_column": 689,
              "end_line": 4,
              "end_column": 767,
              "start_byte": 689,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr_unicode",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr_unicode(self, x, level):\n        # Strictly speaking wrong on narrow builds\n        def repr(u):\n            if \"'\" not in u:\n                return \"'%s'\" % u\n            elif '\"' not in u:\n                return '\"%s\"' % u\n            else:\n                return \"'%s'\" % u.replace(\"'\", r\"\\'\")\n\n        s = repr(x[: self.maxstring])\n        if len(s) > self.maxstring:\n            i = max(0, (self.maxstring - 3) // 2)\n            j = max(0, self.maxstring - 3 - i)\n            s = repr(x[:i] + x[len(x) - j :])\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
              "start_line": 27,
              "start_column": 773,
              "end_line": 4,
              "end_column": 1361,
              "start_byte": 773,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr_instance(self, x, level):\n        return self._callhelper(repr, x)",
              "start_line": 45,
              "start_column": 1367,
              "end_line": 4,
              "end_column": 1442,
              "start_byte": 1367,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr._callhelper",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _callhelper(self, call, x, *args):\n        s = _call_and_format_exception(call, x, *args)\n        if len(s) > self.maxsize:\n            i = max(0, (self.maxsize - 3) // 2)\n            j = max(0, self.maxsize - 3 - i)\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
              "start_line": 48,
              "start_column": 1448,
              "end_line": 4,
              "end_column": 1733,
              "start_byte": 1448,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def saferepr(obj, maxsize=240):\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    # review exception handling\n    srepr = SafeRepr()\n    srepr.maxstring = maxsize\n    srepr.maxsize = maxsize\n    srepr.maxother = 160\n    return srepr.repr(obj)",
              "start_line": 65,
              "start_column": 1988,
              "end_line": 0,
              "end_column": 2530,
              "start_byte": 1988,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "",
              "start_line": 331,
              "start_column": 12599,
              "end_line": 0,
              "end_column": 13099,
              "start_byte": 12599,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.truncate_if_required",
              "file_path": "src/_pytest/assertion/truncate.py",
              "file_content": "def truncate_if_required(explanation, item, max_length=None):\n    \"\"\"\n    Truncate this assertion explanation if the given test item is eligible.\n    \"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation",
              "start_line": 13,
              "start_column": 279,
              "end_line": 0,
              "end_column": 541,
              "start_byte": 279,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._truncate_explanation",
              "file_path": "src/_pytest/assertion/truncate.py",
              "file_content": "def _truncate_explanation(input_lines, max_lines=None, max_chars=None):\n    \"\"\"\n    Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first. The remaining lines will be replaced by a usage message.\n    \"\"\"\n\n    if max_lines is None:\n        max_lines = DEFAULT_MAX_LINES\n    if max_chars is None:\n        max_chars = DEFAULT_MAX_CHARS\n\n    # Check if truncation required\n    input_char_count = len(\"\".join(input_lines))\n    if len(input_lines) <= max_lines and input_char_count <= max_chars:\n        return input_lines\n\n    # Truncate first to max_lines, and then truncate to max_chars if max_chars\n    # is exceeded.\n    truncated_explanation = input_lines[:max_lines]\n    truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)\n\n    # Add ellipsis to final line\n    truncated_explanation[-1] = truncated_explanation[-1] + \"...\"\n\n    # Append useful message to explanation\n    truncated_line_count = len(input_lines) - len(truncated_explanation)\n    truncated_line_count += 1  # Account for the part-truncated final line\n    msg = \"...Full output truncated\"\n    if truncated_line_count == 1:\n        msg += \" ({} line hidden)\".format(truncated_line_count)\n    else:\n        msg += \" ({} lines hidden)\".format(truncated_line_count)\n    msg += \", {}\".format(USAGE_MSG)\n    truncated_explanation.extend([\"\", str(msg)])\n    return truncated_explanation",
              "start_line": 36,
              "start_column": 921,
              "end_line": 0,
              "end_column": 2404,
              "start_byte": 921,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._truncate_by_char_count",
              "file_path": "src/_pytest/assertion/truncate.py",
              "file_content": "def _truncate_by_char_count(input_lines, max_chars):\n    # Check if truncation required\n    if len(\"\".join(input_lines)) <= max_chars:\n        return input_lines\n\n    # Find point at which input length exceeds total allowed length\n    iterated_char_count = 0\n    for iterated_index, input_line in enumerate(input_lines):\n        if iterated_char_count + len(input_line) > max_chars:\n            break\n        iterated_char_count += len(input_line)\n\n    # Create truncated explanation with modified final line\n    truncated_result = input_lines[:iterated_index]\n    final_line = input_lines[iterated_index]\n    if final_line:\n        final_line_truncate_point = max_chars - iterated_char_count\n        final_line = final_line[:final_line_truncate_point]\n    truncated_result.append(final_line)\n    return truncated_result",
              "start_line": 75,
              "start_column": 2407,
              "end_line": 0,
              "end_column": 3227,
              "start_byte": 2407,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "elif op == \"not in\":\n            if istext(left) an",
              "start_line": 144,
              "start_column": 4794,
              "end_line": 0,
              "end_column": 4845,
              "start_byte": 4794,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
              "start_line": 115,
              "start_column": 3183,
              "end_line": 0,
              "end_column": 5297,
              "start_byte": 3183,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._diff_text",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
              "start_line": 165,
              "start_column": 5300,
              "end_line": 0,
              "end_column": 7552,
              "start_byte": 5300,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "",
              "start_line": 475,
              "start_column": 15508,
              "end_line": 0,
              "end_column": 16001,
              "start_byte": 15508,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Step 1: Analyze User Instructions:\n1.1 The user reports an issue with confusing assertion messages when comparing byte strings in tests. Specifically, the assertion does not clearly communicate the nature of the difference between the byte strings.\n1.2 The problem is manifested during the comparison output of byte strings, showing ASCII values rather than the string itself which is leading to confusion.\n1.3 The expected result should be a clearer explanation that directly shows the differences between byte strings themselves, rather than focusing on their ASCII values. \n1.4 Expectations from the user, implied or otherwise, would be that the diff should correctly highlight the exact nature of string differences without defaulting to a character encoding that might be unclear, like ASCII values.\n1.5 To fix the issue, the code should directly compare byte strings and output meaningful differences without relying on ASCII equivalents that might confuse users.\n\nStep 2: Make the evaluate:\nLooking through given symbols for potentially relevant points of modification:\n2.1 From a brief look at the code snippets provided, areas related to byte string comparison might involve `_pytest.assertion.pytest_assertrepr_compare` and its associated methods like `_diff_text` that handle differences between texts and bytes.\n2.2 Particularly the code in `_diff_text` where it processes byte inputs by converting them to text and potentially misrepresents their differences could be a root cause.\n2.3 Thus, emphasizing/clearing out this part might pave the way to an improvement that addresses the confusion.\n2.4 We may need to alter how byte strings differences are exhibited by the function `_diff_text` for clarity.\n2.5 Clarification on the byte string processing in `assertrepr_compare` as well addresses potential conversion clarity issues ensuring there is no ASCII confusion.\n\nAsk for More Info:\n2.6 It would be beneficial to further review if there are any test cases or expected results whose content we could use to anchor the expected behavior. Or, perhaps more detail on how the `saferepr` is expected to integrate with byte strings.",
          "symbols": [
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "reason": "Handles the comparison of strings (bytes/text). This symbol directly impacts how byte strings are compared and explained, which is the core issue the user is facing."
            },
            {
              "name": "_pytest.assertion._diff_text",
              "file_path": "src/_pytest/assertion/util.py",
              "reason": "Function responsible for detailing the differences between text/bytes. This is where the ASCII numbers are being introduced and should be revised to reflect more intuitive difference explanations without relying on numerical ASCII representations."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "The symbol seems incomplete, but it is related to the function `assertrepr_compare` which produces explanations for operand comparisons during assertions. The confusion may originate from how text comparisons are currently handled, notably when byte-specific comparisons are done.",
            "This function `assertrepr_compare` likely produces custom comparison explanations for assertions. Since it handles matchmaking of left/right objects and attempts to yield added clarification via explanations lists, a part of this could deal with byte comparisons when text-based explanations are sought.\n",
            "Exploration suggests the `_diff_text` function handles diff computation between text/byte structures. The conversion of bytes into text for diffs is tangible here, which suggests where ASCII interpretations are coming into play, a restructuring to avoid ASCII during processing might be necessary while ensuring bytes are accurately represented.",
            "This symbol seems to describe a hook or a placeholder without practical content offered, but defining how comparison explanation might typically be prepared, which the other symbols act upon. Potentially would need to check if the comparison explainer invocation translates to the `assertrepr_compare` methodology.\n",
            "Seems mostly about getting a safe repr for objects; does not directly handle byte vs. string assertions. More so, aiding related representations especially for assertion messages. Not a direct line to the issue being faced.\n",
            "Handles reformatting of errors, more about message arrangement than addressing specific output details in assertions. Likely involved with output post-assertion details visually, not at the assertion logic.",
            "This function performs comparison checks implemented directly within rewritten assert structures. The significance is largely internal, considering it likely runs checks rather than affects output presentation. It allows custom comparison representations, apparently relevant to byte comparisons.",
            "May relate to the rewriting mechanisms for assertions, but practically speaking doesn't dictate presentations or handle explicit byte string differences. More ambient, given it generally sets up AST conditions for checks.",
            "As with above symbolic visitation functions, runs processing relevant to such assertions but isn't specifying byte outputs. It treats comparative analysis at logic level; not addressing practical output differences with byte-specific facets as outlined by the user.",
            "A safe repr utility, relies on well-processing structures within it to aid safe-to-use representations facilitating assertion message preparation, but more indirectly concerned with byte casting differences.",
            "This calls upon standard representation challenges and manages complex representations involved in Saferepr. Addressing object failure scenarios in repr attempts, not however altering byte comparisons or diff outputs directly.",
            "A SafeRepr aspect resolving user-facing string representations, seemingly limits to object representations in assertion contexts over logical differences. Handles user-defined object outputs partially, but more related to the results than differences.",
            "Like the above, invokes `SafeRepr` and is thereupon handling potential exechelp scenarios built for safe repr generation with exceptions handles properly. Helps safe output creation but not aligned exactly with byte confusion resolutions.",
            "Embedded within the SafeRepr file, acting to appropriately prepare reps over misaligned inputs. It integrates within broader saferepr notion ensuring representation safety, complexity wise."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/assertion/util.py"
        ],
        "symbols": [
          "_pytest.assertion.pytest_assertrepr_compare",
          "_pytest.assertion._diff_text"
        ],
        "code_spans": {
          "_pytest.assertion._saferepr": {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 331,
            "start_column": 12599,
            "end_line": 0,
            "end_column": 13099,
            "start_byte": 12599,
            "end_byte": 0
          },
          "_pytest.assertion._format_assertmsg": {
            "name": "_pytest.assertion._format_assertmsg",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _format_assertmsg(obj):\n    \"\"\"Format the custom assertion message given.\n\n    For strings this simply replaces newlines with '\\n~' so that\n    util.format_explanation() will preserve them instead of escaping\n    newlines.  For other objects saferepr() is used first.\n\n    \"\"\"\n    # reprlib appears to have a bug which means that if a string\n    # contains a newline it gets escaped, however if an object has a\n    # .__repr__() which contains newlines it does not get escaped.\n    # However in either case we want to preserve the newline.\n    replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n    if not isinstance(obj, str):\n        obj = saferepr(obj)\n        replaces.append((\"\\\\n\", \"\\n~\"))\n\n    for r1, r2 in replaces:\n        obj = obj.replace(r1, r2)\n\n    return obj",
            "start_line": 345,
            "start_column": 13102,
            "end_line": 0,
            "end_column": 13869,
            "start_byte": 13102,
            "end_byte": 0
          },
          "_pytest.assertion._call_reprcompare": {
            "name": "_pytest.assertion._call_reprcompare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def _call_reprcompare(ops, results, expls, each_obj):\n    for i, res, expl in zip(range(len(ops)), results, expls):\n        try:\n            done = not res\n        except Exception:\n            done = True\n        if done:\n            break\n    if util._reprcompare is not None:\n        custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n        if custom is not None:\n            return custom\n    return expl",
            "start_line": 386,
            "start_column": 14311,
            "end_line": 0,
            "end_column": 14735,
            "start_byte": 14311,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter.visit_Assert": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=self.module_path,\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast.Call(err_name, [fmt], [])\n        raise_ = ast.Raise(exc, None)\n\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 662,
            "start_column": 24275,
            "end_line": 4,
            "end_column": 26963,
            "start_byte": 24275,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_BinOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"({} {} {})\".format(left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 805,
            "start_column": 30312,
            "end_line": 4,
            "end_column": 30674,
            "start_byte": 30312,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Compare": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"{} {} {}\".format(left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 856,
            "start_column": 32390,
            "end_line": 4,
            "end_column": 34123,
            "start_byte": 32390,
            "end_byte": 4
          },
          "_pytest._io._call_and_format_exception": {
            "name": "_pytest._io._call_and_format_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _call_and_format_exception(call, x, *args):\n    try:\n        # Try the vanilla repr and make sure that the result is a string\n        return call(x, *args)\n    except Exception as exc:\n        exc_name = type(exc).__name__\n        try:\n            exc_info = str(exc)\n        except Exception:\n            exc_info = \"unknown\"\n        return '<[{}(\"{}\") raised in repr()] {} object at 0x{:x}>'.format(\n            exc_name, exc_info, x.__class__.__name__, id(x)\n        )",
            "start_line": 4,
            "start_column": 31,
            "end_line": 0,
            "end_column": 506,
            "start_byte": 31,
            "end_byte": 0
          },
          "_pytest._io.SafeRepr.repr": {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x):\n        return self._callhelper(reprlib.Repr.repr, self, x)",
            "start_line": 24,
            "start_column": 689,
            "end_line": 4,
            "end_column": 767,
            "start_byte": 689,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr_unicode": {
            "name": "_pytest._io.SafeRepr.repr_unicode",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_unicode(self, x, level):\n        # Strictly speaking wrong on narrow builds\n        def repr(u):\n            if \"'\" not in u:\n                return \"'%s'\" % u\n            elif '\"' not in u:\n                return '\"%s\"' % u\n            else:\n                return \"'%s'\" % u.replace(\"'\", r\"\\'\")\n\n        s = repr(x[: self.maxstring])\n        if len(s) > self.maxstring:\n            i = max(0, (self.maxstring - 3) // 2)\n            j = max(0, self.maxstring - 3 - i)\n            s = repr(x[:i] + x[len(x) - j :])\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 27,
            "start_column": 773,
            "end_line": 4,
            "end_column": 1361,
            "start_byte": 773,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr_instance": {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x, level):\n        return self._callhelper(repr, x)",
            "start_line": 45,
            "start_column": 1367,
            "end_line": 4,
            "end_column": 1442,
            "start_byte": 1367,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr._callhelper": {
            "name": "_pytest._io.SafeRepr._callhelper",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _callhelper(self, call, x, *args):\n        s = _call_and_format_exception(call, x, *args)\n        if len(s) > self.maxsize:\n            i = max(0, (self.maxsize - 3) // 2)\n            j = max(0, self.maxsize - 3 - i)\n            s = s[:i] + \"...\" + s[len(s) - j :]\n        return s",
            "start_line": 48,
            "start_column": 1448,
            "end_line": 4,
            "end_column": 1733,
            "start_byte": 1448,
            "end_byte": 4
          },
          "_pytest._io.saferepr": {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj, maxsize=240):\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    # review exception handling\n    srepr = SafeRepr()\n    srepr.maxstring = maxsize\n    srepr.maxsize = maxsize\n    srepr.maxother = 160\n    return srepr.repr(obj)",
            "start_line": 65,
            "start_column": 1988,
            "end_line": 0,
            "end_column": 2530,
            "start_byte": 1988,
            "end_byte": 0
          },
          "_pytest.assertion.truncate_if_required": {
            "name": "_pytest.assertion.truncate_if_required",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def truncate_if_required(explanation, item, max_length=None):\n    \"\"\"\n    Truncate this assertion explanation if the given test item is eligible.\n    \"\"\"\n    if _should_truncate_item(item):\n        return _truncate_explanation(explanation)\n    return explanation",
            "start_line": 13,
            "start_column": 279,
            "end_line": 0,
            "end_column": 541,
            "start_byte": 279,
            "end_byte": 0
          },
          "_pytest.assertion._truncate_explanation": {
            "name": "_pytest.assertion._truncate_explanation",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_explanation(input_lines, max_lines=None, max_chars=None):\n    \"\"\"\n    Truncate given list of strings that makes up the assertion explanation.\n\n    Truncates to either 8 lines, or 640 characters - whichever the input reaches\n    first. The remaining lines will be replaced by a usage message.\n    \"\"\"\n\n    if max_lines is None:\n        max_lines = DEFAULT_MAX_LINES\n    if max_chars is None:\n        max_chars = DEFAULT_MAX_CHARS\n\n    # Check if truncation required\n    input_char_count = len(\"\".join(input_lines))\n    if len(input_lines) <= max_lines and input_char_count <= max_chars:\n        return input_lines\n\n    # Truncate first to max_lines, and then truncate to max_chars if max_chars\n    # is exceeded.\n    truncated_explanation = input_lines[:max_lines]\n    truncated_explanation = _truncate_by_char_count(truncated_explanation, max_chars)\n\n    # Add ellipsis to final line\n    truncated_explanation[-1] = truncated_explanation[-1] + \"...\"\n\n    # Append useful message to explanation\n    truncated_line_count = len(input_lines) - len(truncated_explanation)\n    truncated_line_count += 1  # Account for the part-truncated final line\n    msg = \"...Full output truncated\"\n    if truncated_line_count == 1:\n        msg += \" ({} line hidden)\".format(truncated_line_count)\n    else:\n        msg += \" ({} lines hidden)\".format(truncated_line_count)\n    msg += \", {}\".format(USAGE_MSG)\n    truncated_explanation.extend([\"\", str(msg)])\n    return truncated_explanation",
            "start_line": 36,
            "start_column": 921,
            "end_line": 0,
            "end_column": 2404,
            "start_byte": 921,
            "end_byte": 0
          },
          "_pytest.assertion._truncate_by_char_count": {
            "name": "_pytest.assertion._truncate_by_char_count",
            "file_path": "src/_pytest/assertion/truncate.py",
            "file_content": "def _truncate_by_char_count(input_lines, max_chars):\n    # Check if truncation required\n    if len(\"\".join(input_lines)) <= max_chars:\n        return input_lines\n\n    # Find point at which input length exceeds total allowed length\n    iterated_char_count = 0\n    for iterated_index, input_line in enumerate(input_lines):\n        if iterated_char_count + len(input_line) > max_chars:\n            break\n        iterated_char_count += len(input_line)\n\n    # Create truncated explanation with modified final line\n    truncated_result = input_lines[:iterated_index]\n    final_line = input_lines[iterated_index]\n    if final_line:\n        final_line_truncate_point = max_chars - iterated_char_count\n        final_line = final_line[:final_line_truncate_point]\n    truncated_result.append(final_line)\n    return truncated_result",
            "start_line": 75,
            "start_column": 2407,
            "end_line": 0,
            "end_column": 3227,
            "start_byte": 2407,
            "end_byte": 0
          },
          "_pytest.assertion.pytest_assertrepr_compare": {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "elif op == \"not in\":\n            if istext(left) an",
            "start_line": 144,
            "start_column": 4794,
            "end_line": 0,
            "end_column": 4845,
            "start_byte": 4794,
            "end_byte": 0
          },
          "_pytest.assertion.assertrepr_compare": {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = \"{} {} {}\".format(left_repr, op, right_repr)\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            \"(pytest_assertion plugin: representation of details failed.  \"\n            \"Probably an object has a faulty __repr__.)\",\n            str(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 115,
            "start_column": 3183,
            "end_line": 0,
            "end_column": 5297,
            "start_byte": 3183,
            "end_byte": 0
          },
          "_pytest.assertion._diff_text": {
            "name": "_pytest.assertion._diff_text",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _diff_text(left, right, verbose=0):\n    \"\"\"Return the explanation for the diff between text or bytes.\n\n    Unless --verbose is used this will skip leading and trailing\n    characters which are identical to keep the diff minimal.\n\n    If the input are bytes they will be safely converted to text.\n    \"\"\"\n    from difflib import ndiff\n\n    explanation = []\n\n    def escape_for_readable_diff(binary_text):\n        \"\"\"\n        Ensures that the internal string is always valid unicode, converting any bytes safely to valid unicode.\n        This is done using repr() which then needs post-processing to fix the encompassing quotes and un-escape\n        newlines and carriage returns (#429).\n        \"\"\"\n        r = str(repr(binary_text)[1:-1])\n        r = r.replace(r\"\\n\", \"\\n\")\n        r = r.replace(r\"\\r\", \"\\r\")\n        return r\n\n    if isinstance(left, bytes):\n        left = escape_for_readable_diff(left)\n    if isinstance(right, bytes):\n        right = escape_for_readable_diff(right)\n    if verbose < 1:\n        i = 0  # just in case left or right has zero length\n        for i in range(min(len(left), len(right))):\n            if left[i] != right[i]:\n                break\n        if i > 42:\n            i -= 10  # Provide some context\n            explanation = [\n                \"Skipping %s identical leading characters in diff, use -v to show\" % i\n            ]\n            left = left[i:]\n            right = right[i:]\n        if len(left) == len(right):\n            for i in range(len(left)):\n                if left[-i] != right[-i]:\n                    break\n            if i > 42:\n                i -= 10  # Provide some context\n                explanation += [\n                    \"Skipping {} identical trailing \"\n                    \"characters in diff, use -v to show\".format(i)\n                ]\n                left = left[:-i]\n                right = right[:-i]\n    keepends = True\n    if left.isspace() or right.isspace():\n        left = repr(str(left))\n        right = repr(str(right))\n        explanation += [\"Strings contain only whitespace, escaping them using repr()\"]\n    explanation += [\n        line.strip(\"\\n\")\n        for line in ndiff(left.splitlines(keepends), right.splitlines(keepends))\n    ]\n    return explanation",
            "start_line": 165,
            "start_column": 5300,
            "end_line": 0,
            "end_column": 7552,
            "start_byte": 5300,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_assertrepr_compare": {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        }
      }
    }
  ]
}