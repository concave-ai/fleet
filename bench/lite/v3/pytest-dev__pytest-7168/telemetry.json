{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7168",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:54.781532",
        "usage": "1470.353126525879 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "try_makedirs",
          "putaround",
          "setenv",
          "CollectError",
          "FILLFUNCARGS",
          "maketxtfile",
          "duration",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "_create_formatter",
          "_with_exception",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "wrap_pytest_function_for_tracing",
          "_find_spec",
          "popcall",
          "pytest_collect_directory",
          "_CACHE_PREFIX_VALUES",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "TeeSysCapture",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "Store",
          "StoreKey",
          "visit_BoolOp",
          "check_strict_xfail",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "FakeCollectModule",
          "ReprExceptionInfo",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "map_fixname_class",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "no_re_match_line",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "_get_teardown_reports",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "_validate_ids",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "dir",
          "_ellipsize",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "prog",
          "_PytestWrapper",
          "mode",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "reprlocals",
          "fslocation",
          "_get_pdb_wrapper_class",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "_write_source",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "fault_handler_stderr_key",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "type",
          "_inject_setup_teardown_fixtures",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "FormattedExcinfo",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "xml_key",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "pytest_assertion_pass",
          "_from_json",
          "getplugin",
          "failed",
          "_handle_teardown_sections",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_try_repr_or_str",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "FIXTURE_ARGS_ORDER",
          "freeze_support",
          "_W",
          "monkeypatch",
          "__bool__",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "__contains__",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "async_warn_and_skip",
          "addini",
          "faulthandler",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "CHECKER_CLASS",
          "fail_fixturefunc",
          "pytest_ignore_collect",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_visit_filter",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "KNOWN_TYPES",
          "_try_load_conftest",
          "_fail",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "_write_content",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "_expecting_failure",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "reprtraceback",
          "CACHEDIR_TAG_CONTENT",
          "_repr_style",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_report_to_json",
          "_compare_eq_cls",
          "done",
          "CallInfo",
          "WarningsChecker",
          "fixture",
          "__attrs_post_init__",
          "MonkeyPatch",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_make_plural",
          "_set_main_color",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "extraline",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "writer",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "TESTS_FAILED",
          "verbosity",
          "_check_scope",
          "_update_message",
          "ParameterSet",
          "raises",
          "from_parent",
          "Junit",
          "format",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "caplog",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "from_exc_info",
          "_fail_on_non_top_pytest_plugins",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "__slots__",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "get_last_failed_paths",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "pastebinfile_key",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "TYPE_CHECKING",
          "pytest_configure",
          "CollectErrorRepr",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "T",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "Exception",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "pytest",
          "INTERNAL_ERROR",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "TeeCaptureIO",
          "_do_configure",
          "on_rm_rf_error",
          "exec_module",
          "get_fslocation_from_item",
          "DummyRewriteHook",
          "_is_last_item",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "skipped_by_mark_key",
          "getnode",
          "_showfixtures_main",
          "_add_stats",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "lines",
          "is_async_function",
          "import_plugin",
          "_assert_expr_to_lineno",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "_no_match_line",
          "append_pass",
          "record_xml_attribute",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "maybe_wrap_pytest_function_for_tracing",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "_bytes_to_ascii",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "RaisesContext",
          "store",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "_check_if_assertion_pass_impl",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_format",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "rewrite",
          "toterminal",
          "nodes",
          "_in_suspended",
          "LFPluginCollSkipfiles",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "old_mark_config_key",
          "addSkip",
          "assert_contains",
          "_get_auto_indent",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "parse_args",
          "FaultHandlerHooks",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "_prepare_content",
          "ishidden",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "LFPluginCollWrapper",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_write_pyc_fp",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "NO_PRINT_LOGS",
          "WarningReport",
          "_parse_parametrize_parameters",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "OK",
          "TERMINALWRITER_WRITER",
          "COLLECT_DIRECTORY_HOOK",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "_determine_main_color",
          "LineComp",
          "_striptext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "clear_cache",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "_pformat_dispatch",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "_REPORTCHARS_DEFAULT",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "evalxfail_key",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "_report_kwargs_from_json",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "NodeMeta",
          "parse_known_args",
          "pytest_generate_tests",
          "PYTEST_COLLECT_MODULE",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "USAGE_ERROR",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "reprfuncargs",
          "add_stats",
          "fill_unfilled",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "NO_TESTS_COLLECTED",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "_get_assertion_exprs",
          "_non_numeric_type_error",
          "_F",
          "iter_markers_with_node",
          "PYTEST_TAG",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "_done",
          "NODE_USE_FROM_PARENT",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "get_use_fixtures_for_node",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_rget_with_confmod",
          "setmulti2",
          "tracebackcutdir",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "_AnyPurePath",
          "clear",
          "parsefactories",
          "BINOP_MAP",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "longrepr",
          "bin_xml_escape",
          "_names",
          "context",
          "short_test_summary",
          "__next__",
          "format_session_duration",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "D",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "_capturing_for_request",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "addError",
          "call_optional",
          "_PluggyPlugin",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "find_spec",
          "_makepath",
          "_format_action_invocation",
          "_getvaluepath",
          "reprfileloc",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_T",
          "_get_global_properties_node",
          "getpathnode",
          "__dir__",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "_parse_fixture_args",
          "Session",
          "addinivalue_line",
          "Exit",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "create_module",
          "_assertion_pass",
          "_teardown_yield_fixture",
          "_get_multicapture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "_ET",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "_has_param_ids",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "rm_rf",
          "_WithException",
          "emit",
          "_log",
          "reprentries",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "no_fnmatch_line",
          "outcomes",
          "sections",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "wasvalid",
          "_CACHE_PREFIX_DIRS",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "reprcrash",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "append_collect_skipped",
          "_collectfile",
          "_gethookproxy",
          "_color_for_type",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "PseudoFixtureDef",
          "_reprcompare",
          "_validate_explicit_parameters",
          "unexpectedsuccess_key",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "_get_number_flag",
          "_S",
          "INTERRUPTED",
          "_readline_workaround",
          "_teardown_towards",
          "exitstatus",
          "_runtest_for_main",
          "_ensure_relative_to_basetemp",
          "_check_record_param_type",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "resultlog_key",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_param_ids_generated",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "_get_main_color",
          "yield_fixture",
          "_setupstate",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "setdefault",
          "PyobjMixin",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "lineno",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "AlwaysDispatchingPrettyPrinter",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "_pluginmanager",
          "evalcache_key",
          "pytest_cmdline_preparse",
          "formatrepr",
          "_E",
          "_create",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_param_ids_from",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "get_timeout_config_value",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "TerminalWriter",
          "call_and_report",
          "visit_Starred",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "InvocationParams",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "JUNIT_XML_DEFAULT_FAMILY",
          "from_current",
          "isset",
          "markname",
          "_given_basetemp",
          "popen",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "UNARY_MAP",
          "nextitem",
          "approx",
          "_addoption_instance",
          "_color_for_type_default",
          "LineMatcher_fixture",
          "plugins",
          "_init_checker_class",
          "_excinfo",
          "assertstate_key",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_call_assertion_pass",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "_result",
          "getbasetemp",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "get_log_level_for_setting",
          "repr_excinfo",
          "ExitCode",
          "syspath_prepend",
          "cache_key",
          "set_trace",
          "__iter__",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "rex_session_duration",
          "istrue",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "_fixturemanager",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "set_repr_style",
          "_addoption",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "FUNCARGNAMES",
          "MarkMapping",
          "append_skipped",
          "_get_stderr_fileno",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "get_cache_dir",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "_highlight",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "_surrounding_parens_on_own_lines",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "_eval_scope_callable",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "_format_repr_exception",
          "nose",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "_write_entry_lines",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "saferepr",
          "repr_failure",
          "INTERNAL_ERROR",
          "pytest_runtest_makereport",
          "ReprEntry",
          "ReprFuncArgs"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:56.251900",
        "usage": "250.9448528289795 ms"
      },
      "request": {
        "tokens": [
          "saferepr",
          "repr_failure",
          "INTERNAL_ERROR",
          "pytest_runtest_makereport",
          "ReprEntry",
          "ReprFuncArgs"
        ]
      },
      "response": {
        "results": {
          "pytest_runtest_makereport": [
            "src/_pytest/skipping.py",
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "INTERNAL_ERROR": [
            "src/_pytest/main.py",
            "src/_pytest/config/__init__.py"
          ],
          "saferepr": [
            "src/_pytest/_code/code.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_failure": [
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/reports.py",
            "src/_pytest/nodes.py"
          ],
          "ReprEntry": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ],
          "ReprFuncArgs": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:56.502856",
        "usage": "5634.711980819702 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_runtest_makereport": [
            "src/_pytest/skipping.py",
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "INTERNAL_ERROR": [
            "src/_pytest/main.py",
            "src/_pytest/config/__init__.py"
          ],
          "saferepr": [
            "src/_pytest/_code/code.py",
            "src/_pytest/python.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/_io/saferepr.py"
          ],
          "repr_failure": [
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py",
            "src/_pytest/reports.py",
            "src/_pytest/nodes.py"
          ],
          "ReprEntry": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ],
          "ReprFuncArgs": [
            "src/_pytest/_code/code.py",
            "src/_pytest/reports.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue at hand is an INTERNALERROR raised when an exception occurs inside the __repr__ method of a class during testing with pytest. This error seems to propagate through several internal pytest mechanisms, so we have to find the files that deal with repr functions and exception handling during pytest's test session runs.\n\nKeywords that are potentially related:\n1. \"saferepr\": This is critical since the stack trace indicates that the problem surfaces in the saferepr module when attempting to handle __repr__ exceptions. Inspecting files matching this keyword might lead us to the problem.\n2. \"INTERNAL_ERROR\": This directly mentions the kind of error we're looking at. Files that pop up under this category may include error handling specific to internal exceptions that occur during pytest runs.\n3. \"repr_failure\": This seems crucial as the traceback involves calls to repr_failure and similar methods, indicating this might relate to how pytest processes and formats failures, which are presumably wrapped around errors in repr functions.\n4. \"pytest_runtest_makereport\": Since this is related to the test report generation phase where exceptions might be repr'd, it's likely relevant too.\n\nAnalyzing the keyword search results:\n- From \"saferepr\", `src/_pytest/_io/saferepr.py` is directly indicated in the traceback, suggesting it's involved in the issue.\n- From \"INTERNAL_ERROR\", `src/_pytest/main.py` is involved per the traceback as where the error wraps begin.\n- From \"repr_failure\", `src/_pytest/python.py` and `src/_pytest/nodes.py` are part of the trace around repr_failure handling.\n- From \"pytest_runtest_makereport\", `src/_pytest/runner.py` is frequently mentioned as part of the chain leading to the error.\n\nThus, these files are likely to contain relevant logic around handling exceptions in __repr__ during test execution.",
        "file_paths": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/main.py",
          "src/_pytest/python.py",
          "src/_pytest/nodes.py",
          "src/_pytest/runner.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:02.137586",
        "usage": "8044.852018356323 ms"
      },
      "request": {
        "file_path": "src/_pytest/_io/saferepr.py"
      },
      "response": {
        "scratch_pad": "1. **Analyzing the Issue:**  \n   - The issue describes a situation where an `INTERNALERROR` is encountered when the `__repr__` method in a custom class raises an exception. \n   - The provided code has a class `SomeClass` which defines `__getattribute__` and `__repr__` methods that both raise exceptions.\n   - The user provided a minimal reproducible code where accessing an attribute of `SomeClass` would trigger these methods, leading to unhandled exceptions.\n   \n2. **Reproduce Steps:**\n   - Steps mention creating an instance of `SomeClass`.\n   - Attempting to access an attribute on this class instance, which should call `__repr__` during the error reporting, leading to another exception since it just raises.\n   - This double-exception scenario likely causes the internal error.\n\n3. **User Expectation and Issue Cause:**\n   - uesr expects Pytest should handle exceptions more gracefully, especially when methods like `__repr__` fail unexpectedly.\n   - The root cause seems to be that the `__repr__` failure isn't being properly managed within the Pytest error handling framework.\n\n4. **Possible Solutions:**\n   - Enhance the error handling mechanism to deal with cases where `__repr__` might fail.\n   - Improve the `saferepr` functionality to capture the exception without escalating to an `INTERNALERROR`.\n\n5. **File Evaluation:**\n   - The file implements `saferepr` and related components, intended to create safe representation strings.\n   - Functions like `_try_repr_or_str`, `_format_repr_exception`, and `SafeRepr` class methods are designed to catch exceptions during representation and provide safe fallbacks.\n   - The implementations help prevent exception propagation during `repr()` calls, consistent with the error issue described.\n\n6. **Matching Symbols:**\n   - The methods `saferepr()`, `SafeRepr.repr()`, and `_format_repr_exception()` are directly related.\n   - They aim to safely handle exceptions in representative string formations, indicating that the file is relevant to the root cause of how representation errors could escalate in Pytest internal error.\n\n7. **Conclusion:**\n   - This file is related and likely the root cause area since it aims to mitigate `repr` errors which align with the issue kind. \n   - The main issue might lie within these error handling enhancements not being comprehensive enough for the scenario the user encountered.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "saferepr",
          "SafeRepr.repr",
          "_format_repr_exception"
        ],
        "root_cause_symbols": [
          "saferepr",
          "SafeRepr.repr",
          "_format_repr_exception"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:10.182477",
        "usage": "9073.616981506348 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an INTERNALERROR when an exception occurs in the `__repr__` method of a class during a pytest session. This issue arises when a test is conducted on an object of a class where `__repr__` raises an exception, causing pytest to crash internally.\n1.2 The user provides minimal code and a traceback to demonstrate the issue. The error occurs when accessing an undefined attribute causing `__getattribute__` to raise an exception, which in turn causes the `__repr__` method to raise an exception.\n1.3 This issue is caused because pytest attempts to invoke `__repr__` on failing test items (or during various internal operations) and if `__repr__` itself raises an exception, pytest doesn't handle it gracefully, resulting in an INTERNALERROR instead of reporting the intended error.\n1.4 The expectation is that pytest should gracefully handle exceptions in the `__repr__` method and provide a helpful error message or traceback specific to the test failure rather than crashing entirely.\n1.5 The root cause is likely related to how pytest's internal error handling or representation logic is not shielding its calls to `__repr__` properly, which in an exceptional case results in broader breakage.\n\n2. Make file evaluation:\n2.1 The file, 'src/_pytest/main.py', is responsible for core implementation of testing processes, but includes key function wrap_session(), which encapsulates testing and session control flow, capturing exceptions during a run using different handlers for specific types.\n2.2 Looking for exception handlers related to internal errors and where `__repr__` might get called is a critical point.\n2.3 Important part to examine would be if wrap_session() or any other related function captures and correctly handles exceptions of type raised from __repr__, and find a location where exceptions not caught might lead to INTERNALERROR.\n2.4 Part of the issue may lie in `_main()` within the same file trying multiple stages, although detailed tracing for execution leading to exception handling lapse isn't provided here.\n2.5 No immediate references to `__repr__` directly indicated by this snippet so locating the precise control structure around exception handling for these cases is crucial.\n\n3. Conclusion:\n- The file '_pytest/main.py' is definitely related because it handles core exception and session management logic.\n- Contact points to actual test internals like TestReport creation not clearly shown but main execution wrapped in this module.\n- Additional exploration needed for exception notification where handling flow deviates.\n\nRelevant suggestion:\n- Focus around exception capture and how errors transported or not handled inside Session or these core functions; it's likely close to or part of where crashes surface.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_code/code.py",
          "src/_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "wrap_session",
          "pytest_cmdline_main",
          "_main",
          "Session"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:19.256104",
        "usage": "9341.907978057861 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user has described an issue where an INTERNALERROR occurs when an exception is raised in the `__repr__` method of a class. The provided minimal reproduction code and traceback suggest that pytest is not handling exceptions in `__repr__` correctly, leading to an unexpected RuntimeError.\n1.2 The user provided steps to reproduce, which involve creating a class with `__getattribute__` and `__repr__` methods that both raise exceptions, and then attempting to access an attribute of an instance of this class during a test run. This causes an exception in `__repr__` when pytest tries to use it for reporting, leading to the INTERNALERROR.\n1.3 The issue seems to be caused by pytest's error handling mechanism not being robust enough to handle exceptions raised during the object's string representation (often used for logging or error reporting).\n1.4 The user's expectation is that exceptions in `__repr__` should be handled gracefully, without causing an INTERNALERROR, potentially by wrapping calls to `repr()` in a try-except block to handle any raised exceptions.\n1.6 Possible solutions could include modifying pytest's error handling code to catch and appropriately handle exceptions raised during repr() calls.\n\n2. Make file evaluation:\n2.1 After evaluating the file `src/_pytest/python.py`, some parts of the traceback suggest that the issue arises in the reporting functions, particularly where pytest is trying to represent an object during error reporting.\n2.3 Relevant symbols are:\n    - `FunctionDefinition` or `Function` classes, as these classes handle running the test functions and managing their execution environment. The `repr_failure` method in the `Function` class uses the `._repr_failure_py` method, which indirectly calls `getrepr` with potential exposure to the problematic `repr` issue.\n    - The `_repr_failure_py` and `repr_failure` methods of the `Function` class, as they deal with representing failures, might not be catching exceptions from `repr()` properly.\n    \n2.6 The file may not be the root cause, but it is relevant as it involves code intended to handle test failures and their representation. It's likely that other parts of Pytest could be causing the issue, potentially libraries dealing with safety or representation (`saferepr`).",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/reports.py",
          "src/_pytest/_code/code.py"
        ],
        "relevant_symbols": [
          "Function.repr_failure",
          "Function._repr_failure_py"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:28.598034",
        "usage": "6105.768918991089 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is an INTERNALERROR occurring in pytest when there is an exception in the __repr__ method of an object being tested. This is causing pytest to crash instead of handling the exception gracefully.\n1.2 The user has provided the steps to reproduce the issue by defining a minimal class with a __repr__ method that raises an exception and then accessing an attribute on an instance of this class.\n1.3 The issue is caused by pytest trying to use the __repr__ method of the object (which raises an exception) during exception handling, leading to a crash.\n1.4 The user's expectation might be for pytest to report the exception without crashing and handle it more gracefully, even if __repr__ methods raise exceptions.\n1.5 Possible solutions could involve enhancing the system handling within pytest for cases where __repr__ itself has exceptions, potentially catching such exceptions and providing an alternative representation.\n\n2. Make file evaluation:\n2.1 Start by looking at the provided file `src/_pytest/nodes.py`.\n2.2 Check for any function or class that seems to be involved in exception representation or traceback manipulation.\n2.3 The `Node` class and particularly the comment and method around `_repr_failure_py` seem relevant as it deals with repr representation of failures.\n2.4 Look at the `repr_failure` method in the `Node` class. It's possible that this method could be where the actual invocation of the `repr` happens.\n2.5 Follow the logic in `_repr_failure_py`.\n2.6 Look at the imported files and dependencies that might import exception or saferepr related symbols to see if they offer additional insights or need alterations.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Node._repr_failure_py",
          "Node.repr_failure"
        ],
        "root_cause_symbols": [
          "Node._repr_failure_py",
          "Node.repr_failure"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:34.703818",
        "usage": "8751.87087059021 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n   - **Issue Description:** The user is experiencing an INTERNALERROR in pytest when an exception is raised in the `__repr__` method of an object that is being tested. This is likely occurring because pytest tries to call the `__repr__` method to represent the object, and if an exception is raised within `__repr__`, it is not handled gracefully, causing a failure in pytest's internal error handling.\n   - **Steps to Reproduce:**\n     - A class `SomeClass` is defined with a `__getattribute__` and `__repr__` method both set to raise exceptions.\n     - A test accesses an attribute on `SomeClass`, triggering `__getattribute__`, potentially causing pytest to try and call `__repr__` when encountering the exception.\n     - This results in an unhandled exception causing an INTERNALERROR.\n   - **How was the Issue Caused:** The core issue seems to arise from pytest's handling (or lack of handling) of exceptions raised within the `__repr__` method of an object.\n   - **User Expectation:** The expected behavior is for pytest to handle exceptions in `__repr__` gracefully without causing an INTERNALERROR.\n   - **Possible Causes/Solutions:** The traceback points to calls within `saferepr.py` when attempting to represent an argument of an exception. A robust solution might involve try-except blocks around `repr` calls to catch exceptions and provide fallbacks.\n\n2. **Make File Evaluation:**\n\n   - The file `src/_pytest/runner.py` is fundamental to the test execution workflow in pytest.\n   - **Potential Relevance:** The function `call_and_report()` in `runner.py` is central as it handles the invocation of test phases (`setup`, `call`, `teardown`).\n   - **Relevant Symbols Analyzed:**\n     - `pytest_runtest_protocol`: Orchestrates each test item through its lifecycle.\n     - `runtestprotocol`: Manages setup, call, and teardown phases of a test.\n     - `call_and_report`: Triggers phase hooks and reports outcomes, important for debugging exceptions during test execution.\n     \n   - **Root Cause Analysis:** The root cause is likely deeper in how exceptions within `repr` are surfaced or managed, needing potential investigation into how `ExceptionInfo` is gathered and processed.\n\n   - **Conclusion:** The file is relevant in managing test execution where the error could surface, but may not be the direct root cause for handling exceptions in `repr`. Additional evaluation of exception representation and saferepr handling may be necessary beyond this file.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/_code/code.py",
          "src/_pytest/test_result.py"
        ],
        "relevant_symbols": [
          "call_and_report",
          "pytest_runtest_protocol",
          "runtestprotocol"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:46:43.455727",
        "usage": "248.37684631347656 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/_io/saferepr.py",
            "relevant_symbol_keys": [
              "saferepr",
              "SafeRepr.repr",
              "_format_repr_exception"
            ],
            "root_cause_symbol_keys": [
              "saferepr",
              "SafeRepr.repr",
              "_format_repr_exception"
            ]
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "wrap_session",
              "pytest_cmdline_main",
              "_main",
              "Session"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "Function.repr_failure",
              "Function._repr_failure_py"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node._repr_failure_py",
              "Node.repr_failure"
            ],
            "root_cause_symbol_keys": [
              "Node._repr_failure_py",
              "Node.repr_failure"
            ]
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "call_and_report",
              "pytest_runtest_protocol",
              "runtestprotocol"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "arts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozen",
            "start_line": 424,
            "start_column": 15300,
            "end_line": 0,
            "end_column": 15458,
            "start_byte": 15300,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "nfcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption",
            "start_line": 129,
            "start_column": 3852,
            "end_line": 0,
            "end_column": 4098,
            "start_byte": 3852,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "est=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )\n\n\ndef wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.",
            "start_line": 141,
            "start_column": 4823,
            "end_line": 0,
            "end_column": 5267,
            "start_byte": 4823,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                 ",
            "start_line": 626,
            "start_column": 22071,
            "end_line": 4,
            "end_column": 23420,
            "start_byte": 22071,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_cmdline_main(config):\n    return wrap_session(config, _main)",
            "start_line": 238,
            "start_column": 7570,
            "end_line": 0,
            "end_column": 7641,
            "start_byte": 7570,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None",
            "start_line": 242,
            "start_column": 7644,
            "end_line": 0,
            "end_column": 8094,
            "start_byte": 7644,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "       \"--co\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path patt",
            "start_line": 85,
            "start_column": 3045,
            "end_line": 0,
            "end_column": 3578,
            "start_byte": 3045,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "utdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addopti",
            "start_line": 126,
            "start_column": 3882,
            "end_line": 0,
            "end_column": 4096,
            "start_byte": 3882,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1347,
            "start_column": 50315,
            "end_line": 0,
            "end_column": 52174,
            "start_byte": 50315,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n       ",
            "start_line": 74,
            "start_column": 2327,
            "end_line": 0,
            "end_column": 2462,
            "start_byte": 2327,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": " UsageError\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.reports import CollectReport\nfrom _pytest.runner import collect_one_nod",
            "start_line": 23,
            "start_column": 643,
            "end_line": 0,
            "end_column": 817,
            "start_byte": 643,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1071,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38833,
            "start_byte": 38535,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1078,
            "start_column": 38839,
            "end_line": 4,
            "end_column": 39287,
            "start_byte": 38839,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1090,
            "start_column": 39293,
            "end_line": 4,
            "end_column": 39778,
            "start_byte": 39293,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ite(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item, when):\n    \"\"\"\n    Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"\n    var_name = \"PYTEST_CURRENT_TEST\"\n    if when:\n        value = \"{} ({})\".format(item.nodeid, when)\n        # don't allow null bytes on environment variables (see #2644, #2957)\n        value = value.replace(\"\\x00\", \"(null)\")\n        os.environ[var_name] = value\n    else:\n        os.environ.pop(var_name)\n\n\ndef pytest_report_teststatus(report):\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n\n\n#\n# Implementation\n\n\ndef call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=repor",
            "start_line": 112,
            "start_column": 3744,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 3744,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": ", \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n",
            "start_line": 81,
            "start_column": 2904,
            "end_line": 4,
            "end_column": 3419,
            "start_byte": 2904,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "er,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem):\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self):\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem):\n        needed_col",
            "start_line": 338,
            "start_column": 11262,
            "end_line": 0,
            "end_column": 11904,
            "start_byte": 11262,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.LsofFdLeakChecker.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item",
            "start_line": 138,
            "start_column": 3722,
            "end_line": 4,
            "end_column": 4680,
            "start_byte": 3722,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_protocol(item, nextitem):\n    item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    item.ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True",
            "start_line": 86,
            "start_column": 2435,
            "end_line": 0,
            "end_column": 2707,
            "start_byte": 2435,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 186,
            "start_column": 5519,
            "end_line": 0,
            "end_column": 5961,
            "start_byte": 5519,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": " unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if call.excinfo.errisinstance(tuple(skip_exceptions)):\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    rep = CollectReport(\n        collector.nodeid, outcome, longrepr, getattr(call, \"result\", None)\n    )\n    rep.call = call  # type: ignore # see collect_one_node\n    return rep\n\n\nclass SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Nod",
            "start_line": 265,
            "start_column": 9374,
            "end_line": 0,
            "end_column": 10403,
            "start_byte": 9374,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "minal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", ",
            "start_line": 112,
            "start_column": 3570,
            "end_line": 0,
            "end_column": 3781,
            "start_byte": 3570,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(\n        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 319,
            "start_column": 10544,
            "end_line": 4,
            "end_column": 12143,
            "start_byte": 10544,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 363,
            "start_column": 12149,
            "end_line": 4,
            "end_column": 12490,
            "start_byte": 12149,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:43.704111",
        "usage": "13651.368856430054 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "arts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozen",
            "start_line": 424,
            "start_column": 15300,
            "end_line": 0,
            "end_column": 15458,
            "start_byte": 15300,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "nfcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption",
            "start_line": 129,
            "start_column": 3852,
            "end_line": 0,
            "end_column": 4098,
            "start_byte": 3852,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "est=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )\n\n\ndef wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.",
            "start_line": 141,
            "start_column": 4823,
            "end_line": 0,
            "end_column": 5267,
            "start_byte": 4823,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                 ",
            "start_line": 626,
            "start_column": 22071,
            "end_line": 4,
            "end_column": 23420,
            "start_byte": 22071,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_cmdline_main(config):\n    return wrap_session(config, _main)",
            "start_line": 238,
            "start_column": 7570,
            "end_line": 0,
            "end_column": 7641,
            "start_byte": 7570,
            "end_byte": 0
          },
          {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None",
            "start_line": 242,
            "start_column": 7644,
            "end_line": 0,
            "end_column": 8094,
            "start_byte": 7644,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "       \"--co\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path patt",
            "start_line": 85,
            "start_column": 3045,
            "end_line": 0,
            "end_column": 3578,
            "start_byte": 3045,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "utdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addopti",
            "start_line": 126,
            "start_column": 3882,
            "end_line": 0,
            "end_column": 4096,
            "start_byte": 3882,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1347,
            "start_column": 50315,
            "end_line": 0,
            "end_column": 52174,
            "start_byte": 50315,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n       ",
            "start_line": 74,
            "start_column": 2327,
            "end_line": 0,
            "end_column": 2462,
            "start_byte": 2327,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": " UsageError\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.reports import CollectReport\nfrom _pytest.runner import collect_one_nod",
            "start_line": 23,
            "start_column": 643,
            "end_line": 0,
            "end_column": 817,
            "start_byte": 643,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1071,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38833,
            "start_byte": 38535,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1078,
            "start_column": 38839,
            "end_line": 4,
            "end_column": 39287,
            "start_byte": 38839,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1090,
            "start_column": 39293,
            "end_line": 4,
            "end_column": 39778,
            "start_byte": 39293,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ite(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item, when):\n    \"\"\"\n    Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"\n    var_name = \"PYTEST_CURRENT_TEST\"\n    if when:\n        value = \"{} ({})\".format(item.nodeid, when)\n        # don't allow null bytes on environment variables (see #2644, #2957)\n        value = value.replace(\"\\x00\", \"(null)\")\n        os.environ[var_name] = value\n    else:\n        os.environ.pop(var_name)\n\n\ndef pytest_report_teststatus(report):\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n\n\n#\n# Implementation\n\n\ndef call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=repor",
            "start_line": 112,
            "start_column": 3744,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 3744,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": ", \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n",
            "start_line": 81,
            "start_column": 2904,
            "end_line": 4,
            "end_column": 3419,
            "start_byte": 2904,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "er,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem):\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self):\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem):\n        needed_col",
            "start_line": 338,
            "start_column": 11262,
            "end_line": 0,
            "end_column": 11904,
            "start_byte": 11262,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.LsofFdLeakChecker.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item",
            "start_line": 138,
            "start_column": 3722,
            "end_line": 4,
            "end_column": 4680,
            "start_byte": 3722,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_protocol(item, nextitem):\n    item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    item.ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True",
            "start_line": 86,
            "start_column": 2435,
            "end_line": 0,
            "end_column": 2707,
            "start_byte": 2435,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 186,
            "start_column": 5519,
            "end_line": 0,
            "end_column": 5961,
            "start_byte": 5519,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": " unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if call.excinfo.errisinstance(tuple(skip_exceptions)):\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    rep = CollectReport(\n        collector.nodeid, outcome, longrepr, getattr(call, \"result\", None)\n    )\n    rep.call = call  # type: ignore # see collect_one_node\n    return rep\n\n\nclass SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Nod",
            "start_line": 265,
            "start_column": 9374,
            "end_line": 0,
            "end_column": 10403,
            "start_byte": 9374,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "minal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", ",
            "start_line": 112,
            "start_column": 3570,
            "end_line": 0,
            "end_column": 3781,
            "start_byte": 3570,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(\n        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 319,
            "start_column": 10544,
            "end_line": 4,
            "end_column": 12143,
            "start_byte": 10544,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 363,
            "start_column": 12149,
            "end_line": 4,
            "end_column": 12490,
            "start_byte": 12149,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "Step 1: Analyzing the reported issue\n1.1 The issue described is an INTERNALERROR when an exception occurs in the __repr__ method of a class.\n1.2 This issue was likely caused during the test session when an attribute of SomeClass is accessed, invoking __getattribute__, which raises an exception, leading to troubles in __repr__.\n1.3 The reported stack trace points to the INTERNALERROR stemming from the raising of an exception in repr, without catching the exception properly, which ultimately leads to a RuntimeError: No active exception to reraise.\n1.4 The expected result should be proper exception handling to prevent INTERNALERRORS, specifically from exceptions raised in repr.\n1.5 To fix the issue, code around __repr__ execution should ensure exceptions are caught and re-raised with more detailed context or handled without causing an incomplete exception state.\n\nSymbols Evaluate:\n\nStart analyzing each provided symbol to identify how it relates to existing pytest functions responsible for handling representations and exceptions:\n\nStep 2:\n2.1 Analyzing each symbol related to repr and exceptions, handling, and identifying key elements/functions:\n\n2.2 Matching the `_format_repr_exception` function and others symbol with the information from the issue.\n2.3 Evaluating how each symbol connects or potentially affects the error described.\n\nConclusion:\n2.4 Determine how many need modification:\n\n- `_pytest._io._format_repr_exception`: This function provides an error string based on an exception raised during repr.\n- `_pytest._io.SafeRepr.repr`: It catches BaseException and uses `_format_repr_exception`.\n- `_pytest._io.SafeRepr.repr_instance`: Similar to `repr`, it provides a safe version of repr for instances.\n- `_pytest._io.saferepr`: Wraps SafeRepr, provides safe repr for objects.\n\nThese four functions are directly related to capturing and rendering exceptions in representations and are relevant to the bug reported, but only changes need to be likely at `_format_repr_exception` and methods in `SafeRepr`.\n2.5 Identify any missing information and whether more symbols or files are needed.\n\nHowever, it appears we have clear enough context. As of now, asking for more context in nodes or other configurations handling failing tests representation could be beneficial.\n\nUltimately, three symbols closely tied to handling printing of exceptions need changes to prevent the stack trace issue.\n\n2.6 Output all gathered information and provide complete evaluation thoughts.",
        "symbols": [
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This function contributes to the way exceptions thrown in __repr__ are handled and represented as strings. It is central to the issue because it improperly manages the context of exceptions."
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "Associated with rendering a safe repr of objects, when exceptions happen its execution path involves calling `_format_repr_exception`. Likely modification needed for better exception handling."
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "Similar to repr, repr_instance tries to safely produce a representation for instance objects, directly depending on safe exception handling."
          }
        ],
        "more_info": [
          {
            "type": "symbol",
            "path": "src/_pytest/nodes.py",
            "name": "_pytest.nodes.Node.repr_failure",
            "reason": "If this function is responsible for dealing with failures, modifications here could ensure proper handling of exceptions raised in repr without leading to internal error."
          },
          {
            "type": "symbol",
            "path": "src/_pytest/python.py",
            "name": "_pytest.python.Function.repr_failure",
            "reason": "More context on how failures being represented during testing incorporate repr exceptions could shed light on necessary changes."
          }
        ],
        "is_done": false,
        "symbols_scratch_pad": [
          "_pytest._io._format_repr_exception: This function is directly involved in formatting exceptions raised during repr execution, which is relevant due to the INTERNALERROR reported.",
          "_pytest._io.SafeRepr.repr: Involved with rendering safe representations, calls _format_repr_exception, meaning exceptions during repr are caught here. Critical to proper exception management.",
          "_pytest._io.SafeRepr.repr_instance: Similarly involved with instance representation, this needs an improved mechanism for exception handling when similar errors arise."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:46:57.355493",
        "usage": "2.3889541625976562 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.cacheprovider.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "arts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozen",
              "start_line": 424,
              "start_column": 15300,
              "end_line": 0,
              "end_column": 15458,
              "start_byte": 15300,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "nfcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption",
              "start_line": 129,
              "start_column": 3852,
              "end_line": 0,
              "end_column": 4098,
              "start_byte": 3852,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "est=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )\n\n\ndef wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.",
              "start_line": 141,
              "start_column": 4823,
              "end_line": 0,
              "end_column": 5267,
              "start_byte": 4823,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "    self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                 ",
              "start_line": 626,
              "start_column": 22071,
              "end_line": 4,
              "end_column": 23420,
              "start_byte": 22071,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.wrap_session",
              "file_path": "src/_pytest/main.py",
              "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
              "start_line": 177,
              "start_column": 5040,
              "end_line": 0,
              "end_column": 7567,
              "start_byte": 5040,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "def pytest_cmdline_main(config):\n    return wrap_session(config, _main)",
              "start_line": 238,
              "start_column": 7570,
              "end_line": 0,
              "end_column": 7641,
              "start_byte": 7570,
              "end_byte": 0
            },
            {
              "name": "_pytest.main._main",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None",
              "start_line": 242,
              "start_column": 7644,
              "end_line": 0,
              "end_column": 8094,
              "start_byte": 7644,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 367,
              "start_column": 11404,
              "end_line": 0,
              "end_column": 24571,
              "start_byte": 11404,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.Interrupted",
              "file_path": "src/_pytest/main.py",
              "file_content": "Interrupted = Interrupted",
              "start_line": 368,
              "start_column": 11442,
              "end_line": 4,
              "end_column": 11467,
              "start_byte": 11442,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.Failed",
              "file_path": "src/_pytest/main.py",
              "file_content": "Failed = Failed",
              "start_line": 369,
              "start_column": 11472,
              "end_line": 4,
              "end_column": 11487,
              "start_byte": 11472,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._setupstate",
              "file_path": "src/_pytest/main.py",
              "file_content": "_setupstate = None",
              "start_line": 371,
              "start_column": 11548,
              "end_line": 4,
              "end_column": 11566,
              "start_byte": 11548,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._fixturemanager",
              "file_path": "src/_pytest/main.py",
              "file_content": "_fixturemanager = None",
              "start_line": 373,
              "start_column": 11649,
              "end_line": 4,
              "end_column": 11671,
              "start_byte": 11649,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.exitstatus",
              "file_path": "src/_pytest/main.py",
              "file_content": "exitstatus = None",
              "start_line": 374,
              "start_column": 11700,
              "end_line": 4,
              "end_column": 11717,
              "start_byte": 11700,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
              "start_line": 376,
              "start_column": 11753,
              "end_line": 4,
              "end_column": 13031,
              "start_byte": 11753,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.from_config",
              "file_path": "src/_pytest/main.py",
              "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
              "start_line": 408,
              "start_column": 13037,
              "end_line": 4,
              "end_column": 13118,
              "start_byte": 13037,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__repr__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
              "start_line": 412,
              "start_column": 13124,
              "end_line": 4,
              "end_column": 13404,
              "start_byte": 13124,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
              "start_line": 421,
              "start_column": 13410,
              "end_line": 4,
              "end_column": 13575,
              "start_byte": 13410,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectstart",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
              "start_line": 425,
              "start_column": 13581,
              "end_line": 4,
              "end_column": 13795,
              "start_byte": 13581,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_runtest_logreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
              "start_line": 432,
              "start_column": 13801,
              "end_line": 4,
              "end_column": 14163,
              "start_byte": 13801,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "pytest_collectreport = pytest_runtest_logreport",
              "start_line": 440,
              "start_column": 14169,
              "end_line": 4,
              "end_column": 14216,
              "start_byte": 14169,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
              "start_line": 442,
              "start_column": 14222,
              "end_line": 4,
              "end_column": 14291,
              "start_byte": 14222,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/main.py",
              "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
              "start_line": 445,
              "start_column": 14297,
              "end_line": 4,
              "end_column": 14388,
              "start_byte": 14297,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 448,
              "start_column": 14394,
              "end_line": 4,
              "end_column": 14862,
              "start_byte": 14394,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
              "start_line": 461,
              "start_column": 14868,
              "end_line": 4,
              "end_column": 16102,
              "start_byte": 14868,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
              "start_line": 492,
              "start_column": 16108,
              "end_line": 4,
              "end_column": 16843,
              "start_byte": 16108,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
              "start_line": 510,
              "start_column": 16849,
              "end_line": 4,
              "end_column": 20645,
              "start_byte": 16849,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._visit_filter",
              "file_path": "src/_pytest/main.py",
              "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
              "start_line": 589,
              "start_column": 20651,
              "end_line": 4,
              "end_column": 20721,
              "start_byte": 20651,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
              "start_line": 593,
              "start_column": 20727,
              "end_line": 4,
              "end_column": 21331,
              "start_byte": 20727,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
              "start_line": 609,
              "start_column": 21337,
              "end_line": 4,
              "end_column": 22022,
              "start_byte": 21337,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
              "start_line": 625,
              "start_column": 22028,
              "end_line": 4,
              "end_column": 22412,
              "start_byte": 22028,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
              "start_line": 636,
              "start_column": 22418,
              "end_line": 4,
              "end_column": 24096,
              "start_byte": 22418,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.genitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 673,
              "start_column": 24102,
              "end_line": 4,
              "end_column": 24571,
              "start_byte": 24102,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "       \"--co\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path patt",
              "start_line": 85,
              "start_column": 3045,
              "end_line": 0,
              "end_column": 3578,
              "start_byte": 3045,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.Testdir.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 772,
              "start_column": 25095,
              "end_line": 4,
              "end_column": 25112,
              "start_byte": 25095,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "utdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addopti",
              "start_line": 126,
              "start_column": 3882,
              "end_line": 0,
              "end_column": 4096,
              "start_byte": 3882,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1347,
              "start_column": 50315,
              "end_line": 0,
              "end_column": 52174,
              "start_byte": 50315,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": "    \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n       ",
              "start_line": 74,
              "start_column": 2327,
              "end_line": 0,
              "end_column": 2462,
              "start_byte": 2327,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_cmdline_main",
              "file_path": "src/_pytest/main.py",
              "file_content": " UsageError\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.reports import CollectReport\nfrom _pytest.runner import collect_one_nod",
              "start_line": 23,
              "start_column": 643,
              "end_line": 0,
              "end_column": 817,
              "start_byte": 643,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.TerminalReporter._get_main_color",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1071,
              "start_column": 38535,
              "end_line": 4,
              "end_column": 38833,
              "start_byte": 38535,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._determine_main_color",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1078,
              "start_column": 38839,
              "end_line": 4,
              "end_column": 39287,
              "start_byte": 38839,
              "end_byte": 4
            },
            {
              "name": "_pytest.terminal.TerminalReporter._set_main_color",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 1090,
              "start_column": 39293,
              "end_line": 4,
              "end_column": 39778,
              "start_byte": 39293,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1540,
              "start_column": 56933,
              "end_line": 4,
              "end_column": 57213,
              "start_byte": 56933,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "ite(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item, when):\n    \"\"\"\n    Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"\n    var_name = \"PYTEST_CURRENT_TEST\"\n    if when:\n        value = \"{} ({})\".format(item.nodeid, when)\n        # don't allow null bytes on environment variables (see #2644, #2957)\n        value = value.replace(\"\\x00\", \"(null)\")\n        os.environ[var_name] = value\n    else:\n        os.environ.pop(var_name)\n\n\ndef pytest_report_teststatus(report):\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n\n\n#\n# Implementation\n\n\ndef call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=repor",
              "start_line": 112,
              "start_column": 3744,
              "end_line": 0,
              "end_column": 5815,
              "start_byte": 3744,
              "end_byte": 0
            },
            {
              "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": ", \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n",
              "start_line": 81,
              "start_column": 2904,
              "end_line": 4,
              "end_column": 3419,
              "start_byte": 2904,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "er,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem):\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self):\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem):\n        needed_col",
              "start_line": 338,
              "start_column": 11262,
              "end_line": 0,
              "end_column": 11904,
              "start_byte": 11262,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.LsofFdLeakChecker.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "ixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item",
              "start_line": 138,
              "start_column": 3722,
              "end_line": 4,
              "end_column": 4680,
              "start_byte": 3722,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def pytest_runtest_protocol(item, nextitem):\n    item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    item.ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True",
              "start_line": 86,
              "start_column": 2435,
              "end_line": 0,
              "end_column": 2707,
              "start_byte": 2435,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.runtestprotocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
              "start_line": 93,
              "start_column": 2710,
              "end_line": 0,
              "end_column": 3437,
              "start_byte": 2710,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 186,
              "start_column": 5519,
              "end_line": 0,
              "end_column": 5961,
              "start_byte": 5519,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": " unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if call.excinfo.errisinstance(tuple(skip_exceptions)):\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    rep = CollectReport(\n        collector.nodeid, outcome, longrepr, getattr(call, \"result\", None)\n    )\n    rep.call = call  # type: ignore # see collect_one_node\n    return rep\n\n\nclass SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Nod",
              "start_line": 265,
              "start_column": 9374,
              "end_line": 0,
              "end_column": 10403,
              "start_byte": 9374,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_runtest_protocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "minal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", ",
              "start_line": 112,
              "start_column": 3570,
              "end_line": 0,
              "end_column": 3781,
              "start_byte": 3570,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
              "start_line": 14,
              "start_column": 259,
              "end_line": 0,
              "end_column": 665,
              "start_byte": 259,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 44,
              "start_column": 1193,
              "end_line": 4,
              "end_column": 1461,
              "start_byte": 1193,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 53,
              "start_column": 1467,
              "end_line": 4,
              "end_column": 1748,
              "start_byte": 1467,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
              "start_line": 74,
              "start_column": 2077,
              "end_line": 0,
              "end_column": 2512,
              "start_byte": 2077,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "",
              "start_line": 375,
              "start_column": 13624,
              "end_line": 0,
              "end_column": 14124,
              "start_byte": 13624,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Node._repr_failure_py",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def _repr_failure_py(\n        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
              "start_line": 319,
              "start_column": 10544,
              "end_line": 4,
              "end_column": 12143,
              "start_byte": 10544,
              "end_byte": 4
            },
            {
              "name": "_pytest.nodes.Node.repr_failure",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
              "start_line": 363,
              "start_column": 12149,
              "end_line": 4,
              "end_column": 12490,
              "start_byte": 12149,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "Step 1: Analyzing the reported issue\n1.1 The issue described is an INTERNALERROR when an exception occurs in the __repr__ method of a class.\n1.2 This issue was likely caused during the test session when an attribute of SomeClass is accessed, invoking __getattribute__, which raises an exception, leading to troubles in __repr__.\n1.3 The reported stack trace points to the INTERNALERROR stemming from the raising of an exception in repr, without catching the exception properly, which ultimately leads to a RuntimeError: No active exception to reraise.\n1.4 The expected result should be proper exception handling to prevent INTERNALERRORS, specifically from exceptions raised in repr.\n1.5 To fix the issue, code around __repr__ execution should ensure exceptions are caught and re-raised with more detailed context or handled without causing an incomplete exception state.\n\nSymbols Evaluate:\n\nStart analyzing each provided symbol to identify how it relates to existing pytest functions responsible for handling representations and exceptions:\n\nStep 2:\n2.1 Analyzing each symbol related to repr and exceptions, handling, and identifying key elements/functions:\n\n2.2 Matching the `_format_repr_exception` function and others symbol with the information from the issue.\n2.3 Evaluating how each symbol connects or potentially affects the error described.\n\nConclusion:\n2.4 Determine how many need modification:\n\n- `_pytest._io._format_repr_exception`: This function provides an error string based on an exception raised during repr.\n- `_pytest._io.SafeRepr.repr`: It catches BaseException and uses `_format_repr_exception`.\n- `_pytest._io.SafeRepr.repr_instance`: Similar to `repr`, it provides a safe version of repr for instances.\n- `_pytest._io.saferepr`: Wraps SafeRepr, provides safe repr for objects.\n\nThese four functions are directly related to capturing and rendering exceptions in representations and are relevant to the bug reported, but only changes need to be likely at `_format_repr_exception` and methods in `SafeRepr`.\n2.5 Identify any missing information and whether more symbols or files are needed.\n\nHowever, it appears we have clear enough context. As of now, asking for more context in nodes or other configurations handling failing tests representation could be beneficial.\n\nUltimately, three symbols closely tied to handling printing of exceptions need changes to prevent the stack trace issue.\n\n2.6 Output all gathered information and provide complete evaluation thoughts.",
          "symbols": [
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This function contributes to the way exceptions thrown in __repr__ are handled and represented as strings. It is central to the issue because it improperly manages the context of exceptions."
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "Associated with rendering a safe repr of objects, when exceptions happen its execution path involves calling `_format_repr_exception`. Likely modification needed for better exception handling."
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "Similar to repr, repr_instance tries to safely produce a representation for instance objects, directly depending on safe exception handling."
            }
          ],
          "more_info": [
            {
              "type": "symbol",
              "path": "src/_pytest/nodes.py",
              "name": "_pytest.nodes.Node.repr_failure",
              "reason": "If this function is responsible for dealing with failures, modifications here could ensure proper handling of exceptions raised in repr without leading to internal error."
            },
            {
              "type": "symbol",
              "path": "src/_pytest/python.py",
              "name": "_pytest.python.Function.repr_failure",
              "reason": "More context on how failures being represented during testing incorporate repr exceptions could shed light on necessary changes."
            }
          ],
          "is_done": false,
          "symbols_scratch_pad": [
            "_pytest._io._format_repr_exception: This function is directly involved in formatting exceptions raised during repr execution, which is relevant due to the INTERNALERROR reported.",
            "_pytest._io.SafeRepr.repr: Involved with rendering safe representations, calls _format_repr_exception, meaning exceptions during repr are caught here. Critical to proper exception management.",
            "_pytest._io.SafeRepr.repr_instance: Similarly involved with instance representation, this needs an improved mechanism for exception handling when similar errors arise."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_io/saferepr.py"
        ],
        "symbols": [
          "_pytest._io._format_repr_exception",
          "_pytest._io.SafeRepr.repr",
          "_pytest._io.SafeRepr.repr_instance"
        ],
        "code_spans": {
          "_pytest.cacheprovider.pytest_cmdline_main": {
            "name": "_pytest.cacheprovider.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "arts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozen",
            "start_line": 424,
            "start_column": 15300,
            "end_line": 0,
            "end_column": 15458,
            "start_byte": 15300,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_cmdline_main": {
            "name": "_pytest.helpconfig.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "nfcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption",
            "start_line": 129,
            "start_column": 3852,
            "end_line": 0,
            "end_column": 4098,
            "start_byte": 3852,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_cmdline_main": {
            "name": "_pytest.hookspec.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "est=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )\n\n\ndef wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.",
            "start_line": 141,
            "start_column": 4823,
            "end_line": 0,
            "end_column": 5267,
            "start_byte": 4823,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin._runtest_for_main": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                 ",
            "start_line": 626,
            "start_column": 22071,
            "end_line": 4,
            "end_column": 23420,
            "start_byte": 22071,
            "end_byte": 4
          },
          "_pytest.main.wrap_session": {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          "_pytest.main.pytest_cmdline_main": {
            "name": "_pytest.main.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def pytest_cmdline_main(config):\n    return wrap_session(config, _main)",
            "start_line": 238,
            "start_column": 7570,
            "end_line": 0,
            "end_column": 7641,
            "start_byte": 7570,
            "end_byte": 0
          },
          "_pytest.main._main": {
            "name": "_pytest.main._main",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _main(config: Config, session: \"Session\") -> Optional[Union[int, ExitCode]]:\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n    return None",
            "start_line": 242,
            "start_column": 7644,
            "end_line": 0,
            "end_column": 8094,
            "start_byte": 7644,
            "end_byte": 0
          },
          "_pytest.main.Session": {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          "_pytest.main.Session.Interrupted": {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          "_pytest.main.Session.Failed": {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          "_pytest.main.Session._setupstate": {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          "_pytest.main.Session._fixturemanager": {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          "_pytest.main.Session.exitstatus": {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          "_pytest.main.Session.__init__": {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          "_pytest.main.Session.from_config": {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          "_pytest.main.Session.__repr__": {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          "_pytest.main.Session._node_location_to_relpath": {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectstart": {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_runtest_logreport": {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectreport": {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          "_pytest.main.Session.gethookproxy": {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          "_pytest.main.Session._visit_filter": {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          "_pytest.main.Session._tryconvertpyarg": {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          "_pytest.main.Session._parsearg": {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          "_pytest.main.Session.matchnodes": {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          "_pytest.main.Session._matchnodes": {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          "_pytest.main.Session.genitems": {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          "_pytest.mark.pytest_cmdline_main": {
            "name": "_pytest.mark.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "       \"--co\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    )\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path patt",
            "start_line": 85,
            "start_column": 3045,
            "end_line": 0,
            "end_column": 3578,
            "start_byte": 3045,
            "end_byte": 0
          },
          "_pytest.pytester.Testdir.Session": {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          "_pytest.python.pytest_cmdline_main": {
            "name": "_pytest.python.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "utdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addopti",
            "start_line": 126,
            "start_column": 3882,
            "end_line": 0,
            "end_column": 4096,
            "start_byte": 3882,
            "end_byte": 0
          },
          "_pytest.python._showfixtures_main": {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1347,
            "start_column": 50315,
            "end_line": 0,
            "end_column": 52174,
            "start_byte": 50315,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_cmdline_main": {
            "name": "_pytest.setuponly.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": "    \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n       ",
            "start_line": 74,
            "start_column": 2327,
            "end_line": 0,
            "end_column": 2462,
            "start_byte": 2327,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_cmdline_main": {
            "name": "_pytest.setupplan.pytest_cmdline_main",
            "file_path": "src/_pytest/main.py",
            "file_content": " UsageError\nfrom _pytest.fixtures import FixtureManager\nfrom _pytest.outcomes import exit\nfrom _pytest.reports import CollectReport\nfrom _pytest.runner import collect_one_nod",
            "start_line": 23,
            "start_column": 643,
            "end_line": 0,
            "end_column": 817,
            "start_byte": 643,
            "end_byte": 0
          },
          "_pytest.terminal.TerminalReporter._get_main_color": {
            "name": "_pytest.terminal.TerminalReporter._get_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1071,
            "start_column": 38535,
            "end_line": 4,
            "end_column": 38833,
            "start_byte": 38535,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._determine_main_color": {
            "name": "_pytest.terminal.TerminalReporter._determine_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1078,
            "start_column": 38839,
            "end_line": 4,
            "end_column": 39287,
            "start_byte": 38839,
            "end_byte": 4
          },
          "_pytest.terminal.TerminalReporter._set_main_color": {
            "name": "_pytest.terminal.TerminalReporter._set_main_color",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 1090,
            "start_column": 39293,
            "end_line": 4,
            "end_column": 39778,
            "start_byte": 39293,
            "end_byte": 4
          },
          "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(self, excinfo, outerr=None):\n        assert outerr is None, \"XXX outerr usage is deprecated\"\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1540,
            "start_column": 56933,
            "end_line": 4,
            "end_column": 57213,
            "start_byte": 56933,
            "end_byte": 4
          },
          "_pytest.assertion.pytest_runtest_protocol": {
            "name": "_pytest.assertion.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ite(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item, when):\n    \"\"\"\n    Update :envvar:`PYTEST_CURRENT_TEST` to reflect the current item and stage.\n\n    If ``when`` is None, delete ``PYTEST_CURRENT_TEST`` from the environment.\n    \"\"\"\n    var_name = \"PYTEST_CURRENT_TEST\"\n    if when:\n        value = \"{} ({})\".format(item.nodeid, when)\n        # don't allow null bytes on environment variables (see #2644, #2957)\n        value = value.replace(\"\\x00\", \"(null)\")\n        os.environ[var_name] = value\n    else:\n        os.environ.pop(var_name)\n\n\ndef pytest_report_teststatus(report):\n    if report.when in (\"setup\", \"teardown\"):\n        if report.failed:\n            #      category, shortletter, verbose-word\n            return \"error\", \"E\", \"ERROR\"\n        elif report.skipped:\n            return \"skipped\", \"s\", \"SKIPPED\"\n        else:\n            return \"\", \"\", \"\"\n\n\n#\n# Implementation\n\n\ndef call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=repor",
            "start_line": 112,
            "start_column": 3744,
            "end_line": 0,
            "end_column": 5815,
            "start_byte": 3744,
            "end_byte": 0
          },
          "_pytest.faulthandler.FaultHandlerHooks.pytest_runtest_protocol": {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": ", \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n",
            "start_line": 81,
            "start_column": 2904,
            "end_line": 4,
            "end_column": 3419,
            "start_byte": 2904,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_protocol": {
            "name": "_pytest.hookspec.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "er,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem):\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self):\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem):\n        needed_col",
            "start_line": 338,
            "start_column": 11262,
            "end_line": 0,
            "end_column": 11904,
            "start_byte": 11262,
            "end_byte": 0
          },
          "_pytest.pytester.LsofFdLeakChecker.pytest_runtest_protocol": {
            "name": "_pytest.pytester.LsofFdLeakChecker.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "ixtures:\n        tw.write(\" (fixtures used: {})\".format(\", \".join(used_fixtures)))\n\n\ndef pytest_runtest_setup(item):\n    _update_current_test_var(item, \"setup\")\n    item.session._setupstate.prepare(item)\n\n\ndef pytest_runtest_call(item):\n    _update_current_test_var(item, \"call\")\n    try:\n        del sys.last_type\n        del sys.last_value\n        del sys.last_traceback\n    except AttributeError:\n        pass\n    try:\n        item.runtest()\n    except Exception as e:\n        # Store trace info to allow postmortem debugging\n        sys.last_type = type(e)\n        sys.last_value = e\n        assert e.__traceback__ is not None\n        # Skip *this* frame\n        sys.last_traceback = e.__traceback__.tb_next\n        raise e\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    _update_current_test_var(item, \"teardown\")\n    item.session._setupstate.teardown_exact(item, nextitem)\n    _update_current_test_var(item, None)\n\n\ndef _update_current_test_var(item",
            "start_line": 138,
            "start_column": 3722,
            "end_line": 4,
            "end_column": 4680,
            "start_byte": 3722,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_protocol": {
            "name": "_pytest.runner.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def pytest_runtest_protocol(item, nextitem):\n    item.ihook.pytest_runtest_logstart(nodeid=item.nodeid, location=item.location)\n    runtestprotocol(item, nextitem=nextitem)\n    item.ihook.pytest_runtest_logfinish(nodeid=item.nodeid, location=item.location)\n    return True",
            "start_line": 86,
            "start_column": 2435,
            "end_line": 0,
            "end_column": 2707,
            "start_byte": 2435,
            "end_byte": 0
          },
          "_pytest.runner.runtestprotocol": {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(item, log=True, nextitem=None):\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:\n        item._initrequest()\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False\n        item.funcargs = None\n    return reports",
            "start_line": 93,
            "start_column": 2710,
            "end_line": 0,
            "end_column": 3437,
            "start_byte": 2710,
            "end_byte": 0
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item, when: \"Literal['setup', 'call', 'teardown']\", log=True, **kwds\n):\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 186,
            "start_column": 5519,
            "end_line": 0,
            "end_column": 5961,
            "start_byte": 5519,
            "end_byte": 0
          },
          "_pytest.unittest.pytest_runtest_protocol": {
            "name": "_pytest.unittest.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": " unittest is loaded dynamically.\n            skip_exceptions.append(unittest.SkipTest)  # type: ignore\n        if call.excinfo.errisinstance(tuple(skip_exceptions)):\n            outcome = \"skipped\"\n            r_ = collector._repr_failure_py(call.excinfo, \"line\")\n            assert isinstance(r_, ExceptionChainRepr), repr(r_)\n            r = r_.reprcrash\n            assert r\n            longrepr = (str(r.path), r.lineno, r.message)\n        else:\n            outcome = \"failed\"\n            errorinfo = collector.repr_failure(call.excinfo)\n            if not hasattr(errorinfo, \"toterminal\"):\n                errorinfo = CollectErrorRepr(errorinfo)\n            longrepr = errorinfo\n    rep = CollectReport(\n        collector.nodeid, outcome, longrepr, getattr(call, \"result\", None)\n    )\n    rep.call = call  # type: ignore # see collect_one_node\n    return rep\n\n\nclass SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Nod",
            "start_line": 265,
            "start_column": 9374,
            "end_line": 0,
            "end_column": 10403,
            "start_byte": 9374,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_runtest_protocol": {
            "name": "_pytest.warnings.pytest_runtest_protocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "minal_writer()\n    tw.line()\n    tw.write(\" \" * 8)\n    tw.write(item.nodeid)\n    used_fixtures = sorted(getattr(item, \"fixturenames\", []))\n    if used_fixtures:\n        tw.write(\" (fixtures used: {})\".format(\", ",
            "start_line": 112,
            "start_column": 3570,
            "end_line": 0,
            "end_column": 3781,
            "start_byte": 3570,
            "end_byte": 0
          },
          "_pytest._io._format_repr_exception": {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          "_pytest._io.SafeRepr.repr": {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr_instance": {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          "_pytest._io.saferepr": {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          "_pytest.assertion._saferepr": {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          "_pytest.nodes.Node._repr_failure_py": {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(\n        self, excinfo: ExceptionInfo[Union[Failed, FixtureLookupError]], style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                return str(excinfo.value)\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        try:\n            os.getcwd()\n            abspath = False\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 319,
            "start_column": 10544,
            "end_line": 4,
            "end_column": 12143,
            "start_byte": 10544,
            "end_byte": 4
          },
          "_pytest.nodes.Node.repr_failure": {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(\n        self, excinfo, style=None\n    ) -> Union[str, ReprExceptionInfo, ExceptionChainRepr, FixtureLookupErrorRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 363,
            "start_column": 12149,
            "end_line": 4,
            "end_column": 12490,
            "start_byte": 12149,
            "end_byte": 4
          }
        }
      }
    }
  ]
}