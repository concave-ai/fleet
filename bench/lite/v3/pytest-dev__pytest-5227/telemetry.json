{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5227",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:23.170737",
        "usage": "1522.836446762085 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "putaround",
          "setenv",
          "CollectError",
          "maketxtfile",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "ecu",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "dummy_context_manager",
          "NodeMarkers",
          "Entry",
          "popcall",
          "pytest_collect_directory",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "_is_unittest_unexpected_success_a_failure",
          "write",
          "StepwisePlugin",
          "visit_BoolOp",
          "check_strict_xfail",
          "_format_final_exc_line",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "ReprExceptionInfo",
          "__call__",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "FIXTURE_FUNCTION_CALL",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "_fix_spoof_python2",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "FunctionMixin",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "pytest_itemstart",
          "prog",
          "_PytestWrapper",
          "PYTEST_ENSURETEMP",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "winpymap",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "fslocation",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "_PY3",
          "type",
          "_inject_setup_teardown_fixtures",
          "FormattedExcinfo",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "EXIT_USAGEERROR",
          "_log_cli_enabled",
          "register",
          "_patched_find_module",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "_from_json",
          "getplugin",
          "failed",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_PY2",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "makeini",
          "freeze_support",
          "own_markers",
          "monkeypatch",
          "__bool__",
          "find_module",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "GETFUNCARGVALUE",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "addini",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "fail_fixturefunc",
          "PYTEST_LOGWARNING",
          "pytest_ignore_collect",
          "unary_map",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "_try_load_conftest",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "EXIT_NOTESTSCOLLECTED",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "EXIT_INTERRUPTED",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_ConfigDeprecated",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "importorskip",
          "source",
          "CACHEDIR_TAG_CONTENT",
          "_repr_style",
          "N",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_compare_eq_cls",
          "safe_text_dupfile",
          "done",
          "CallInfo",
          "WarningsChecker",
          "_write_pyc",
          "fixture",
          "MonkeyPatch",
          "PY36",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_callhelper",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "ensuretemp",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "_pdb_cls",
          "hasopt",
          "verbosity",
          "_check_scope",
          "ParameterSet",
          "raises",
          "Junit",
          "format",
          "_imp_find_module",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "pytest_logwarning",
          "caplog",
          "_cmp_raises_type_error",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytestPDB",
          "record_testreport",
          "_outrep_summary",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "CollectErrorRepr",
          "pytest_configure",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "RemovedInPytest4Warning",
          "PYTEST_CONFIG_GLOBAL",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "_do_configure",
          "get_fslocation_from_item",
          "_attempt_to_close_capture_file",
          "DummyRewriteHook",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "import_plugin",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "append_pass",
          "writelines",
          "record_xml_attribute",
          "EXIT_OK",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "_register_with_pkg_resources",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "setall",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "EXIT_TESTSFAILED",
          "RaisesContext",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "NoneType",
          "_fix_unittest_skip_decorator",
          "warn_about_none_ast",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "binop_map",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "errors",
          "_assertion_supported",
          "_force_symlink",
          "__unicode__",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_call_and_format_exception",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "exc_clear",
          "rewrite",
          "toterminal",
          "nodes",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "getargs",
          "getfuncargvalue",
          "BOM_UTF8",
          "addSkip",
          "update",
          "assert_contains",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "is_package",
          "parametrize",
          "__str__",
          "_traceback",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "_ensure_only_one_capture_fixture",
          "parse_args",
          "_find_last_non_hidden_frame",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "_get_xunit_setup_teardown",
          "ishidden",
          "defaultfuncargprefixmarker",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "_printcollecteditems",
          "str",
          "getdecoded",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "_handle_skip",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "setns",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "EXIT_INTERNALERROR",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "alias",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "format_exception_only",
          "LineComp",
          "_striptext",
          "PyobjContext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "WARNS_EXEC",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "parse_known_args",
          "pytest_generate_tests",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "add_stats",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "FIXTURE_NAMED_REQUEST",
          "_non_numeric_type_error",
          "iter_markers_with_node",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_getcapture",
          "_rget_with_confmod",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_get_non_fixture_func",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "clear",
          "parsefactories",
          "get_skip_exceptions",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "bin_xml_escape",
          "visit_Call_35",
          "context",
          "short_test_summary",
          "__next__",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_ensure_basetemp",
          "capture_fixtures",
          "addError",
          "call_optional",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "_makepath",
          "_format_action_invocation",
          "FuncargnamesCompatAttr",
          "_getvaluepath",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_get_global_properties_node",
          "getpathnode",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "Exit",
          "_import_pdbcls",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PY35",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "_teardown_yield_fixture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "patchsysdict",
          "_processopt",
          "raise_on_kwargs",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "emit",
          "RAISES_MESSAGE_PARAMETER",
          "_log",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "outcomes",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_setup_collect_fakemodule",
          "wasvalid",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "module",
          "_warn_if_env_name_is_not_str",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_test_pytest_function",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "__nonzero__",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "repr_unicode",
          "append_collect_skipped",
          "_collectfile",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "rmtree",
          "PseudoFixtureDef",
          "_reprcompare",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "_readline_workaround",
          "_teardown_towards",
          "_runtest_for_main",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "yield_fixture",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "YIELD_TESTS",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "PyobjMixin",
          "RN",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "last_failed_paths",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "find",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "_some_str",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "RAISES_EXEC",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "call_and_report",
          "visit_Starred",
          "isfunction",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "markname",
          "getlocals",
          "_given_basetemp",
          "popen",
          "load_module",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "nextitem",
          "approx",
          "_addoption_instance",
          "LineMatcher_fixture",
          "_excinfo",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "__setattr__",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "cookie_re",
          "ASCII_IS_DEFAULT_ENCODING",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "repr_excinfo",
          "syspath_prepend",
          "set_trace",
          "__iter__",
          "get_actual_log_level",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "istrue",
          "isclass",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "visit_Call_legacy",
          "set_repr_style",
          "_addoption",
          "__getattr__",
          "ReprFuncArgs",
          "MarkMapping",
          "append_skipped",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "nose",
          "addhooks",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "DEFAULT_LOG_FORMAT",
          "log_outcome",
          "LoggingPlugin",
          "formatter",
          "LogCaptureHandler",
          "logging",
          "debugging",
          "LogCaptureFixture"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:24.693588",
        "usage": "204.46300506591797 ms"
      },
      "request": {
        "tokens": [
          "DEFAULT_LOG_FORMAT",
          "log_outcome",
          "LoggingPlugin",
          "formatter",
          "LogCaptureHandler",
          "logging",
          "debugging",
          "LogCaptureFixture"
        ]
      },
      "response": {
        "results": {
          "logging": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/compat.py"
          ],
          "debugging": [
            "src/_pytest/_argcomplete.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/pytest.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/debugging.py",
            "src/_pytest/unittest.py"
          ],
          "DEFAULT_LOG_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "formatter": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureHandler": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "log_outcome": [
            "src/_pytest/resultlog.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:24.898060",
        "usage": "8346.681833267212 ms"
      },
      "request": {
        "keyword_search_results": {
          "logging": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/compat.py"
          ],
          "debugging": [
            "src/_pytest/_argcomplete.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/pytest.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/debugging.py",
            "src/_pytest/unittest.py"
          ],
          "DEFAULT_LOG_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "formatter": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureHandler": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "log_outcome": [
            "src/_pytest/resultlog.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue**:\n   - The issue describes a need to enhance the logging format by including the module name `name` and possibly the relative path in log messages .\n   - The existing logging format focuses on filename, line number, and log level. \n\n2. **Evaluating Keyword Matches**:\n   - The keywords that seem directly relevant to logging include `logging`, `DEFAULT_LOG_FORMAT`, `formatter`, and various logging-related classes like `LogCaptureHandler`, `LogCaptureFixture`, and `LoggingPlugin`.\n   - Specifically, `DEFAULT_LOG_FORMAT` directly matches the setting mentioned in the issue, so any file associated with it is likely crucial.\n\n3. **Relevant Files**:\n   - `src/_pytest/logging.py` appears in matches for `logging`, `DEFAULT_LOG_FORMAT`, `formatter`, `LogCaptureHandler`, `LogCaptureFixture`, and `LoggingPlugin`. This suggests it contains significant logic around logging, including potentially the log format.\n   - Other files under `logging` keyword such as `src/_pytest/config/__init__.py` does not directly match `DEFAULT_LOG_FORMAT` or other keyword variations, making it less relevant compared to `src/_pytest/logging.py`.\n\n4. **Conclusion**: Based on the issue and keyword results, `src/_pytest/logging.py` is likely the most relevant file as it directly matches all relevant keywords including `DEFAULT_LOG_FORMAT`, which is central to the issue.",
        "file_paths": [
          "src/_pytest/logging.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:33.244756",
        "usage": "7345.741033554077 ms"
      },
      "request": {
        "file_path": "src/_pytest/logging.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n   1.1 The user is asking to improve the default logging format. Specifically, they want the current format that displays the filename, line number, level name, and message to include the module name, and also consider adding a relative path at the end.\n   1.2 The user has not provided explicit steps to reproduce an error but suggests the current output format provided by DEFAULT_LOG_FORMAT is not ideal as it lacks module names.\n   1.3 This issue is not about a malfunction but about enhancing functionality to include more detailed logging information.\n   1.4 The expectation is to change the DEFAULT_LOG_FORMAT to include the module name, which will give users additional context when reading logs, improving debugging and tracing capabilities.\n   1.6 A potential solution is to change DEFAULT_LOG_FORMAT from \"%\\(filename\\)-25s %\\(lineno\\)4d %\\(levelname\\)-8s %\\(message\\)s\" to something like \"%\\(levelname\\)-8s %\\(name\\)s:%\\(filename\\)s:%\\(lineno\\)d %\\(message\\)s\".\n\n2. Make file evaluation:\n   2.1 In the file, DEFAULT_LOG_FORMAT is defined at the top, which matches the user's report.\n   2.2 The function pytest_addoption() mentions log_format and sets its default to DEFAULT_LOG_FORMAT.\n   2.3 The class LoggingPlugin uses this format when registering log handlers. Particularly the formatter in LoggingPlugin is initialized with this log format.\n   2.4. There is a method set_log_path() which changes log file path and might indirectly relate to log format if file logs are being considered.\n   2.5. The code suggests multiple points where DEFAULT_LOG_FORMAT is crucial, notably in formatter-related operations. Changing the DEFAULT_LOG_FORMAT would alter the log appearance as per user request.\n   2.6 The file seems to be a key part of the logging customization, although it might not be entirely responsible for what appears in some user's scenario.\n\n3. Output Your Decision:\n   The file is relevant because it directly uses and appends DEFAULT_LOG_FORMAT in its logging setup. Any change made to DEFAULT_LOG_FORMAT here would affect the logging format used.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [],
        "relevant_symbols": [
          "DEFAULT_LOG_FORMAT",
          "pytest_addoption",
          "LoggingPlugin"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:45:40.590526",
        "usage": "66.81013107299805 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/logging.py",
            "relevant_symbol_keys": [
              "DEFAULT_LOG_FORMAT",
              "pytest_addoption",
              "LoggingPlugin"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:40.657342",
        "usage": "5268.171072006226 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "1. The task is to improve the default logging format in the file and introduce the module name to the log format.\n2. The OLD format is `DEFAULT_LOG_FORMAT = \"%filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"` and the NEW format should be `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"`.\n3. From the symbols received, the most relevant symbol to consider for modification is `_pytest.logging.DEFAULT_LOG_FORMAT` which currently defines the logging format.\n4. Other symbols like `_pytest.logging.LoggingPlugin` and its methods handle various aspects of logging, but the core issue is with the `DEFAULT_LOG_FORMAT`. There is no need to change any logic elsewhere since the rest of the structure uses this default format which can be overridden in individual cases if needed.\n5. Upon reviewing, changes need only to be done in one symbol which is `_pytest.logging.DEFAULT_LOG_FORMAT`.",
        "symbols": [
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "reason": "This is the symbol where the default logging format is defined. The change in log format should be applied directly to this symbol."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          ""
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:45:45.925532",
        "usage": "2.192258834838867 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
              "start_line": 16,
              "start_column": 323,
              "end_line": 0,
              "end_column": 911,
              "start_byte": 323,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
              "start_line": 302,
              "start_column": 11191,
              "end_line": 0,
              "end_column": 12956,
              "start_byte": 11191,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
              "start_line": 25,
              "start_column": 455,
              "end_line": 0,
              "end_column": 934,
              "start_byte": 455,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
              "start_line": 26,
              "start_column": 683,
              "end_line": 0,
              "end_column": 1381,
              "start_byte": 683,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
              "start_line": 37,
              "start_column": 1019,
              "end_line": 0,
              "end_column": 2437,
              "start_byte": 1019,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
              "start_line": 42,
              "start_column": 1294,
              "end_line": 0,
              "end_column": 2608,
              "start_byte": 1294,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
              "start_line": 37,
              "start_column": 1119,
              "end_line": 0,
              "end_column": 2377,
              "start_byte": 1119,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
              "start_line": 347,
              "start_column": 11276,
              "end_line": 0,
              "end_column": 12485,
              "start_byte": 11276,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
              "file_path": "src/_pytest/logging.py",
              "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
              "start_line": 17,
              "start_column": 385,
              "end_line": 0,
              "end_column": 463,
              "start_byte": 385,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
              "start_line": 82,
              "start_column": 2586,
              "end_line": 0,
              "end_column": 5014,
              "start_byte": 2586,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin",
              "file_path": "src/_pytest/logging.py",
              "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
              "start_line": 378,
              "start_column": 12060,
              "end_line": 0,
              "end_column": 20813,
              "start_byte": 12060,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.__init__",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
              "start_line": 382,
              "start_column": 12181,
              "end_line": 4,
              "end_column": 14040,
              "start_byte": 12181,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
              "start_line": 429,
              "start_column": 14046,
              "end_line": 4,
              "end_column": 15496,
              "start_byte": 14046,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.set_log_path",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
              "start_line": 462,
              "start_column": 15502,
              "end_line": 4,
              "end_column": 16175,
              "start_byte": 15502,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
              "start_line": 483,
              "start_column": 16181,
              "end_line": 4,
              "end_column": 16493,
              "start_byte": 16181,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_collection",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 491,
              "start_column": 16499,
              "end_line": 4,
              "end_column": 16920,
              "start_byte": 16499,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 503,
              "start_column": 16926,
              "end_line": 4,
              "end_column": 17232,
              "start_byte": 16926,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
              "start_line": 512,
              "start_column": 17238,
              "end_line": 4,
              "end_column": 18305,
              "start_byte": 17238,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
              "start_line": 541,
              "start_column": 18311,
              "end_line": 4,
              "end_column": 18452,
              "start_byte": 18311,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
              "start_line": 546,
              "start_column": 18458,
              "end_line": 4,
              "end_column": 18597,
              "start_byte": 18458,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
              "start_line": 551,
              "start_column": 18603,
              "end_line": 4,
              "end_column": 18750,
              "start_byte": 18603,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
              "start_line": 556,
              "start_column": 18756,
              "end_line": 4,
              "end_column": 18968,
              "start_byte": 18756,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
              "start_line": 563,
              "start_column": 18974,
              "end_line": 4,
              "end_column": 19114,
              "start_byte": 18974,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
              "start_line": 568,
              "start_column": 19120,
              "end_line": 4,
              "end_column": 19263,
              "start_byte": 19120,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
              "start_line": 573,
              "start_column": 19269,
              "end_line": 4,
              "end_column": 19972,
              "start_byte": 19269,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 591,
              "start_column": 19978,
              "end_line": 4,
              "end_column": 20402,
              "start_byte": 19978,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
              "start_line": 602,
              "start_column": 20408,
              "end_line": 4,
              "end_column": 20813,
              "start_byte": 20408,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
              "start_line": 35,
              "start_column": 775,
              "end_line": 0,
              "end_column": 5042,
              "start_byte": 775,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
              "start_line": 39,
              "start_column": 1365,
              "end_line": 0,
              "end_column": 2919,
              "start_byte": 1365,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
              "start_line": 13,
              "start_column": 240,
              "end_line": 0,
              "end_column": 568,
              "start_byte": 240,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
              "start_line": 39,
              "start_column": 994,
              "end_line": 0,
              "end_column": 1605,
              "start_byte": 994,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
              "start_line": 63,
              "start_column": 1905,
              "end_line": 0,
              "end_column": 3675,
              "start_byte": 1905,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
              "start_line": 25,
              "start_column": 538,
              "end_line": 0,
              "end_column": 850,
              "start_byte": 538,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
              "start_line": 9,
              "start_column": 138,
              "end_line": 0,
              "end_column": 537,
              "start_byte": 138,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
              "start_line": 7,
              "start_column": 126,
              "end_line": 0,
              "end_column": 403,
              "start_byte": 126,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
              "start_line": 12,
              "start_column": 353,
              "end_line": 0,
              "end_column": 833,
              "start_byte": 353,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 479,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
              "start_line": 57,
              "start_column": 1520,
              "end_line": 0,
              "end_column": 4162,
              "start_byte": 1520,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
              "start_line": 38,
              "start_column": 1068,
              "end_line": 0,
              "end_column": 1530,
              "start_byte": 1068,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
              "start_line": 12,
              "start_column": 217,
              "end_line": 0,
              "end_column": 533,
              "start_byte": 217,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The task is to improve the default logging format in the file and introduce the module name to the log format.\n2. The OLD format is `DEFAULT_LOG_FORMAT = \"%filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"` and the NEW format should be `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"`.\n3. From the symbols received, the most relevant symbol to consider for modification is `_pytest.logging.DEFAULT_LOG_FORMAT` which currently defines the logging format.\n4. Other symbols like `_pytest.logging.LoggingPlugin` and its methods handle various aspects of logging, but the core issue is with the `DEFAULT_LOG_FORMAT`. There is no need to change any logic elsewhere since the rest of the structure uses this default format which can be overridden in individual cases if needed.\n5. Upon reviewing, changes need only to be done in one symbol which is `_pytest.logging.DEFAULT_LOG_FORMAT`.",
          "symbols": [
            {
              "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
              "file_path": "src/_pytest/logging.py",
              "reason": "This is the symbol where the default logging format is defined. The change in log format should be applied directly to this symbol."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            ""
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/logging.py"
        ],
        "symbols": [
          "_pytest.logging.DEFAULT_LOG_FORMAT"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          "_pytest.logging.DEFAULT_LOG_FORMAT": {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin": {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.__init__": {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._setup_cli_logging": {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.set_log_path": {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._log_cli_enabled": {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_collection": {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._runtest_for": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._runtest_for_main": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_setup": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_call": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_teardown": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logstart": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logreport": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_sessionfinish": {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_sessionstart": {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtestloop": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          }
        }
      }
    }
  ]
}