{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5221",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:45:23.054711",
        "usage": "1314.1529560089111 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "putaround",
          "setenv",
          "CollectError",
          "maketxtfile",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "ecu",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "dummy_context_manager",
          "NodeMarkers",
          "Entry",
          "popcall",
          "pytest_collect_directory",
          "_compare_eq_verbose",
          "keywords",
          "_get_marks",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "_is_unittest_unexpected_success_a_failure",
          "write",
          "StepwisePlugin",
          "visit_BoolOp",
          "check_strict_xfail",
          "_format_final_exc_line",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "ReprExceptionInfo",
          "__call__",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "hasplugin",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "FIXTURE_FUNCTION_CALL",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "_fix_spoof_python2",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "FunctionMixin",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "pytest_itemstart",
          "prog",
          "_PytestWrapper",
          "PYTEST_ENSURETEMP",
          "repr_locals",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "winpymap",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "fslocation",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "showfixtures",
          "classnamefilter",
          "Skipped",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "_PY3",
          "type",
          "_inject_setup_teardown_fixtures",
          "FormattedExcinfo",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "is_true",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "EXIT_USAGEERROR",
          "_log_cli_enabled",
          "register",
          "_patched_find_module",
          "_getparser",
          "exec_",
          "deactivate_fixture",
          "getitems",
          "_from_json",
          "getplugin",
          "failed",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_PY2",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "makeini",
          "freeze_support",
          "own_markers",
          "monkeypatch",
          "__bool__",
          "find_module",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "GETFUNCARGVALUE",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "addini",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "fail_fixturefunc",
          "PYTEST_LOGWARNING",
          "pytest_ignore_collect",
          "unary_map",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_parse_lsof_output",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "_try_load_conftest",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "EXIT_NOTESTSCOLLECTED",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "istestfunction",
          "__enter__",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "getcfg",
          "addSuccess",
          "EXIT_INTERRUPTED",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_ConfigDeprecated",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "importorskip",
          "source",
          "CACHEDIR_TAG_CONTENT",
          "_repr_style",
          "N",
          "match",
          "MultipleDoctestFailures",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_compare_eq_cls",
          "safe_text_dupfile",
          "done",
          "CallInfo",
          "WarningsChecker",
          "_write_pyc",
          "fixture",
          "MonkeyPatch",
          "PY36",
          "getfixturedefs",
          "genitems",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_callhelper",
          "invalidraise",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "ensuretemp",
          "fixturenames",
          "isparseable",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "_pdb_cls",
          "hasopt",
          "verbosity",
          "_check_scope",
          "ParameterSet",
          "raises",
          "Junit",
          "format",
          "_imp_find_module",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "pytest_logwarning",
          "caplog",
          "_cmp_raises_type_error",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "pytest_doctest_prepare_content",
          "CollectReport",
          "_tryconvertpyarg",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "pytestPDB",
          "record_testreport",
          "_outrep_summary",
          "listoutcomes",
          "getinicfg",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "stepwise",
          "CollectErrorRepr",
          "pytest_configure",
          "TYPE_CHECKING",
          "make_hook_recorder",
          "finish_recording",
          "restore",
          "RE_IMPORT_ERROR_NAME",
          "_exec_lsof",
          "istestfunc",
          "IGNORE_PAM",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "pytest_runtest_protocol",
          "CaptureResult",
          "typename",
          "perform_collect",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "RemovedInPytest4Warning",
          "PYTEST_CONFIG_GLOBAL",
          "visit_Assert",
          "resume",
          "_setoption",
          "_matchnodes",
          "_do_configure",
          "get_fslocation_from_item",
          "_attempt_to_close_capture_file",
          "DummyRewriteHook",
          "parse_num",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "getnode",
          "_showfixtures_main",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "import_plugin",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "append_pass",
          "writelines",
          "record_xml_attribute",
          "EXIT_OK",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "Mark",
          "EncodedFile",
          "own_mark_names",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "get_empty_parameterset_mark",
          "__exit__",
          "_register_with_pkg_resources",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "matchkeyword",
          "setall",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "pytest_enter_pdb",
          "store_mark",
          "_compilecounter",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_show_fixture_action",
          "EXIT_TESTSFAILED",
          "RaisesContext",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "NoneType",
          "_fix_unittest_skip_decorator",
          "warn_about_none_ast",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "binop_map",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "errors",
          "_assertion_supported",
          "_force_symlink",
          "__unicode__",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_call_and_format_exception",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "exc_clear",
          "rewrite",
          "toterminal",
          "nodes",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "getargs",
          "getfuncargvalue",
          "BOM_UTF8",
          "addSkip",
          "update",
          "assert_contains",
          "capsysbinary",
          "FastFilesCompleter",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "is_package",
          "parametrize",
          "__str__",
          "_traceback",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "_ensure_only_one_capture_fixture",
          "parse_args",
          "_find_last_non_hidden_frame",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "MODULE_NOT_FOUND_ERROR",
          "setuponly",
          "_get_xunit_setup_teardown",
          "ishidden",
          "defaultfuncargprefixmarker",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "_printcollecteditems",
          "str",
          "getdecoded",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "getslaveinfoline",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "_handle_skip",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "setns",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "EXIT_INTERNALERROR",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "alias",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "format_exception_only",
          "LineComp",
          "_striptext",
          "PyobjContext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "deindent",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "WARNS_EXEC",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "repr_instance",
          "scopename2class",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "copy_example",
          "assert_contains_lines",
          "KeywordMapping",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "parse_known_args",
          "pytest_generate_tests",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "add_stats",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "getfuncargnames",
          "getreportopt",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "FIXTURE_NAMED_REQUEST",
          "_non_numeric_type_error",
          "iter_markers_with_node",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_getcapture",
          "_rget_with_confmod",
          "setmulti2",
          "_install_capture_fixture_on_item",
          "tracebackcutdir",
          "_get_non_fixture_func",
          "_consider_importhook",
          "global_and_fixture_disabled",
          "statement",
          "clear",
          "parsefactories",
          "get_skip_exceptions",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "bin_xml_escape",
          "visit_Call_35",
          "context",
          "short_test_summary",
          "__next__",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "getexplanation",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_ensure_basetemp",
          "capture_fixtures",
          "addError",
          "call_optional",
          "_getglobals",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "_setup_cli_logging",
          "_makepath",
          "_format_action_invocation",
          "FuncargnamesCompatAttr",
          "_getvaluepath",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_get_global_properties_node",
          "getpathnode",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "Exit",
          "_import_pdbcls",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PY35",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "_teardown_yield_fixture",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "start",
          "patchsysdict",
          "_processopt",
          "raise_on_kwargs",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "emit",
          "RAISES_MESSAGE_PARAMETER",
          "_log",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "ApproxDecimal",
          "getvalue",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "outcomes",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_setup_collect_fakemodule",
          "wasvalid",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "module",
          "_warn_if_env_name_is_not_str",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "_test_pytest_function",
          "PytestArg",
          "xfail",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "__nonzero__",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "repr_unicode",
          "append_collect_skipped",
          "_collectfile",
          "python_keywords_allowed_list",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "rmtree",
          "PseudoFixtureDef",
          "_reprcompare",
          "_getcrashline",
          "pytest_cmdline_parse",
          "handler",
          "_readline_workaround",
          "_teardown_towards",
          "_runtest_for_main",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_format_args",
          "Config",
          "pytest_runtestloop",
          "yield_fixture",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "out",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "YIELD_TESTS",
          "_get_allow_unicode_flag",
          "teardown_all",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "PyobjMixin",
          "RN",
          "combined_with",
          "_makefile",
          "unittest",
          "exists",
          "last_failed_paths",
          "pyobj_property",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "find",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "applymarker",
          "_pytest",
          "_istrue",
          "_some_str",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "RAISES_EXEC",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_getnextfixturedef",
          "getfailedcollections",
          "chain",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "call_and_report",
          "visit_Starred",
          "isfunction",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "from_current",
          "isset",
          "markname",
          "getlocals",
          "_given_basetemp",
          "popen",
          "load_module",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "nextitem",
          "approx",
          "_addoption_instance",
          "LineMatcher_fixture",
          "_excinfo",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "__setattr__",
          "args",
          "_teardown_with_finalization",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "getbasetemp",
          "_result",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "cookie_re",
          "ASCII_IS_DEFAULT_ENCODING",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "repr_excinfo",
          "syspath_prepend",
          "set_trace",
          "__iter__",
          "get_actual_log_level",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "istrue",
          "isclass",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "cached_eval",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "function",
          "visit_Call_legacy",
          "set_repr_style",
          "_addoption",
          "__getattr__",
          "ReprFuncArgs",
          "MarkMapping",
          "append_skipped",
          "wrap_function_to_error_out_if_called_directly",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "_translate_non_printable",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "_legal_chars",
          "TestReport",
          "SetupState",
          "pytest_runtest_logstart",
          "matchmark",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "check_xfail_no_run",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "MarkEvaluator",
          "compile_",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "nose",
          "addhooks",
          "capfd",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "showfixtures",
          "FixtureDef",
          "FixtureManager",
          "scope",
          "getfixturedefs",
          "pytest_configure",
          "pytest_addoption",
          "pytest_sessionfinish",
          "setup"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:45:24.368891",
        "usage": "274.0590572357178 ms"
      },
      "request": {
        "tokens": [
          "showfixtures",
          "FixtureDef",
          "FixtureManager",
          "scope",
          "getfixturedefs",
          "pytest_configure",
          "pytest_addoption",
          "pytest_sessionfinish",
          "setup"
        ]
      },
      "response": {
        "results": {
          "pytest_addoption": [
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/main.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/debugging.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/__init__.py"
          ],
          "setup": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/debugging.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py"
          ],
          "pytest_configure": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/warnings.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_sessionfinish": [
            "src/_pytest/pytester.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/junitxml.py"
          ],
          "scope": [
            "src/_pytest/setuponly.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py"
          ],
          "showfixtures": [
            "src/_pytest/python.py"
          ],
          "FixtureManager": [
            "src/_pytest/fixtures.py"
          ],
          "FixtureDef": [
            "src/_pytest/fixtures.py"
          ],
          "getfixturedefs": [
            "src/_pytest/fixtures.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:45:24.642960",
        "usage": "8316.61319732666 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_addoption": [
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/main.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/warnings.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/debugging.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/terminal.py",
            "src/_pytest/mark/__init__.py"
          ],
          "setup": [
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python.py",
            "src/_pytest/nose.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pytester.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/debugging.py",
            "src/_pytest/terminal.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py"
          ],
          "pytest_configure": [
            "src/_pytest/deprecated.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pytester.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/warnings.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytest_sessionfinish": [
            "src/_pytest/pytester.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py",
            "src/_pytest/terminal.py",
            "src/_pytest/runner.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/junitxml.py"
          ],
          "scope": [
            "src/_pytest/setuponly.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nodes.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py"
          ],
          "showfixtures": [
            "src/_pytest/python.py"
          ],
          "FixtureManager": [
            "src/_pytest/fixtures.py"
          ],
          "FixtureDef": [
            "src/_pytest/fixtures.py"
          ],
          "getfixturedefs": [
            "src/_pytest/fixtures.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue revolves around displaying fixture scopes using the `pytest --fixtures` command, which currently doesn't provide this information directly. The focus is on anything that involves fixtures and their configuration or how they are represented and displayed in pytest.\n\nLooking at the `keyword_search_results`:\n\n1. **'scope'** is mentioned in files like `src/_pytest/fixtures.py`, `src/_pytest/setuponly.py`, and some others. However, `src/_pytest/fixtures.py` seems the most relevant under this keyword since it directly relates to fixtures which is the core of the issue.\n\n2. **'showfixtures'** shows a match in `src/_pytest/python.py`. This is likely related to how fixtures are displayed, a key part of the problem statement.\n\n3. **'FixtureManager'**, **'FixtureDef'**, and **'getfixturedefs'** appear in `src/_pytest/fixtures.py`. These components are likely involved in managing or defining fixtures, which would be necessary for modifying how fixture scopes are displayed.\n\nTherefore, the most relevant files are likely those related to the core fixture machinery and the way fixtures are shown:\n\n1. `src/_pytest/fixtures.py`: Most likely contains definitions and management for fixtures, directly related to adding scope information.\n2. `src/_pytest/python.py`: Contains `showfixtures`, potentially related to how fixtures are displayed in pytest which is central to this issue.\n\nOther files are less relevant as they do not directly deal with the representation of fixtures or their configuration, as required by the issue.",
        "file_paths": [
          "src/_pytest/fixtures.py",
          "src/_pytest/python.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:32.959589",
        "usage": "7467.519998550415 ms"
      },
      "request": {
        "file_path": "src/_pytest/fixtures.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n\nThe reported issue is about enhancing the output of the `pytest --fixtures` command to include information regarding fixture scopes. Currently, users need to look up the docs or source code to determine the scope of a fixture, which is inconvenient. To address this, the expectation is to modify the `pytest --fixtures` functionality to list the scope alongside each fixture.\n\n2. Make file evaluation:\n\n- The file `src/_pytest/fixtures.py` is relevant to fixture management in pytest, which might include defining scopes, managing and retrieving fixtures, etc.\n- The symbols and functions related to fixture definitions and scopes include `FixtureDef`, `FixtureFunctionMarker`, `fixture`, `FixtureManager`, and methods that involve scope like `get_scope_node`.\n- The class `FixtureDef` is a container for factory definitions and has a `scope` attribute. The method `fixture()` also allows users to define the scope of a fixture (`scope=\"function\"` by default but can be changed to \"class\", \"module\", \"package\", or \"session\").\n- The rendering of fixtures by `pytest --fixtures` might be handled elsewhere or need enhancement to include fixture scope.\n- The `FixtureManager` is another critical class here, as it manages the registration and lookup of fixtures, including scoping.\n\n3. Output Decision:\n- The file `src/_pytest/fixtures.py` appears relevant for this issue because it contains the logic pertinent to fixture management and scope definitions. It may need amendments where fixtures are displayed to include scope information.\n\nRelevance\n- Symbols like `FixtureDef`, `fixture`, and `FixtureManager` could be the starting point to make the necessary changes to the `pytest --fixtures` command behavior to include scopes.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/config/__init__.py",
          "src/_pytest/terminal.py",
          "src/_pytest/main.py"
        ],
        "relevant_symbols": [
          "FixtureDef",
          "fixture",
          "FixtureFunctionMarker",
          "FixtureManager",
          "FixtureRequest"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:40.427121",
        "usage": "15071.629047393799 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "## Step 1: Analyzing the User Instructions\n1.1 The issue is about enhancing the `pytest --fixtures` command to show the scope of each fixture directly when the fixtures are listed, instead of having to check the documentation or source code manually to find this information.\n1.2 No specific reproduction steps are provided, the lack of fixture scope information is the issue itself.\n1.3 This issue arises because the current implementation of `pytest --fixtures` does not include code that fetches or displays the scope of fixtures.\n1.4 The user expects to see the scope of a fixture listed alongside it when the `pytest --fixtures` command is run, which requires enhancing the display functionality to include this data.\n1.5 The issue is likely because the `pytest --fixtures` feature currently only displays information about available fixtures, but doesn\u2019t explicitly include scope information within its output.\n1.6 A potential solution would be to modify the part of the code that handles the `pytest --fixtures` command to extract the scope of each fixture object and include that in the output to the terminal.\n\n## Step 2: Evaluating the Given File\n2.1 The file `src/_pytest/python.py` appears to manage test discovery and the setup/execution of test functions in pytest.\n2.2 & 2.3 Notably, this file imports and uses functionalities from `_pytest.fixtures`, which is directly related to how fixtures are managed.\n2.4-2.5 Within this file, functions like `showfixtures`, `show_fixtures_per_test`, and associated functions operate to list fixtures, appearing relevant to `pytest --fixtures` output management.\n2.6 The methods `_showfixtures_main`, and `write_fixture` in particular deal with writing out the fixtures and could be adjusted to add scope information.\n\nKey observation is that fixture manipulation/loading is handled by `session._fixturemanager` and `fixtureinfo.name2fixturedefs`, showing potential areas where fixture scope could be extracted and displayed.\n\n## Conclusion\nThis file appears to be relevant to the issue, though modifications might be needed in conjunction with areas of the code that more directly associate with fixture scope (likely within `_pytest.fixtures`).\n",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/fixtures.py"
        ],
        "relevant_symbols": [
          "showfixtures",
          "_showfixtures_main",
          "write_fixture"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:45:55.498780",
        "usage": "122.07603454589844 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/fixtures.py",
            "relevant_symbol_keys": [
              "FixtureDef",
              "fixture",
              "FixtureFunctionMarker",
              "FixtureManager",
              "FixtureRequest"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "showfixtures",
              "_showfixtures_main",
              "write_fixture"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.capture.CaptureManager.activate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n",
            "start_line": 153,
            "start_column": 5146,
            "end_line": 4,
            "end_column": 5446,
            "start_byte": 5146,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.deactivate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "          get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node i",
            "start_line": 161,
            "start_column": 5452,
            "end_line": 4,
            "end_column": 5689,
            "start_byte": 5452,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.suspend_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "None:\n                node._name2pseudofixturedef[argname] = fixturedef\n\n\ndef getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't e",
            "start_line": 167,
            "start_column": 5695,
            "end_line": 4,
            "end_column": 5848,
            "start_byte": 5695,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.resume_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "r raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise ",
            "start_line": 172,
            "start_column": 5854,
            "end_line": 4,
            "end_column": 6005,
            "start_byte": 5854,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.global_and_fixture_disabled",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t request)\n        # we don't expect them to be fixture functions\n        return None\n\n\ndef get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenu",
            "start_line": 179,
            "start_column": 6042,
            "end_line": 4,
            "end_column": 6299,
            "start_byte": 6042,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.capture_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(item, []):\n            items_by_argkey[scopenum][key].appendleft(",
            "start_line": 249,
            "start_column": 8145,
            "end_line": 0,
            "end_column": 8214,
            "start_byte": 8145,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture._ensure_only_one_capture_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "m)\n\n\ndef reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items",
            "start_line": 252,
            "start_column": 8217,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8217,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture._install_capture_fixture_on_item",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "pecified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not incl",
            "start_line": 326,
            "start_column": 10965,
            "end_line": 0,
            "end_column": 11905,
            "start_byte": 10965,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest._setup_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-funct",
            "start_line": 433,
            "start_column": 14408,
            "end_line": 0,
            "end_column": 14874,
            "start_byte": 14408,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.pytest_sessionstart",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"function\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)",
            "start_line": 47,
            "start_column": 1307,
            "end_line": 0,
            "end_column": 1724,
            "start_byte": 1307,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopename2class",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopename2class = {}",
            "start_line": 63,
            "start_column": 1727,
            "end_line": 0,
            "end_column": 1747,
            "start_byte": 1727,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scope2props",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope2props = dict(session=())",
            "start_line": 66,
            "start_column": 1750,
            "end_line": 0,
            "end_column": 1780,
            "start_byte": 1750,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopeproperty",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope",
            "start_line": 74,
            "start_column": 2061,
            "end_line": 0,
            "end_column": 2506,
            "start_byte": 2061,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_scope_package",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current",
            "start_line": 90,
            "start_column": 2509,
            "end_line": 0,
            "end_column": 2894,
            "start_byte": 2509,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_scope_node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)",
            "start_line": 105,
            "start_column": 2897,
            "end_line": 0,
            "end_column": 3059,
            "start_byte": 2897,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.add_funcarg_pseudo_fixture_def",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        return  # this function call does not have direct parametrization\n    # collect funcargs of all callspecs into a list of values\n    arg2params = {}\n    arg2scope = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # if we have a scope that is higher than function we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # use module-level collector for class-scope (for now)\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n                get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node is not None:\n                node._name2pseudofixturedef[argname] = fixturedef",
            "start_line": 112,
            "start_column": 3062,
            "end_line": 0,
            "end_column": 5766,
            "start_byte": 3062,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.getfixturemarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None",
            "start_line": 170,
            "start_column": 5769,
            "end_line": 0,
            "end_column": 6127,
            "start_byte": 5769,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_parametrized_fixture_keys",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenum < scopenum_function  # function\n    try:\n        cs = item.callspec\n    except AttributeError:\n        pass\n    else:\n        # cs.indices.items() is random order of argnames.  Need to\n        # sort this so that different calls to\n        # get_parametrized_fixture_keys will be deterministic.\n        for argname, param_index in sorted(cs.indices.items()):\n            if cs._arg2scopenum[argname] != scopenum:\n                continue\n            if scopenum == 0:  # session\n                key = (argname, param_index)\n            elif scopenum == 1:  # package\n                key = (argname, param_index, item.fspath.dirpath())\n            elif scopenum == 2:  # module\n                key = (argname, param_index, item.fspath)\n            elif scopenum == 3:  # class\n                key = (argname, param_index, item.fspath, item.cls)\n            yield key",
            "start_line": 181,
            "start_column": 6130,
            "end_line": 0,
            "end_column": 7166,
            "start_byte": 6130,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.reorder_items",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items(items):\n    argkeys_cache = {}\n    items_by_argkey = {}\n    for scopenum in range(0, scopenum_function):\n        argkeys_cache[scopenum] = d = {}\n        items_by_argkey[scopenum] = item_d = defaultdict(deque)\n        for item in items:\n            keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items = OrderedDict.fromkeys(items)\n    return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))",
            "start_line": 213,
            "start_column": 7399,
            "end_line": 0,
            "end_column": 7991,
            "start_byte": 7399,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.fix_cache_order",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fix_cache_order(item, argkeys_cache, items_by_argkey):\n    for scopenum in range(0, scopenum_function):\n        for key in argkeys_cache[scopenum].get(item, []):\n            items_by_argkey[scopenum][key].appendleft(item)",
            "start_line": 229,
            "start_column": 7994,
            "end_line": 0,
            "end_column": 8219,
            "start_byte": 7994,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.reorder_items_atscope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items_deque:\n        no_argkey_group = OrderedDict()\n        slicing_argkey = None\n        while items_deque:\n            item = items_deque.popleft()\n            if item in items_done or item in no_argkey_group:\n                continue\n            argkeys = OrderedDict.fromkeys(\n                k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n            )\n            if not argkeys:\n                no_argkey_group[item] = None\n            else:\n                slicing_argkey, _ = argkeys.popitem()\n                # we don't have to remove relevant items from later in the deque because they'll just be ignored\n                matching_items = [\n                    i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                ]\n                for i in reversed(matching_items):\n                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                    items_deque.appendleft(i)\n                break\n        if no_argkey_group:\n            no_argkey_group = reorder_items_atscope(\n                no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n            )\n            for item in no_argkey_group:\n                items_done[item] = None\n        ignore.add(slicing_argkey)\n    return items_done",
            "start_line": 235,
            "start_column": 8222,
            "end_line": 0,
            "end_column": 9844,
            "start_byte": 8222,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fillfixtures(function):\n    \"\"\" fill missing funcargs for a test function. \"\"\"\n    try:\n        request = function._request\n    except AttributeError:\n        # XXX this special code path is only expected to execute\n        # with the oejskit plugin.  It uses classes with funcargs\n        # and we thus have to work a bit to allow this.\n        fm = function.session._fixturemanager\n        fi = fm.getfixtureinfo(function.parent, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._request = FixtureRequest(function)\n        request._fillfixtures()\n        # prune out funcargs for jstests\n        newfuncargs = {}\n        for name in fi.argnames:\n            newfuncargs[name] = function.funcargs[name]\n        function.funcargs = newfuncargs\n    else:\n        request._fillfixtures()",
            "start_line": 275,
            "start_column": 9847,
            "end_line": 0,
            "end_column": 10669,
            "start_byte": 9847,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_direct_param_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_direct_param_fixture_func(request):\n    return request.param",
            "start_line": 297,
            "start_column": 10672,
            "end_line": 0,
            "end_column": 10740,
            "start_byte": 10672,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(slots=True)\nclass FuncFixtureInfo(object):\n    # original function argument names\n    argnames = attr.ib(type=tuple)\n    # argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 301,
            "start_column": 10743,
            "end_line": 0,
            "end_column": 12559,
            "start_byte": 10743,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.argnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "argnames = attr.ib(type=tuple)",
            "start_line": 304,
            "start_column": 10837,
            "end_line": 4,
            "end_column": 10867,
            "start_byte": 10837,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.initialnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "initialnames = attr.ib(type=tuple)",
            "start_line": 308,
            "start_column": 11045,
            "end_line": 4,
            "end_column": 11079,
            "start_byte": 11045,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.names_closure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "names_closure = attr.ib()",
            "start_line": 309,
            "start_column": 11084,
            "end_line": 4,
            "end_column": 11109,
            "start_byte": 11084,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.name2fixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name2fixturedefs = attr.ib()",
            "start_line": 310,
            "start_column": 11127,
            "end_line": 4,
            "end_column": 11155,
            "start_byte": 11127,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.prune_dependency_tree",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 312,
            "start_column": 11192,
            "end_line": 4,
            "end_column": 12559,
            "start_byte": 11192,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 340,
            "start_column": 12562,
            "end_line": 0,
            "end_column": 24573,
            "start_byte": 12562,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 348,
            "start_column": 12848,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12848,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 360,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13638,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 367,
            "start_column": 13644,
            "end_line": 4,
            "end_column": 13796,
            "start_byte": 13644,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 372,
            "start_column": 13802,
            "end_line": 4,
            "end_column": 14617,
            "start_byte": 13802,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 388,
            "start_column": 14623,
            "end_line": 4,
            "end_column": 14764,
            "start_byte": 14623,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 393,
            "start_column": 14770,
            "end_line": 4,
            "end_column": 14924,
            "start_byte": 14770,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 398,
            "start_column": 14930,
            "end_line": 4,
            "end_column": 15162,
            "start_byte": 14930,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 405,
            "start_column": 15168,
            "end_line": 4,
            "end_column": 15549,
            "start_byte": 15168,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 415,
            "start_column": 15555,
            "end_line": 4,
            "end_column": 15738,
            "start_byte": 15555,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 420,
            "start_column": 15744,
            "end_line": 4,
            "end_column": 15904,
            "start_byte": 15744,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 425,
            "start_column": 15910,
            "end_line": 4,
            "end_column": 16046,
            "start_byte": 15910,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 430,
            "start_column": 16052,
            "end_line": 4,
            "end_column": 16163,
            "start_byte": 16052,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 435,
            "start_column": 16169,
            "end_line": 4,
            "end_column": 16485,
            "start_byte": 16169,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 442,
            "start_column": 16491,
            "end_line": 4,
            "end_column": 16695,
            "start_byte": 16491,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 448,
            "start_column": 16701,
            "end_line": 4,
            "end_column": 17085,
            "start_byte": 16701,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 458,
            "start_column": 17091,
            "end_line": 4,
            "end_column": 17255,
            "start_byte": 17091,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 462,
            "start_column": 17261,
            "end_line": 4,
            "end_column": 17542,
            "start_byte": 17261,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 469,
            "start_column": 17548,
            "end_line": 4,
            "end_column": 17982,
            "start_byte": 17548,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 479,
            "start_column": 17988,
            "end_line": 4,
            "end_column": 18221,
            "start_byte": 17988,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 486,
            "start_column": 18227,
            "end_line": 4,
            "end_column": 18911,
            "start_byte": 18227,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 504,
            "start_column": 18917,
            "end_line": 4,
            "end_column": 19250,
            "start_byte": 18917,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 515,
            "start_column": 19256,
            "end_line": 4,
            "end_column": 22579,
            "start_byte": 19256,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 589,
            "start_column": 22585,
            "end_line": 4,
            "end_column": 22856,
            "start_byte": 22585,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 595,
            "start_column": 22862,
            "end_line": 4,
            "end_column": 23446,
            "start_byte": 22862,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 609,
            "start_column": 23452,
            "end_line": 4,
            "end_column": 23848,
            "start_byte": 23452,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 619,
            "start_column": 23854,
            "end_line": 4,
            "end_column": 24493,
            "start_byte": 23854,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 635,
            "start_column": 24499,
            "end_line": 4,
            "end_column": 24573,
            "start_byte": 24499,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class SubRequest(FixtureRequest):\n    \"\"\" a sub request for handling getting a fixture from a\n    test function/fixture. \"\"\"\n\n    def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager\n\n    def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)\n\n    def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 639,
            "start_column": 24576,
            "end_line": 0,
            "end_column": 25997,
            "start_byte": 24576,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.SubRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager",
            "start_line": 643,
            "start_column": 24706,
            "end_line": 4,
            "end_column": 25280,
            "start_byte": 24706,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)",
            "start_line": 657,
            "start_column": 25286,
            "end_line": 4,
            "end_column": 25384,
            "start_byte": 25286,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)",
            "start_line": 660,
            "start_column": 25390,
            "end_line": 4,
            "end_column": 25473,
            "start_byte": 25390,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 663,
            "start_column": 25479,
            "end_line": 4,
            "end_column": 25997,
            "start_byte": 25479,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.scopes",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopes = \"session package module class function\".split()",
            "start_line": 674,
            "start_column": 26000,
            "end_line": 0,
            "end_column": 26056,
            "start_byte": 26000,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopenum_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopenum_function = scopes.index(\"function\")",
            "start_line": 675,
            "start_column": 26057,
            "end_line": 0,
            "end_column": 26101,
            "start_byte": 26057,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopemismatch",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopemismatch(currentscope, newscope):\n    return scopes.index(newscope) > scopes.index(currentscope)",
            "start_line": 678,
            "start_column": 26104,
            "end_line": 0,
            "end_column": 26209,
            "start_byte": 26104,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scope2index",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scope2index(scope, descr, where=None):\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\n    \"\"\"\n    try:\n        return scopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, \"from {} \".format(where) if where else \"\", scope\n            ),\n            pytrace=False,\n        )",
            "start_line": 682,
            "start_column": 26212,
            "end_line": 0,
            "end_column": 26623,
            "start_byte": 26212,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n\n    def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 697,
            "start_column": 26626,
            "end_line": 0,
            "end_column": 28844,
            "start_byte": 26626,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg",
            "start_line": 700,
            "start_column": 26741,
            "end_line": 4,
            "end_column": 26929,
            "start_byte": 26741,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError.formatrepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 706,
            "start_column": 26935,
            "end_line": 4,
            "end_column": 28844,
            "start_byte": 26935,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 751,
            "start_column": 28847,
            "end_line": 0,
            "end_column": 29802,
            "start_byte": 28847,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname",
            "start_line": 752,
            "start_column": 28895,
            "end_line": 4,
            "end_column": 29141,
            "start_byte": 28895,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.toterminal",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 759,
            "start_column": 29147,
            "end_line": 4,
            "end_column": 29802,
            "start_byte": 29147,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.fail_fixturefunc",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)",
            "start_line": 778,
            "start_column": 29805,
            "end_line": 0,
            "end_column": 30055,
            "start_byte": 29805,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.call_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def call_fixture_func(fixturefunc, request, kwargs):\n    yieldctx = is_generator(fixturefunc)\n    if yieldctx:\n        it = fixturefunc(**kwargs)\n        res = next(it)\n        finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)\n        request.addfinalizer(finalizer)\n    else:\n        res = fixturefunc(**kwargs)\n    return res",
            "start_line": 785,
            "start_column": 30058,
            "end_line": 0,
            "end_column": 30407,
            "start_byte": 30058,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures._teardown_yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _teardown_yield_fixture(fixturefunc, it):\n    \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n    yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        fail_fixturefunc(\n            fixturefunc, \"yield_fixture function has more than one 'yield'\"\n        )",
            "start_line": 797,
            "start_column": 30410,
            "end_line": 0,
            "end_column": 30835,
            "start_byte": 30410,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.resolve_fixture_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def resolve_fixture_function(fixturedef, request):\n    \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n    instances and bound methods.\n    \"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # bind the unbound method to the TestCase instance\n            fixturefunc = fixturedef.func.__get__(request.instance)\n    else:\n        # the fixture function needs to be bound to the actual\n        # request.instance so that code working with \"fixturedef\" behaves\n        # as expected.\n        if request.instance is not None:\n            fixturefunc = getimfunc(fixturedef.func)\n            if fixturefunc != fixturedef.func:\n                fixturefunc = fixturefunc.__get__(request.instance)\n    return fixturefunc",
            "start_line": 904,
            "start_column": 34058,
            "end_line": 0,
            "end_column": 34896,
            "start_byte": 34058,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_fixture_setup(fixturedef, request):\n    \"\"\" Execution of fixture setup. \"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = request.param_index\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result",
            "start_line": 924,
            "start_column": 34899,
            "end_line": 0,
            "end_column": 35623,
            "start_byte": 34899,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures._ensure_immutable_ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _ensure_immutable_ids(ids):\n    if ids is None:\n        return\n    if callable(ids):\n        return ids\n    return tuple(ids)",
            "start_line": 944,
            "start_column": 35626,
            "end_line": 0,
            "end_column": 35755,
            "start_byte": 35626,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.wrap_function_to_error_out_if_called_directly",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\n    \"\"\"\n    message = FIXTURE_FUNCTION_CALL.format(\n        name=fixture_marker.name or function.__name__\n    )\n\n    @six.wraps(function)\n    def result(*args, **kwargs):\n        fail(message, pytrace=False)\n\n    # keep reference to the original function in our own custom attribute so we don't unwrap\n    # further than this point and lose useful wrappings like @mock.patch (#3774)\n    result.__pytest_wrapped__ = _PytestWrapper(function)\n\n    return result",
            "start_line": 952,
            "start_column": 35758,
            "end_line": 0,
            "end_column": 36444,
            "start_byte": 35758,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass FixtureFunctionMarker(object):\n    scope = attr.ib()\n    params = attr.ib(converter=attr.converters.optional(tuple))\n    autouse = attr.ib(default=False)\n    ids = attr.ib(default=None, converter=_ensure_immutable_ids)\n    name = attr.ib(default=None)\n\n    def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 971,
            "start_column": 36447,
            "end_line": 0,
            "end_column": 37339,
            "start_byte": 36447,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 973,
            "start_column": 36509,
            "end_line": 4,
            "end_column": 36526,
            "start_byte": 36509,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "params = attr.ib(converter=attr.converters.optional(tuple))",
            "start_line": 974,
            "start_column": 36531,
            "end_line": 4,
            "end_column": 36590,
            "start_byte": 36531,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "autouse = attr.ib(default=False)",
            "start_line": 975,
            "start_column": 36595,
            "end_line": 4,
            "end_column": 36627,
            "start_byte": 36595,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ids = attr.ib(default=None, converter=_ensure_immutable_ids)",
            "start_line": 976,
            "start_column": 36632,
            "end_line": 4,
            "end_column": 36692,
            "start_byte": 36632,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name = attr.ib(default=None)",
            "start_line": 977,
            "start_column": 36697,
            "end_line": 4,
            "end_column": 36725,
            "start_byte": 36697,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 979,
            "start_column": 36731,
            "end_line": 4,
            "end_column": 37339,
            "start_byte": 36731,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\"Decorator to mark a fixture factory function.\n\n    This decorator can be used, with or without parameters, to define a\n    fixture function.\n\n    The name of the fixture function can later be referenced to cause its\n    invocation ahead of running tests: test\n    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n    marker.\n\n    Test functions can directly use fixture names as input\n    arguments in which case the fixture instance returned from the fixture\n    function will be injected.\n\n    Fixtures can provide their values to test functions using ``return`` or ``yield``\n    statements. When using ``yield`` the code block after the ``yield`` statement is executed\n    as teardown code regardless of the test outcome, and must yield exactly once.\n\n    :arg scope: the scope for which this fixture is shared, one of\n                ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n                ``\"package\"`` or ``\"session\"``.\n\n                ``\"package\"`` is considered **experimental** at this time.\n\n    :arg params: an optional list of parameters which will cause multiple\n                invocations of the fixture function and all of the tests\n                using it.\n                The current parameter is available in ``request.param``.\n\n    :arg autouse: if True, the fixture func is activated for all tests that\n                can see it.  If False (the default) then an explicit\n                reference is needed to activate the fixture.\n\n    :arg ids: list of string ids each corresponding to the params\n                so that they are part of the test id. If no ids are provided\n                they will be generated automatically from the params.\n\n    :arg name: the name of the fixture. This defaults to the name of the\n                decorated function. If a fixture is used in the same module in\n                which it is defined, the function name of the fixture will be\n                shadowed by the function arg that requests the fixture; one way\n                to resolve this is to name the decorated function\n                ``fixture_<fixturename>`` and then use\n                ``@pytest.fixture(name='<fixturename>')``.\n    \"\"\"\n    if callable(scope) and params is None and autouse is False:\n        # direct decoration\n        return FixtureFunctionMarker(\"function\", params, autouse, name=name)(scope)\n    if params is not None and not isinstance(params, (list, tuple)):\n        params = list(params)\n    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)",
            "start_line": 997,
            "start_column": 37342,
            "end_line": 0,
            "end_column": 39985,
            "start_byte": 37342,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def yield_fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\" (return a) decorator to mark a yield-fixture factory function.\n\n    .. deprecated:: 3.0\n        Use :py:func:`pytest.fixture` directly instead.\n    \"\"\"\n    return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)",
            "start_line": 1051,
            "start_column": 39988,
            "end_line": 0,
            "end_column": 40317,
            "start_byte": 39988,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.defaultfuncargprefixmarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "defaultfuncargprefixmarker = fixture()",
            "start_line": 1060,
            "start_column": 40320,
            "end_line": 0,
            "end_column": 40358,
            "start_byte": 40320,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytestconfig",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@fixture(scope=\"session\")\ndef pytestconfig(request):\n    \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n\n    Example::\n\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n\n    \"\"\"\n    return request.config",
            "start_line": 1063,
            "start_column": 40361,
            "end_line": 0,
            "end_column": 40660,
            "start_byte": 40361,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager",
            "start_line": 421,
            "start_column": 13750,
            "end_line": 0,
            "end_column": 14210,
            "start_byte": 13750,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "tfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n  ",
            "start_line": 436,
            "start_column": 14213,
            "end_line": 0,
            "end_column": 14430,
            "start_byte": 14213,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.LineMatcher_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._reques",
            "start_line": 337,
            "start_column": 10280,
            "end_line": 0,
            "end_column": 10372,
            "start_byte": 10280,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._inject_setup_module_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixture",
            "start_line": 452,
            "start_column": 16149,
            "end_line": 4,
            "end_column": 17383,
            "start_byte": 16149,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Module._inject_setup_function_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(",
            "start_line": 480,
            "start_column": 17389,
            "end_line": 4,
            "end_column": 18651,
            "start_byte": 17389,
            "end_byte": 4
          },
          {
            "name": "_pytest.python._get_non_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e\n            ),\n            pytrace=False,\n        )\n\n\nclass FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_f",
            "start_line": 706,
            "start_column": 26570,
            "end_line": 0,
            "end_column": 26893,
            "start_byte": 26570,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Class._inject_setup_class_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": ", line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno",
            "start_line": 744,
            "start_column": 27769,
            "end_line": 4,
            "end_column": 28815,
            "start_byte": 27769,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Class._inject_setup_method_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "nes, msg, self.argname)\n\n\nclass FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))\n\n\ndef fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _py",
            "start_line": 768,
            "start_column": 28821,
            "end_line": 4,
            "end_column": 29945,
            "start_byte": 28821,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "TSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_",
            "start_line": 1238,
            "start_column": 47680,
            "end_line": 0,
            "end_column": 47815,
            "start_byte": 47680,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n      ",
            "start_line": 1244,
            "start_column": 47818,
            "end_line": 0,
            "end_column": 49588,
            "start_byte": 47818,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.showfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "       # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n",
            "start_line": 1296,
            "start_column": 49591,
            "end_line": 0,
            "end_column": 49711,
            "start_byte": 49591,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "             i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef\n",
            "start_line": 1302,
            "start_column": 49714,
            "end_line": 0,
            "end_column": 51470,
            "start_byte": 49714,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "om _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import get_real_method\nfrom _pytest.compat import getfslineno\nfrom _pytest.compat import getfuncargnames\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import isclass\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import safe_getattr\nfrom _pytest.deprecated import FIXTURE_FUNCTION_CALL\nfrom _pytest.deprecated import FIXTURE_NAMED_REQUEST\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\n\n@attr.s(frozen=True)\nclass PseudoFixtureDef(object",
            "start_line": 25,
            "start_column": 540,
            "end_line": 0,
            "end_column": 1250,
            "start_byte": 540,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "    cached_result = attr.ib()\n    scope = attr.ib()\n\n\ndef pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"funct",
            "start_line": 43,
            "start_column": 1253,
            "end_line": 0,
            "end_column": 1584,
            "start_byte": 1253,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly._show_fixture_action",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)\n\n\nscopename2class = {}\n\n\nscope2props = dict(session=())\nscope2props[\"package\"] = (\"fspath\",)\nscope2props[\"module\"] = (\"fspath\", \"module\")\nscope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\nscope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\nscope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n\n\ndef scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytes",
            "start_line": 52,
            "start_column": 1587,
            "end_line": 0,
            "end_column": 2566,
            "start_byte": 1587,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cinfo\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest.compat import _format_args\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat imp",
            "start_line": 18,
            "start_column": 406,
            "end_line": 0,
            "end_column": 689,
            "start_byte": 406,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.UnitTestCase._inject_setup_teardown_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n      ",
            "start_line": 65,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 2715,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ype(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current\n\n\ndef get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)\n\n\ndef add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for c",
            "start_line": 81,
            "start_column": 2718,
            "end_line": 0,
            "end_column": 3491,
            "start_byte": 2718,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.showfixtures",
            "file_path": "src/_pytest/python.py",
            "file_content": "def showfixtures(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)",
            "start_line": 1296,
            "start_column": 49591,
            "end_line": 0,
            "end_column": 49711,
            "start_byte": 49591,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _showfixtures_main(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    fm = session._fixturemanager\n\n    available = []\n    seen = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, curdir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    curdir.bestrelpath(loc),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, bestrel, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n                currentmodule = module\n        if verbose <= 0 and argname[0] == \"_\":\n            continue\n        if verbose > 0:\n            funcargspec = \"%s -- %s\" % (argname, bestrel)\n        else:\n            funcargspec = argname\n        tw.line(funcargspec, green=True)\n        loc = getlocation(fixturedef.func, curdir)\n        doc = fixturedef.func.__doc__ or \"\"\n        if doc:\n            write_docstring(tw, doc)\n        else:\n            tw.line(\"    %s: no docstring available\" % (loc,), red=True)",
            "start_line": 1302,
            "start_column": 49714,
            "end_line": 0,
            "end_column": 51470,
            "start_byte": 49714,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:45:55.620870",
        "usage": "10890.586137771606 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.capture.CaptureManager.activate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n",
            "start_line": 153,
            "start_column": 5146,
            "end_line": 4,
            "end_column": 5446,
            "start_byte": 5146,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.deactivate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "          get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node i",
            "start_line": 161,
            "start_column": 5452,
            "end_line": 4,
            "end_column": 5689,
            "start_byte": 5452,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.suspend_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "None:\n                node._name2pseudofixturedef[argname] = fixturedef\n\n\ndef getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't e",
            "start_line": 167,
            "start_column": 5695,
            "end_line": 4,
            "end_column": 5848,
            "start_byte": 5695,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.resume_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "r raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise ",
            "start_line": 172,
            "start_column": 5854,
            "end_line": 4,
            "end_column": 6005,
            "start_byte": 5854,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.global_and_fixture_disabled",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t request)\n        # we don't expect them to be fixture functions\n        return None\n\n\ndef get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenu",
            "start_line": 179,
            "start_column": 6042,
            "end_line": 4,
            "end_column": 6299,
            "start_byte": 6042,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.capture_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(item, []):\n            items_by_argkey[scopenum][key].appendleft(",
            "start_line": 249,
            "start_column": 8145,
            "end_line": 0,
            "end_column": 8214,
            "start_byte": 8145,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture._ensure_only_one_capture_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "m)\n\n\ndef reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items",
            "start_line": 252,
            "start_column": 8217,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8217,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture._install_capture_fixture_on_item",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "pecified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not incl",
            "start_line": 326,
            "start_column": 10965,
            "end_line": 0,
            "end_column": 11905,
            "start_byte": 10965,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest._setup_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-funct",
            "start_line": 433,
            "start_column": 14408,
            "end_line": 0,
            "end_column": 14874,
            "start_byte": 14408,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.pytest_sessionstart",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"function\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)",
            "start_line": 47,
            "start_column": 1307,
            "end_line": 0,
            "end_column": 1724,
            "start_byte": 1307,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopename2class",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopename2class = {}",
            "start_line": 63,
            "start_column": 1727,
            "end_line": 0,
            "end_column": 1747,
            "start_byte": 1727,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scope2props",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope2props = dict(session=())",
            "start_line": 66,
            "start_column": 1750,
            "end_line": 0,
            "end_column": 1780,
            "start_byte": 1750,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopeproperty",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope",
            "start_line": 74,
            "start_column": 2061,
            "end_line": 0,
            "end_column": 2506,
            "start_byte": 2061,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_scope_package",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current",
            "start_line": 90,
            "start_column": 2509,
            "end_line": 0,
            "end_column": 2894,
            "start_byte": 2509,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_scope_node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)",
            "start_line": 105,
            "start_column": 2897,
            "end_line": 0,
            "end_column": 3059,
            "start_byte": 2897,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.add_funcarg_pseudo_fixture_def",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        return  # this function call does not have direct parametrization\n    # collect funcargs of all callspecs into a list of values\n    arg2params = {}\n    arg2scope = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # if we have a scope that is higher than function we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # use module-level collector for class-scope (for now)\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n                get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node is not None:\n                node._name2pseudofixturedef[argname] = fixturedef",
            "start_line": 112,
            "start_column": 3062,
            "end_line": 0,
            "end_column": 5766,
            "start_byte": 3062,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.getfixturemarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None",
            "start_line": 170,
            "start_column": 5769,
            "end_line": 0,
            "end_column": 6127,
            "start_byte": 5769,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_parametrized_fixture_keys",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenum < scopenum_function  # function\n    try:\n        cs = item.callspec\n    except AttributeError:\n        pass\n    else:\n        # cs.indices.items() is random order of argnames.  Need to\n        # sort this so that different calls to\n        # get_parametrized_fixture_keys will be deterministic.\n        for argname, param_index in sorted(cs.indices.items()):\n            if cs._arg2scopenum[argname] != scopenum:\n                continue\n            if scopenum == 0:  # session\n                key = (argname, param_index)\n            elif scopenum == 1:  # package\n                key = (argname, param_index, item.fspath.dirpath())\n            elif scopenum == 2:  # module\n                key = (argname, param_index, item.fspath)\n            elif scopenum == 3:  # class\n                key = (argname, param_index, item.fspath, item.cls)\n            yield key",
            "start_line": 181,
            "start_column": 6130,
            "end_line": 0,
            "end_column": 7166,
            "start_byte": 6130,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.reorder_items",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items(items):\n    argkeys_cache = {}\n    items_by_argkey = {}\n    for scopenum in range(0, scopenum_function):\n        argkeys_cache[scopenum] = d = {}\n        items_by_argkey[scopenum] = item_d = defaultdict(deque)\n        for item in items:\n            keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items = OrderedDict.fromkeys(items)\n    return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))",
            "start_line": 213,
            "start_column": 7399,
            "end_line": 0,
            "end_column": 7991,
            "start_byte": 7399,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.fix_cache_order",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fix_cache_order(item, argkeys_cache, items_by_argkey):\n    for scopenum in range(0, scopenum_function):\n        for key in argkeys_cache[scopenum].get(item, []):\n            items_by_argkey[scopenum][key].appendleft(item)",
            "start_line": 229,
            "start_column": 7994,
            "end_line": 0,
            "end_column": 8219,
            "start_byte": 7994,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.reorder_items_atscope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items_deque:\n        no_argkey_group = OrderedDict()\n        slicing_argkey = None\n        while items_deque:\n            item = items_deque.popleft()\n            if item in items_done or item in no_argkey_group:\n                continue\n            argkeys = OrderedDict.fromkeys(\n                k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n            )\n            if not argkeys:\n                no_argkey_group[item] = None\n            else:\n                slicing_argkey, _ = argkeys.popitem()\n                # we don't have to remove relevant items from later in the deque because they'll just be ignored\n                matching_items = [\n                    i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                ]\n                for i in reversed(matching_items):\n                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                    items_deque.appendleft(i)\n                break\n        if no_argkey_group:\n            no_argkey_group = reorder_items_atscope(\n                no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n            )\n            for item in no_argkey_group:\n                items_done[item] = None\n        ignore.add(slicing_argkey)\n    return items_done",
            "start_line": 235,
            "start_column": 8222,
            "end_line": 0,
            "end_column": 9844,
            "start_byte": 8222,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fillfixtures(function):\n    \"\"\" fill missing funcargs for a test function. \"\"\"\n    try:\n        request = function._request\n    except AttributeError:\n        # XXX this special code path is only expected to execute\n        # with the oejskit plugin.  It uses classes with funcargs\n        # and we thus have to work a bit to allow this.\n        fm = function.session._fixturemanager\n        fi = fm.getfixtureinfo(function.parent, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._request = FixtureRequest(function)\n        request._fillfixtures()\n        # prune out funcargs for jstests\n        newfuncargs = {}\n        for name in fi.argnames:\n            newfuncargs[name] = function.funcargs[name]\n        function.funcargs = newfuncargs\n    else:\n        request._fillfixtures()",
            "start_line": 275,
            "start_column": 9847,
            "end_line": 0,
            "end_column": 10669,
            "start_byte": 9847,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.get_direct_param_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_direct_param_fixture_func(request):\n    return request.param",
            "start_line": 297,
            "start_column": 10672,
            "end_line": 0,
            "end_column": 10740,
            "start_byte": 10672,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(slots=True)\nclass FuncFixtureInfo(object):\n    # original function argument names\n    argnames = attr.ib(type=tuple)\n    # argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 301,
            "start_column": 10743,
            "end_line": 0,
            "end_column": 12559,
            "start_byte": 10743,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.argnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "argnames = attr.ib(type=tuple)",
            "start_line": 304,
            "start_column": 10837,
            "end_line": 4,
            "end_column": 10867,
            "start_byte": 10837,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.initialnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "initialnames = attr.ib(type=tuple)",
            "start_line": 308,
            "start_column": 11045,
            "end_line": 4,
            "end_column": 11079,
            "start_byte": 11045,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.names_closure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "names_closure = attr.ib()",
            "start_line": 309,
            "start_column": 11084,
            "end_line": 4,
            "end_column": 11109,
            "start_byte": 11084,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.name2fixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name2fixturedefs = attr.ib()",
            "start_line": 310,
            "start_column": 11127,
            "end_line": 4,
            "end_column": 11155,
            "start_byte": 11127,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FuncFixtureInfo.prune_dependency_tree",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 312,
            "start_column": 11192,
            "end_line": 4,
            "end_column": 12559,
            "start_byte": 11192,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 340,
            "start_column": 12562,
            "end_line": 0,
            "end_column": 24573,
            "start_byte": 12562,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 348,
            "start_column": 12848,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12848,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 360,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13638,
            "start_byte": 13387,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 367,
            "start_column": 13644,
            "end_line": 4,
            "end_column": 13796,
            "start_byte": 13644,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 372,
            "start_column": 13802,
            "end_line": 4,
            "end_column": 14617,
            "start_byte": 13802,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 388,
            "start_column": 14623,
            "end_line": 4,
            "end_column": 14764,
            "start_byte": 14623,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 393,
            "start_column": 14770,
            "end_line": 4,
            "end_column": 14924,
            "start_byte": 14770,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 398,
            "start_column": 14930,
            "end_line": 4,
            "end_column": 15162,
            "start_byte": 14930,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 405,
            "start_column": 15168,
            "end_line": 4,
            "end_column": 15549,
            "start_byte": 15168,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 415,
            "start_column": 15555,
            "end_line": 4,
            "end_column": 15738,
            "start_byte": 15555,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 420,
            "start_column": 15744,
            "end_line": 4,
            "end_column": 15904,
            "start_byte": 15744,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 425,
            "start_column": 15910,
            "end_line": 4,
            "end_column": 16046,
            "start_byte": 15910,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 430,
            "start_column": 16052,
            "end_line": 4,
            "end_column": 16163,
            "start_byte": 16052,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 435,
            "start_column": 16169,
            "end_line": 4,
            "end_column": 16485,
            "start_byte": 16169,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 442,
            "start_column": 16491,
            "end_line": 4,
            "end_column": 16695,
            "start_byte": 16491,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 448,
            "start_column": 16701,
            "end_line": 4,
            "end_column": 17085,
            "start_byte": 16701,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 458,
            "start_column": 17091,
            "end_line": 4,
            "end_column": 17255,
            "start_byte": 17091,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 462,
            "start_column": 17261,
            "end_line": 4,
            "end_column": 17542,
            "start_byte": 17261,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 469,
            "start_column": 17548,
            "end_line": 4,
            "end_column": 17982,
            "start_byte": 17548,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 479,
            "start_column": 17988,
            "end_line": 4,
            "end_column": 18221,
            "start_byte": 17988,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 486,
            "start_column": 18227,
            "end_line": 4,
            "end_column": 18911,
            "start_byte": 18227,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 504,
            "start_column": 18917,
            "end_line": 4,
            "end_column": 19250,
            "start_byte": 18917,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 515,
            "start_column": 19256,
            "end_line": 4,
            "end_column": 22579,
            "start_byte": 19256,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 589,
            "start_column": 22585,
            "end_line": 4,
            "end_column": 22856,
            "start_byte": 22585,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 595,
            "start_column": 22862,
            "end_line": 4,
            "end_column": 23446,
            "start_byte": 22862,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 609,
            "start_column": 23452,
            "end_line": 4,
            "end_column": 23848,
            "start_byte": 23452,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 619,
            "start_column": 23854,
            "end_line": 4,
            "end_column": 24493,
            "start_byte": 23854,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 635,
            "start_column": 24499,
            "end_line": 4,
            "end_column": 24573,
            "start_byte": 24499,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class SubRequest(FixtureRequest):\n    \"\"\" a sub request for handling getting a fixture from a\n    test function/fixture. \"\"\"\n\n    def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager\n\n    def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)\n\n    def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 639,
            "start_column": 24576,
            "end_line": 0,
            "end_column": 25997,
            "start_byte": 24576,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.SubRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager",
            "start_line": 643,
            "start_column": 24706,
            "end_line": 4,
            "end_column": 25280,
            "start_byte": 24706,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)",
            "start_line": 657,
            "start_column": 25286,
            "end_line": 4,
            "end_column": 25384,
            "start_byte": 25286,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)",
            "start_line": 660,
            "start_column": 25390,
            "end_line": 4,
            "end_column": 25473,
            "start_byte": 25390,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.SubRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 663,
            "start_column": 25479,
            "end_line": 4,
            "end_column": 25997,
            "start_byte": 25479,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.scopes",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopes = \"session package module class function\".split()",
            "start_line": 674,
            "start_column": 26000,
            "end_line": 0,
            "end_column": 26056,
            "start_byte": 26000,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopenum_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopenum_function = scopes.index(\"function\")",
            "start_line": 675,
            "start_column": 26057,
            "end_line": 0,
            "end_column": 26101,
            "start_byte": 26057,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scopemismatch",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopemismatch(currentscope, newscope):\n    return scopes.index(newscope) > scopes.index(currentscope)",
            "start_line": 678,
            "start_column": 26104,
            "end_line": 0,
            "end_column": 26209,
            "start_byte": 26104,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.scope2index",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scope2index(scope, descr, where=None):\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\n    \"\"\"\n    try:\n        return scopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, \"from {} \".format(where) if where else \"\", scope\n            ),\n            pytrace=False,\n        )",
            "start_line": 682,
            "start_column": 26212,
            "end_line": 0,
            "end_column": 26623,
            "start_byte": 26212,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n\n    def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 697,
            "start_column": 26626,
            "end_line": 0,
            "end_column": 28844,
            "start_byte": 26626,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg",
            "start_line": 700,
            "start_column": 26741,
            "end_line": 4,
            "end_column": 26929,
            "start_byte": 26741,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupError.formatrepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 706,
            "start_column": 26935,
            "end_line": 4,
            "end_column": 28844,
            "start_byte": 26935,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 751,
            "start_column": 28847,
            "end_line": 0,
            "end_column": 29802,
            "start_byte": 28847,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname",
            "start_line": 752,
            "start_column": 28895,
            "end_line": 4,
            "end_column": 29141,
            "start_byte": 28895,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.toterminal",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 759,
            "start_column": 29147,
            "end_line": 4,
            "end_column": 29802,
            "start_byte": 29147,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.fail_fixturefunc",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)",
            "start_line": 778,
            "start_column": 29805,
            "end_line": 0,
            "end_column": 30055,
            "start_byte": 29805,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.call_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def call_fixture_func(fixturefunc, request, kwargs):\n    yieldctx = is_generator(fixturefunc)\n    if yieldctx:\n        it = fixturefunc(**kwargs)\n        res = next(it)\n        finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)\n        request.addfinalizer(finalizer)\n    else:\n        res = fixturefunc(**kwargs)\n    return res",
            "start_line": 785,
            "start_column": 30058,
            "end_line": 0,
            "end_column": 30407,
            "start_byte": 30058,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures._teardown_yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _teardown_yield_fixture(fixturefunc, it):\n    \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n    yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        fail_fixturefunc(\n            fixturefunc, \"yield_fixture function has more than one 'yield'\"\n        )",
            "start_line": 797,
            "start_column": 30410,
            "end_line": 0,
            "end_column": 30835,
            "start_byte": 30410,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.resolve_fixture_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def resolve_fixture_function(fixturedef, request):\n    \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n    instances and bound methods.\n    \"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # bind the unbound method to the TestCase instance\n            fixturefunc = fixturedef.func.__get__(request.instance)\n    else:\n        # the fixture function needs to be bound to the actual\n        # request.instance so that code working with \"fixturedef\" behaves\n        # as expected.\n        if request.instance is not None:\n            fixturefunc = getimfunc(fixturedef.func)\n            if fixturefunc != fixturedef.func:\n                fixturefunc = fixturefunc.__get__(request.instance)\n    return fixturefunc",
            "start_line": 904,
            "start_column": 34058,
            "end_line": 0,
            "end_column": 34896,
            "start_byte": 34058,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_fixture_setup(fixturedef, request):\n    \"\"\" Execution of fixture setup. \"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = request.param_index\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result",
            "start_line": 924,
            "start_column": 34899,
            "end_line": 0,
            "end_column": 35623,
            "start_byte": 34899,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures._ensure_immutable_ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _ensure_immutable_ids(ids):\n    if ids is None:\n        return\n    if callable(ids):\n        return ids\n    return tuple(ids)",
            "start_line": 944,
            "start_column": 35626,
            "end_line": 0,
            "end_column": 35755,
            "start_byte": 35626,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.wrap_function_to_error_out_if_called_directly",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\n    \"\"\"\n    message = FIXTURE_FUNCTION_CALL.format(\n        name=fixture_marker.name or function.__name__\n    )\n\n    @six.wraps(function)\n    def result(*args, **kwargs):\n        fail(message, pytrace=False)\n\n    # keep reference to the original function in our own custom attribute so we don't unwrap\n    # further than this point and lose useful wrappings like @mock.patch (#3774)\n    result.__pytest_wrapped__ = _PytestWrapper(function)\n\n    return result",
            "start_line": 952,
            "start_column": 35758,
            "end_line": 0,
            "end_column": 36444,
            "start_byte": 35758,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass FixtureFunctionMarker(object):\n    scope = attr.ib()\n    params = attr.ib(converter=attr.converters.optional(tuple))\n    autouse = attr.ib(default=False)\n    ids = attr.ib(default=None, converter=_ensure_immutable_ids)\n    name = attr.ib(default=None)\n\n    def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 971,
            "start_column": 36447,
            "end_line": 0,
            "end_column": 37339,
            "start_byte": 36447,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 973,
            "start_column": 36509,
            "end_line": 4,
            "end_column": 36526,
            "start_byte": 36509,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "params = attr.ib(converter=attr.converters.optional(tuple))",
            "start_line": 974,
            "start_column": 36531,
            "end_line": 4,
            "end_column": 36590,
            "start_byte": 36531,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "autouse = attr.ib(default=False)",
            "start_line": 975,
            "start_column": 36595,
            "end_line": 4,
            "end_column": 36627,
            "start_byte": 36595,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ids = attr.ib(default=None, converter=_ensure_immutable_ids)",
            "start_line": 976,
            "start_column": 36632,
            "end_line": 4,
            "end_column": 36692,
            "start_byte": 36632,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name = attr.ib(default=None)",
            "start_line": 977,
            "start_column": 36697,
            "end_line": 4,
            "end_column": 36725,
            "start_byte": 36697,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 979,
            "start_column": 36731,
            "end_line": 4,
            "end_column": 37339,
            "start_byte": 36731,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\"Decorator to mark a fixture factory function.\n\n    This decorator can be used, with or without parameters, to define a\n    fixture function.\n\n    The name of the fixture function can later be referenced to cause its\n    invocation ahead of running tests: test\n    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n    marker.\n\n    Test functions can directly use fixture names as input\n    arguments in which case the fixture instance returned from the fixture\n    function will be injected.\n\n    Fixtures can provide their values to test functions using ``return`` or ``yield``\n    statements. When using ``yield`` the code block after the ``yield`` statement is executed\n    as teardown code regardless of the test outcome, and must yield exactly once.\n\n    :arg scope: the scope for which this fixture is shared, one of\n                ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n                ``\"package\"`` or ``\"session\"``.\n\n                ``\"package\"`` is considered **experimental** at this time.\n\n    :arg params: an optional list of parameters which will cause multiple\n                invocations of the fixture function and all of the tests\n                using it.\n                The current parameter is available in ``request.param``.\n\n    :arg autouse: if True, the fixture func is activated for all tests that\n                can see it.  If False (the default) then an explicit\n                reference is needed to activate the fixture.\n\n    :arg ids: list of string ids each corresponding to the params\n                so that they are part of the test id. If no ids are provided\n                they will be generated automatically from the params.\n\n    :arg name: the name of the fixture. This defaults to the name of the\n                decorated function. If a fixture is used in the same module in\n                which it is defined, the function name of the fixture will be\n                shadowed by the function arg that requests the fixture; one way\n                to resolve this is to name the decorated function\n                ``fixture_<fixturename>`` and then use\n                ``@pytest.fixture(name='<fixturename>')``.\n    \"\"\"\n    if callable(scope) and params is None and autouse is False:\n        # direct decoration\n        return FixtureFunctionMarker(\"function\", params, autouse, name=name)(scope)\n    if params is not None and not isinstance(params, (list, tuple)):\n        params = list(params)\n    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)",
            "start_line": 997,
            "start_column": 37342,
            "end_line": 0,
            "end_column": 39985,
            "start_byte": 37342,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def yield_fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\" (return a) decorator to mark a yield-fixture factory function.\n\n    .. deprecated:: 3.0\n        Use :py:func:`pytest.fixture` directly instead.\n    \"\"\"\n    return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)",
            "start_line": 1051,
            "start_column": 39988,
            "end_line": 0,
            "end_column": 40317,
            "start_byte": 39988,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.defaultfuncargprefixmarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "defaultfuncargprefixmarker = fixture()",
            "start_line": 1060,
            "start_column": 40320,
            "end_line": 0,
            "end_column": 40358,
            "start_byte": 40320,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.pytestconfig",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@fixture(scope=\"session\")\ndef pytestconfig(request):\n    \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n\n    Example::\n\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n\n    \"\"\"\n    return request.config",
            "start_line": 1063,
            "start_column": 40361,
            "end_line": 0,
            "end_column": 40660,
            "start_byte": 40361,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager",
            "start_line": 421,
            "start_column": 13750,
            "end_line": 0,
            "end_column": 14210,
            "start_byte": 13750,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "tfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n  ",
            "start_line": 436,
            "start_column": 14213,
            "end_line": 0,
            "end_column": 14430,
            "start_byte": 14213,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.LineMatcher_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._reques",
            "start_line": 337,
            "start_column": 10280,
            "end_line": 0,
            "end_column": 10372,
            "start_byte": 10280,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Module._inject_setup_module_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixture",
            "start_line": 452,
            "start_column": 16149,
            "end_line": 4,
            "end_column": 17383,
            "start_byte": 16149,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Module._inject_setup_function_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(",
            "start_line": 480,
            "start_column": 17389,
            "end_line": 4,
            "end_column": 18651,
            "start_byte": 17389,
            "end_byte": 4
          },
          {
            "name": "_pytest.python._get_non_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e\n            ),\n            pytrace=False,\n        )\n\n\nclass FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_f",
            "start_line": 706,
            "start_column": 26570,
            "end_line": 0,
            "end_column": 26893,
            "start_byte": 26570,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Class._inject_setup_class_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": ", line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno",
            "start_line": 744,
            "start_column": 27769,
            "end_line": 4,
            "end_column": 28815,
            "start_byte": 27769,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Class._inject_setup_method_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "nes, msg, self.argname)\n\n\nclass FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))\n\n\ndef fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _py",
            "start_line": 768,
            "start_column": 28821,
            "end_line": 4,
            "end_column": 29945,
            "start_byte": 28821,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "TSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_",
            "start_line": 1238,
            "start_column": 47680,
            "end_line": 0,
            "end_column": 47815,
            "start_byte": 47680,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n      ",
            "start_line": 1244,
            "start_column": 47818,
            "end_line": 0,
            "end_column": 49588,
            "start_byte": 47818,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.showfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "       # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n",
            "start_line": 1296,
            "start_column": 49591,
            "end_line": 0,
            "end_column": 49711,
            "start_byte": 49591,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "             i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef\n",
            "start_line": 1302,
            "start_column": 49714,
            "end_line": 0,
            "end_column": 51470,
            "start_byte": 49714,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "om _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import get_real_method\nfrom _pytest.compat import getfslineno\nfrom _pytest.compat import getfuncargnames\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import isclass\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import safe_getattr\nfrom _pytest.deprecated import FIXTURE_FUNCTION_CALL\nfrom _pytest.deprecated import FIXTURE_NAMED_REQUEST\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\n\n@attr.s(frozen=True)\nclass PseudoFixtureDef(object",
            "start_line": 25,
            "start_column": 540,
            "end_line": 0,
            "end_column": 1250,
            "start_byte": 540,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "    cached_result = attr.ib()\n    scope = attr.ib()\n\n\ndef pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"funct",
            "start_line": 43,
            "start_column": 1253,
            "end_line": 0,
            "end_column": 1584,
            "start_byte": 1253,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly._show_fixture_action",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)\n\n\nscopename2class = {}\n\n\nscope2props = dict(session=())\nscope2props[\"package\"] = (\"fspath\",)\nscope2props[\"module\"] = (\"fspath\", \"module\")\nscope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\nscope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\nscope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n\n\ndef scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytes",
            "start_line": 52,
            "start_column": 1587,
            "end_line": 0,
            "end_column": 2566,
            "start_byte": 1587,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cinfo\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest.compat import _format_args\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat imp",
            "start_line": 18,
            "start_column": 406,
            "end_line": 0,
            "end_column": 689,
            "start_byte": 406,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.UnitTestCase._inject_setup_teardown_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n      ",
            "start_line": 65,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 2715,
            "start_byte": 2097,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ype(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current\n\n\ndef get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)\n\n\ndef add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for c",
            "start_line": 81,
            "start_column": 2718,
            "end_line": 0,
            "end_column": 3491,
            "start_byte": 2718,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.showfixtures",
            "file_path": "src/_pytest/python.py",
            "file_content": "def showfixtures(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)",
            "start_line": 1296,
            "start_column": 49591,
            "end_line": 0,
            "end_column": 49711,
            "start_byte": 49591,
            "end_byte": 0
          },
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _showfixtures_main(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    fm = session._fixturemanager\n\n    available = []\n    seen = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, curdir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    curdir.bestrelpath(loc),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, bestrel, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n                currentmodule = module\n        if verbose <= 0 and argname[0] == \"_\":\n            continue\n        if verbose > 0:\n            funcargspec = \"%s -- %s\" % (argname, bestrel)\n        else:\n            funcargspec = argname\n        tw.line(funcargspec, green=True)\n        loc = getlocation(fixturedef.func, curdir)\n        doc = fixturedef.func.__doc__ or \"\"\n        if doc:\n            write_docstring(tw, doc)\n        else:\n            tw.line(\"    %s: no docstring available\" % (loc,), red=True)",
            "start_line": 1302,
            "start_column": 49714,
            "end_line": 0,
            "end_column": 51470,
            "start_byte": 49714,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "To solve the issue of displaying fixture scopes with `pytest --fixtures`, we should identify where in the pytest codebase it deals with fixture management and display. There are several relevant places to look at:\n\n1. **Fixture Management and Definitions**:\n   - How fixtures are defined and stored (`FixtureDef` class and `FixtureManager` class).\n   - The function that sets up fixtures (`FixtureDef.execute`), which might provide a scope view.\n\n2. **Displaying Fixtures Information**:\n   - There is a `showfixtures` command in `_pytest/python.py` and its helper function `_showfixtures_main`, which seems directly related to displaying fixture information.\n\n3. **Scope Handling**:\n   - `scopeproperty` function allows accessing properties based on the scope, which might be useful to display in command outputs.\n   - `scopename2class` is a dictionary that maps scope names to classes which could be referenced for displaying information.\n\nCurrently, the `_showfixtures_main` function appears to handle outputting fixture information, but it does not show scope. Enhancing this function to also print the `scope` attribute from the `FixtureDef` objects would be a direct approach to solve the issue. The symbol `FixtureDef` is important as it contains a `scope` attribute, which should be displayed with other fixture info.\n\nBy altering `_showfixtures_main` to incorporate the `scope` details, it can be ensured that this information is available when the `--fixtures` option is used in pytest.\n\nThus the symbols likely requiring changes are:\n- `_pytest/python.py` in the `_showfixtures_main` function where fixture details are displayed.",
        "symbols": [
          {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/python.py",
            "reason": "Enhance this function to include displaying the scope of each fixture using the `scope` attribute from `FixtureDef`."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "The `_showfixtures_main` function in `_pytest/python.py` is responsible for collecting and displaying fixture information. However, it currently does not display scope information. It iterates through fixtures managed by the `FixtureManager` but misses the chance to display the `scope` property available in `FixtureDef`. Enhancing this function to show `FixtureDef.scope` should address the issue.",
          "The `FixtureDef` class contains a `scope` attribute which is vital for displaying the scope information of a fixture. By looking at how the scope is accessed in the `FixtureDef` class, especially in the `__init__` and other methods, it is evident that this is where the scope is established and should be accessed in the display function."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:46:06.511472",
        "usage": "4.544734954833984 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.capture.CaptureManager.activate_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n",
              "start_line": 153,
              "start_column": 5146,
              "end_line": 4,
              "end_column": 5446,
              "start_byte": 5146,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.deactivate_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "          get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node i",
              "start_line": 161,
              "start_column": 5452,
              "end_line": 4,
              "end_column": 5689,
              "start_byte": 5452,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.suspend_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "None:\n                node._name2pseudofixturedef[argname] = fixturedef\n\n\ndef getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't e",
              "start_line": 167,
              "start_column": 5695,
              "end_line": 4,
              "end_column": 5848,
              "start_byte": 5695,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.resume_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "r raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise ",
              "start_line": 172,
              "start_column": 5854,
              "end_line": 4,
              "end_column": 6005,
              "start_byte": 5854,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.global_and_fixture_disabled",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "t request)\n        # we don't expect them to be fixture functions\n        return None\n\n\ndef get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenu",
              "start_line": 179,
              "start_column": 6042,
              "end_line": 4,
              "end_column": 6299,
              "start_byte": 6042,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.capture_fixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "get(item, []):\n            items_by_argkey[scopenum][key].appendleft(",
              "start_line": 249,
              "start_column": 8145,
              "end_line": 0,
              "end_column": 8214,
              "start_byte": 8145,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture._ensure_only_one_capture_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "m)\n\n\ndef reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items",
              "start_line": 252,
              "start_column": 8217,
              "end_line": 0,
              "end_column": 8577,
              "start_byte": 8217,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture._install_capture_fixture_on_item",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "pecified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not incl",
              "start_line": 326,
              "start_column": 10965,
              "end_line": 0,
              "end_column": 11905,
              "start_byte": 10965,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest._setup_fixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-funct",
              "start_line": 433,
              "start_column": 14408,
              "end_line": 0,
              "end_column": 14874,
              "start_byte": 14408,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
              "start_line": 41,
              "start_column": 1200,
              "end_line": 0,
              "end_column": 1304,
              "start_byte": 1200,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "cached_result = attr.ib()",
              "start_line": 43,
              "start_column": 1257,
              "end_line": 4,
              "end_column": 1282,
              "start_byte": 1257,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scope = attr.ib()",
              "start_line": 44,
              "start_column": 1287,
              "end_line": 4,
              "end_column": 1304,
              "start_byte": 1287,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.pytest_sessionstart",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"function\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)",
              "start_line": 47,
              "start_column": 1307,
              "end_line": 0,
              "end_column": 1724,
              "start_byte": 1307,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scopename2class",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scopename2class = {}",
              "start_line": 63,
              "start_column": 1727,
              "end_line": 0,
              "end_column": 1747,
              "start_byte": 1727,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scope2props",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scope2props = dict(session=())",
              "start_line": 66,
              "start_column": 1750,
              "end_line": 0,
              "end_column": 1780,
              "start_byte": 1750,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scopeproperty",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope",
              "start_line": 74,
              "start_column": 2061,
              "end_line": 0,
              "end_column": 2506,
              "start_byte": 2061,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.get_scope_package",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current",
              "start_line": 90,
              "start_column": 2509,
              "end_line": 0,
              "end_column": 2894,
              "start_byte": 2509,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.get_scope_node",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)",
              "start_line": 105,
              "start_column": 2897,
              "end_line": 0,
              "end_column": 3059,
              "start_byte": 2897,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.add_funcarg_pseudo_fixture_def",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        return  # this function call does not have direct parametrization\n    # collect funcargs of all callspecs into a list of values\n    arg2params = {}\n    arg2scope = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # if we have a scope that is higher than function we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # use module-level collector for class-scope (for now)\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n                get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node is not None:\n                node._name2pseudofixturedef[argname] = fixturedef",
              "start_line": 112,
              "start_column": 3062,
              "end_line": 0,
              "end_column": 5766,
              "start_byte": 3062,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.getfixturemarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None",
              "start_line": 170,
              "start_column": 5769,
              "end_line": 0,
              "end_column": 6127,
              "start_byte": 5769,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.get_parametrized_fixture_keys",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenum < scopenum_function  # function\n    try:\n        cs = item.callspec\n    except AttributeError:\n        pass\n    else:\n        # cs.indices.items() is random order of argnames.  Need to\n        # sort this so that different calls to\n        # get_parametrized_fixture_keys will be deterministic.\n        for argname, param_index in sorted(cs.indices.items()):\n            if cs._arg2scopenum[argname] != scopenum:\n                continue\n            if scopenum == 0:  # session\n                key = (argname, param_index)\n            elif scopenum == 1:  # package\n                key = (argname, param_index, item.fspath.dirpath())\n            elif scopenum == 2:  # module\n                key = (argname, param_index, item.fspath)\n            elif scopenum == 3:  # class\n                key = (argname, param_index, item.fspath, item.cls)\n            yield key",
              "start_line": 181,
              "start_column": 6130,
              "end_line": 0,
              "end_column": 7166,
              "start_byte": 6130,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.reorder_items",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def reorder_items(items):\n    argkeys_cache = {}\n    items_by_argkey = {}\n    for scopenum in range(0, scopenum_function):\n        argkeys_cache[scopenum] = d = {}\n        items_by_argkey[scopenum] = item_d = defaultdict(deque)\n        for item in items:\n            keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items = OrderedDict.fromkeys(items)\n    return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))",
              "start_line": 213,
              "start_column": 7399,
              "end_line": 0,
              "end_column": 7991,
              "start_byte": 7399,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.fix_cache_order",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def fix_cache_order(item, argkeys_cache, items_by_argkey):\n    for scopenum in range(0, scopenum_function):\n        for key in argkeys_cache[scopenum].get(item, []):\n            items_by_argkey[scopenum][key].appendleft(item)",
              "start_line": 229,
              "start_column": 7994,
              "end_line": 0,
              "end_column": 8219,
              "start_byte": 7994,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.reorder_items_atscope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items_deque:\n        no_argkey_group = OrderedDict()\n        slicing_argkey = None\n        while items_deque:\n            item = items_deque.popleft()\n            if item in items_done or item in no_argkey_group:\n                continue\n            argkeys = OrderedDict.fromkeys(\n                k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n            )\n            if not argkeys:\n                no_argkey_group[item] = None\n            else:\n                slicing_argkey, _ = argkeys.popitem()\n                # we don't have to remove relevant items from later in the deque because they'll just be ignored\n                matching_items = [\n                    i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                ]\n                for i in reversed(matching_items):\n                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                    items_deque.appendleft(i)\n                break\n        if no_argkey_group:\n            no_argkey_group = reorder_items_atscope(\n                no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n            )\n            for item in no_argkey_group:\n                items_done[item] = None\n        ignore.add(slicing_argkey)\n    return items_done",
              "start_line": 235,
              "start_column": 8222,
              "end_line": 0,
              "end_column": 9844,
              "start_byte": 8222,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.fillfixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def fillfixtures(function):\n    \"\"\" fill missing funcargs for a test function. \"\"\"\n    try:\n        request = function._request\n    except AttributeError:\n        # XXX this special code path is only expected to execute\n        # with the oejskit plugin.  It uses classes with funcargs\n        # and we thus have to work a bit to allow this.\n        fm = function.session._fixturemanager\n        fi = fm.getfixtureinfo(function.parent, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._request = FixtureRequest(function)\n        request._fillfixtures()\n        # prune out funcargs for jstests\n        newfuncargs = {}\n        for name in fi.argnames:\n            newfuncargs[name] = function.funcargs[name]\n        function.funcargs = newfuncargs\n    else:\n        request._fillfixtures()",
              "start_line": 275,
              "start_column": 9847,
              "end_line": 0,
              "end_column": 10669,
              "start_byte": 9847,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.get_direct_param_fixture_func",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def get_direct_param_fixture_func(request):\n    return request.param",
              "start_line": 297,
              "start_column": 10672,
              "end_line": 0,
              "end_column": 10740,
              "start_byte": 10672,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@attr.s(slots=True)\nclass FuncFixtureInfo(object):\n    # original function argument names\n    argnames = attr.ib(type=tuple)\n    # argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
              "start_line": 301,
              "start_column": 10743,
              "end_line": 0,
              "end_column": 12559,
              "start_byte": 10743,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo.argnames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "argnames = attr.ib(type=tuple)",
              "start_line": 304,
              "start_column": 10837,
              "end_line": 4,
              "end_column": 10867,
              "start_byte": 10837,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo.initialnames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "initialnames = attr.ib(type=tuple)",
              "start_line": 308,
              "start_column": 11045,
              "end_line": 4,
              "end_column": 11079,
              "start_byte": 11045,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo.names_closure",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "names_closure = attr.ib()",
              "start_line": 309,
              "start_column": 11084,
              "end_line": 4,
              "end_column": 11109,
              "start_byte": 11084,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo.name2fixturedefs",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "name2fixturedefs = attr.ib()",
              "start_line": 310,
              "start_column": 11127,
              "end_line": 4,
              "end_column": 11155,
              "start_byte": 11127,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FuncFixtureInfo.prune_dependency_tree",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
              "start_line": 312,
              "start_column": 11192,
              "end_line": 4,
              "end_column": 12559,
              "start_byte": 11192,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
              "start_line": 340,
              "start_column": 12562,
              "end_line": 0,
              "end_column": 24573,
              "start_byte": 12562,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
              "start_line": 348,
              "start_column": 12848,
              "end_line": 4,
              "end_column": 13381,
              "start_byte": 12848,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.fixturenames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
              "start_line": 360,
              "start_column": 13387,
              "end_line": 4,
              "end_column": 13638,
              "start_byte": 13387,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.node",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
              "start_line": 367,
              "start_column": 13644,
              "end_line": 4,
              "end_column": 13796,
              "start_byte": 13644,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
              "start_line": 372,
              "start_column": 13802,
              "end_line": 4,
              "end_column": 14617,
              "start_byte": 13802,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.config",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
              "start_line": 388,
              "start_column": 14623,
              "end_line": 4,
              "end_column": 14764,
              "start_byte": 14623,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.function",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
              "start_line": 393,
              "start_column": 14770,
              "end_line": 4,
              "end_column": 14924,
              "start_byte": 14770,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.cls",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
              "start_line": 398,
              "start_column": 14930,
              "end_line": 4,
              "end_column": 15162,
              "start_byte": 14930,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.instance",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
              "start_line": 405,
              "start_column": 15168,
              "end_line": 4,
              "end_column": 15549,
              "start_byte": 15168,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.module",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
              "start_line": 415,
              "start_column": 15555,
              "end_line": 4,
              "end_column": 15738,
              "start_byte": 15555,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.fspath",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
              "start_line": 420,
              "start_column": 15744,
              "end_line": 4,
              "end_column": 15904,
              "start_byte": 15744,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.keywords",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
              "start_line": 425,
              "start_column": 15910,
              "end_line": 4,
              "end_column": 16046,
              "start_byte": 15910,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.session",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
              "start_line": 430,
              "start_column": 16052,
              "end_line": 4,
              "end_column": 16163,
              "start_byte": 16052,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
              "start_line": 435,
              "start_column": 16169,
              "end_line": 4,
              "end_column": 16485,
              "start_byte": 16169,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
              "start_line": 442,
              "start_column": 16491,
              "end_line": 4,
              "end_column": 16695,
              "start_byte": 16491,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.applymarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
              "start_line": 448,
              "start_column": 16701,
              "end_line": 4,
              "end_column": 17085,
              "start_byte": 16701,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.raiseerror",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
              "start_line": 458,
              "start_column": 17091,
              "end_line": 4,
              "end_column": 17255,
              "start_byte": 17091,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
              "start_line": 462,
              "start_column": 17261,
              "end_line": 4,
              "end_column": 17542,
              "start_byte": 17261,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
              "start_line": 469,
              "start_column": 17548,
              "end_line": 4,
              "end_column": 17982,
              "start_byte": 17548,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
              "start_line": 479,
              "start_column": 17988,
              "end_line": 4,
              "end_column": 18221,
              "start_byte": 17988,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
              "start_line": 486,
              "start_column": 18227,
              "end_line": 4,
              "end_column": 18911,
              "start_byte": 18227,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
              "start_line": 504,
              "start_column": 18917,
              "end_line": 4,
              "end_column": 19250,
              "start_byte": 18917,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
              "start_line": 515,
              "start_column": 19256,
              "end_line": 4,
              "end_column": 22579,
              "start_byte": 19256,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
              "start_line": 589,
              "start_column": 22585,
              "end_line": 4,
              "end_column": 22856,
              "start_byte": 22585,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._check_scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
              "start_line": 595,
              "start_column": 22862,
              "end_line": 4,
              "end_column": 23446,
              "start_byte": 22862,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
              "start_line": 609,
              "start_column": 23452,
              "end_line": 4,
              "end_column": 23848,
              "start_byte": 23452,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
              "start_line": 619,
              "start_column": 23854,
              "end_line": 4,
              "end_column": 24493,
              "start_byte": 23854,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
              "start_line": 635,
              "start_column": 24499,
              "end_line": 4,
              "end_column": 24573,
              "start_byte": 24499,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.SubRequest",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class SubRequest(FixtureRequest):\n    \"\"\" a sub request for handling getting a fixture from a\n    test function/fixture. \"\"\"\n\n    def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager\n\n    def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)\n\n    def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
              "start_line": 639,
              "start_column": 24576,
              "end_line": 0,
              "end_column": 25997,
              "start_byte": 24576,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.SubRequest.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager",
              "start_line": 643,
              "start_column": 24706,
              "end_line": 4,
              "end_column": 25280,
              "start_byte": 24706,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.SubRequest.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)",
              "start_line": 657,
              "start_column": 25286,
              "end_line": 4,
              "end_column": 25384,
              "start_byte": 25286,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.SubRequest.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)",
              "start_line": 660,
              "start_column": 25390,
              "end_line": 4,
              "end_column": 25473,
              "start_byte": 25390,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.SubRequest._schedule_finalizers",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
              "start_line": 663,
              "start_column": 25479,
              "end_line": 4,
              "end_column": 25997,
              "start_byte": 25479,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.scopes",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scopes = \"session package module class function\".split()",
              "start_line": 674,
              "start_column": 26000,
              "end_line": 0,
              "end_column": 26056,
              "start_byte": 26000,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scopenum_function",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scopenum_function = scopes.index(\"function\")",
              "start_line": 675,
              "start_column": 26057,
              "end_line": 0,
              "end_column": 26101,
              "start_byte": 26057,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scopemismatch",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def scopemismatch(currentscope, newscope):\n    return scopes.index(newscope) > scopes.index(currentscope)",
              "start_line": 678,
              "start_column": 26104,
              "end_line": 0,
              "end_column": 26209,
              "start_byte": 26104,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.scope2index",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def scope2index(scope, descr, where=None):\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\n    \"\"\"\n    try:\n        return scopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, \"from {} \".format(where) if where else \"\", scope\n            ),\n            pytrace=False,\n        )",
              "start_line": 682,
              "start_column": 26212,
              "end_line": 0,
              "end_column": 26623,
              "start_byte": 26212,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureLookupError",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n\n    def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
              "start_line": 697,
              "start_column": 26626,
              "end_line": 0,
              "end_column": 28844,
              "start_byte": 26626,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureLookupError.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg",
              "start_line": 700,
              "start_column": 26741,
              "end_line": 4,
              "end_column": 26929,
              "start_byte": 26741,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureLookupError.formatrepr",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
              "start_line": 706,
              "start_column": 26935,
              "end_line": 4,
              "end_column": 28844,
              "start_byte": 26935,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureLookupErrorRepr",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
              "start_line": 751,
              "start_column": 28847,
              "end_line": 0,
              "end_column": 29802,
              "start_byte": 28847,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureLookupErrorRepr.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname",
              "start_line": 752,
              "start_column": 28895,
              "end_line": 4,
              "end_column": 29141,
              "start_byte": 28895,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureLookupErrorRepr.toterminal",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
              "start_line": 759,
              "start_column": 29147,
              "end_line": 4,
              "end_column": 29802,
              "start_byte": 29147,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.fail_fixturefunc",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)",
              "start_line": 778,
              "start_column": 29805,
              "end_line": 0,
              "end_column": 30055,
              "start_byte": 29805,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.call_fixture_func",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def call_fixture_func(fixturefunc, request, kwargs):\n    yieldctx = is_generator(fixturefunc)\n    if yieldctx:\n        it = fixturefunc(**kwargs)\n        res = next(it)\n        finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)\n        request.addfinalizer(finalizer)\n    else:\n        res = fixturefunc(**kwargs)\n    return res",
              "start_line": 785,
              "start_column": 30058,
              "end_line": 0,
              "end_column": 30407,
              "start_byte": 30058,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures._teardown_yield_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _teardown_yield_fixture(fixturefunc, it):\n    \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n    yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        fail_fixturefunc(\n            fixturefunc, \"yield_fixture function has more than one 'yield'\"\n        )",
              "start_line": 797,
              "start_column": 30410,
              "end_line": 0,
              "end_column": 30835,
              "start_byte": 30410,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
              "start_line": 810,
              "start_column": 30838,
              "end_line": 0,
              "end_column": 34055,
              "start_byte": 30838,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
              "start_line": 813,
              "start_column": 30919,
              "end_line": 4,
              "end_column": 31651,
              "start_byte": 30919,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
              "start_line": 841,
              "start_column": 31657,
              "end_line": 4,
              "end_column": 31734,
              "start_byte": 31657,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.finish",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
              "start_line": 844,
              "start_column": 31740,
              "end_line": 4,
              "end_column": 32769,
              "start_byte": 31740,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.execute",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
              "start_line": 871,
              "start_column": 32775,
              "end_line": 4,
              "end_column": 33881,
              "start_byte": 32775,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
              "start_line": 896,
              "start_column": 33887,
              "end_line": 4,
              "end_column": 34055,
              "start_byte": 33887,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.resolve_fixture_function",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def resolve_fixture_function(fixturedef, request):\n    \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n    instances and bound methods.\n    \"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # bind the unbound method to the TestCase instance\n            fixturefunc = fixturedef.func.__get__(request.instance)\n    else:\n        # the fixture function needs to be bound to the actual\n        # request.instance so that code working with \"fixturedef\" behaves\n        # as expected.\n        if request.instance is not None:\n            fixturefunc = getimfunc(fixturedef.func)\n            if fixturefunc != fixturedef.func:\n                fixturefunc = fixturefunc.__get__(request.instance)\n    return fixturefunc",
              "start_line": 904,
              "start_column": 34058,
              "end_line": 0,
              "end_column": 34896,
              "start_byte": 34058,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytest_fixture_setup",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_fixture_setup(fixturedef, request):\n    \"\"\" Execution of fixture setup. \"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = request.param_index\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result",
              "start_line": 924,
              "start_column": 34899,
              "end_line": 0,
              "end_column": 35623,
              "start_byte": 34899,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures._ensure_immutable_ids",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _ensure_immutable_ids(ids):\n    if ids is None:\n        return\n    if callable(ids):\n        return ids\n    return tuple(ids)",
              "start_line": 944,
              "start_column": 35626,
              "end_line": 0,
              "end_column": 35755,
              "start_byte": 35626,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.wrap_function_to_error_out_if_called_directly",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\n    \"\"\"\n    message = FIXTURE_FUNCTION_CALL.format(\n        name=fixture_marker.name or function.__name__\n    )\n\n    @six.wraps(function)\n    def result(*args, **kwargs):\n        fail(message, pytrace=False)\n\n    # keep reference to the original function in our own custom attribute so we don't unwrap\n    # further than this point and lose useful wrappings like @mock.patch (#3774)\n    result.__pytest_wrapped__ = _PytestWrapper(function)\n\n    return result",
              "start_line": 952,
              "start_column": 35758,
              "end_line": 0,
              "end_column": 36444,
              "start_byte": 35758,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@attr.s(frozen=True)\nclass FixtureFunctionMarker(object):\n    scope = attr.ib()\n    params = attr.ib(converter=attr.converters.optional(tuple))\n    autouse = attr.ib(default=False)\n    ids = attr.ib(default=None, converter=_ensure_immutable_ids)\n    name = attr.ib(default=None)\n\n    def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
              "start_line": 971,
              "start_column": 36447,
              "end_line": 0,
              "end_column": 37339,
              "start_byte": 36447,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scope = attr.ib()",
              "start_line": 973,
              "start_column": 36509,
              "end_line": 4,
              "end_column": 36526,
              "start_byte": 36509,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.params",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "params = attr.ib(converter=attr.converters.optional(tuple))",
              "start_line": 974,
              "start_column": 36531,
              "end_line": 4,
              "end_column": 36590,
              "start_byte": 36531,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "autouse = attr.ib(default=False)",
              "start_line": 975,
              "start_column": 36595,
              "end_line": 4,
              "end_column": 36627,
              "start_byte": 36595,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "ids = attr.ib(default=None, converter=_ensure_immutable_ids)",
              "start_line": 976,
              "start_column": 36632,
              "end_line": 4,
              "end_column": 36692,
              "start_byte": 36632,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.name",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "name = attr.ib(default=None)",
              "start_line": 977,
              "start_column": 36697,
              "end_line": 4,
              "end_column": 36725,
              "start_byte": 36697,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
              "start_line": 979,
              "start_column": 36731,
              "end_line": 4,
              "end_column": 37339,
              "start_byte": 36731,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\"Decorator to mark a fixture factory function.\n\n    This decorator can be used, with or without parameters, to define a\n    fixture function.\n\n    The name of the fixture function can later be referenced to cause its\n    invocation ahead of running tests: test\n    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n    marker.\n\n    Test functions can directly use fixture names as input\n    arguments in which case the fixture instance returned from the fixture\n    function will be injected.\n\n    Fixtures can provide their values to test functions using ``return`` or ``yield``\n    statements. When using ``yield`` the code block after the ``yield`` statement is executed\n    as teardown code regardless of the test outcome, and must yield exactly once.\n\n    :arg scope: the scope for which this fixture is shared, one of\n                ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n                ``\"package\"`` or ``\"session\"``.\n\n                ``\"package\"`` is considered **experimental** at this time.\n\n    :arg params: an optional list of parameters which will cause multiple\n                invocations of the fixture function and all of the tests\n                using it.\n                The current parameter is available in ``request.param``.\n\n    :arg autouse: if True, the fixture func is activated for all tests that\n                can see it.  If False (the default) then an explicit\n                reference is needed to activate the fixture.\n\n    :arg ids: list of string ids each corresponding to the params\n                so that they are part of the test id. If no ids are provided\n                they will be generated automatically from the params.\n\n    :arg name: the name of the fixture. This defaults to the name of the\n                decorated function. If a fixture is used in the same module in\n                which it is defined, the function name of the fixture will be\n                shadowed by the function arg that requests the fixture; one way\n                to resolve this is to name the decorated function\n                ``fixture_<fixturename>`` and then use\n                ``@pytest.fixture(name='<fixturename>')``.\n    \"\"\"\n    if callable(scope) and params is None and autouse is False:\n        # direct decoration\n        return FixtureFunctionMarker(\"function\", params, autouse, name=name)(scope)\n    if params is not None and not isinstance(params, (list, tuple)):\n        params = list(params)\n    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)",
              "start_line": 997,
              "start_column": 37342,
              "end_line": 0,
              "end_column": 39985,
              "start_byte": 37342,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.yield_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def yield_fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\" (return a) decorator to mark a yield-fixture factory function.\n\n    .. deprecated:: 3.0\n        Use :py:func:`pytest.fixture` directly instead.\n    \"\"\"\n    return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)",
              "start_line": 1051,
              "start_column": 39988,
              "end_line": 0,
              "end_column": 40317,
              "start_byte": 39988,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.defaultfuncargprefixmarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "defaultfuncargprefixmarker = fixture()",
              "start_line": 1060,
              "start_column": 40320,
              "end_line": 0,
              "end_column": 40358,
              "start_byte": 40320,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.pytestconfig",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@fixture(scope=\"session\")\ndef pytestconfig(request):\n    \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n\n    Example::\n\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n\n    \"\"\"\n    return request.config",
              "start_line": 1063,
              "start_column": 40361,
              "end_line": 0,
              "end_column": 40660,
              "start_byte": 40361,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureManager",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1077,
              "start_column": 40663,
              "end_line": 0,
              "end_column": 50680,
              "start_byte": 40663,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupError = FixtureLookupError",
              "start_line": 1109,
              "start_column": 41972,
              "end_line": 4,
              "end_column": 42011,
              "start_byte": 41972,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
              "start_line": 1110,
              "start_column": 42016,
              "end_line": 4,
              "end_column": 42063,
              "start_byte": 42016,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
              "start_line": 1112,
              "start_column": 42069,
              "end_line": 4,
              "end_column": 42414,
              "start_byte": 42069,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
              "start_line": 1121,
              "start_column": 42420,
              "end_line": 4,
              "end_column": 43070,
              "start_byte": 42420,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
              "start_line": 1136,
              "start_column": 43076,
              "end_line": 4,
              "end_column": 43711,
              "start_byte": 43076,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._getautousenames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
              "start_line": 1153,
              "start_column": 43717,
              "end_line": 4,
              "end_column": 44222,
              "start_byte": 43717,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
              "start_line": 1166,
              "start_column": 44228,
              "end_line": 4,
              "end_column": 46132,
              "start_byte": 44228,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
              "start_line": 1212,
              "start_column": 46138,
              "end_line": 4,
              "end_column": 47495,
              "start_byte": 46138,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
              "start_line": 1242,
              "start_column": 47501,
              "end_line": 4,
              "end_column": 47627,
              "start_byte": 47501,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.parsefactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
              "start_line": 1246,
              "start_column": 47633,
              "end_line": 4,
              "end_column": 50003,
              "start_byte": 47633,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
              "start_line": 1306,
              "start_column": 50009,
              "end_line": 4,
              "end_column": 50494,
              "start_byte": 50009,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._matchfactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1320,
              "start_column": 50500,
              "end_line": 4,
              "end_column": 50680,
              "start_byte": 50500,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_fixture_setup",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager",
              "start_line": 421,
              "start_column": 13750,
              "end_line": 0,
              "end_column": 14210,
              "start_byte": 13750,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_fixture_post_finalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "tfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n  ",
              "start_line": 436,
              "start_column": 14213,
              "end_line": 0,
              "end_column": 14430,
              "start_byte": 14213,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.LineMatcher_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "t, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._reques",
              "start_line": 337,
              "start_column": 10280,
              "end_line": 0,
              "end_column": 10372,
              "start_byte": 10280,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Module._inject_setup_module_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "ncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixture",
              "start_line": 452,
              "start_column": 16149,
              "end_line": 4,
              "end_column": 17383,
              "start_byte": 16149,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Module._inject_setup_function_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(",
              "start_line": 480,
              "start_column": 17389,
              "end_line": 4,
              "end_column": 18651,
              "start_byte": 17389,
              "end_byte": 4
            },
            {
              "name": "_pytest.python._get_non_fixture_func",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "e\n            ),\n            pytrace=False,\n        )\n\n\nclass FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_f",
              "start_line": 706,
              "start_column": 26570,
              "end_line": 0,
              "end_column": 26893,
              "start_byte": 26570,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Class._inject_setup_class_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": ", line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno",
              "start_line": 744,
              "start_column": 27769,
              "end_line": 4,
              "end_column": 28815,
              "start_byte": 27769,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Class._inject_setup_method_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "nes, msg, self.argname)\n\n\nclass FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))\n\n\ndef fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _py",
              "start_line": 768,
              "start_column": 28821,
              "end_line": 4,
              "end_column": 29945,
              "start_byte": 28821,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.show_fixtures_per_test",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "TSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_",
              "start_line": 1238,
              "start_column": 47680,
              "end_line": 0,
              "end_column": 47815,
              "start_byte": 47680,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._show_fixtures_per_test",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n      ",
              "start_line": 1244,
              "start_column": 47818,
              "end_line": 0,
              "end_column": 49588,
              "start_byte": 47818,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.showfixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "       # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n",
              "start_line": 1296,
              "start_column": 49591,
              "end_line": 0,
              "end_column": 49711,
              "start_byte": 49591,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "             i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef\n",
              "start_line": 1302,
              "start_column": 49714,
              "end_line": 0,
              "end_column": 51470,
              "start_byte": 49714,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_fixture_setup",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "om _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import get_real_method\nfrom _pytest.compat import getfslineno\nfrom _pytest.compat import getfuncargnames\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import isclass\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import safe_getattr\nfrom _pytest.deprecated import FIXTURE_FUNCTION_CALL\nfrom _pytest.deprecated import FIXTURE_NAMED_REQUEST\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\n\n@attr.s(frozen=True)\nclass PseudoFixtureDef(object",
              "start_line": 25,
              "start_column": 540,
              "end_line": 0,
              "end_column": 1250,
              "start_byte": 540,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_fixture_post_finalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "    cached_result = attr.ib()\n    scope = attr.ib()\n\n\ndef pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"funct",
              "start_line": 43,
              "start_column": 1253,
              "end_line": 0,
              "end_column": 1584,
              "start_byte": 1253,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly._show_fixture_action",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)\n\n\nscopename2class = {}\n\n\nscope2props = dict(session=())\nscope2props[\"package\"] = (\"fspath\",)\nscope2props[\"module\"] = (\"fspath\", \"module\")\nscope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\nscope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\nscope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n\n\ndef scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytes",
              "start_line": 52,
              "start_column": 1587,
              "end_line": 0,
              "end_column": 2566,
              "start_byte": 1587,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_fixture_setup",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "cinfo\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest.compat import _format_args\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat imp",
              "start_line": 18,
              "start_column": 406,
              "end_line": 0,
              "end_column": 689,
              "start_byte": 406,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.UnitTestCase._inject_setup_teardown_fixtures",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "e):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n      ",
              "start_line": 65,
              "start_column": 2097,
              "end_line": 4,
              "end_column": 2715,
              "start_byte": 2097,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest._make_xunit_fixture",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "ype(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current\n\n\ndef get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)\n\n\ndef add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for c",
              "start_line": 81,
              "start_column": 2718,
              "end_line": 0,
              "end_column": 3491,
              "start_byte": 2718,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.showfixtures",
              "file_path": "src/_pytest/python.py",
              "file_content": "def showfixtures(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)",
              "start_line": 1296,
              "start_column": 49591,
              "end_line": 0,
              "end_column": 49711,
              "start_byte": 49591,
              "end_byte": 0
            },
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _showfixtures_main(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    fm = session._fixturemanager\n\n    available = []\n    seen = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, curdir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    curdir.bestrelpath(loc),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, bestrel, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n                currentmodule = module\n        if verbose <= 0 and argname[0] == \"_\":\n            continue\n        if verbose > 0:\n            funcargspec = \"%s -- %s\" % (argname, bestrel)\n        else:\n            funcargspec = argname\n        tw.line(funcargspec, green=True)\n        loc = getlocation(fixturedef.func, curdir)\n        doc = fixturedef.func.__doc__ or \"\"\n        if doc:\n            write_docstring(tw, doc)\n        else:\n            tw.line(\"    %s: no docstring available\" % (loc,), red=True)",
              "start_line": 1302,
              "start_column": 49714,
              "end_line": 0,
              "end_column": 51470,
              "start_byte": 49714,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "To solve the issue of displaying fixture scopes with `pytest --fixtures`, we should identify where in the pytest codebase it deals with fixture management and display. There are several relevant places to look at:\n\n1. **Fixture Management and Definitions**:\n   - How fixtures are defined and stored (`FixtureDef` class and `FixtureManager` class).\n   - The function that sets up fixtures (`FixtureDef.execute`), which might provide a scope view.\n\n2. **Displaying Fixtures Information**:\n   - There is a `showfixtures` command in `_pytest/python.py` and its helper function `_showfixtures_main`, which seems directly related to displaying fixture information.\n\n3. **Scope Handling**:\n   - `scopeproperty` function allows accessing properties based on the scope, which might be useful to display in command outputs.\n   - `scopename2class` is a dictionary that maps scope names to classes which could be referenced for displaying information.\n\nCurrently, the `_showfixtures_main` function appears to handle outputting fixture information, but it does not show scope. Enhancing this function to also print the `scope` attribute from the `FixtureDef` objects would be a direct approach to solve the issue. The symbol `FixtureDef` is important as it contains a `scope` attribute, which should be displayed with other fixture info.\n\nBy altering `_showfixtures_main` to incorporate the `scope` details, it can be ensured that this information is available when the `--fixtures` option is used in pytest.\n\nThus the symbols likely requiring changes are:\n- `_pytest/python.py` in the `_showfixtures_main` function where fixture details are displayed.",
          "symbols": [
            {
              "name": "_pytest.python._showfixtures_main",
              "file_path": "src/_pytest/python.py",
              "reason": "Enhance this function to include displaying the scope of each fixture using the `scope` attribute from `FixtureDef`."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "The `_showfixtures_main` function in `_pytest/python.py` is responsible for collecting and displaying fixture information. However, it currently does not display scope information. It iterates through fixtures managed by the `FixtureManager` but misses the chance to display the `scope` property available in `FixtureDef`. Enhancing this function to show `FixtureDef.scope` should address the issue.",
            "The `FixtureDef` class contains a `scope` attribute which is vital for displaying the scope information of a fixture. By looking at how the scope is accessed in the `FixtureDef` class, especially in the `__init__` and other methods, it is evident that this is where the scope is established and should be accessed in the display function."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/python.py"
        ],
        "symbols": [
          "_pytest.python._showfixtures_main"
        ],
        "code_spans": {
          "_pytest.capture.CaptureManager.activate_fixture": {
            "name": "_pytest.capture.CaptureManager.activate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n",
            "start_line": 153,
            "start_column": 5146,
            "end_line": 4,
            "end_column": 5446,
            "start_byte": 5146,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.deactivate_fixture": {
            "name": "_pytest.capture.CaptureManager.deactivate_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "          get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node i",
            "start_line": 161,
            "start_column": 5452,
            "end_line": 4,
            "end_column": 5689,
            "start_byte": 5452,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.suspend_fixture": {
            "name": "_pytest.capture.CaptureManager.suspend_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "None:\n                node._name2pseudofixturedef[argname] = fixturedef\n\n\ndef getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't e",
            "start_line": 167,
            "start_column": 5695,
            "end_line": 4,
            "end_column": 5848,
            "start_byte": 5695,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.resume_fixture": {
            "name": "_pytest.capture.CaptureManager.resume_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "r raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise ",
            "start_line": 172,
            "start_column": 5854,
            "end_line": 4,
            "end_column": 6005,
            "start_byte": 5854,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.global_and_fixture_disabled": {
            "name": "_pytest.capture.CaptureManager.global_and_fixture_disabled",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t request)\n        # we don't expect them to be fixture functions\n        return None\n\n\ndef get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenu",
            "start_line": 179,
            "start_column": 6042,
            "end_line": 4,
            "end_column": 6299,
            "start_byte": 6042,
            "end_byte": 4
          },
          "_pytest.capture.capture_fixtures": {
            "name": "_pytest.capture.capture_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(item, []):\n            items_by_argkey[scopenum][key].appendleft(",
            "start_line": 249,
            "start_column": 8145,
            "end_line": 0,
            "end_column": 8214,
            "start_byte": 8145,
            "end_byte": 0
          },
          "_pytest.capture._ensure_only_one_capture_fixture": {
            "name": "_pytest.capture._ensure_only_one_capture_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "m)\n\n\ndef reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items",
            "start_line": 252,
            "start_column": 8217,
            "end_line": 0,
            "end_column": 8577,
            "start_byte": 8217,
            "end_byte": 0
          },
          "_pytest.capture._install_capture_fixture_on_item": {
            "name": "_pytest.capture._install_capture_fixture_on_item",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "pecified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not incl",
            "start_line": 326,
            "start_column": 10965,
            "end_line": 0,
            "end_column": 11905,
            "start_byte": 10965,
            "end_byte": 0
          },
          "_pytest.doctest._setup_fixtures": {
            "name": "_pytest.doctest._setup_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-funct",
            "start_line": 433,
            "start_column": 14408,
            "end_line": 0,
            "end_column": 14874,
            "start_byte": 14408,
            "end_byte": 0
          },
          "_pytest.fixtures.PseudoFixtureDef": {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          "_pytest.fixtures.PseudoFixtureDef.cached_result": {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          "_pytest.fixtures.PseudoFixtureDef.scope": {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          "_pytest.fixtures.pytest_sessionstart": {
            "name": "_pytest.fixtures.pytest_sessionstart",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"function\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)",
            "start_line": 47,
            "start_column": 1307,
            "end_line": 0,
            "end_column": 1724,
            "start_byte": 1307,
            "end_byte": 0
          },
          "_pytest.fixtures.scopename2class": {
            "name": "_pytest.fixtures.scopename2class",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopename2class = {}",
            "start_line": 63,
            "start_column": 1727,
            "end_line": 0,
            "end_column": 1747,
            "start_byte": 1727,
            "end_byte": 0
          },
          "_pytest.fixtures.scope2props": {
            "name": "_pytest.fixtures.scope2props",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope2props = dict(session=())",
            "start_line": 66,
            "start_column": 1750,
            "end_line": 0,
            "end_column": 1780,
            "start_byte": 1750,
            "end_byte": 0
          },
          "_pytest.fixtures.scopeproperty": {
            "name": "_pytest.fixtures.scopeproperty",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope",
            "start_line": 74,
            "start_column": 2061,
            "end_line": 0,
            "end_column": 2506,
            "start_byte": 2061,
            "end_byte": 0
          },
          "_pytest.fixtures.get_scope_package": {
            "name": "_pytest.fixtures.get_scope_package",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n        type(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current",
            "start_line": 90,
            "start_column": 2509,
            "end_line": 0,
            "end_column": 2894,
            "start_byte": 2509,
            "end_byte": 0
          },
          "_pytest.fixtures.get_scope_node": {
            "name": "_pytest.fixtures.get_scope_node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)",
            "start_line": 105,
            "start_column": 2897,
            "end_line": 0,
            "end_column": 3059,
            "start_byte": 2897,
            "end_byte": 0
          },
          "_pytest.fixtures.add_funcarg_pseudo_fixture_def": {
            "name": "_pytest.fixtures.add_funcarg_pseudo_fixture_def",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for creating the fixturedefs within its methods.\n    if not metafunc._calls[0].funcargs:\n        return  # this function call does not have direct parametrization\n    # collect funcargs of all callspecs into a list of values\n    arg2params = {}\n    arg2scope = {}\n    for callspec in metafunc._calls:\n        for argname, argvalue in callspec.funcargs.items():\n            assert argname not in callspec.params\n            callspec.params[argname] = argvalue\n            arg2params_list = arg2params.setdefault(argname, [])\n            callspec.indices[argname] = len(arg2params_list)\n            arg2params_list.append(argvalue)\n            if argname not in arg2scope:\n                scopenum = callspec._arg2scopenum.get(argname, scopenum_function)\n                arg2scope[argname] = scopes[scopenum]\n        callspec.funcargs.clear()\n\n    # register artificial FixtureDef's so that later at test execution\n    # time we can rely on a proper FixtureDef to exist for fixture setup.\n    arg2fixturedefs = metafunc._arg2fixturedefs\n    for argname, valuelist in arg2params.items():\n        # if we have a scope that is higher than function we need\n        # to make sure we only ever create an according fixturedef on\n        # a per-scope basis. We thus store and cache the fixturedef on the\n        # node related to the scope.\n        scope = arg2scope[argname]\n        node = None\n        if scope != \"function\":\n            node = get_scope_node(collector, scope)\n            if node is None:\n                assert scope == \"class\" and isinstance(collector, _pytest.python.Module)\n                # use module-level collector for class-scope (for now)\n                node = collector\n        if node and argname in node._name2pseudofixturedef:\n            arg2fixturedefs[argname] = [node._name2pseudofixturedef[argname]]\n        else:\n            fixturedef = FixtureDef(\n                fixturemanager,\n                \"\",\n                argname,\n                get_direct_param_fixture_func,\n                arg2scope[argname],\n                valuelist,\n                False,\n                False,\n            )\n            arg2fixturedefs[argname] = [fixturedef]\n            if node is not None:\n                node._name2pseudofixturedef[argname] = fixturedef",
            "start_line": 112,
            "start_column": 3062,
            "end_line": 0,
            "end_column": 5766,
            "start_byte": 3062,
            "end_byte": 0
          },
          "_pytest.fixtures.getfixturemarker": {
            "name": "_pytest.fixtures.getfixturemarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturemarker(obj):\n    \"\"\" return fixturemarker or None if it doesn't exist or raised\n    exceptions.\"\"\"\n    try:\n        return getattr(obj, \"_pytestfixturefunction\", None)\n    except TEST_OUTCOME:\n        # some objects raise errors like request (from flask import request)\n        # we don't expect them to be fixture functions\n        return None",
            "start_line": 170,
            "start_column": 5769,
            "end_line": 0,
            "end_column": 6127,
            "start_byte": 5769,
            "end_byte": 0
          },
          "_pytest.fixtures.get_parametrized_fixture_keys": {
            "name": "_pytest.fixtures.get_parametrized_fixture_keys",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_parametrized_fixture_keys(item, scopenum):\n    \"\"\" return list of keys for all parametrized arguments which match\n    the specified scope. \"\"\"\n    assert scopenum < scopenum_function  # function\n    try:\n        cs = item.callspec\n    except AttributeError:\n        pass\n    else:\n        # cs.indices.items() is random order of argnames.  Need to\n        # sort this so that different calls to\n        # get_parametrized_fixture_keys will be deterministic.\n        for argname, param_index in sorted(cs.indices.items()):\n            if cs._arg2scopenum[argname] != scopenum:\n                continue\n            if scopenum == 0:  # session\n                key = (argname, param_index)\n            elif scopenum == 1:  # package\n                key = (argname, param_index, item.fspath.dirpath())\n            elif scopenum == 2:  # module\n                key = (argname, param_index, item.fspath)\n            elif scopenum == 3:  # class\n                key = (argname, param_index, item.fspath, item.cls)\n            yield key",
            "start_line": 181,
            "start_column": 6130,
            "end_line": 0,
            "end_column": 7166,
            "start_byte": 6130,
            "end_byte": 0
          },
          "_pytest.fixtures.reorder_items": {
            "name": "_pytest.fixtures.reorder_items",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items(items):\n    argkeys_cache = {}\n    items_by_argkey = {}\n    for scopenum in range(0, scopenum_function):\n        argkeys_cache[scopenum] = d = {}\n        items_by_argkey[scopenum] = item_d = defaultdict(deque)\n        for item in items:\n            keys = OrderedDict.fromkeys(get_parametrized_fixture_keys(item, scopenum))\n            if keys:\n                d[item] = keys\n                for key in keys:\n                    item_d[key].append(item)\n    items = OrderedDict.fromkeys(items)\n    return list(reorder_items_atscope(items, argkeys_cache, items_by_argkey, 0))",
            "start_line": 213,
            "start_column": 7399,
            "end_line": 0,
            "end_column": 7991,
            "start_byte": 7399,
            "end_byte": 0
          },
          "_pytest.fixtures.fix_cache_order": {
            "name": "_pytest.fixtures.fix_cache_order",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fix_cache_order(item, argkeys_cache, items_by_argkey):\n    for scopenum in range(0, scopenum_function):\n        for key in argkeys_cache[scopenum].get(item, []):\n            items_by_argkey[scopenum][key].appendleft(item)",
            "start_line": 229,
            "start_column": 7994,
            "end_line": 0,
            "end_column": 8219,
            "start_byte": 7994,
            "end_byte": 0
          },
          "_pytest.fixtures.reorder_items_atscope": {
            "name": "_pytest.fixtures.reorder_items_atscope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def reorder_items_atscope(items, argkeys_cache, items_by_argkey, scopenum):\n    if scopenum >= scopenum_function or len(items) < 3:\n        return items\n    ignore = set()\n    items_deque = deque(items)\n    items_done = OrderedDict()\n    scoped_items_by_argkey = items_by_argkey[scopenum]\n    scoped_argkeys_cache = argkeys_cache[scopenum]\n    while items_deque:\n        no_argkey_group = OrderedDict()\n        slicing_argkey = None\n        while items_deque:\n            item = items_deque.popleft()\n            if item in items_done or item in no_argkey_group:\n                continue\n            argkeys = OrderedDict.fromkeys(\n                k for k in scoped_argkeys_cache.get(item, []) if k not in ignore\n            )\n            if not argkeys:\n                no_argkey_group[item] = None\n            else:\n                slicing_argkey, _ = argkeys.popitem()\n                # we don't have to remove relevant items from later in the deque because they'll just be ignored\n                matching_items = [\n                    i for i in scoped_items_by_argkey[slicing_argkey] if i in items\n                ]\n                for i in reversed(matching_items):\n                    fix_cache_order(i, argkeys_cache, items_by_argkey)\n                    items_deque.appendleft(i)\n                break\n        if no_argkey_group:\n            no_argkey_group = reorder_items_atscope(\n                no_argkey_group, argkeys_cache, items_by_argkey, scopenum + 1\n            )\n            for item in no_argkey_group:\n                items_done[item] = None\n        ignore.add(slicing_argkey)\n    return items_done",
            "start_line": 235,
            "start_column": 8222,
            "end_line": 0,
            "end_column": 9844,
            "start_byte": 8222,
            "end_byte": 0
          },
          "_pytest.fixtures.fillfixtures": {
            "name": "_pytest.fixtures.fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fillfixtures(function):\n    \"\"\" fill missing funcargs for a test function. \"\"\"\n    try:\n        request = function._request\n    except AttributeError:\n        # XXX this special code path is only expected to execute\n        # with the oejskit plugin.  It uses classes with funcargs\n        # and we thus have to work a bit to allow this.\n        fm = function.session._fixturemanager\n        fi = fm.getfixtureinfo(function.parent, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._request = FixtureRequest(function)\n        request._fillfixtures()\n        # prune out funcargs for jstests\n        newfuncargs = {}\n        for name in fi.argnames:\n            newfuncargs[name] = function.funcargs[name]\n        function.funcargs = newfuncargs\n    else:\n        request._fillfixtures()",
            "start_line": 275,
            "start_column": 9847,
            "end_line": 0,
            "end_column": 10669,
            "start_byte": 9847,
            "end_byte": 0
          },
          "_pytest.fixtures.get_direct_param_fixture_func": {
            "name": "_pytest.fixtures.get_direct_param_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def get_direct_param_fixture_func(request):\n    return request.param",
            "start_line": 297,
            "start_column": 10672,
            "end_line": 0,
            "end_column": 10740,
            "start_byte": 10672,
            "end_byte": 0
          },
          "_pytest.fixtures.FuncFixtureInfo": {
            "name": "_pytest.fixtures.FuncFixtureInfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(slots=True)\nclass FuncFixtureInfo(object):\n    # original function argument names\n    argnames = attr.ib(type=tuple)\n    # argnames that function immediately requires. These include argnames +\n    # fixture names specified via usefixtures and via autouse=True in fixture\n    # definitions.\n    initialnames = attr.ib(type=tuple)\n    names_closure = attr.ib()  # List[str]\n    name2fixturedefs = attr.ib()  # List[str, List[FixtureDef]]\n\n    def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 301,
            "start_column": 10743,
            "end_line": 0,
            "end_column": 12559,
            "start_byte": 10743,
            "end_byte": 0
          },
          "_pytest.fixtures.FuncFixtureInfo.argnames": {
            "name": "_pytest.fixtures.FuncFixtureInfo.argnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "argnames = attr.ib(type=tuple)",
            "start_line": 304,
            "start_column": 10837,
            "end_line": 4,
            "end_column": 10867,
            "start_byte": 10837,
            "end_byte": 4
          },
          "_pytest.fixtures.FuncFixtureInfo.initialnames": {
            "name": "_pytest.fixtures.FuncFixtureInfo.initialnames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "initialnames = attr.ib(type=tuple)",
            "start_line": 308,
            "start_column": 11045,
            "end_line": 4,
            "end_column": 11079,
            "start_byte": 11045,
            "end_byte": 4
          },
          "_pytest.fixtures.FuncFixtureInfo.names_closure": {
            "name": "_pytest.fixtures.FuncFixtureInfo.names_closure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "names_closure = attr.ib()",
            "start_line": 309,
            "start_column": 11084,
            "end_line": 4,
            "end_column": 11109,
            "start_byte": 11084,
            "end_byte": 4
          },
          "_pytest.fixtures.FuncFixtureInfo.name2fixturedefs": {
            "name": "_pytest.fixtures.FuncFixtureInfo.name2fixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name2fixturedefs = attr.ib()",
            "start_line": 310,
            "start_column": 11127,
            "end_line": 4,
            "end_column": 11155,
            "start_byte": 11127,
            "end_byte": 4
          },
          "_pytest.fixtures.FuncFixtureInfo.prune_dependency_tree": {
            "name": "_pytest.fixtures.FuncFixtureInfo.prune_dependency_tree",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def prune_dependency_tree(self):\n        \"\"\"Recompute names_closure from initialnames and name2fixturedefs\n\n        Can only reduce names_closure, which means that the new closure will\n        always be a subset of the old one. The order is preserved.\n\n        This method is needed because direct parametrization may shadow some\n        of the fixtures that were included in the originally built dependency\n        tree. In this way the dependency tree can get pruned, and the closure\n        of argnames may get reduced.\n        \"\"\"\n        closure = set()\n        working_set = set(self.initialnames)\n        while working_set:\n            argname = working_set.pop()\n            # argname may be smth not included in the original names_closure,\n            # in which case we ignore it. This currently happens with pseudo\n            # FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.\n            # So they introduce the new dependency 'request' which might have\n            # been missing in the original tree (closure).\n            if argname not in closure and argname in self.names_closure:\n                closure.add(argname)\n                if argname in self.name2fixturedefs:\n                    working_set.update(self.name2fixturedefs[argname][-1].argnames)\n\n        self.names_closure[:] = sorted(closure, key=self.names_closure.index)",
            "start_line": 312,
            "start_column": 11192,
            "end_line": 4,
            "end_column": 12559,
            "start_byte": 11192,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest": {
            "name": "_pytest.fixtures.FixtureRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureRequest(FuncargnamesCompatAttr):\n    \"\"\" A request for a fixture from a test or fixture function.\n\n    A request object gives access to the requesting test context\n    and has an optional ``param`` attribute in case\n    the fixture is parametrized indirectly.\n    \"\"\"\n\n    def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager\n\n    @property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result\n\n    @property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]\n\n    @property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config\n\n    @scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj\n\n    @scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj\n\n    @property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)\n\n    @scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj\n\n    @scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath\n\n    @property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords\n\n    @property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef\n\n    def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request\n\n    def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )\n\n    def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )\n\n    def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines\n\n    def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node\n\n    def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 340,
            "start_column": 12562,
            "end_line": 0,
            "end_column": 24573,
            "start_byte": 12562,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureRequest.__init__": {
            "name": "_pytest.fixtures.FixtureRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, pyfuncitem):\n        self._pyfuncitem = pyfuncitem\n        #: fixture for which this request is being performed\n        self.fixturename = None\n        #: Scope string, one of \"function\", \"class\", \"module\", \"session\"\n        self.scope = \"function\"\n        self._fixture_defs = {}  # argname -> FixtureDef\n        fixtureinfo = pyfuncitem._fixtureinfo\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()\n        self._arg2index = {}\n        self._fixturemanager = pyfuncitem.session._fixturemanager",
            "start_line": 348,
            "start_column": 12848,
            "end_line": 4,
            "end_column": 13381,
            "start_byte": 12848,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.fixturenames": {
            "name": "_pytest.fixtures.FixtureRequest.fixturenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def fixturenames(self):\n        \"\"\"names of all active fixtures in this request\"\"\"\n        result = list(self._pyfuncitem._fixtureinfo.names_closure)\n        result.extend(set(self._fixture_defs).difference(result))\n        return result",
            "start_line": 360,
            "start_column": 13387,
            "end_line": 4,
            "end_column": 13638,
            "start_byte": 13387,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.node": {
            "name": "_pytest.fixtures.FixtureRequest.node",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def node(self):\n        \"\"\" underlying collection node (depends on current request scope)\"\"\"\n        return self._getscopeitem(self.scope)",
            "start_line": 367,
            "start_column": 13644,
            "end_line": 4,
            "end_column": 13796,
            "start_byte": 13644,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._getnextfixturedef": {
            "name": "_pytest.fixtures.FixtureRequest._getnextfixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n        if fixturedefs is None or (-index > len(fixturedefs)):\n            raise FixtureLookupError(argname, self)\n        self._arg2index[argname] = index\n        return fixturedefs[index]",
            "start_line": 372,
            "start_column": 13802,
            "end_line": 4,
            "end_column": 14617,
            "start_byte": 13802,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.config": {
            "name": "_pytest.fixtures.FixtureRequest.config",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def config(self):\n        \"\"\" the pytest config object associated with this request. \"\"\"\n        return self._pyfuncitem.config",
            "start_line": 388,
            "start_column": 14623,
            "end_line": 4,
            "end_column": 14764,
            "start_byte": 14623,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.function": {
            "name": "_pytest.fixtures.FixtureRequest.function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def function(self):\n        \"\"\" test function object if the request has a per-function scope. \"\"\"\n        return self._pyfuncitem.obj",
            "start_line": 393,
            "start_column": 14770,
            "end_line": 4,
            "end_column": 14924,
            "start_byte": 14770,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.cls": {
            "name": "_pytest.fixtures.FixtureRequest.cls",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty(\"class\")\n    def cls(self):\n        \"\"\" class (can be None) where the test function was collected. \"\"\"\n        clscol = self._pyfuncitem.getparent(_pytest.python.Class)\n        if clscol:\n            return clscol.obj",
            "start_line": 398,
            "start_column": 14930,
            "end_line": 4,
            "end_column": 15162,
            "start_byte": 14930,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.instance": {
            "name": "_pytest.fixtures.FixtureRequest.instance",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def instance(self):\n        \"\"\" instance (can be None) on which test function was collected. \"\"\"\n        # unittest support hack, see _pytest.unittest.TestCaseFunction\n        try:\n            return self._pyfuncitem._testcase\n        except AttributeError:\n            function = getattr(self, \"function\", None)\n            return getattr(function, \"__self__\", None)",
            "start_line": 405,
            "start_column": 15168,
            "end_line": 4,
            "end_column": 15549,
            "start_byte": 15168,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.module": {
            "name": "_pytest.fixtures.FixtureRequest.module",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def module(self):\n        \"\"\" python module object where the test function was collected. \"\"\"\n        return self._pyfuncitem.getparent(_pytest.python.Module).obj",
            "start_line": 415,
            "start_column": 15555,
            "end_line": 4,
            "end_column": 15738,
            "start_byte": 15555,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.fspath": {
            "name": "_pytest.fixtures.FixtureRequest.fspath",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@scopeproperty()\n    def fspath(self):\n        \"\"\" the file system path of the test module which collected this test. \"\"\"\n        return self._pyfuncitem.fspath",
            "start_line": 420,
            "start_column": 15744,
            "end_line": 4,
            "end_column": 15904,
            "start_byte": 15744,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.keywords": {
            "name": "_pytest.fixtures.FixtureRequest.keywords",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def keywords(self):\n        \"\"\" keywords/markers dictionary for the underlying node. \"\"\"\n        return self.node.keywords",
            "start_line": 425,
            "start_column": 15910,
            "end_line": 4,
            "end_column": 16046,
            "start_byte": 15910,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.session": {
            "name": "_pytest.fixtures.FixtureRequest.session",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@property\n    def session(self):\n        \"\"\" pytest session object. \"\"\"\n        return self._pyfuncitem.session",
            "start_line": 430,
            "start_column": 16052,
            "end_line": 4,
            "end_column": 16163,
            "start_byte": 16052,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.addfinalizer": {
            "name": "_pytest.fixtures.FixtureRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)",
            "start_line": 435,
            "start_column": 16169,
            "end_line": 4,
            "end_column": 16485,
            "start_byte": 16169,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._addfinalizer": {
            "name": "_pytest.fixtures.FixtureRequest._addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )",
            "start_line": 442,
            "start_column": 16491,
            "end_line": 4,
            "end_column": 16695,
            "start_byte": 16491,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.applymarker": {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 448,
            "start_column": 16701,
            "end_line": 4,
            "end_column": 17085,
            "start_byte": 16701,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.raiseerror": {
            "name": "_pytest.fixtures.FixtureRequest.raiseerror",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)",
            "start_line": 458,
            "start_column": 17091,
            "end_line": 4,
            "end_column": 17255,
            "start_byte": 17091,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._fillfixtures": {
            "name": "_pytest.fixtures.FixtureRequest._fillfixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixturenames)\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)",
            "start_line": 462,
            "start_column": 17261,
            "end_line": 4,
            "end_column": 17542,
            "start_byte": 17261,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.getfixturevalue": {
            "name": "_pytest.fixtures.FixtureRequest.getfixturevalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]",
            "start_line": 469,
            "start_column": 17548,
            "end_line": 4,
            "end_column": 17982,
            "start_byte": 17548,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.getfuncargvalue": {
            "name": "_pytest.fixtures.FixtureRequest.getfuncargvalue",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)",
            "start_line": 479,
            "start_column": 17988,
            "end_line": 4,
            "end_column": 18221,
            "start_byte": 17988,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._get_active_fixturedef": {
            "name": "_pytest.fixtures.FixtureRequest._get_active_fixturedef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(cached_result, scope)\n                raise\n        # remove indent to prevent the python3 exception\n        # from leaking into the call\n        self._compute_fixture_value(fixturedef)\n        self._fixture_defs[argname] = fixturedef\n        return fixturedef",
            "start_line": 486,
            "start_column": 18227,
            "end_line": 4,
            "end_column": 18911,
            "start_byte": 18227,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._get_fixturestack": {
            "name": "_pytest.fixtures.FixtureRequest._get_fixturestack",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _get_fixturestack(self):\n        current = self\n        values = []\n        while 1:\n            fixturedef = getattr(current, \"_fixturedef\", None)\n            if fixturedef is None:\n                values.reverse()\n                return values\n            values.append(fixturedef)\n            current = current._parent_request",
            "start_line": 504,
            "start_column": 18917,
            "end_line": 4,
            "end_column": 19250,
            "start_byte": 18917,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._compute_fixture_value": {
            "name": "_pytest.fixtures.FixtureRequest._compute_fixture_value",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _compute_fixture_value(self, fixturedef):\n        \"\"\"\n        Creates a SubRequest based on \"self\" and calls the execute method of the given fixturedef object. This will\n        force the FixtureDef object to throw away any previous results and compute a new fixture value, which\n        will be stored into the FixtureDef object itself.\n\n        :param FixtureDef fixturedef:\n        \"\"\"\n        # prepare a subrequest object before calling fixture function\n        # (latter managed by fixturedef)\n        argname = fixturedef.argname\n        funcitem = self._pyfuncitem\n        scope = fixturedef.scope\n        try:\n            param = funcitem.callspec.getparam(argname)\n        except (AttributeError, ValueError):\n            param = NOTSET\n            param_index = 0\n            has_params = fixturedef.params is not None\n            fixtures_not_supported = getattr(funcitem, \"nofuncargs\", False)\n            if has_params and fixtures_not_supported:\n                msg = (\n                    \"{name} does not support fixtures, maybe unittest.TestCase subclass?\\n\"\n                    \"Node id: {nodeid}\\n\"\n                    \"Function type: {typename}\"\n                ).format(\n                    name=funcitem.name,\n                    nodeid=funcitem.nodeid,\n                    typename=type(funcitem).__name__,\n                )\n                fail(msg, pytrace=False)\n            if has_params:\n                frame = inspect.stack()[3]\n                frameinfo = inspect.getframeinfo(frame[0])\n                source_path = frameinfo.filename\n                source_lineno = frameinfo.lineno\n                source_path = py.path.local(source_path)\n                if source_path.relto(funcitem.config.rootdir):\n                    source_path = source_path.relto(funcitem.config.rootdir)\n                msg = (\n                    \"The requested fixture has no parameter defined for test:\\n\"\n                    \"    {}\\n\\n\"\n                    \"Requested fixture '{}' defined in:\\n{}\"\n                    \"\\n\\nRequested here:\\n{}:{}\".format(\n                        funcitem.nodeid,\n                        fixturedef.argname,\n                        getlocation(fixturedef.func, funcitem.config.rootdir),\n                        source_path,\n                        source_lineno,\n                    )\n                )\n                fail(msg, pytrace=False)\n        else:\n            param_index = funcitem.callspec.indices[argname]\n            # if a parametrize invocation set a scope it will override\n            # the static scope defined with the fixture function\n            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)\n            if paramscopenum is not None:\n                scope = scopes[paramscopenum]\n\n        subrequest = SubRequest(self, scope, param, param_index, fixturedef)\n\n        # check if a higher-level scoped fixture accesses a lower level one\n        subrequest._check_scope(argname, self.scope, scope)\n\n        # clear sys.exc_info before invoking the fixture (python bug?)\n        # if it's not explicitly cleared it will leak into the call\n        exc_clear()\n        try:\n            # call the fixture function\n            fixturedef.execute(request=subrequest)\n        finally:\n            self._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 515,
            "start_column": 19256,
            "end_line": 4,
            "end_column": 22579,
            "start_byte": 19256,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._schedule_finalizers": {
            "name": "_pytest.fixtures.FixtureRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if fixture function failed it might have registered finalizers\n        self.session._setupstate.addfinalizer(\n            functools.partial(fixturedef.finish, request=subrequest), subrequest.node\n        )",
            "start_line": 589,
            "start_column": 22585,
            "end_line": 4,
            "end_column": 22856,
            "start_byte": 22585,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._check_scope": {
            "name": "_pytest.fixtures.FixtureRequest._check_scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _check_scope(self, argname, invoking_scope, requested_scope):\n        if argname == \"request\":\n            return\n        if scopemismatch(invoking_scope, requested_scope):\n            # try to report something helpful\n            lines = self._factorytraceback()\n            fail(\n                \"ScopeMismatch: You tried to access the %r scoped \"\n                \"fixture %r with a %r scoped request object, \"\n                \"involved factories\\n%s\"\n                % ((requested_scope, argname, invoking_scope, \"\\n\".join(lines))),\n                pytrace=False,\n            )",
            "start_line": 595,
            "start_column": 22862,
            "end_line": 4,
            "end_column": 23446,
            "start_byte": 22862,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._factorytraceback": {
            "name": "_pytest.fixtures.FixtureRequest._factorytraceback",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _factorytraceback(self):\n        lines = []\n        for fixturedef in self._get_fixturestack():\n            factory = fixturedef.func\n            fs, lineno = getfslineno(factory)\n            p = self._pyfuncitem.session.fspath.bestrelpath(fs)\n            args = _format_args(factory)\n            lines.append(\"%s:%d:  def %s%s\" % (p, lineno + 1, factory.__name__, args))\n        return lines",
            "start_line": 609,
            "start_column": 23452,
            "end_line": 4,
            "end_column": 23848,
            "start_byte": 23452,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest._getscopeitem": {
            "name": "_pytest.fixtures.FixtureRequest._getscopeitem",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getscopeitem(self, scope):\n        if scope == \"function\":\n            # this might also be a non-function Item despite its attribute name\n            return self._pyfuncitem\n        if scope == \"package\":\n            node = get_scope_package(self._pyfuncitem, self._fixturedef)\n        else:\n            node = get_scope_node(self._pyfuncitem, scope)\n        if node is None and scope == \"class\":\n            # fallback to function item itself\n            node = self._pyfuncitem\n        assert node, 'Could not obtain a node for scope \"{}\" for function {!r}'.format(\n            scope, self._pyfuncitem\n        )\n        return node",
            "start_line": 619,
            "start_column": 23854,
            "end_line": 4,
            "end_column": 24493,
            "start_byte": 23854,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.__repr__": {
            "name": "_pytest.fixtures.FixtureRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureRequest for %r>\" % (self.node)",
            "start_line": 635,
            "start_column": 24499,
            "end_line": 4,
            "end_column": 24573,
            "start_byte": 24499,
            "end_byte": 4
          },
          "_pytest.fixtures.SubRequest": {
            "name": "_pytest.fixtures.SubRequest",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class SubRequest(FixtureRequest):\n    \"\"\" a sub request for handling getting a fixture from a\n    test function/fixture. \"\"\"\n\n    def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager\n\n    def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)\n\n    def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)\n\n    def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 639,
            "start_column": 24576,
            "end_line": 0,
            "end_column": 25997,
            "start_byte": 24576,
            "end_byte": 0
          },
          "_pytest.fixtures.SubRequest.__init__": {
            "name": "_pytest.fixtures.SubRequest.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, request, scope, param, param_index, fixturedef):\n        self._parent_request = request\n        self.fixturename = fixturedef.argname\n        if param is not NOTSET:\n            self.param = param\n        self.param_index = param_index\n        self.scope = scope\n        self._fixturedef = fixturedef\n        self._pyfuncitem = request._pyfuncitem\n        self._fixture_defs = request._fixture_defs\n        self._arg2fixturedefs = request._arg2fixturedefs\n        self._arg2index = request._arg2index\n        self._fixturemanager = request._fixturemanager",
            "start_line": 643,
            "start_column": 24706,
            "end_line": 4,
            "end_column": 25280,
            "start_byte": 24706,
            "end_byte": 4
          },
          "_pytest.fixtures.SubRequest.__repr__": {
            "name": "_pytest.fixtures.SubRequest.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<SubRequest %r for %r>\" % (self.fixturename, self._pyfuncitem)",
            "start_line": 657,
            "start_column": 25286,
            "end_line": 4,
            "end_column": 25384,
            "start_byte": 25286,
            "end_byte": 4
          },
          "_pytest.fixtures.SubRequest.addfinalizer": {
            "name": "_pytest.fixtures.SubRequest.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._fixturedef.addfinalizer(finalizer)",
            "start_line": 660,
            "start_column": 25390,
            "end_line": 4,
            "end_column": 25473,
            "start_byte": 25390,
            "end_byte": 4
          },
          "_pytest.fixtures.SubRequest._schedule_finalizers": {
            "name": "_pytest.fixtures.SubRequest._schedule_finalizers",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _schedule_finalizers(self, fixturedef, subrequest):\n        # if the executing fixturedef was not explicitly requested in the argument list (via\n        # getfixturevalue inside the fixture call) then ensure this fixture def will be finished\n        # first\n        if fixturedef.argname not in self.funcargnames:\n            fixturedef.addfinalizer(\n                functools.partial(self._fixturedef.finish, request=self)\n            )\n        super(SubRequest, self)._schedule_finalizers(fixturedef, subrequest)",
            "start_line": 663,
            "start_column": 25479,
            "end_line": 4,
            "end_column": 25997,
            "start_byte": 25479,
            "end_byte": 4
          },
          "_pytest.fixtures.scopes": {
            "name": "_pytest.fixtures.scopes",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopes = \"session package module class function\".split()",
            "start_line": 674,
            "start_column": 26000,
            "end_line": 0,
            "end_column": 26056,
            "start_byte": 26000,
            "end_byte": 0
          },
          "_pytest.fixtures.scopenum_function": {
            "name": "_pytest.fixtures.scopenum_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scopenum_function = scopes.index(\"function\")",
            "start_line": 675,
            "start_column": 26057,
            "end_line": 0,
            "end_column": 26101,
            "start_byte": 26057,
            "end_byte": 0
          },
          "_pytest.fixtures.scopemismatch": {
            "name": "_pytest.fixtures.scopemismatch",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scopemismatch(currentscope, newscope):\n    return scopes.index(newscope) > scopes.index(currentscope)",
            "start_line": 678,
            "start_column": 26104,
            "end_line": 0,
            "end_column": 26209,
            "start_byte": 26104,
            "end_byte": 0
          },
          "_pytest.fixtures.scope2index": {
            "name": "_pytest.fixtures.scope2index",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def scope2index(scope, descr, where=None):\n    \"\"\"Look up the index of ``scope`` and raise a descriptive value error\n    if not defined.\n    \"\"\"\n    try:\n        return scopes.index(scope)\n    except ValueError:\n        fail(\n            \"{} {}got an unexpected scope value '{}'\".format(\n                descr, \"from {} \".format(where) if where else \"\", scope\n            ),\n            pytrace=False,\n        )",
            "start_line": 682,
            "start_column": 26212,
            "end_line": 0,
            "end_column": 26623,
            "start_byte": 26212,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureLookupError": {
            "name": "_pytest.fixtures.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg\n\n    def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 697,
            "start_column": 26626,
            "end_line": 0,
            "end_column": 28844,
            "start_byte": 26626,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureLookupError.__init__": {
            "name": "_pytest.fixtures.FixtureLookupError.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_fixturestack()\n        self.msg = msg",
            "start_line": 700,
            "start_column": 26741,
            "end_line": 4,
            "end_column": 26929,
            "start_byte": 26741,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureLookupError.formatrepr": {
            "name": "_pytest.fixtures.FixtureLookupError.formatrepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def formatrepr(self):\n        tblines = []\n        addline = tblines.append\n        stack = [self.request._pyfuncitem.obj]\n        stack.extend(map(lambda x: x.func, self.fixturestack))\n        msg = self.msg\n        if msg is not None:\n            # the last fixture raise an error, let's present\n            # it at the requesting side\n            stack = stack[:-1]\n        for function in stack:\n            fspath, lineno = getfslineno(function)\n            try:\n                lines, _ = inspect.getsourcelines(get_real_func(function))\n            except (IOError, IndexError, TypeError):\n                error_msg = \"file %s, line %s: source code not available\"\n                addline(error_msg % (fspath, lineno + 1))\n            else:\n                addline(\"file %s, line %s\" % (fspath, lineno + 1))\n                for i, line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)",
            "start_line": 706,
            "start_column": 26935,
            "end_line": 4,
            "end_column": 28844,
            "start_byte": 26935,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureLookupErrorRepr": {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 751,
            "start_column": 28847,
            "end_line": 0,
            "end_column": 29802,
            "start_byte": 28847,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureLookupErrorRepr.__init__": {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname",
            "start_line": 752,
            "start_column": 28895,
            "end_line": 4,
            "end_column": 29141,
            "start_byte": 28895,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureLookupErrorRepr.toterminal": {
            "name": "_pytest.fixtures.FixtureLookupErrorRepr.toterminal",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))",
            "start_line": 759,
            "start_column": 29147,
            "end_line": 4,
            "end_column": 29802,
            "start_byte": 29147,
            "end_byte": 4
          },
          "_pytest.fixtures.fail_fixturefunc": {
            "name": "_pytest.fixtures.fail_fixturefunc",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _pytest._code.Source(fixturefunc)\n    fail(msg + \":\\n\\n\" + str(source.indent()) + \"\\n\" + location, pytrace=False)",
            "start_line": 778,
            "start_column": 29805,
            "end_line": 0,
            "end_column": 30055,
            "start_byte": 29805,
            "end_byte": 0
          },
          "_pytest.fixtures.call_fixture_func": {
            "name": "_pytest.fixtures.call_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def call_fixture_func(fixturefunc, request, kwargs):\n    yieldctx = is_generator(fixturefunc)\n    if yieldctx:\n        it = fixturefunc(**kwargs)\n        res = next(it)\n        finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, it)\n        request.addfinalizer(finalizer)\n    else:\n        res = fixturefunc(**kwargs)\n    return res",
            "start_line": 785,
            "start_column": 30058,
            "end_line": 0,
            "end_column": 30407,
            "start_byte": 30058,
            "end_byte": 0
          },
          "_pytest.fixtures._teardown_yield_fixture": {
            "name": "_pytest.fixtures._teardown_yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _teardown_yield_fixture(fixturefunc, it):\n    \"\"\"Executes the teardown of a fixture function by advancing the iterator after the\n    yield and ensure the iteration ends (if not it means there is more than one yield in the function)\"\"\"\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        fail_fixturefunc(\n            fixturefunc, \"yield_fixture function has more than one 'yield'\"\n        )",
            "start_line": 797,
            "start_column": 30410,
            "end_line": 0,
            "end_column": 30835,
            "start_byte": 30410,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureDef": {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureDef.__init__": {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.addfinalizer": {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.finish": {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.execute": {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.__repr__": {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          "_pytest.fixtures.resolve_fixture_function": {
            "name": "_pytest.fixtures.resolve_fixture_function",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def resolve_fixture_function(fixturedef, request):\n    \"\"\"Gets the actual callable that can be called to obtain the fixture value, dealing with unittest-specific\n    instances and bound methods.\n    \"\"\"\n    fixturefunc = fixturedef.func\n    if fixturedef.unittest:\n        if request.instance is not None:\n            # bind the unbound method to the TestCase instance\n            fixturefunc = fixturedef.func.__get__(request.instance)\n    else:\n        # the fixture function needs to be bound to the actual\n        # request.instance so that code working with \"fixturedef\" behaves\n        # as expected.\n        if request.instance is not None:\n            fixturefunc = getimfunc(fixturedef.func)\n            if fixturefunc != fixturedef.func:\n                fixturefunc = fixturefunc.__get__(request.instance)\n    return fixturefunc",
            "start_line": 904,
            "start_column": 34058,
            "end_line": 0,
            "end_column": 34896,
            "start_byte": 34058,
            "end_byte": 0
          },
          "_pytest.fixtures.pytest_fixture_setup": {
            "name": "_pytest.fixtures.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_fixture_setup(fixturedef, request):\n    \"\"\" Execution of fixture setup. \"\"\"\n    kwargs = {}\n    for argname in fixturedef.argnames:\n        fixdef = request._get_active_fixturedef(argname)\n        result, arg_cache_key, exc = fixdef.cached_result\n        request._check_scope(argname, request.scope, fixdef.scope)\n        kwargs[argname] = result\n\n    fixturefunc = resolve_fixture_function(fixturedef, request)\n    my_cache_key = request.param_index\n    try:\n        result = call_fixture_func(fixturefunc, request, kwargs)\n    except TEST_OUTCOME:\n        fixturedef.cached_result = (None, my_cache_key, sys.exc_info())\n        raise\n    fixturedef.cached_result = (result, my_cache_key, None)\n    return result",
            "start_line": 924,
            "start_column": 34899,
            "end_line": 0,
            "end_column": 35623,
            "start_byte": 34899,
            "end_byte": 0
          },
          "_pytest.fixtures._ensure_immutable_ids": {
            "name": "_pytest.fixtures._ensure_immutable_ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _ensure_immutable_ids(ids):\n    if ids is None:\n        return\n    if callable(ids):\n        return ids\n    return tuple(ids)",
            "start_line": 944,
            "start_column": 35626,
            "end_line": 0,
            "end_column": 35755,
            "start_byte": 35626,
            "end_byte": 0
          },
          "_pytest.fixtures.wrap_function_to_error_out_if_called_directly": {
            "name": "_pytest.fixtures.wrap_function_to_error_out_if_called_directly",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def wrap_function_to_error_out_if_called_directly(function, fixture_marker):\n    \"\"\"Wrap the given fixture function so we can raise an error about it being called directly,\n    instead of used as an argument in a test function.\n    \"\"\"\n    message = FIXTURE_FUNCTION_CALL.format(\n        name=fixture_marker.name or function.__name__\n    )\n\n    @six.wraps(function)\n    def result(*args, **kwargs):\n        fail(message, pytrace=False)\n\n    # keep reference to the original function in our own custom attribute so we don't unwrap\n    # further than this point and lose useful wrappings like @mock.patch (#3774)\n    result.__pytest_wrapped__ = _PytestWrapper(function)\n\n    return result",
            "start_line": 952,
            "start_column": 35758,
            "end_line": 0,
            "end_column": 36444,
            "start_byte": 35758,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass FixtureFunctionMarker(object):\n    scope = attr.ib()\n    params = attr.ib(converter=attr.converters.optional(tuple))\n    autouse = attr.ib(default=False)\n    ids = attr.ib(default=None, converter=_ensure_immutable_ids)\n    name = attr.ib(default=None)\n\n    def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 971,
            "start_column": 36447,
            "end_line": 0,
            "end_column": 37339,
            "start_byte": 36447,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 973,
            "start_column": 36509,
            "end_line": 4,
            "end_column": 36526,
            "start_byte": 36509,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "params = attr.ib(converter=attr.converters.optional(tuple))",
            "start_line": 974,
            "start_column": 36531,
            "end_line": 4,
            "end_column": 36590,
            "start_byte": 36531,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "autouse = attr.ib(default=False)",
            "start_line": 975,
            "start_column": 36595,
            "end_line": 4,
            "end_column": 36627,
            "start_byte": 36595,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ids = attr.ib(default=None, converter=_ensure_immutable_ids)",
            "start_line": 976,
            "start_column": 36632,
            "end_line": 4,
            "end_column": 36692,
            "start_byte": 36632,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "name = attr.ib(default=None)",
            "start_line": 977,
            "start_column": 36697,
            "end_line": 4,
            "end_column": 36725,
            "start_byte": 36697,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __call__(self, function):\n        if isclass(function):\n            raise ValueError(\"class fixtures not supported (maybe in the future)\")\n\n        if getattr(function, \"_pytestfixturefunction\", False):\n            raise ValueError(\n                \"fixture is being applied more than once to the same function\"\n            )\n\n        function = wrap_function_to_error_out_if_called_directly(function, self)\n\n        name = self.name or function.__name__\n        if name == \"request\":\n            warnings.warn(FIXTURE_NAMED_REQUEST)\n        function._pytestfixturefunction = self\n        return function",
            "start_line": 979,
            "start_column": 36731,
            "end_line": 4,
            "end_column": 37339,
            "start_byte": 36731,
            "end_byte": 4
          },
          "_pytest.fixtures.fixture": {
            "name": "_pytest.fixtures.fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\"Decorator to mark a fixture factory function.\n\n    This decorator can be used, with or without parameters, to define a\n    fixture function.\n\n    The name of the fixture function can later be referenced to cause its\n    invocation ahead of running tests: test\n    modules or classes can use the ``pytest.mark.usefixtures(fixturename)``\n    marker.\n\n    Test functions can directly use fixture names as input\n    arguments in which case the fixture instance returned from the fixture\n    function will be injected.\n\n    Fixtures can provide their values to test functions using ``return`` or ``yield``\n    statements. When using ``yield`` the code block after the ``yield`` statement is executed\n    as teardown code regardless of the test outcome, and must yield exactly once.\n\n    :arg scope: the scope for which this fixture is shared, one of\n                ``\"function\"`` (default), ``\"class\"``, ``\"module\"``,\n                ``\"package\"`` or ``\"session\"``.\n\n                ``\"package\"`` is considered **experimental** at this time.\n\n    :arg params: an optional list of parameters which will cause multiple\n                invocations of the fixture function and all of the tests\n                using it.\n                The current parameter is available in ``request.param``.\n\n    :arg autouse: if True, the fixture func is activated for all tests that\n                can see it.  If False (the default) then an explicit\n                reference is needed to activate the fixture.\n\n    :arg ids: list of string ids each corresponding to the params\n                so that they are part of the test id. If no ids are provided\n                they will be generated automatically from the params.\n\n    :arg name: the name of the fixture. This defaults to the name of the\n                decorated function. If a fixture is used in the same module in\n                which it is defined, the function name of the fixture will be\n                shadowed by the function arg that requests the fixture; one way\n                to resolve this is to name the decorated function\n                ``fixture_<fixturename>`` and then use\n                ``@pytest.fixture(name='<fixturename>')``.\n    \"\"\"\n    if callable(scope) and params is None and autouse is False:\n        # direct decoration\n        return FixtureFunctionMarker(\"function\", params, autouse, name=name)(scope)\n    if params is not None and not isinstance(params, (list, tuple)):\n        params = list(params)\n    return FixtureFunctionMarker(scope, params, autouse, ids=ids, name=name)",
            "start_line": 997,
            "start_column": 37342,
            "end_line": 0,
            "end_column": 39985,
            "start_byte": 37342,
            "end_byte": 0
          },
          "_pytest.fixtures.yield_fixture": {
            "name": "_pytest.fixtures.yield_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def yield_fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):\n    \"\"\" (return a) decorator to mark a yield-fixture factory function.\n\n    .. deprecated:: 3.0\n        Use :py:func:`pytest.fixture` directly instead.\n    \"\"\"\n    return fixture(scope=scope, params=params, autouse=autouse, ids=ids, name=name)",
            "start_line": 1051,
            "start_column": 39988,
            "end_line": 0,
            "end_column": 40317,
            "start_byte": 39988,
            "end_byte": 0
          },
          "_pytest.fixtures.defaultfuncargprefixmarker": {
            "name": "_pytest.fixtures.defaultfuncargprefixmarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "defaultfuncargprefixmarker = fixture()",
            "start_line": 1060,
            "start_column": 40320,
            "end_line": 0,
            "end_column": 40358,
            "start_byte": 40320,
            "end_byte": 0
          },
          "_pytest.fixtures.pytestconfig": {
            "name": "_pytest.fixtures.pytestconfig",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@fixture(scope=\"session\")\ndef pytestconfig(request):\n    \"\"\"Session-scoped fixture that returns the :class:`_pytest.config.Config` object.\n\n    Example::\n\n        def test_foo(pytestconfig):\n            if pytestconfig.getoption(\"verbose\") > 0:\n                ...\n\n    \"\"\"\n    return request.config",
            "start_line": 1063,
            "start_column": 40361,
            "end_line": 0,
            "end_column": 40660,
            "start_byte": 40361,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureManager": {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupError": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.__init__": {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureinfo": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_plugin_registered": {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._getautousenames": {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureclosure": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_generate_tests": {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.parsefactories": {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixturedefs": {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._matchfactories": {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_fixture_setup": {
            "name": "_pytest.hookspec.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        return self._getscopeitem(self.scope)\n\n    def _getnextfixturedef(self, argname):\n        fixturedefs = self._arg2fixturedefs.get(argname, None)\n        if fixturedefs is None:\n            # we arrive here because of a dynamic call to\n            # getfixturevalue(argname) usage which was naturally\n            # not known at parsing/collection time\n            parentid = self._pyfuncitem.parent.nodeid\n            fixturedefs = self._fixturemanager",
            "start_line": 421,
            "start_column": 13750,
            "end_line": 0,
            "end_column": 14210,
            "start_byte": 13750,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_fixture_post_finalizer": {
            "name": "_pytest.hookspec.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "tfixturedefs(argname, parentid)\n            self._arg2fixturedefs[argname] = fixturedefs\n        # fixturedefs list is immutable so we maintain a decreasing index\n        index = self._arg2index.get(argname, 0) - 1\n  ",
            "start_line": 436,
            "start_column": 14213,
            "end_line": 0,
            "end_column": 14430,
            "start_byte": 14213,
            "end_byte": 0
          },
          "_pytest.pytester.LineMatcher_fixture": {
            "name": "_pytest.pytester.LineMatcher_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "t, function.obj, None)\n        function._fixtureinfo = fi\n        request = function._reques",
            "start_line": 337,
            "start_column": 10280,
            "end_line": 0,
            "end_column": 10372,
            "start_byte": 10280,
            "end_byte": 0
          },
          "_pytest.python.Module._inject_setup_module_fixture": {
            "name": "_pytest.python.Module._inject_setup_module_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ncitem.session\n\n    def addfinalizer(self, finalizer):\n        \"\"\" add finalizer/teardown function to be called after the\n        last test within the requesting test context finished\n        execution. \"\"\"\n        # XXX usually this method is shadowed by fixturedef specific ones\n        self._addfinalizer(finalizer, scope=self.scope)\n\n    def _addfinalizer(self, finalizer, scope):\n        colitem = self._getscopeitem(scope)\n        self._pyfuncitem.session._setupstate.addfinalizer(\n            finalizer=finalizer, colitem=colitem\n        )\n\n    def applymarker(self, marker):\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)\n\n    def raiseerror(self, msg):\n        \"\"\" raise a FixtureLookupError with the given message. \"\"\"\n        raise self._fixturemanager.FixtureLookupError(None, self, msg)\n\n    def _fillfixtures(self):\n        item = self._pyfuncitem\n        fixturenames = getattr(item, \"fixturenames\", self.fixture",
            "start_line": 452,
            "start_column": 16149,
            "end_line": 4,
            "end_column": 17383,
            "start_byte": 16149,
            "end_byte": 4
          },
          "_pytest.python.Module._inject_setup_function_fixture": {
            "name": "_pytest.python.Module._inject_setup_function_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\n        for argname in fixturenames:\n            if argname not in item.funcargs:\n                item.funcargs[argname] = self.getfixturevalue(argname)\n\n    def getfixturevalue(self, argname):\n        \"\"\" Dynamically run a named fixture function.\n\n        Declaring fixtures via function argument is recommended where possible.\n        But if you can only decide whether to use another fixture at test\n        setup time, you may use this function to retrieve it inside a fixture\n        or test function body.\n        \"\"\"\n        return self._get_active_fixturedef(argname).cached_result[0]\n\n    def getfuncargvalue(self, argname):\n        \"\"\" Deprecated, use getfixturevalue. \"\"\"\n        from _pytest import deprecated\n\n        warnings.warn(deprecated.GETFUNCARGVALUE, stacklevel=2)\n        return self.getfixturevalue(argname)\n\n    def _get_active_fixturedef(self, argname):\n        try:\n            return self._fixture_defs[argname]\n        except KeyError:\n            try:\n                fixturedef = self._getnextfixturedef(argname)\n            except FixtureLookupError:\n                if argname == \"request\":\n                    cached_result = (self, [0], None)\n                    scope = \"function\"\n                    return PseudoFixtureDef(",
            "start_line": 480,
            "start_column": 17389,
            "end_line": 4,
            "end_column": 18651,
            "start_byte": 17389,
            "end_byte": 4
          },
          "_pytest.python._get_non_fixture_func": {
            "name": "_pytest.python._get_non_fixture_func",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e\n            ),\n            pytrace=False,\n        )\n\n\nclass FixtureLookupError(LookupError):\n    \"\"\" could not return a requested Fixture (missing or invalid). \"\"\"\n\n    def __init__(self, argname, request, msg=None):\n        self.argname = argname\n        self.request = request\n        self.fixturestack = request._get_f",
            "start_line": 706,
            "start_column": 26570,
            "end_line": 0,
            "end_column": 26893,
            "start_byte": 26570,
            "end_byte": 0
          },
          "_pytest.python.Class._inject_setup_class_fixture": {
            "name": "_pytest.python.Class._inject_setup_class_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": ", line in enumerate(lines):\n                    line = line.rstrip()\n                    addline(\"  \" + line)\n                    if line.lstrip().startswith(\"def\"):\n                        break\n\n        if msg is None:\n            fm = self.request._fixturemanager\n            available = set()\n            parentid = self.request._pyfuncitem.parent.nodeid\n            for name, fixturedefs in fm._arg2fixturedefs.items():\n                faclist = list(fm._matchfactories(fixturedefs, parentid))\n                if faclist:\n                    available.add(name)\n            if self.argname in available:\n                msg = \" recursive dependency involving fixture '{}' detected\".format(\n                    self.argname\n                )\n            else:\n                msg = \"fixture '{}' not found\".format(self.argname)\n            msg += \"\\n available fixtures: {}\".format(\", \".join(sorted(available)))\n            msg += \"\\n use 'pytest --fixtures [testpath]' for help on them.\"\n\n        return FixtureLookupErrorRepr(fspath, lineno",
            "start_line": 744,
            "start_column": 27769,
            "end_line": 4,
            "end_column": 28815,
            "start_byte": 27769,
            "end_byte": 4
          },
          "_pytest.python.Class._inject_setup_method_fixture": {
            "name": "_pytest.python.Class._inject_setup_method_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "nes, msg, self.argname)\n\n\nclass FixtureLookupErrorRepr(TerminalRepr):\n    def __init__(self, filename, firstlineno, tblines, errorstring, argname):\n        self.tblines = tblines\n        self.errorstring = errorstring\n        self.filename = filename\n        self.firstlineno = firstlineno\n        self.argname = argname\n\n    def toterminal(self, tw):\n        # tw.line(\"FixtureLookupError: %s\" %(self.argname), red=True)\n        for tbline in self.tblines:\n            tw.line(tbline.rstrip())\n        lines = self.errorstring.split(\"\\n\")\n        if lines:\n            tw.line(\n                \"{}       {}\".format(FormattedExcinfo.fail_marker, lines[0].strip()),\n                red=True,\n            )\n            for line in lines[1:]:\n                tw.line(\n                    \"{}       {}\".format(FormattedExcinfo.flow_marker, line.strip()),\n                    red=True,\n                )\n        tw.line()\n        tw.line(\"%s:%d\" % (self.filename, self.firstlineno + 1))\n\n\ndef fail_fixturefunc(fixturefunc, msg):\n    fs, lineno = getfslineno(fixturefunc)\n    location = \"%s:%s\" % (fs, lineno + 1)\n    source = _py",
            "start_line": 768,
            "start_column": 28821,
            "end_line": 4,
            "end_column": 29945,
            "start_byte": 28821,
            "end_byte": 4
          },
          "_pytest.python.show_fixtures_per_test": {
            "name": "_pytest.python.show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "TSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_",
            "start_line": 1238,
            "start_column": 47680,
            "end_line": 0,
            "end_column": 47815,
            "start_byte": 47680,
            "end_byte": 0
          },
          "_pytest.python._show_fixtures_per_test": {
            "name": "_pytest.python._show_fixtures_per_test",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n      ",
            "start_line": 1244,
            "start_column": 47818,
            "end_line": 0,
            "end_column": 49588,
            "start_byte": 47818,
            "end_byte": 0
          },
          "_pytest.python.showfixtures": {
            "name": "_pytest.python.showfixtures",
            "file_path": "src/_pytest/python.py",
            "file_content": "def showfixtures(config):\n    from _pytest.main import wrap_session\n\n    return wrap_session(config, _showfixtures_main)",
            "start_line": 1296,
            "start_column": 49591,
            "end_line": 0,
            "end_column": 49711,
            "start_byte": 49591,
            "end_byte": 0
          },
          "_pytest.python._showfixtures_main": {
            "name": "_pytest.python._showfixtures_main",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _showfixtures_main(config, session):\n    import _pytest.config\n\n    session.perform_collect()\n    curdir = py.path.local()\n    tw = _pytest.config.create_terminal_writer(config)\n    verbose = config.getvalue(\"verbose\")\n\n    fm = session._fixturemanager\n\n    available = []\n    seen = set()\n\n    for argname, fixturedefs in fm._arg2fixturedefs.items():\n        assert fixturedefs is not None\n        if not fixturedefs:\n            continue\n        for fixturedef in fixturedefs:\n            loc = getlocation(fixturedef.func, curdir)\n            if (fixturedef.argname, loc) in seen:\n                continue\n            seen.add((fixturedef.argname, loc))\n            available.append(\n                (\n                    len(fixturedef.baseid),\n                    fixturedef.func.__module__,\n                    curdir.bestrelpath(loc),\n                    fixturedef.argname,\n                    fixturedef,\n                )\n            )\n\n    available.sort()\n    currentmodule = None\n    for baseid, module, bestrel, argname, fixturedef in available:\n        if currentmodule != module:\n            if not module.startswith(\"_pytest.\"):\n                tw.line()\n                tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n                currentmodule = module\n        if verbose <= 0 and argname[0] == \"_\":\n            continue\n        if verbose > 0:\n            funcargspec = \"%s -- %s\" % (argname, bestrel)\n        else:\n            funcargspec = argname\n        tw.line(funcargspec, green=True)\n        loc = getlocation(fixturedef.func, curdir)\n        doc = fixturedef.func.__doc__ or \"\"\n        if doc:\n            write_docstring(tw, doc)\n        else:\n            tw.line(\"    %s: no docstring available\" % (loc,), red=True)",
            "start_line": 1302,
            "start_column": 49714,
            "end_line": 0,
            "end_column": 51470,
            "start_byte": 49714,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_fixture_setup": {
            "name": "_pytest.setuponly.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "om _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat import get_real_method\nfrom _pytest.compat import getfslineno\nfrom _pytest.compat import getfuncargnames\nfrom _pytest.compat import getimfunc\nfrom _pytest.compat import getlocation\nfrom _pytest.compat import is_generator\nfrom _pytest.compat import isclass\nfrom _pytest.compat import NOTSET\nfrom _pytest.compat import safe_getattr\nfrom _pytest.deprecated import FIXTURE_FUNCTION_CALL\nfrom _pytest.deprecated import FIXTURE_NAMED_REQUEST\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import TEST_OUTCOME\n\n\n@attr.s(frozen=True)\nclass PseudoFixtureDef(object",
            "start_line": 25,
            "start_column": 540,
            "end_line": 0,
            "end_column": 1250,
            "start_byte": 540,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_fixture_post_finalizer": {
            "name": "_pytest.setuponly.pytest_fixture_post_finalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "    cached_result = attr.ib()\n    scope = attr.ib()\n\n\ndef pytest_sessionstart(session):\n    import _pytest.python\n    import _pytest.nodes\n\n    scopename2class.update(\n        {\n            \"package\": _pytest.python.Package,\n            \"class\": _pytest.python.Class,\n            \"module\": _pytest.python.Module,\n            \"funct",
            "start_line": 43,
            "start_column": 1253,
            "end_line": 0,
            "end_column": 1584,
            "start_byte": 1253,
            "end_byte": 0
          },
          "_pytest.setuponly._show_fixture_action": {
            "name": "_pytest.setuponly._show_fixture_action",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "\": _pytest.nodes.Item,\n            \"session\": _pytest.main.Session,\n        }\n    )\n    session._fixturemanager = FixtureManager(session)\n\n\nscopename2class = {}\n\n\nscope2props = dict(session=())\nscope2props[\"package\"] = (\"fspath\",)\nscope2props[\"module\"] = (\"fspath\", \"module\")\nscope2props[\"class\"] = scope2props[\"module\"] + (\"cls\",)\nscope2props[\"instance\"] = scope2props[\"class\"] + (\"instance\",)\nscope2props[\"function\"] = scope2props[\"instance\"] + (\"function\", \"keywords\")\n\n\ndef scopeproperty(name=None, doc=None):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytes",
            "start_line": 52,
            "start_column": 1587,
            "end_line": 0,
            "end_column": 2566,
            "start_byte": 1587,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_fixture_setup": {
            "name": "_pytest.setupplan.pytest_fixture_setup",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cinfo\nfrom _pytest._code.code import TerminalRepr\nfrom _pytest.compat import _format_args\nfrom _pytest.compat import _PytestWrapper\nfrom _pytest.compat import exc_clear\nfrom _pytest.compat import FuncargnamesCompatAttr\nfrom _pytest.compat import get_real_func\nfrom _pytest.compat imp",
            "start_line": 18,
            "start_column": 406,
            "end_line": 0,
            "end_column": 689,
            "start_byte": 406,
            "end_byte": 0
          },
          "_pytest.unittest.UnitTestCase._inject_setup_teardown_fixtures": {
            "name": "_pytest.unittest.UnitTestCase._inject_setup_teardown_fixtures",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "e):\n    def decoratescope(func):\n        scopename = name or func.__name__\n\n        def provide(self):\n            if func.__name__ in scope2props[self.scope]:\n                return func(self)\n            raise AttributeError(\n                \"%s not available in %s-scoped context\" % (scopename, self.scope)\n            )\n\n        return property(provide, None, None, func.__doc__)\n\n    return decoratescope\n\n\ndef get_scope_package(node, fixturedef):\n    import pytest\n\n    cls = pytest.Package\n    current = node\n    fixture_package_name = \"%s/%s\" % (fixturedef.baseid, \"__init__.py\")\n    while current and (\n      ",
            "start_line": 65,
            "start_column": 2097,
            "end_line": 4,
            "end_column": 2715,
            "start_byte": 2097,
            "end_byte": 4
          },
          "_pytest.unittest._make_xunit_fixture": {
            "name": "_pytest.unittest._make_xunit_fixture",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "ype(current) is not cls or fixture_package_name != current.nodeid\n    ):\n        current = current.parent\n    if current is None:\n        return node.session\n    return current\n\n\ndef get_scope_node(node, scope):\n    cls = scopename2class.get(scope)\n    if cls is None:\n        raise ValueError(\"unknown scope\")\n    return node.getparent(cls)\n\n\ndef add_funcarg_pseudo_fixture_def(collector, metafunc, fixturemanager):\n    # this function will transform all collected calls to a functions\n    # if they use direct funcargs (i.e. direct parametrization)\n    # because we want later test execution to be able to rely on\n    # an existing FixtureDef structure for all arguments.\n    # XXX we can probably avoid this algorithm  if we modify CallSpec2\n    # to directly care for c",
            "start_line": 81,
            "start_column": 2718,
            "end_line": 0,
            "end_column": 3491,
            "start_byte": 2718,
            "end_byte": 0
          }
        }
      }
    }
  ]
}