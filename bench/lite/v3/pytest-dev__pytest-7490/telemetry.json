{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7490",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T13:46:12.936133",
        "usage": "1894.8087692260742 ms"
      },
      "request": {
        "repo_tokens": [
          "showversion",
          "try_makedirs",
          "setenv",
          "CollectError",
          "FILLFUNCARGS",
          "maketxtfile",
          "duration",
          "get_default_arg_names",
          "pytest_runtest_makereport",
          "Module",
          "pytest_make_collect_report",
          "Cache",
          "LogXML",
          "_is_numpy_array",
          "_create_formatter",
          "_with_exception",
          "get_unpacked_marks",
          "pytest_runtest_setup",
          "ensure_newline",
          "_is_marked_for_rewrite",
          "wrap_pytest_function_for_tracing",
          "_find_spec",
          "popcall",
          "pytest_collect_directory",
          "_CACHE_PREFIX_VALUES",
          "_compare_eq_verbose",
          "evaluate_condition",
          "keywords",
          "get_lock_path",
          "cls",
          "makeconftest",
          "recursionindex",
          "resume_fixture",
          "pytest_addoption",
          "NoMatch",
          "mkpydir",
          "write",
          "StepwisePlugin",
          "Store",
          "StoreKey",
          "visit_BoolOp",
          "fillfixtures",
          "notset",
          "helpconfig",
          "assert_outcomes",
          "funcargnames",
          "_locationline",
          "FakeCollectModule",
          "ReprExceptionInfo",
          "getworkerinfoline",
          "__call__",
          "_get_direct_parametrize_args",
          "_rewrite_test",
          "pytest_exception_interact",
          "merge_family",
          "_for_parametrize",
          "lex",
          "annotated_getattr",
          "essential_plugins",
          "get_closest_marker",
          "pytest_warning_captured",
          "_factorytraceback",
          "setupplan",
          "caplog_handler_key",
          "hasplugin",
          "no_re_match_line",
          "debugging",
          "TestCaseFunction",
          "ConftestImportFailure",
          "resume_global_capture",
          "_config_for_test",
          "activate_fixture",
          "warning_types",
          "_argcomplete",
          "assertoutcome",
          "_getautousenames",
          "getmodulecol",
          "makedir",
          "_import_plugin_specs",
          "_get_teardown_reports",
          "fullsource",
          "_initini",
          "_get_fixturestack",
          "_init_runner_class",
          "explanation_param",
          "PytestCacheWarning",
          "version",
          "_validate_ids",
          "listextrakeywords",
          "write_sep",
          "set",
          "push_format_context",
          "line",
          "terminal",
          "addExpectedFailure",
          "reset",
          "ReprFileLocation",
          "exit",
          "pytest_deselected",
          "warn",
          "dir",
          "_ellipsize",
          "notify_exception",
          "_getconftest_pathlist",
          "runpython_c",
          "Code",
          "disabled",
          "capsys",
          "compat",
          "doctest_namespace",
          "prog",
          "_PytestWrapper",
          "mode",
          "repr_locals",
          "_parse_ini_config",
          "pytest_report_to_serializable",
          "scope2props",
          "try_cleanup",
          "FixtureManager",
          "fnmatch_lines_random",
          "NodeKeywords",
          "ApproxNumpy",
          "inline_runsource",
          "names_closure",
          "writeorg",
          "getpluginversioninfo",
          "Node",
          "no_header",
          "get_source",
          "build_summary_stats_line",
          "getlocation",
          "tmpdir_factory",
          "reprlocals",
          "fslocation",
          "_get_pdb_wrapper_class",
          "ImportPathMismatchError",
          "_ALLOW_MARKERS",
          "_validate_if_using_arg_names",
          "stop_global_capturing",
          "_write_source",
          "showfixtures",
          "accept",
          "classnamefilter",
          "Skipped",
          "_get_unknown_ini_keys",
          "unset_fixture",
          "fault_handler_stderr_key",
          "ExceptionChainRepr",
          "_update_current_test_var",
          "session",
          "repr_traceback_entry",
          "SysModulesSnapshot",
          "instance",
          "evaluate_skip_marks",
          "type",
          "_inject_setup_teardown_fixtures",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "AND",
          "FormattedExcinfo",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "ReprFailDoctest",
          "syspathinsert",
          "CallSpec2",
          "_checkversion",
          "_match_lines",
          "istext",
          "_remove_ansi_escape_sequences",
          "xml_key",
          "resolve_fixture_function",
          "from_item",
          "getvalueorskip",
          "visit_Attribute",
          "chdir",
          "_initrequest",
          "_should_rewrite",
          "add_funcarg_pseudo_fixture_def",
          "deprecated",
          "_resume",
          "_warn_incompatibility_with_xunit2",
          "ReprTracebackNative",
          "_check_initialpaths_for_relpath",
          "pos",
          "_log_cli_enabled",
          "register",
          "_getparser",
          "deactivate_fixture",
          "getitems",
          "pytest_assertion_pass",
          "_from_json",
          "getplugin",
          "failed",
          "_handle_teardown_sections",
          "scopeproperty",
          "is_generator",
          "location",
          "UnitTestCase",
          "_try_repr_or_str",
          "_main",
          "FuncFixtureInfo",
          "_saferepr",
          "get_config",
          "get_scope_package",
          "FixtureLookupErrorRepr",
          "assign",
          "_truncate_explanation",
          "tmp_path_factory",
          "ArgumentError",
          "_args_converter",
          "_idvalset",
          "getfixtureclosure",
          "params",
          "record_testsuite_property",
          "makeini",
          "freeze_support",
          "_W",
          "monkeypatch",
          "_strtobool",
          "_ensure_supporting_files",
          "summary_stats",
          "get_direct_param_fixture_func",
          "re_match_lines",
          "__contains__",
          "pytest_collectreport",
          "register_assert_rewrite",
          "name2fixturedefs",
          "ApproxSequencelike",
          "isnosetest",
          "_get_plugin_specs_as_list",
          "install_importhook",
          "async_warn_and_skip",
          "addini",
          "faulthandler",
          "get_lines_after",
          "__take_sys_modules_snapshot",
          "getsource",
          "getcall",
          "builtin",
          "CHECKER_CLASS",
          "importlib",
          "fail_fixturefunc",
          "pytest_ignore_collect",
          "_opentestcase",
          "scope2index",
          "PytestDeprecationWarning",
          "consider_module",
          "_visit_filter",
          "hookimpl",
          "summary_warnings",
          "_report_unserialization_failure",
          "safe_isclass",
          "__init__",
          "__array_priority__",
          "__all__",
          "KNOWN_TYPES",
          "_try_load_conftest",
          "_NodeType",
          "_fail",
          "TempPathFactory",
          "deselect_by_keyword",
          "illegal_xml_re",
          "_FixtureCachedResult",
          "PYTESTER_COPY_EXAMPLE",
          "matchnodes",
          "showhelp",
          "isdict",
          "summary_failures",
          "spawn_pytest",
          "Failed",
          "__enter__",
          "istestfunction",
          "filename_arg",
          "recwarn",
          "assertion",
          "write_fspath_result",
          "FunctionDefinition",
          "BaseReport",
          "get_exconly",
          "message",
          "write_log_entry",
          "_get_verbose_word",
          "getini",
          "_call_with_optional_argument",
          "_issue_warning_captured",
          "matching_platform",
          "_write_content",
          "get_parametrized_fixture_keys",
          "readouterr",
          "processoption",
          "_early_rewrite_bailout",
          "fspath",
          "getcrashentry",
          "delattr",
          "fileno",
          "addSuccess",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "_expecting_failure",
          "parseconfigure",
          "_PY_DIR",
          "skip",
          "fnmatch_lines",
          "Collector",
          "saferepr",
          "add_cleanup",
          "_getobj",
          "get_terminal_width",
          "_typ_map",
          "PytestAssertRewriteWarning",
          "_perform_collect",
          "_is_capturing",
          "normalize_mark_list",
          "_wrapped_pdb_cls",
          "importorskip",
          "source",
          "reprtraceback",
          "CACHEDIR_TAG_CONTENT",
          "_esctable",
          "_repr_style",
          "match",
          "MultipleDoctestFailures",
          "not_expr",
          "MarkDecorator",
          "teardown_nose",
          "ColoredLevelFormatter",
          "_report_to_json",
          "_compare_eq_cls",
          "done",
          "CallInfo",
          "WarningsChecker",
          "fixture",
          "__attrs_post_init__",
          "MonkeyPatch",
          "getfixturedefs",
          "genitems",
          "timing",
          "_start",
          "fail",
          "filter_traceback",
          "get_data",
          "_get_allow_bytes_flag",
          "entrysep",
          "_make_plural",
          "_set_main_color",
          "from_item_and_call",
          "_show_fixtures_per_test",
          "fix_cache_order",
          "Interrupted",
          "getstatementrange",
          "newinstance",
          "_params_converter",
          "extraline",
          "iscoroutinefunction",
          "collect",
          "cmdline",
          "variable",
          "run",
          "_compare_eq_sequence",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "pytest_fixture_post_finalizer",
          "collect_by_name",
          "writer",
          "getparent",
          "_set_opt_strings",
          "pytest_unconfigure",
          "get_records",
          "_get_increasing_order",
          "fixturenames",
          "Item",
          "DontReadFromInput",
          "text",
          "matchreport",
          "hasopt",
          "TESTS_FAILED",
          "verbosity",
          "_check_scope",
          "_update_message",
          "ParameterSet",
          "raises",
          "from_parent",
          "Junit",
          "_FixtureValue",
          "format",
          "summary_errors",
          "_determine_show_progress_info",
          "getimfunc",
          "warnings",
          "caplog",
          "_saved",
          "tmpdir",
          "_inject_setup_class_fixture",
          "CollectReport",
          "_tryconvertpyarg",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "from_exc_info",
          "cacheprovider",
          "_fillfixtures",
          "when",
          "_legal_ranges",
          "PYC_EXT",
          "__slots__",
          "reportinfo",
          "ensure_reset_dir",
          "_enter_pdb",
          "conftest_options",
          "_get_checker",
          "_parse_filter",
          "log_outcome",
          "finish",
          "ExceptionRepr",
          "pytest_pyfunc_call",
          "_non_printable_ascii_translate_table",
          "rex_outcome",
          "pytest_addhooks",
          "tb",
          "DEFAULT_LOG_DATE_FORMAT",
          "update_testcase_duration",
          "_makeitem",
          "python_api",
          "linecomp",
          "repr_failure",
          "__array_ufunc__",
          "showheader",
          "get_last_failed_paths",
          "wcswidth",
          "pytestPDB",
          "record_testreport",
          "_import_pdb_cls",
          "_outrep_summary",
          "pastebinfile_key",
          "MatcherAdapter",
          "listoutcomes",
          "getinicfg",
          "_Markable",
          "_approx_scalar",
          "_yield_comparisons",
          "DOCTEST_REPORT_CHOICES",
          "junitxml",
          "ReprTraceback",
          "set_fixture",
          "stepwise",
          "TYPE_CHECKING",
          "pytest_configure",
          "CollectErrorRepr",
          "make_hook_recorder",
          "restore",
          "finish_recording",
          "RE_IMPORT_ERROR_NAME",
          "istestfunc",
          "IGNORE_PAM",
          "expression",
          "MARK_GEN",
          "finalize",
          "_parsearg",
          "directory_arg",
          "locals",
          "_get_progress_information_message",
          "findsource",
          "Expression",
          "pytest_runtest_protocol",
          "CaptureResult",
          "T",
          "typename",
          "perform_collect",
          "OR",
          "traceback",
          "is_capturing",
          "MarkGenerator",
          "LogCaptureFixture",
          "pytest_collection_finish",
          "LogCaptureHandler",
          "pytest_collectstart",
          "Exception",
          "argnames",
          "CaptureManager",
          "isinitpath",
          "pytest",
          "INTERNAL_ERROR",
          "visit_Assert",
          "resume",
          "NOT",
          "_matchnodes",
          "TeeCaptureIO",
          "_do_configure",
          "on_rm_rf_error",
          "exec_module",
          "get_fslocation_from_item",
          "_FileHandler",
          "DummyRewriteHook",
          "_FixtureFunc",
          "parse_num",
          "_is_last_item",
          "UnformattedWarning",
          "_validate_args",
          "_warn_about_missing_assertion",
          "skipped_by_mark_key",
          "getnode",
          "_showfixtures_main",
          "_add_stats",
          "parse_hookspec_opts",
          "iter_markers",
          "getstatement",
          "item_capture",
          "LoggingPlugin",
          "reason",
          "lines",
          "is_async_function",
          "import_plugin",
          "_assert_expr_to_lineno",
          "pytest_pycollect_makemodule",
          "stop_capturing",
          "pytest_report_header",
          "_notin_text",
          "_no_match_line",
          "append_pass",
          "record_xml_attribute",
          "prepend",
          "DEFAULT_MAX_CHARS",
          "tolerance",
          "_getreprcrash",
          "_get_override_ini_value",
          "get_terminal_writer",
          "_find_parametrized_scope",
          "_LiveLoggingNullHandler",
          "getrepr",
          "SysCapture",
          "exprinfo",
          "scopenum_function",
          "FixtureLookupError",
          "frame",
          "names",
          "own_mark_names",
          "EncodedFile",
          "Mark",
          "_splitnode",
          "mark_rewrite",
          "LEVELNAME_FMT_REGEX",
          "__exit__",
          "get_empty_parameterset_mark",
          "LineMatcher",
          "_resolve_arg_value_types",
          "_recursive_debug",
          "parseoutcomes",
          "isattrs",
          "encoding",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "maybe_wrap_pytest_function_for_tracing",
          "pytest_enter_pdb",
          "store_mark",
          "_bytes_to_ascii",
          "_validate_keys",
          "consider_preparse",
          "_get_report_choice",
          "LOGLEVEL_COLOROPTS",
          "runpytest",
          "check_testcase_implements_trial_reporter",
          "MyOptionParser",
          "assertrepr_compare",
          "_assert_state",
          "_show_fixture_action",
          "RaisesContext",
          "store",
          "hookspec",
          "list",
          "_matches_prefix_or_glob_option",
          "_format_assertmsg",
          "_py_ext_re",
          "sep",
          "add_marker",
          "PytestExperimentalApiWarning",
          "generic_visit",
          "make_properties_node",
          "BASE_TYPE",
          "mkdir",
          "RESULT_LOG",
          "get_sections",
          "_getini",
          "make_numbered_dir",
          "ParseError",
          "setattr",
          "exconly",
          "_repr_failure_py",
          "_recursive_list_map",
          "_report_keyboardinterrupt",
          "Parser",
          "FDCaptureBinary",
          "_ensure_unconfigure",
          "check_interactive_exception",
          "WARNING_CAPTURED_HOOK",
          "DEFAULT_LOG_FORMAT",
          "passed",
          "repr",
          "_check_if_assertion_pass_impl",
          "_assertion_supported",
          "_force_symlink",
          "__len__",
          "catching_logs",
          "style",
          "eval",
          "_read_pyc",
          "print_teardown_sections",
          "NFPlugin",
          "_format",
          "_Key",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "idmaker",
          "show_test_item",
          "rewrite",
          "toterminal",
          "nodes",
          "_in_suspended",
          "LFPluginCollSkipfiles",
          "_get_flag_lookup",
          "_io",
          "builtin_plugins",
          "_parse_parametrize_args",
          "getargs",
          "old_mark_config_key",
          "addSkip",
          "symlink_or_skip",
          "assert_contains",
          "_get_auto_indent",
          "capsysbinary",
          "reject",
          "fullwidth",
          "FastFilesCompleter",
          "RPAREN",
          "append_collect_error",
          "logging",
          "ParsedCall",
          "IDENT_PREFIX",
          "parametrize",
          "__str__",
          "_traceback",
          "_get_pos",
          "_sys_snapshot",
          "issequence",
          "suspend_fixture",
          "runtestprotocol",
          "_should_truncate_item",
          "indent",
          "parse_args",
          "FaultHandlerHooks",
          "skipped",
          "id",
          "getgroup",
          "num_mock_patch_args",
          "cwd_relative_nodeid",
          "setuponly",
          "MODULE_NOT_FOUND_ERROR",
          "_prepare_content",
          "ishidden",
          "pytest_warning_recorded",
          "_config",
          "REPORT_COLLECTING_RESOLUTION",
          "ascii_escaped",
          "_printcollecteditems",
          "str",
          "LFPluginCollWrapper",
          "expr",
          "__version_tuple__",
          "set_session",
          "showlocals",
          "error",
          "ids",
          "warns",
          "__version__",
          "raiseerror",
          "FixtureRequest",
          "no_summary",
          "pathlib",
          "_code",
          "__module__",
          "astcache",
          "_iter_rewritable_modules",
          "SafeRepr",
          "HookRecorder",
          "README_CONTENT",
          "visit_Compare",
          "record_property",
          "resolve",
          "simple",
          "reorder_items_atscope",
          "read",
          "_validate_usepdb_cls",
          "_write_pyc_fp",
          "_getscopeitem",
          "show_fixtures_per_test",
          "runpython",
          "visit_BinOp",
          "_pop_and_teardown",
          "suspend_capturing",
          "Class",
          "set_log_path",
          "_postmortem_traceback",
          "_getpytestargs",
          "_set_initial_conftests",
          "re_match_lines_random",
          "excinfo",
          "CaptureFixture",
          "PrintHelp",
          "cache",
          "messages",
          "capstdout",
          "WarningReport",
          "_parse_parametrize_parameters",
          "fromdictargs",
          "PYC_TAIL",
          "runpytest_inprocess",
          "DEFAULT_MAX_LINES",
          "summary_passes",
          "_seen",
          "SubRequest",
          "setup",
          "OK",
          "TERMINALWRITER_WRITER",
          "COLLECT_DIRECTORY_HOOK",
          "showfspath",
          "getfixturevalue",
          "EMPTY_BUFFER",
          "_addexcinfo",
          "Metafunc",
          "fnmatch_ex",
          "ApproxMapping",
          "_get_active_fixturedef",
          "visit_Call",
          "_determine_main_color",
          "_R",
          "LineComp",
          "_striptext",
          "isdatacls",
          "SysCaptureBinary",
          "find_suffixes",
          "LFPlugin",
          "count_towards_summary",
          "autouse",
          "CLOSE_STDIN",
          "cached_result",
          "_FixtureFunction",
          "PytestConfigWarning",
          "add_report_section",
          "flow_marker",
          "pop",
          "DEFAULT_RELATIVE_TOLERANCE",
          "clear_cache",
          "deindent",
          "_check_non_top_pytest_plugins",
          "_callfinalizers",
          "capfdbinary",
          "Function",
          "section",
          "_markers",
          "addUnexpectedSuccess",
          "_pformat_dispatch",
          "repr_instance",
          "scopename2class",
          "_compare_eq_any",
          "ReprEntryNative",
          "doctest",
          "_get_continue_on_failure",
          "stop",
          "_REPORTCHARS_DEFAULT",
          "resultlog",
          "MultiCapture",
          "post_mortem",
          "countoutcomes",
          "suspend_global_capture",
          "helper",
          "_report_kwargs_from_json",
          "getoption",
          "append_failure",
          "add_property",
          "write_ensure_prefix",
          "inline_run",
          "_ensure_immutable_ids",
          "teardown_exact",
          "delenv",
          "NotSetType",
          "copy_example",
          "assert_contains_lines",
          "truncate_locals",
          "_collect",
          "append",
          "FSCollector",
          "mangle_test_address",
          "value",
          "NodeMeta",
          "parse_known_args",
          "pytest_generate_tests",
          "PYTEST_COLLECT_MODULE",
          "kwargs",
          "FSHookProxy",
          "cache_dir_from_config",
          "Frame",
          "makepyprojecttoml",
          "_is_skipped",
          "ImportMode",
          "assert_never",
          "head_line",
          "pytest_sessionstart",
          "find_prefixed",
          "Testdir",
          "get_real_func",
          "get_plugin_manager",
          "_basetemp",
          "repr_args",
          "_cachedir",
          "_patch_unwrap_mock_aware",
          "make_numbered_dir_with_cleanup",
          "_match_lines_random",
          "relline",
          "startTest",
          "getcalls",
          "errisinstance",
          "_check_type",
          "_state",
          "USAGE_ERROR",
          "_inject_setup_method_fixture",
          "get",
          "_mark_plugins_for_rewrite",
          "reprfuncargs",
          "add_stats",
          "fill_unfilled",
          "_plugin_nameversions",
          "ensure_deletable",
          "_compare_eq_iterable",
          "NO_TESTS_COLLECTED",
          "getfuncargnames",
          "getreportopt",
          "evaluate_xfail_marks",
          "MoreQuietAction",
          "pytest_collection_modifyitems",
          "AssertionState",
          "showlongtestinfo",
          "FixtureFunctionMarker",
          "_get_assertion_exprs",
          "_non_numeric_type_error",
          "_F",
          "console_main",
          "iter_markers_with_node",
          "PYTEST_TAG",
          "consider_pluginarg",
          "determine_setup",
          "Traceback",
          "NODE_USE_FROM_PARENT",
          "scopes",
          "_suspend",
          "_node_location_to_relpath",
          "safe_getattr",
          "abspath",
          "PytestCollectionWarning",
          "_LiveLoggingStreamHandler",
          "extract_from",
          "ischildnode",
          "_rget_with_confmod",
          "setmulti2",
          "tracebackcutdir",
          "_consider_importhook",
          "filter_traceback_for_conftest_import_failure",
          "import_path",
          "global_and_fixture_disabled",
          "statement",
          "_AnyPurePath",
          "clear",
          "TokenType",
          "parsefactories",
          "get_extended_length_path_str",
          "BINOP_MAP",
          "create_cleanup_lock",
          "_NodeReporter",
          "__delitem__",
          "version_tuple",
          "longrepr",
          "bin_xml_escape",
          "_names",
          "context",
          "short_test_summary",
          "__next__",
          "format_session_duration",
          "FDCapture",
          "get_option_ini",
          "runtest",
          "D",
          "DoctestTextfile",
          "report_collect",
          "addsection",
          "write_captured_output",
          "fail_marker",
          "is_globally_capturing",
          "funcargs",
          "V",
          "get_public_names",
          "_compare_eq_set",
          "_make_xunit_fixture",
          "to_xml",
          "suspend",
          "_version",
          "get_location",
          "Argument",
          "path",
          "default_plugins",
          "USAGE_MSG",
          "_get_line_with_reprcrash_message",
          "_ensure_basetemp",
          "addError",
          "call_optional",
          "_PluggyPlugin",
          "hasinit",
          "_warn_already_imported",
          "pytest_report_from_serializable",
          "SEP",
          "start_global_capturing",
          "_addfinalizer",
          "ReprEntry",
          "funcnamefilter",
          "safeformat",
          "find_spec",
          "_makepath",
          "_format_action_invocation",
          "_getvaluepath",
          "reprfileloc",
          "compile",
          "getfailures",
          "SysPathsSnapshot",
          "_T",
          "_get_global_properties_node",
          "getpathnode",
          "__dir__",
          "_runtest_for",
          "Instance",
          "warning_record_to_str",
          "_warn_or_fail_if_strict",
          "token",
          "pytest_report_teststatus",
          "ApproxBase",
          "skipping",
          "Session",
          "addinivalue_line",
          "Exit",
          "path_matches_patterns",
          "makepyfile",
          "Source",
          "_get_runner",
          "getparam",
          "PercentStyleMultiline",
          "PytestPluginManager",
          "pytest_collection",
          "__setitem__",
          "_preparse",
          "_running_on_ci",
          "pop_outerr_to_orig",
          "create_module",
          "_assertion_pass",
          "_teardown_yield_fixture",
          "_get_multicapture",
          "stream",
          "close",
          "at_level",
          "_prepareconfig",
          "PyCollector",
          "DoctestModule",
          "_init_pdb",
          "_inject_setup_function_fixture",
          "and_expr",
          "start",
          "_ANSI_ESCAPE_SEQ",
          "patchsysdict",
          "_processopt",
          "longreprtext",
          "TempdirFactory",
          "getfslineno",
          "_ET",
          "wrap_session",
          "maybe_delete_a_numbered_dir",
          "_has_param_ids",
          "pytest_fixture_setup",
          "visit_UnaryOp",
          "pytest_runtest_logreport",
          "ihook",
          "rm_rf",
          "_WithException",
          "emit",
          "_log",
          "reprentries",
          "pytest_runtest_teardown",
          "add_global_property",
          "prepare",
          "_split_lines",
          "ApproxDecimal",
          "getvalue",
          "wcwidth",
          "pytest_load_initial_conftests",
          "pytest_terminal_summary",
          "spawn",
          "no_fnmatch_line",
          "markup",
          "outcomes",
          "sections",
          "addoption",
          "result",
          "_compute_fixture_value",
          "ApproxScalar",
          "from_call",
          "getmodpath",
          "_CACHE_PREFIX_DIRS",
          "_importconftest",
          "resume_capturing",
          "_tmppath_factory",
          "reprcrash",
          "module",
          "_prunetraceback",
          "reorder_items",
          "_ascii_escaped_by_config",
          "start_capturing",
          "freeze_includes",
          "pastebin",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "PytestArg",
          "xfail",
          "K",
          "node_reporter",
          "tbfilter",
          "_inject_setup_module_fixture",
          "write_line",
          "locate_config",
          "parseconfig",
          "gethookproxy",
          "name",
          "pytest_itemcollected",
          "_add_simple",
          "deprecated_call",
          "append_collect_skipped",
          "_collectfile",
          "_gethookproxy",
          "_color_for_type",
          "register_cleanup_lock_removal",
          "pytest_plugin_registered",
          "pytest_runtest_call",
          "for_config",
          "PseudoFixtureDef",
          "_reprcompare",
          "unexpectedsuccess_key",
          "pytest_cmdline_parse",
          "_getcrashline",
          "handler",
          "_get_number_flag",
          "_S",
          "INTERRUPTED",
          "_readline_workaround",
          "_teardown_towards",
          "exitstatus",
          "_ensure_relative_to_basetemp",
          "_check_record_param_type",
          "_PLUGGY_DIR",
          "_getentrysource",
          "_py36_windowsconsoleio_workaround",
          "resultlog_key",
          "_HandlerType",
          "create_new_paste",
          "prune_dependency_tree",
          "from_config",
          "pytest_assertrepr_compare",
          "NoCapture",
          "ExceptionInfo",
          "_truncate_recursive_traceback",
          "_param_ids_generated",
          "_format_args",
          "should_do_markup",
          "Config",
          "pytest_runtestloop",
          "_get_main_color",
          "yield_fixture",
          "_setupstate",
          "_resolve_arg_ids",
          "_colorama_workaround",
          "RunResult",
          "_log_text",
          "width_of_current_line",
          "pytest_runtest_logfinish",
          "_write_progress_information_filling_space",
          "resolve_from_str",
          "readlines",
          "__getitem__",
          "parse_hookimpl_opts",
          "_get_allow_unicode_flag",
          "teardown_all",
          "Token",
          "_mk_tmp",
          "_importtestmodule",
          "write_docstring",
          "addFailure",
          "setdefault",
          "PyobjMixin",
          "combined_with",
          "_makefile",
          "unittest",
          "lineno",
          "getstatementrange_ast",
          "pytest_sessionfinish",
          "getfirstlinesource",
          "PytestUnknownMarkWarning",
          "scope",
          "AlwaysDispatchingPrettyPrinter",
          "repr_traceback",
          "TEST_OUTCOME",
          "parse_known_and_unknown_args",
          "runner",
          "Xfail",
          "applymarker",
          "_pytest",
          "PdbInvoke",
          "_diff_text",
          "co_equal",
          "DropShorterLongHelpFormatter",
          "pytest_cmdline_main",
          "_pluginmanager",
          "pytest_cmdline_preparse",
          "formatrepr",
          "_E",
          "_create",
          "isiterable",
          "deselect_by_mark",
          "pytest_make_parametrize_id",
          "pytest_internalerror",
          "LPAREN",
          "get_open_files",
          "pytest_report_collectionfinish",
          "families",
          "resolve_package_path",
          "_PYTEST_DIR",
          "main",
          "TracebackEntry",
          "_param_ids_from",
          "_getnextfixturedef",
          "getfailedcollections",
          "KeywordMatcher",
          "chain",
          "get_timeout_config_value",
          "add_attribute",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "set_level",
          "TerminalWriter",
          "call_and_report",
          "visit_Starred",
          "catch_warnings_for_item",
          "DOCTEST_REPORT_CHOICE_NONE",
          "get_dirs_from_args",
          "mktemp",
          "__ne__",
          "InvocationParams",
          "copy",
          "__test__",
          "OutcomeException",
          "pytestconfig",
          "capstderr",
          "_ensure_removed_sysmodule",
          "JUNIT_XML_DEFAULT_FAMILY",
          "from_current",
          "isset",
          "caplog_records_key",
          "markname",
          "_given_basetemp",
          "popen",
          "_split_explanation",
          "_assert_start_repr",
          "HelpAction",
          "consider_conftest",
          "execute",
          "UNARY_MAP",
          "nextitem",
          "approx",
          "_addoption_instance",
          "_color_for_type_default",
          "LineMatcher_fixture",
          "plugins",
          "_init_checker_class",
          "_excinfo",
          "assertstate_key",
          "derive_importpath",
          "_testcase",
          "_iter_all_modules",
          "category",
          "isatty",
          "_to_json",
          "LsofFdLeakChecker",
          "__eq__",
          "_recurse",
          "getrawcode",
          "args",
          "_teardown_with_finalization",
          "handleError",
          "pop_format_context",
          "CFG_PYTEST_SECTION",
          "REGEX_TYPE",
          "listchain",
          "_format_boolop",
          "nofuncargs",
          "_in_venv",
          "AssertionRewriter",
          "TimeoutExpired",
          "_call_reprcompare",
          "_format_lines",
          "__missing__",
          "_finalize",
          "File",
          "_call_assertion_pass",
          "_matchfactories",
          "addfinalizer",
          "_getconftestmodules",
          "getfixturemarker",
          "PytestWarning",
          "for_later",
          "_genfunctions",
          "_idval",
          "template",
          "parse_setoption",
          "get_statement_startend2",
          "listnames",
          "_result",
          "getbasetemp",
          "FILE_OR_DIR",
          "_trace",
          "EMPTY_PARAMETERSET_OPTION",
          "readline",
          "getreports",
          "visit_Name",
          "_checkargnotcontained",
          "_setup_fixtures",
          "TerminalReporter",
          "__hash__",
          "consider_env",
          "is_rewrite_disabled",
          "call_fixture_func",
          "gethookrecorder",
          "get_log_level_for_setting",
          "strict",
          "repr_excinfo",
          "ExitCode",
          "syspath_prepend",
          "cache_key",
          "set_trace",
          "__iter__",
          "XFailed",
          "mark",
          "pytest_pycollect_makeitem",
          "EOF",
          "MarkMatcher",
          "initialnames",
          "UsageError",
          "_getfailureheadline",
          "fixtures",
          "python",
          "rex_session_duration",
          "PdbTrace",
          "record_tuples",
          "_dump_lines",
          "AssertionRewritingHook",
          "call_runtest_hook",
          "Notset",
          "setitem",
          "LOCK_TIMEOUT",
          "_schedule_finalizers",
          "_getlines",
          "cacheshow",
          "TerminalRepr",
          "_fixturemanager",
          "attrs",
          "snap",
          "undo",
          "_check_all_skipped",
          "_validate_plugins",
          "_is_mocked",
          "istestclass",
          "_legal_xml_re",
          "buffer",
          "validate_basetemp",
          "function",
          "set_repr_style",
          "_addoption",
          "CaptureIO",
          "__getattr__",
          "ReprFuncArgs",
          "FUNCARGNAMES",
          "MINUS_K_COLON",
          "append_skipped",
          "_get_stderr_fileno",
          "wrap_function_to_error_out_if_called_directly",
          "Skip",
          "OptionGroup",
          "runitem",
          "collect_one_node",
          "format_explanation",
          "ReprLocals",
          "get_real_method",
          "rewrite_asserts",
          "evaluate",
          "runpytest_subprocess",
          "PytestUnhandledCoroutineWarning",
          "get_cache_dir",
          "append_error",
          "testdir",
          "pytest_keyboard_interrupt",
          "_width_of_current_line",
          "display",
          "_bestrelpath_cache",
          "is_potential_nosetest",
          "_truncate_by_char_count",
          "create_terminal_writer",
          "pytester",
          "cut",
          "pytest_collect_file",
          "set_when",
          "ResultLog",
          "STRING_TYPES",
          "FixtureDef",
          "capture",
          "Package",
          "_write_report_lines_from_hooks",
          "xfailed_key",
          "_translate_non_printable",
          "_highlight",
          "records",
          "node",
          "_disable_output_capturing_for_darwin",
          "truncate_if_required",
          "strip",
          "_getindent",
          "scopemismatch",
          "filter",
          "makefile",
          "get_user",
          "read_global_capture",
          "RUNNER_CLASS",
          "reports",
          "MINUS_K_DASH",
          "_legal_chars",
          "load_config_dict_from_file",
          "TestReport",
          "SetupState",
          "_surrounding_parens_on_own_lines",
          "flush",
          "pytest_runtest_logstart",
          "cleanup_numbered_dir",
          "config",
          "extract_suffixes",
          "_folded_skips",
          "tmp_path",
          "getfixtureinfo",
          "obj",
          "WarningsRecorder",
          "parse",
          "parse_summary_nouns",
          "_should_repr_global_name",
          "NOTSET",
          "inline_genitems",
          "set_location",
          "Scanner",
          "_compare_eq_dict",
          "with_args",
          "stopTest",
          "IDENT",
          "_eval_scope_callable",
          "delitem",
          "param",
          "get_scope_node",
          "__repr__",
          "getitem",
          "_format_repr_exception",
          "nose",
          "capfd",
          "ensure_extended_length_path",
          "CwdSnapshot",
          "get_optionflags",
          "_is_doctest",
          "DoctestItem",
          "pytest_leave_pdb",
          "_pyfuncitem",
          "_is_setup_py",
          "_write_entry_lines",
          "hasnew",
          "parts",
          "get_common_ancestor",
          "teardown",
          "cleanup_candidates",
          "nodeid"
        ]
      },
      "response": {
        "keywords": [
          "add_marker",
          "request",
          "xfail",
          "pytest",
          "pytestmark",
          "Request",
          "Function",
          "mark",
          "pyfuncitem",
          "pytest_runtest_makereport"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T13:46:14.830958",
        "usage": "239.22085762023926 ms"
      },
      "request": {
        "tokens": [
          "add_marker",
          "request",
          "xfail",
          "pytest",
          "pytestmark",
          "Request",
          "Function",
          "mark",
          "pyfuncitem",
          "pytest_runtest_makereport"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/skipping.py",
            "src/pytest/collect.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/timing.py",
            "src/_pytest/warnings.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/pytest/__main__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "mark": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/python_api.py",
            "src/_pytest/warnings.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/__init__.py"
          ],
          "xfail": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py"
          ],
          "Function": [
            "src/pytest/collect.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytestmark": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/config/__init__.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/skipping.py",
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "request": [
            "src/_pytest/setuponly.py",
            "src/_pytest/pytester.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/runner.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py"
          ],
          "pyfuncitem": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py"
          ],
          "add_marker": [
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T13:46:15.070190",
        "usage": "6080.89280128479 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/deprecated.py",
            "src/_pytest/faulthandler.py",
            "src/_pytest/logging.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/skipping.py",
            "src/pytest/collect.py",
            "src/_pytest/pytester.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/main.py",
            "src/_pytest/timing.py",
            "src/_pytest/warnings.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/unittest.py",
            "src/_pytest/nodes.py",
            "src/pytest/__main__.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/compat.py",
            "src/_pytest/debugging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/terminal.py",
            "src/_pytest/python_api.py",
            "src/_pytest/reports.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/mark/__init__.py"
          ],
          "mark": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/python_api.py",
            "src/_pytest/warnings.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py",
            "src/_pytest/mark/__init__.py"
          ],
          "xfail": [
            "src/_pytest/skipping.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py"
          ],
          "Function": [
            "src/pytest/collect.py",
            "src/_pytest/_argcomplete.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/pytest/__init__.py",
            "src/_pytest/nose.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py"
          ],
          "pytestmark": [
            "src/_pytest/mark/structures.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/config/__init__.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/skipping.py",
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py"
          ],
          "request": [
            "src/_pytest/setuponly.py",
            "src/_pytest/pytester.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/logging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/runner.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/unittest.py"
          ],
          "pyfuncitem": [
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py"
          ],
          "add_marker": [
            "src/_pytest/python.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is that pytest 6.0.0rc0 raises an error when dynamically adding an xfail marker using `request.node.add_marker(mark)`, which did not happen in version 5.x.\n\n1. Look at the keywords and their file listings.\n2. Keywords 'pytest', 'mark', 'xfail', and 'add_marker' seem closely related to the problem since they relate to the functionality being changed or broken (i.e., xfail marker dynamic addition through pytest xfail functionality).\n3. From keywords:\n   - 'add_marker': the mention of 'src/_pytest/nodes.py', 'src/_pytest/fixtures.py', and 'src/_pytest/python.py' might be highly relevant because they possibly handle the dynamic aspect of adding markers to test nodes in pytest.\n   - 'xfail' might be handled directly in 'src/_pytest/skipping.py', which might be responsible for handling tests that should be skipped or expected to fail.\n   - 'pytest': focus on files that might handle test execution or configuration such as 'src/_pytest/runner.py' which might directly interact with test running machinery and marker application.\n   - 'request': since the error originates from the request object, any fixture or method interactions in 'src/_pytest/python.py' related to requests could be key.\n4. Combine these insights to determine the most relevant files likely influencing this issue based on the keyword enumeration provided.\n\nRelevant files given the issue's focus on marker handling and request target:\n- 'src/_pytest/python.py': handles general Python functions and possibly node interactions, also shows up in most relevant keyword searches.\n- 'src/_pytest/mark/structures.py': potentially involved with setting up and working with markers and could be where xfail handling changed.\n- 'src/_pytest/skipping.py': traditionally handles xfail and skip logic, which is directly relevant to xfail functionalities.",
        "file_paths": [
          "src/_pytest/python.py",
          "src/_pytest/mark/structures.py",
          "src/_pytest/skipping.py",
          "src/_pytest/nodes.py",
          "src/_pytest/fixtures.py",
          "src/_pytest/runner.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:21.151114",
        "usage": "12823.943853378296 ms"
      },
      "request": {
        "file_path": "src/_pytest/python.py"
      },
      "response": {
        "scratch_pad": "1. **Issue Analysis:**\n   - The issue pertains to a change in behavior from pytest version 5.x to 6.x concerning dynamically adding an `xfail` marker to a test.\n   - In pytest 5.x, adding an `xfail` marker dynamically to a test would cause the test to be handled as an expected failure (i.e., xfail), whereas in 6.0.0rc0, doing so results in the test failing.\n   - The user highlights how the transition from one version to the other impacts the test results.\n\n2. **Related Concepts in the Issue:**\n   - Use of `request.node.add_marker(mark)` to add the `xfail` marker.\n   - Change in the mechanism of how failing tests with added markers are handled in new pytest version 6.0.0rc0.\n\n3. **Exploring Root Cause:**\n   - The core change appears to stem from how dynamically added markers are processed in the new pytest version.\n   - Understanding these changes involves looking for where pytest handles markers for tests and the logic likely affecting failure and result reporting.\n\n4. **Expectation & Solution:**\n   - The expected behavior is for the xfail marker added dynamically to result in the test being marked as xfail, not failed.\n   - A possible solution may involve altering the handling mechanism for dynamically added markers, possibly a regression or feature change in pytest.\n\n### File Evaluation\n\n- The file at `src/_pytest/python.py` appears to be focused on the discovery, collection, and execution routines involved in processing Python test functions.\n- **Symbols and Key Areas:**\n   - `pytest_pyfunc_call()`: Runs test functions and interacts with test items.\n   - `Function` class: Represents a test function item which could be involved when `request.node.add_marker(mark)` is called.\n   - Review if the `Function` class or related classes and methods handle markers applied dynamically, especially concerning xfail.\n\n- **Investigation:**\n   - Within the `Function` class, search for marker handling, especially relating to dynamically added scenarios.\n   - Check if any changes have been made to marker handling logic between versions 5.x and 6.x, especially around areas dealing with test call results and finalizing outcomes.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "pytest_pyfunc_call",
          "Function",
          "Function.from_parent",
          "Function.runtest",
          "Metafunc"
        ],
        "root_cause_symbols": [
          "Function",
          "Function.runtest",
          "FunctionDefinition"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:33.975080",
        "usage": "6099.624872207642 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/structures.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n   - The user reports an issue related to the transition from pytest 5.x to pytest 6.0.0rc0.\n   - In pytest 5.x, dynamically adding an xfail to a test request using `request.node.add_marker(mark)` treats the test as expected to fail (xfail) without error.\n   - In pytest 6.0.0rc0, it instead results in a direct failure without marking it as an xfail.\n   - Reproduction steps include using `pytest.mark.xfail` added dynamically to a test before an assertion failure occurs.\n\n2. **Make file evaluation:**\n   - The file `structures.py` contains code related to test markers which is relevant to the issue. One area of interest could be the `MarkDecorator` and `Mark` classes and related methods like `combined_with`, which deal with how markers are applied.\n   - The `store_mark` function is relevant as it is responsible for attaching a marker to an object, possibly impacting dynamic additions.\n   - Another potentially relevant segment is `get_unpacked_marks` and `normalize_mark_list` since these functions handle fetching and normalizing mark lists from objects.\n   - `MarkGenerator` and `MARK_GEN` are relevant as they deal with marker creation and might be part of the dynamic marker assignment process.\n   - `NodeKeywords` class, dealing with node keyword handling, might also indirectly play a role if keyword interactions have changed.\n   - A specific behavior change regarding xfail markers could involve modifications in how markers are stored or retrieved, causing the observed shift in behavior between pytest versions.\n\n3. **Output Your Decision:**",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/main.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [
          "Mark",
          "MarkDecorator",
          "store_mark",
          "get_unpacked_marks",
          "normalize_mark_list",
          "MarkGenerator",
          "MARK_GEN",
          "NodeKeywords"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:40.074731",
        "usage": "8527.463912963867 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "## Analysis of the Reported Issue\n1. **Issue Description**: The issue reported is that dynamically adding an xfail marker in a test using `request.node.add_marker(mark)` does not work in pytest version 6.0 as it did in version 5. In version 5, this would treat the test marked with xfail dynamically the same as if it were marked statically. However, in version 6.0, it raises an error instead.\n   - The error occurs because a dynamically added xfail marker does not result in the expected behavior of skipping the test when it fails.\n\n2. **User Expectation and Cause**: \n   - The user expects the dynamically added xfail markers to behave the same as statically added ones, meaning they should treat failures as expected and not raise them.\n   - The issue seems to arise from changes in how xfail markers are evaluated or handled internally between pytest versions 5 and 6.\n\n3. **Possible Causes**: \n   - Changes in the internal handling of markers in pytest version 6.\n   - The phase of the test lifecycle when `request.node.add_marker(mark)` is processed might behave differently in v6.\n   - Configuration or defaults related to xfail handling might have changed.\n\n4. **Possible Solutions**:\n   - Ensure that the dynamically added markers are correctly evaluated like the static ones by examining the marker handling logic.\n   - Check if version 6 introduced a more strict xfail evaluation or lifecycle processing that needs adjustment when adding markers dynamically.\n\n## Analysis of the Provided Code File\n- The relevant part for xfail handling seems to be around the `evaluate_xfail_marks()` function, as this determines how xfails are evaluated.\n- The `pytest_runtest_makereport` function, which processes test outcomes and interacts with the report when xfailed, may also be related.\n- The internal handling of `xfailed_key` and evaluation logic within `evaluate_xfail_marks` and `pytest_runtest_call` seem crucial for the issue.\n\n## Identifying Relevant Functions\nThese functions seem critical per the provided file content:\n- `evaluate_xfail_marks()`\n- `pytest_runtest_makereport`\n- `pytest_runtest_call`\n\nThese are possibly involved in processing when the dynamic xfail is added and how it affects the behavior when the test fails.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/hooks.py",
          "src/_pytest/mark/structures.py"
        ],
        "relevant_symbols": [
          "evaluate_xfail_marks",
          "pytest_runtest_call",
          "pytest_runtest_makereport"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:48.602212",
        "usage": "9119.184732437134 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue**: The reported issue mentions that, in pytest version 6.0.0rc0, dynamically adding an `xfail` marker to a test using `request.node.add_marker(mark)` results in the test not being marked as expected failure (`xfail`). Instead, it raises an error, whereas in pytest 5.x, it was considered an expected failure.\n   \n2. **Given Reproduction Steps**: The code snippet provided demonstrates this behavior:\n   ```python\n   import pytest\n\n   def test_xfail_test(request):\n       mark = pytest.mark.xfail(reason=\"xfail\")\n       request.node.add_marker(mark)\n       assert 0\n   ```\n   In pytest 5.x, this would result in an `xfailed` test, but in 6.0.0rc0, it results in a failure.\n   \n3. **Understanding the Codebase**:\n   - `_pytest/nodes.py` file contains a `Node` class with the `add_marker` method.\n   - This method allows markers to be added to a node dynamically.\n   - The function `add_marker` is utilized when `request.node.add_marker(mark)` is called in the test.\n   - In theory, this file should deal with the dynamic addition of markers and the behavior of these markers.\n\n4. **Potential Cause**:\n   - Changes in how markers are interpreted or processed in pytest 6.x might lead to a difference in test status from `xpass` to failure.\n   - Possible that changes in `Node` or marker-related processing mean dynamically added markers are not recognized correctly for failure handling.\n\n5. **Traceback and Assertions**:\n   - `Node.add_marker()` \u2014 responsible for adding markers, including `xfail`.\n   - Code alterations or legacy behavior changes could affect this method, changing how test results are handled post marker addition.\n\n6. **Potential Solutions**:\n   - Investigate and verify no regression exists in the behavior of Node.add_marker that affects `xfail` status.\n   - Look into how the pytest framework now processes markers post addition to ensure `xfail` is treated as expected failure.\n   - Modify `Node.add_marker` or related functionality to ensure it works correctly under the updated pytest 6.x environment.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/mark/structures.py",
          "src/_pytest/mark/__init__.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [
          "Node.add_marker",
          "Node.own_markers.append"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:46:57.721411",
        "usage": "7871.304988861084 ms"
      },
      "request": {
        "file_path": "src/_pytest/fixtures.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue is about a change in behavior between pytest version 5.x and 6.0 concerning the `xfail` marker. In pytest 5.x, dynamically adding an `xfail` to a test using `request.node.add_marker(mark)` would make the test behave as if statically marked with `xfail`, i.e., it would ignore failures. However, in 6.0.0rc0, the same test raises an assertion error and does not behave as expected.\n1.2 The reproduce step provided indicates the use of a test function, `test_xfail_test`, which adds a marker and asserts.Falsey, demonstrating the failure is not ignored.\n1.3 It seems the issue could be due to changes in how pytest handles markers or changes in internals related to test outcomes, possibly regarding how dynamically added markers are processed during a test's lifecycle.\n1.4 The user expects dynamically added `xfail` markers to behave as they did in previous versions, meaning that tests would not report errors if they are expected to fail (i.e., are marked as `xfail`). The failure not being ignored indicates a regression or intentional change in behavior that was unaccounted for.\n1.6 Possible solutions include investigating changes in `applymarker` or the processing of `xfail` markers and ensuring they align with the intended behavior for dynamically added markers.\n\n2. Make file evaluation:\n2.1 The file content seems to include mechanisms related to fixture processing and management, which might be related to marker handling.\n2.2 Look for functions or methods that directly work with the request object, especially where markers might be applied.\n2.3 The `FixtureRequest` class has a method `applymarker`.\n2.4 The `applymarker` method in the `FixtureRequest` class uses `self.node.add_marker(marker)`, which matches the mechanism issue where the test reports failure instead of ignoring it.\n2.5\n2.6 This file includes mechanisms related to adding markers to the request node, which are likely candidates for being part of the current issue, particularly the `applymarker` in `FixtureRequest`, responsible for adding xfail dynamically.\n\nChecking for any relevant parts or mentions about how markers are applied or processed, especially differences between static and dynamic additions, would confirm if this source file is indeed the root cause.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/mark/__init__.py"
        ],
        "relevant_symbols": [
          "FixtureRequest.applymarker"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T13:47:05.592745",
        "usage": "7574.261903762817 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. **Analysis of the Issue:**\n   - The issue reported is about a behavior change in pytest 6.0.0 where dynamically adding an `xfail` marker using `request.node.add_marker(mark)` no longer behaves the same as it did in version 5.x.\n   - The user expects that adding an `xfail` marker dynamically should allow the test to fail without causing a failure report, which was the behavior in 5.x. However, pytest 6.0.0 raises an assertion error instead of considering the test to be expected to fail.\n2. **Understanding User Instructions:**\n   - The provided example demonstrates a test `test_xfail_test` where an `xfail` marker is added to the test dynamically.\n   - In pytest 5.x, this would result in the test being expected to fail, thus not being counted as a failed test.\n   - In pytest 6.0.0, despite the `xfail`, the test is counted as failed, which is not the expected behavior.\n3. **Analyzing the Code:**\n   - This file `runner.py` contains the main test execution components of pytest, especially the `runtestprotocol` and `call_and_report` functions which handle the running and reporting of test outcomes.\n   - The function `check_interactive_exception` checks if exceptions need special handling; it looks for `xfail` configurations to decide if an exception was expected.\n   - The key problem seems to be that dynamically added `xfail` marks are not being recognized correctly during this checking process.\n4. **Conclusion:**\n   - This file is definitely relevant to the issue since the functions handling the running, exception checking, and reporting of test items are all here.\n   - It is likely part of the root cause because the behavior change lies within how these tests and their outcomes are processed, particularly in handling `xfail` conditions.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "runtestprotocol",
          "call_and_report",
          "check_interactive_exception",
          "SetupState"
        ],
        "root_cause_symbols": [
          "runtestprotocol",
          "call_and_report",
          "check_interactive_exception"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T13:47:13.167041",
        "usage": "316.5428638458252 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/python.py",
            "relevant_symbol_keys": [
              "pytest_pyfunc_call",
              "Function",
              "Function.from_parent",
              "Function.runtest",
              "Metafunc"
            ],
            "root_cause_symbol_keys": [
              "Function",
              "Function.runtest",
              "FunctionDefinition"
            ]
          },
          {
            "file_path": "src/_pytest/mark/structures.py",
            "relevant_symbol_keys": [
              "Mark",
              "MarkDecorator",
              "store_mark",
              "get_unpacked_marks",
              "normalize_mark_list",
              "MarkGenerator",
              "MARK_GEN",
              "NodeKeywords"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [
              "evaluate_xfail_marks",
              "pytest_runtest_call",
              "pytest_runtest_makereport"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node.add_marker",
              "Node.own_markers.append"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/fixtures.py",
            "relevant_symbol_keys": [
              "FixtureRequest.applymarker"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [
              "runtestprotocol",
              "call_and_report",
              "check_interactive_exception",
              "SetupState"
            ],
            "root_cause_symbol_keys": [
              "runtestprotocol",
              "call_and_report",
              "check_interactive_exception"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.debugging.PdbTrace.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "  def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if n",
            "start_line": 293,
            "start_column": 9927,
            "end_line": 4,
            "end_column": 10098,
            "start_byte": 9927,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[o",
            "start_line": 338,
            "start_column": 11720,
            "end_line": 0,
            "end_column": 11918,
            "start_byte": 11720,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True",
            "start_line": 171,
            "start_column": 5901,
            "end_line": 0,
            "end_column": 6398,
            "start_byte": 5901,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Metafunc",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Metafunc:\n    \"\"\"\n    Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls\n\n    def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)\n\n    def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes\n\n    def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 872,
            "start_column": 33237,
            "end_line": 0,
            "end_column": 45943,
            "start_byte": 33237,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Metafunc.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs",
            "start_line": 880,
            "start_column": 33570,
            "end_line": 4,
            "end_column": 34424,
            "start_byte": 33570,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 908,
            "start_column": 34430,
            "end_line": 4,
            "end_column": 34641,
            "start_byte": 34430,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc.parametrize",
            "file_path": "src/_pytest/python.py",
            "file_content": "def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls",
            "start_line": 914,
            "start_column": 34647,
            "end_line": 4,
            "end_column": 40044,
            "start_byte": 34647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._resolve_arg_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)",
            "start_line": 1036,
            "start_column": 40050,
            "end_line": 4,
            "end_column": 41319,
            "start_byte": 40050,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._validate_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids",
            "start_line": 1069,
            "start_column": 41325,
            "end_line": 4,
            "end_column": 42745,
            "start_byte": 41325,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._resolve_arg_value_types",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes",
            "start_line": 1103,
            "start_column": 42751,
            "end_line": 4,
            "end_column": 44544,
            "start_byte": 42751,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._validate_if_using_arg_names",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 1142,
            "start_column": 44550,
            "end_line": 4,
            "end_column": 45943,
            "start_byte": 44550,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": " Mark.\n\n        Combines b",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 195,
            "start_column": 6452,
            "end_line": 0,
            "end_column": 7948,
            "start_byte": 6452,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.Mark.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "name = attr.ib(type=str)",
            "start_line": 198,
            "start_column": 6514,
            "end_line": 4,
            "end_column": 6538,
            "start_byte": 6514,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "args = attr.ib(type=Tuple[Any, ...])",
            "start_line": 200,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6630,
            "start_byte": 6594,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
            "start_line": 202,
            "start_column": 6683,
            "end_line": 4,
            "end_column": 6723,
            "start_byte": 6683,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._param_ids_from",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
            "start_line": 205,
            "start_column": 6780,
            "end_line": 4,
            "end_column": 6854,
            "start_byte": 6780,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._param_ids_generated",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
            "start_line": 207,
            "start_column": 6913,
            "end_line": 4,
            "end_column": 7013,
            "start_byte": 6913,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._has_param_ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
            "start_line": 211,
            "start_column": 7019,
            "end_line": 4,
            "end_column": 7111,
            "start_byte": 7019,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 214,
            "start_column": 7117,
            "end_line": 4,
            "end_column": 7948,
            "start_byte": 7117,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark._Markable",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
            "start_line": 245,
            "start_column": 8132,
            "end_line": 0,
            "end_column": 8206,
            "start_byte": 8132,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkDecorator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 248,
            "start_column": 8209,
            "end_line": 0,
            "end_column": 11549,
            "start_byte": 8209,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkDecorator.mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
            "start_line": 284,
            "start_column": 9608,
            "end_line": 4,
            "end_column": 9678,
            "start_byte": 9608,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
            "start_line": 286,
            "start_column": 9684,
            "end_line": 4,
            "end_column": 9785,
            "start_byte": 9684,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
            "start_line": 291,
            "start_column": 9791,
            "end_line": 4,
            "end_column": 9904,
            "start_byte": 9791,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
            "start_line": 296,
            "start_column": 9910,
            "end_line": 4,
            "end_column": 10031,
            "start_byte": 9910,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.markname",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
            "start_line": 301,
            "start_column": 10037,
            "end_line": 4,
            "end_column": 10147,
            "start_byte": 10037,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
            "start_line": 305,
            "start_column": 10153,
            "end_line": 4,
            "end_column": 10235,
            "start_byte": 10153,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.with_args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
            "start_line": 308,
            "start_column": 10241,
            "end_line": 4,
            "end_column": 10647,
            "start_byte": 10241,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()",
            "start_line": 322,
            "start_column": 10861,
            "end_line": 4,
            "end_column": 10981,
            "start_byte": 10861,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()",
            "start_line": 326,
            "start_column": 10987,
            "end_line": 4,
            "end_column": 11150,
            "start_byte": 10987,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def get_unpacked_marks(obj) -> List[Mark]:\n    \"\"\"\n    obtain the unpacked marks that are stored on an object\n    \"\"\"\n    mark_list = getattr(obj, \"pytestmark\", [])\n    if not isinstance(mark_list, list):\n        mark_list = [mark_list]\n    return normalize_mark_list(mark_list)",
            "start_line": 343,
            "start_column": 11552,
            "end_line": 0,
            "end_column": 11830,
            "start_byte": 11552,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"\n    normalizes marker decorating helpers to mark objects\n\n    :type mark_list: List[Union[Mark, Markdecorator]]\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(\"got {!r} instead of Mark\".format(mark))\n    return [x for x in extracted if isinstance(x, Mark)]",
            "start_line": 353,
            "start_column": 11833,
            "end_line": 0,
            "end_column": 12369,
            "start_byte": 11833,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 450,
            "start_column": 15252,
            "end_line": 0,
            "end_column": 18166,
            "start_byte": 15252,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator._config",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_config = None",
            "start_line": 465,
            "start_column": 15571,
            "end_line": 4,
            "end_column": 15585,
            "start_byte": 15571,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkGenerator._markers",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_markers = set()",
            "start_line": 466,
            "start_column": 15616,
            "end_line": 4,
            "end_column": 15632,
            "start_byte": 15616,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MARK_GEN",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "MARK_GEN = MarkGenerator()",
            "start_line": 520,
            "start_column": 18169,
            "end_line": 0,
            "end_column": 18195,
            "start_byte": 18169,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class NodeKeywords(collections.abc.MutableMapping):\n    def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n\n    def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]\n\n    def __setitem__(self, key, value):\n        self._markers[key] = value\n\n    def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")\n\n    def __iter__(self):\n        seen = self._seen()\n        return iter(seen)\n\n    def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen\n\n    def __len__(self) -> int:\n        return len(self._seen())\n\n    def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 523,
            "start_column": 18198,
            "end_line": 0,
            "end_column": 19158,
            "start_byte": 18198,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}",
            "start_line": 524,
            "start_column": 18254,
            "end_line": 4,
            "end_column": 18380,
            "start_byte": 18254,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]",
            "start_line": 529,
            "start_column": 18386,
            "end_line": 4,
            "end_column": 18592,
            "start_byte": 18386,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __setitem__(self, key, value):\n        self._markers[key] = value",
            "start_line": 537,
            "start_column": 18598,
            "end_line": 4,
            "end_column": 18667,
            "start_byte": 18598,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")",
            "start_line": 540,
            "start_column": 18673,
            "end_line": 4,
            "end_column": 18763,
            "start_byte": 18673,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __iter__(self):\n        seen = self._seen()\n        return iter(seen)",
            "start_line": 543,
            "start_column": 18769,
            "end_line": 4,
            "end_column": 18842,
            "start_byte": 18769,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen",
            "start_line": 547,
            "start_column": 18848,
            "end_line": 4,
            "end_column": 19000,
            "start_byte": 18848,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __len__(self) -> int:\n        return len(self._seen())",
            "start_line": 553,
            "start_column": 19006,
            "end_line": 4,
            "end_column": 19064,
            "start_byte": 19006,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 556,
            "start_column": 19070,
            "end_line": 4,
            "end_column": 19158,
            "start_byte": 19070,
            "end_byte": 4
          },
          {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
            "start_line": 77,
            "start_column": 1903,
            "end_line": 0,
            "end_column": 2100,
            "start_byte": 1903,
            "end_byte": 0
          },
          {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "   @classmethod\n    d",
            "start_line": 83,
            "start_column": 2079,
            "end_line": 4,
            "end_column": 2100,
            "start_byte": 2079,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 740,
            "start_column": 23827,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 23827,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16497,
            "end_line": 0,
            "end_column": 16671,
            "start_byte": 16497,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 698,
            "start_column": 25610,
            "end_line": 4,
            "end_column": 25826,
            "start_byte": 25610,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "        msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n           ",
            "start_line": 143,
            "start_column": 4461,
            "end_line": 0,
            "end_column": 4996,
            "start_byte": 4461,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    if xfailed is None:\n        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield",
            "start_line": 246,
            "start_column": 8107,
            "end_line": 0,
            "end_column": 8487,
            "start_byte": 8107,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker) -> None:\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 548,
            "start_column": 21159,
            "end_line": 4,
            "end_column": 21551,
            "start_byte": 21159,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState",
            "file_path": "src/_pytest/runner.py",
            "file_content": "class SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]\n\n    def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)\n\n    def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)\n\n    def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)\n\n    def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 353,
            "start_column": 11976,
            "end_line": 0,
            "end_column": 14977,
            "start_byte": 11976,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.SetupState.__init__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]",
            "start_line": 356,
            "start_column": 12078,
            "end_line": 4,
            "end_column": 12219,
            "start_byte": 12078,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.addfinalizer",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)",
            "start_line": 360,
            "start_column": 12225,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 12225,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._pop_and_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)",
            "start_line": 367,
            "start_column": 12600,
            "end_line": 4,
            "end_column": 12713,
            "start_byte": 12600,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._callfinalizers",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 371,
            "start_column": 12719,
            "end_line": 4,
            "end_column": 13193,
            "start_byte": 12719,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._teardown_with_finalization",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack",
            "start_line": 386,
            "start_column": 13199,
            "end_line": 4,
            "end_column": 13401,
            "start_byte": 13199,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.teardown_all",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers",
            "start_line": 392,
            "start_column": 13407,
            "end_line": 4,
            "end_column": 13630,
            "start_byte": 13407,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.teardown_exact",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)",
            "start_line": 399,
            "start_column": 13636,
            "end_line": 4,
            "end_column": 13803,
            "start_byte": 13636,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._teardown_towards",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 403,
            "start_column": 13809,
            "end_line": 4,
            "end_column": 14311,
            "start_byte": 13809,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.prepare",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 418,
            "start_column": 14317,
            "end_line": 4,
            "end_column": 14977,
            "start_byte": 14317,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 104,
            "start_column": 3022,
            "end_line": 0,
            "end_column": 3927,
            "start_byte": 3022,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)  # type: TestReport\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 203,
            "start_column": 6228,
            "end_line": 0,
            "end_column": 6718,
            "start_byte": 6228,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 216,
            "start_column": 6721,
            "end_line": 0,
            "end_column": 7203,
            "start_byte": 6721,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T13:47:13.483593",
        "usage": "13115.761995315552 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.debugging.PdbTrace.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "  def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if n",
            "start_line": 293,
            "start_column": 9927,
            "end_line": 4,
            "end_column": 10098,
            "start_byte": 9927,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[o",
            "start_line": 338,
            "start_column": 11720,
            "end_line": 0,
            "end_column": 11918,
            "start_byte": 11720,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True",
            "start_line": 171,
            "start_column": 5901,
            "end_line": 0,
            "end_column": 6398,
            "start_byte": 5901,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Metafunc",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Metafunc:\n    \"\"\"\n    Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls\n\n    def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)\n\n    def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes\n\n    def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 872,
            "start_column": 33237,
            "end_line": 0,
            "end_column": 45943,
            "start_byte": 33237,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Metafunc.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs",
            "start_line": 880,
            "start_column": 33570,
            "end_line": 4,
            "end_column": 34424,
            "start_byte": 33570,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 908,
            "start_column": 34430,
            "end_line": 4,
            "end_column": 34641,
            "start_byte": 34430,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc.parametrize",
            "file_path": "src/_pytest/python.py",
            "file_content": "def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls",
            "start_line": 914,
            "start_column": 34647,
            "end_line": 4,
            "end_column": 40044,
            "start_byte": 34647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._resolve_arg_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)",
            "start_line": 1036,
            "start_column": 40050,
            "end_line": 4,
            "end_column": 41319,
            "start_byte": 40050,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._validate_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids",
            "start_line": 1069,
            "start_column": 41325,
            "end_line": 4,
            "end_column": 42745,
            "start_byte": 41325,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._resolve_arg_value_types",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes",
            "start_line": 1103,
            "start_column": 42751,
            "end_line": 4,
            "end_column": 44544,
            "start_byte": 42751,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Metafunc._validate_if_using_arg_names",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 1142,
            "start_column": 44550,
            "end_line": 4,
            "end_column": 45943,
            "start_byte": 44550,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": " Mark.\n\n        Combines b",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 195,
            "start_column": 6452,
            "end_line": 0,
            "end_column": 7948,
            "start_byte": 6452,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.Mark.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "name = attr.ib(type=str)",
            "start_line": 198,
            "start_column": 6514,
            "end_line": 4,
            "end_column": 6538,
            "start_byte": 6514,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "args = attr.ib(type=Tuple[Any, ...])",
            "start_line": 200,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6630,
            "start_byte": 6594,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
            "start_line": 202,
            "start_column": 6683,
            "end_line": 4,
            "end_column": 6723,
            "start_byte": 6683,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._param_ids_from",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
            "start_line": 205,
            "start_column": 6780,
            "end_line": 4,
            "end_column": 6854,
            "start_byte": 6780,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._param_ids_generated",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
            "start_line": 207,
            "start_column": 6913,
            "end_line": 4,
            "end_column": 7013,
            "start_byte": 6913,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark._has_param_ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
            "start_line": 211,
            "start_column": 7019,
            "end_line": 4,
            "end_column": 7111,
            "start_byte": 7019,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 214,
            "start_column": 7117,
            "end_line": 4,
            "end_column": 7948,
            "start_byte": 7117,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark._Markable",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
            "start_line": 245,
            "start_column": 8132,
            "end_line": 0,
            "end_column": 8206,
            "start_byte": 8132,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkDecorator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 248,
            "start_column": 8209,
            "end_line": 0,
            "end_column": 11549,
            "start_byte": 8209,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkDecorator.mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
            "start_line": 284,
            "start_column": 9608,
            "end_line": 4,
            "end_column": 9678,
            "start_byte": 9608,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
            "start_line": 286,
            "start_column": 9684,
            "end_line": 4,
            "end_column": 9785,
            "start_byte": 9684,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
            "start_line": 291,
            "start_column": 9791,
            "end_line": 4,
            "end_column": 9904,
            "start_byte": 9791,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
            "start_line": 296,
            "start_column": 9910,
            "end_line": 4,
            "end_column": 10031,
            "start_byte": 9910,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.markname",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
            "start_line": 301,
            "start_column": 10037,
            "end_line": 4,
            "end_column": 10147,
            "start_byte": 10037,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
            "start_line": 305,
            "start_column": 10153,
            "end_line": 4,
            "end_column": 10235,
            "start_byte": 10153,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.with_args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
            "start_line": 308,
            "start_column": 10241,
            "end_line": 4,
            "end_column": 10647,
            "start_byte": 10241,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()",
            "start_line": 322,
            "start_column": 10861,
            "end_line": 4,
            "end_column": 10981,
            "start_byte": 10861,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()",
            "start_line": 326,
            "start_column": 10987,
            "end_line": 4,
            "end_column": 11150,
            "start_byte": 10987,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def get_unpacked_marks(obj) -> List[Mark]:\n    \"\"\"\n    obtain the unpacked marks that are stored on an object\n    \"\"\"\n    mark_list = getattr(obj, \"pytestmark\", [])\n    if not isinstance(mark_list, list):\n        mark_list = [mark_list]\n    return normalize_mark_list(mark_list)",
            "start_line": 343,
            "start_column": 11552,
            "end_line": 0,
            "end_column": 11830,
            "start_byte": 11552,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"\n    normalizes marker decorating helpers to mark objects\n\n    :type mark_list: List[Union[Mark, Markdecorator]]\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(\"got {!r} instead of Mark\".format(mark))\n    return [x for x in extracted if isinstance(x, Mark)]",
            "start_line": 353,
            "start_column": 11833,
            "end_line": 0,
            "end_column": 12369,
            "start_byte": 11833,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 450,
            "start_column": 15252,
            "end_line": 0,
            "end_column": 18166,
            "start_byte": 15252,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator._config",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_config = None",
            "start_line": 465,
            "start_column": 15571,
            "end_line": 4,
            "end_column": 15585,
            "start_byte": 15571,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkGenerator._markers",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_markers = set()",
            "start_line": 466,
            "start_column": 15616,
            "end_line": 4,
            "end_column": 15632,
            "start_byte": 15616,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MARK_GEN",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "MARK_GEN = MarkGenerator()",
            "start_line": 520,
            "start_column": 18169,
            "end_line": 0,
            "end_column": 18195,
            "start_byte": 18169,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class NodeKeywords(collections.abc.MutableMapping):\n    def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n\n    def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]\n\n    def __setitem__(self, key, value):\n        self._markers[key] = value\n\n    def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")\n\n    def __iter__(self):\n        seen = self._seen()\n        return iter(seen)\n\n    def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen\n\n    def __len__(self) -> int:\n        return len(self._seen())\n\n    def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 523,
            "start_column": 18198,
            "end_line": 0,
            "end_column": 19158,
            "start_byte": 18198,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}",
            "start_line": 524,
            "start_column": 18254,
            "end_line": 4,
            "end_column": 18380,
            "start_byte": 18254,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]",
            "start_line": 529,
            "start_column": 18386,
            "end_line": 4,
            "end_column": 18592,
            "start_byte": 18386,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __setitem__(self, key, value):\n        self._markers[key] = value",
            "start_line": 537,
            "start_column": 18598,
            "end_line": 4,
            "end_column": 18667,
            "start_byte": 18598,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")",
            "start_line": 540,
            "start_column": 18673,
            "end_line": 4,
            "end_column": 18763,
            "start_byte": 18673,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __iter__(self):\n        seen = self._seen()\n        return iter(seen)",
            "start_line": 543,
            "start_column": 18769,
            "end_line": 4,
            "end_column": 18842,
            "start_byte": 18769,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen",
            "start_line": 547,
            "start_column": 18848,
            "end_line": 4,
            "end_column": 19000,
            "start_byte": 18848,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __len__(self) -> int:\n        return len(self._seen())",
            "start_line": 553,
            "start_column": 19006,
            "end_line": 4,
            "end_column": 19064,
            "start_byte": 19006,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 556,
            "start_column": 19070,
            "end_line": 4,
            "end_column": 19158,
            "start_byte": 19070,
            "end_byte": 4
          },
          {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
            "start_line": 77,
            "start_column": 1903,
            "end_line": 0,
            "end_column": 2100,
            "start_byte": 1903,
            "end_byte": 0
          },
          {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "   @classmethod\n    d",
            "start_line": 83,
            "start_column": 2079,
            "end_line": 4,
            "end_column": 2100,
            "start_byte": 2079,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 740,
            "start_column": 23827,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 23827,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16497,
            "end_line": 0,
            "end_column": 16671,
            "start_byte": 16497,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 698,
            "start_column": 25610,
            "end_line": 4,
            "end_column": 25826,
            "start_byte": 25610,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "        msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n           ",
            "start_line": 143,
            "start_column": 4461,
            "end_line": 0,
            "end_column": 4996,
            "start_byte": 4461,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    if xfailed is None:\n        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield",
            "start_line": 246,
            "start_column": 8107,
            "end_line": 0,
            "end_column": 8487,
            "start_byte": 8107,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker) -> None:\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 548,
            "start_column": 21159,
            "end_line": 4,
            "end_column": 21551,
            "start_byte": 21159,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState",
            "file_path": "src/_pytest/runner.py",
            "file_content": "class SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]\n\n    def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)\n\n    def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)\n\n    def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)\n\n    def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 353,
            "start_column": 11976,
            "end_line": 0,
            "end_column": 14977,
            "start_byte": 11976,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.SetupState.__init__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]",
            "start_line": 356,
            "start_column": 12078,
            "end_line": 4,
            "end_column": 12219,
            "start_byte": 12078,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.addfinalizer",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)",
            "start_line": 360,
            "start_column": 12225,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 12225,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._pop_and_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)",
            "start_line": 367,
            "start_column": 12600,
            "end_line": 4,
            "end_column": 12713,
            "start_byte": 12600,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._callfinalizers",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 371,
            "start_column": 12719,
            "end_line": 4,
            "end_column": 13193,
            "start_byte": 12719,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._teardown_with_finalization",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack",
            "start_line": 386,
            "start_column": 13199,
            "end_line": 4,
            "end_column": 13401,
            "start_byte": 13199,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.teardown_all",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers",
            "start_line": 392,
            "start_column": 13407,
            "end_line": 4,
            "end_column": 13630,
            "start_byte": 13407,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.teardown_exact",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)",
            "start_line": 399,
            "start_column": 13636,
            "end_line": 4,
            "end_column": 13803,
            "start_byte": 13636,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState._teardown_towards",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 403,
            "start_column": 13809,
            "end_line": 4,
            "end_column": 14311,
            "start_byte": 13809,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.SetupState.prepare",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 418,
            "start_column": 14317,
            "end_line": 4,
            "end_column": 14977,
            "start_byte": 14317,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 104,
            "start_column": 3022,
            "end_line": 0,
            "end_column": 3927,
            "start_byte": 3022,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)  # type: TestReport\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 203,
            "start_column": 6228,
            "end_line": 0,
            "end_column": 6718,
            "start_byte": 6228,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 216,
            "start_column": 6721,
            "end_line": 0,
            "end_column": 7203,
            "start_byte": 6721,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The user is reporting an issue with Pytest 6 where dynamically adding an xfail marker to a test no longer ignores failures as it did in Pytest 5.\n2. In Pytest 5.x, dynamically adding an xfail marker treated failing tests like tests marked statically with xfail, including raising exceptions.\n3. Expected behavior is for dynamic xfail markers to ignore test failures.\n4. There is no specific suggestion from the user except expecting previous behavior from version 5.x.\n5. The solution may involve handling test markers more consistently, especially for dynamically added xfail markers. \n6. Symbols possibly related to this issue involve implementation and handling of markers and their effects during test execution.",
        "symbols": [
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "reason": "The function `add_marker` is directly involved in adding markers to nodes during a test, including the xfail marker mentioned in the issue."
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "reason": "This function evaluates the xfail markers and needs to handle dynamic xfail markers correctly according to the described problem."
          },
          {
            "name": "_pytest.skipping.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "reason": "This hook implementation involves running tests and handling skip and xfail logic, which is directly related to the issue described."
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "reason": "It appears to influence the outcome recorded when there's an xfail, something that is clearly described in the issue context, including re-evaluation of outcomes and proper marking."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The symbol `_pytest.nodes.Node.add_marker` is involved in how markers, including xfail, are applied to test nodes. This is relevant because the complaint is about how xfail markers affect the test outcome, which starts with how they are added.",
          "The symbol `_pytest.skipping.evaluate_xfail_marks` deals with appraising whether an xfail should be applied to a test. This correlates to the issue since there may be a mismatch in expected outcomes when dynamically adding an xfail.",
          "The symbol `_pytest.skipping.pytest_runtest_call` should oversee how tests are executed in light of xfail or skip conditions, key to understanding where the behavior deviates from expectations.",
          "The symbol `_pytest.skipping.pytest_runtest_makereport` gathers test results and marks that are confirmed or modified in the process, which encompass xfail handling, requiring inspecting for correct behavior application."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T13:47:26.599389",
        "usage": "7.112264633178711 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.debugging.PdbTrace.pytest_pyfunc_call",
              "file_path": "src/_pytest/python.py",
              "file_content": "  def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if n",
              "start_line": 293,
              "start_column": 9927,
              "end_line": 4,
              "end_column": 10098,
              "start_byte": 9927,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_pyfunc_call",
              "file_path": "src/_pytest/python.py",
              "file_content": "\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[o",
              "start_line": 338,
              "start_column": 11720,
              "end_line": 0,
              "end_column": 11918,
              "start_byte": 11720,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_pyfunc_call",
              "file_path": "src/_pytest/python.py",
              "file_content": "@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True",
              "start_line": 171,
              "start_column": 5901,
              "end_line": 0,
              "end_column": 6398,
              "start_byte": 5901,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Metafunc",
              "file_path": "src/_pytest/python.py",
              "file_content": "class Metafunc:\n    \"\"\"\n    Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls\n\n    def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)\n\n    def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes\n\n    def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
              "start_line": 872,
              "start_column": 33237,
              "end_line": 0,
              "end_column": 45943,
              "start_byte": 33237,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Metafunc.__init__",
              "file_path": "src/_pytest/python.py",
              "file_content": "def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs",
              "start_line": 880,
              "start_column": 33570,
              "end_line": 4,
              "end_column": 34424,
              "start_byte": 33570,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc.funcargnames",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
              "start_line": 908,
              "start_column": 34430,
              "end_line": 4,
              "end_column": 34641,
              "start_byte": 34430,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc.parametrize",
              "file_path": "src/_pytest/python.py",
              "file_content": "def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls",
              "start_line": 914,
              "start_column": 34647,
              "end_line": 4,
              "end_column": 40044,
              "start_byte": 34647,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc._resolve_arg_ids",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)",
              "start_line": 1036,
              "start_column": 40050,
              "end_line": 4,
              "end_column": 41319,
              "start_byte": 40050,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc._validate_ids",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids",
              "start_line": 1069,
              "start_column": 41325,
              "end_line": 4,
              "end_column": 42745,
              "start_byte": 41325,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc._resolve_arg_value_types",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes",
              "start_line": 1103,
              "start_column": 42751,
              "end_line": 4,
              "end_column": 44544,
              "start_byte": 42751,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Metafunc._validate_if_using_arg_names",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
              "start_line": 1142,
              "start_column": 44550,
              "end_line": 4,
              "end_column": 45943,
              "start_byte": 44550,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1174,
              "start_column": 45925,
              "end_line": 0,
              "end_column": 47430,
              "start_byte": 45925,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1176,
              "start_column": 45979,
              "end_line": 4,
              "end_column": 46049,
              "start_byte": 45979,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.params",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1177,
              "start_column": 46054,
              "end_line": 4,
              "end_column": 46134,
              "start_byte": 46054,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1178,
              "start_column": 46139,
              "end_line": 4,
              "end_column": 46182,
              "start_byte": 46139,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1179,
              "start_column": 46187,
              "end_line": 4,
              "end_column": 46411,
              "start_byte": 46187,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.name",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1187,
              "start_column": 46416,
              "end_line": 4,
              "end_column": 46464,
              "start_byte": 46416,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "",
              "start_line": 1189,
              "start_column": 46470,
              "end_line": 4,
              "end_column": 47430,
              "start_byte": 46470,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkMatcher",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
              "start_line": 214,
              "start_column": 7079,
              "end_line": 0,
              "end_column": 7525,
              "start_byte": 7079,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkMatcher.own_mark_names",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": " Mark.\n\n        Combines b",
              "start_line": 221,
              "start_column": 7251,
              "end_line": 4,
              "end_column": 7277,
              "start_byte": 7251,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkMatcher.from_item",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
              "start_line": 223,
              "start_column": 7283,
              "end_line": 4,
              "end_column": 7438,
              "start_byte": 7283,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkMatcher.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
              "start_line": 228,
              "start_column": 7444,
              "end_line": 4,
              "end_column": 7525,
              "start_byte": 7444,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
              "start_line": 195,
              "start_column": 6452,
              "end_line": 0,
              "end_column": 7948,
              "start_byte": 6452,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.Mark.name",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "name = attr.ib(type=str)",
              "start_line": 198,
              "start_column": 6514,
              "end_line": 4,
              "end_column": 6538,
              "start_byte": 6514,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark.args",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "args = attr.ib(type=Tuple[Any, ...])",
              "start_line": 200,
              "start_column": 6594,
              "end_line": 4,
              "end_column": 6630,
              "start_byte": 6594,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark.kwargs",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
              "start_line": 202,
              "start_column": 6683,
              "end_line": 4,
              "end_column": 6723,
              "start_byte": 6683,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark._param_ids_from",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
              "start_line": 205,
              "start_column": 6780,
              "end_line": 4,
              "end_column": 6854,
              "start_byte": 6780,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark._param_ids_generated",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
              "start_line": 207,
              "start_column": 6913,
              "end_line": 4,
              "end_column": 7013,
              "start_byte": 6913,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark._has_param_ids",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
              "start_line": 211,
              "start_column": 7019,
              "end_line": 4,
              "end_column": 7111,
              "start_byte": 7019,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.Mark.combined_with",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
              "start_line": 214,
              "start_column": 7117,
              "end_line": 4,
              "end_column": 7948,
              "start_byte": 7117,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark._Markable",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
              "start_line": 245,
              "start_column": 8132,
              "end_line": 0,
              "end_column": 8206,
              "start_byte": 8132,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkDecorator",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
              "start_line": 248,
              "start_column": 8209,
              "end_line": 0,
              "end_column": 11549,
              "start_byte": 8209,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkDecorator.mark",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
              "start_line": 284,
              "start_column": 9608,
              "end_line": 4,
              "end_column": 9678,
              "start_byte": 9608,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.name",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
              "start_line": 286,
              "start_column": 9684,
              "end_line": 4,
              "end_column": 9785,
              "start_byte": 9684,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.args",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
              "start_line": 291,
              "start_column": 9791,
              "end_line": 4,
              "end_column": 9904,
              "start_byte": 9791,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.kwargs",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
              "start_line": 296,
              "start_column": 9910,
              "end_line": 4,
              "end_column": 10031,
              "start_byte": 9910,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.markname",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
              "start_line": 301,
              "start_column": 10037,
              "end_line": 4,
              "end_column": 10147,
              "start_byte": 10037,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__repr__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
              "start_line": 305,
              "start_column": 10153,
              "end_line": 4,
              "end_column": 10235,
              "start_byte": 10153,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.with_args",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
              "start_line": 308,
              "start_column": 10241,
              "end_line": 4,
              "end_column": 10647,
              "start_byte": 10241,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()",
              "start_line": 322,
              "start_column": 10861,
              "end_line": 4,
              "end_column": 10981,
              "start_byte": 10861,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "@overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()",
              "start_line": 326,
              "start_column": 10987,
              "end_line": 4,
              "end_column": 11150,
              "start_byte": 10987,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkDecorator.__call__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
              "start_line": 332,
              "start_column": 11156,
              "end_line": 4,
              "end_column": 11549,
              "start_byte": 11156,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.get_unpacked_marks",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def get_unpacked_marks(obj) -> List[Mark]:\n    \"\"\"\n    obtain the unpacked marks that are stored on an object\n    \"\"\"\n    mark_list = getattr(obj, \"pytestmark\", [])\n    if not isinstance(mark_list, list):\n        mark_list = [mark_list]\n    return normalize_mark_list(mark_list)",
              "start_line": 343,
              "start_column": 11552,
              "end_line": 0,
              "end_column": 11830,
              "start_byte": 11552,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.normalize_mark_list",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"\n    normalizes marker decorating helpers to mark objects\n\n    :type mark_list: List[Union[Mark, Markdecorator]]\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(\"got {!r} instead of Mark\".format(mark))\n    return [x for x in extracted if isinstance(x, Mark)]",
              "start_line": 353,
              "start_column": 11833,
              "end_line": 0,
              "end_column": 12369,
              "start_byte": 11833,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.store_mark",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
              "start_line": 369,
              "start_column": 12372,
              "end_line": 0,
              "end_column": 12724,
              "start_byte": 12372,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkGenerator",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
              "start_line": 450,
              "start_column": 15252,
              "end_line": 0,
              "end_column": 18166,
              "start_byte": 15252,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.MarkGenerator._config",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "_config = None",
              "start_line": 465,
              "start_column": 15571,
              "end_line": 4,
              "end_column": 15585,
              "start_byte": 15571,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkGenerator._markers",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "_markers = set()",
              "start_line": 466,
              "start_column": 15616,
              "end_line": 4,
              "end_column": 15632,
              "start_byte": 15616,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MarkGenerator.__getattr__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
              "start_line": 479,
              "start_column": 16175,
              "end_line": 4,
              "end_column": 18166,
              "start_byte": 16175,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.MARK_GEN",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "MARK_GEN = MarkGenerator()",
              "start_line": 520,
              "start_column": 18169,
              "end_line": 0,
              "end_column": 18195,
              "start_byte": 18169,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeKeywords",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "class NodeKeywords(collections.abc.MutableMapping):\n    def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n\n    def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]\n\n    def __setitem__(self, key, value):\n        self._markers[key] = value\n\n    def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")\n\n    def __iter__(self):\n        seen = self._seen()\n        return iter(seen)\n\n    def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen\n\n    def __len__(self) -> int:\n        return len(self._seen())\n\n    def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
              "start_line": 523,
              "start_column": 18198,
              "end_line": 0,
              "end_column": 19158,
              "start_byte": 18198,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.NodeKeywords.__init__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}",
              "start_line": 524,
              "start_column": 18254,
              "end_line": 4,
              "end_column": 18380,
              "start_byte": 18254,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__getitem__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]",
              "start_line": 529,
              "start_column": 18386,
              "end_line": 4,
              "end_column": 18592,
              "start_byte": 18386,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__setitem__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __setitem__(self, key, value):\n        self._markers[key] = value",
              "start_line": 537,
              "start_column": 18598,
              "end_line": 4,
              "end_column": 18667,
              "start_byte": 18598,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__delitem__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")",
              "start_line": 540,
              "start_column": 18673,
              "end_line": 4,
              "end_column": 18763,
              "start_byte": 18673,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__iter__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __iter__(self):\n        seen = self._seen()\n        return iter(seen)",
              "start_line": 543,
              "start_column": 18769,
              "end_line": 4,
              "end_column": 18842,
              "start_byte": 18769,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords._seen",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen",
              "start_line": 547,
              "start_column": 18848,
              "end_line": 4,
              "end_column": 19000,
              "start_byte": 18848,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__len__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __len__(self) -> int:\n        return len(self._seen())",
              "start_line": 553,
              "start_column": 19006,
              "end_line": 4,
              "end_column": 19064,
              "start_byte": 19006,
              "end_byte": 4
            },
            {
              "name": "_pytest.mark.NodeKeywords.__repr__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
              "start_line": 556,
              "start_column": 19070,
              "end_line": 4,
              "end_column": 19158,
              "start_byte": 19070,
              "end_byte": 4
            },
            {
              "name": "_pytest.warning_types.PytestUnknownMarkWarning",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
              "start_line": 77,
              "start_column": 1903,
              "end_line": 0,
              "end_column": 2100,
              "start_byte": 1903,
              "end_byte": 0
            },
            {
              "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
              "file_path": "src/_pytest/mark/structures.py",
              "file_content": "   @classmethod\n    d",
              "start_line": 83,
              "start_column": 2079,
              "end_line": 4,
              "end_column": 2100,
              "start_byte": 2079,
              "end_byte": 4
            },
            {
              "name": "_pytest.capture.CaptureManager.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 740,
              "start_column": 23827,
              "end_line": 4,
              "end_column": 24003,
              "start_byte": 23827,
              "end_byte": 4
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 464,
              "start_column": 16497,
              "end_line": 0,
              "end_column": 16671,
              "start_byte": 16497,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 486,
              "start_column": 17380,
              "end_line": 0,
              "end_column": 17867,
              "start_byte": 17380,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "",
              "start_line": 698,
              "start_column": 25610,
              "end_line": 4,
              "end_column": 25826,
              "start_byte": 25610,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "        msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n           ",
              "start_line": 143,
              "start_column": 4461,
              "end_line": 0,
              "end_column": 4996,
              "start_byte": 4461,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
              "start_line": 318,
              "start_column": 10464,
              "end_line": 0,
              "end_column": 10595,
              "start_byte": 10464,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.evaluate_xfail_marks",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
              "start_line": 199,
              "start_column": 6507,
              "end_line": 0,
              "end_column": 7408,
              "start_byte": 6507,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    if xfailed is None:\n        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield",
              "start_line": 246,
              "start_column": 8107,
              "end_line": 0,
              "end_column": 8487,
              "start_byte": 8107,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
              "start_line": 259,
              "start_column": 8490,
              "end_line": 0,
              "end_column": 10447,
              "start_byte": 8490,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
              "start_line": 290,
              "start_column": 10683,
              "end_line": 0,
              "end_column": 11441,
              "start_byte": 10683,
              "end_byte": 0
            },
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
              "start_line": 260,
              "start_column": 8242,
              "end_line": 4,
              "end_column": 9073,
              "start_byte": 8242,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureRequest.applymarker",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def applymarker(self, marker) -> None:\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
              "start_line": 548,
              "start_column": 21159,
              "end_line": 4,
              "end_column": 21551,
              "start_byte": 21159,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState",
              "file_path": "src/_pytest/runner.py",
              "file_content": "class SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]\n\n    def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)\n\n    def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)\n\n    def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)\n\n    def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
              "start_line": 353,
              "start_column": 11976,
              "end_line": 0,
              "end_column": 14977,
              "start_byte": 11976,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.SetupState.__init__",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]",
              "start_line": 356,
              "start_column": 12078,
              "end_line": 4,
              "end_column": 12219,
              "start_byte": 12078,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState.addfinalizer",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)",
              "start_line": 360,
              "start_column": 12225,
              "end_line": 4,
              "end_column": 12594,
              "start_byte": 12225,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState._pop_and_teardown",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)",
              "start_line": 367,
              "start_column": 12600,
              "end_line": 4,
              "end_column": 12713,
              "start_byte": 12600,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState._callfinalizers",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
              "start_line": 371,
              "start_column": 12719,
              "end_line": 4,
              "end_column": 13193,
              "start_byte": 12719,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState._teardown_with_finalization",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack",
              "start_line": 386,
              "start_column": 13199,
              "end_line": 4,
              "end_column": 13401,
              "start_byte": 13199,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState.teardown_all",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers",
              "start_line": 392,
              "start_column": 13407,
              "end_line": 4,
              "end_column": 13630,
              "start_byte": 13407,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState.teardown_exact",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)",
              "start_line": 399,
              "start_column": 13636,
              "end_line": 4,
              "end_column": 13803,
              "start_byte": 13636,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState._teardown_towards",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
              "start_line": 403,
              "start_column": 13809,
              "end_line": 4,
              "end_column": 14311,
              "start_byte": 13809,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.SetupState.prepare",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
              "start_line": 418,
              "start_column": 14317,
              "end_line": 4,
              "end_column": 14977,
              "start_byte": 14317,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.fixtures._FixtureFunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
              "start_line": 73,
              "start_column": 2273,
              "end_line": 0,
              "end_column": 2348,
              "start_byte": 2273,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker",
              "file_path": "src/_pytest/python.py",
              "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
              "start_line": 1174,
              "start_column": 45925,
              "end_line": 0,
              "end_column": 47430,
              "start_byte": 45925,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
              "file_path": "src/_pytest/python.py",
              "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
              "start_line": 1176,
              "start_column": 45979,
              "end_line": 4,
              "end_column": 46049,
              "start_byte": 45979,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.params",
              "file_path": "src/_pytest/python.py",
              "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
              "start_line": 1177,
              "start_column": 46054,
              "end_line": 4,
              "end_column": 46134,
              "start_byte": 46054,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
              "file_path": "src/_pytest/python.py",
              "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
              "start_line": 1178,
              "start_column": 46139,
              "end_line": 4,
              "end_column": 46182,
              "start_byte": 46139,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
              "file_path": "src/_pytest/python.py",
              "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
              "start_line": 1179,
              "start_column": 46187,
              "end_line": 4,
              "end_column": 46411,
              "start_byte": 46187,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.name",
              "file_path": "src/_pytest/python.py",
              "file_content": "s), return the most narrow scope based on the fi",
              "start_line": 1187,
              "start_column": 46416,
              "end_line": 4,
              "end_column": 46464,
              "start_byte": 46416,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
              "file_path": "src/_pytest/python.py",
              "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
              "start_line": 1189,
              "start_column": 46470,
              "end_line": 4,
              "end_column": 47430,
              "start_byte": 46470,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function",
              "file_path": "src/_pytest/python.py",
              "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1444,
              "start_column": 55214,
              "end_line": 0,
              "end_column": 61637,
              "start_byte": 55214,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.Function._ALLOW_MARKERS",
              "file_path": "src/_pytest/python.py",
              "file_content": "_ALLOW_MARKERS = False",
              "start_line": 1450,
              "start_column": 55414,
              "end_line": 4,
              "end_column": 55436,
              "start_byte": 55414,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.__init__",
              "file_path": "src/_pytest/python.py",
              "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
              "start_line": 1452,
              "start_column": 55442,
              "end_line": 4,
              "end_column": 58875,
              "start_byte": 55442,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.from_parent",
              "file_path": "src/_pytest/python.py",
              "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
              "start_line": 1532,
              "start_column": 58881,
              "end_line": 4,
              "end_column": 59087,
              "start_byte": 58881,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._initrequest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
              "start_line": 1539,
              "start_column": 59093,
              "end_line": 4,
              "end_column": 59232,
              "start_byte": 59093,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.function",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
              "start_line": 1543,
              "start_column": 59238,
              "end_line": 4,
              "end_column": 59352,
              "start_byte": 59238,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._getobj",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
              "start_line": 1548,
              "start_column": 59358,
              "end_line": 4,
              "end_column": 59504,
              "start_byte": 59358,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._pyfuncitem",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
              "start_line": 1552,
              "start_column": 59510,
              "end_line": 4,
              "end_column": 59641,
              "start_byte": 59510,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.funcargnames",
              "file_path": "src/_pytest/python.py",
              "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
              "start_line": 1557,
              "start_column": 59647,
              "end_line": 4,
              "end_column": 59858,
              "start_byte": 59647,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
              "start_line": 1563,
              "start_column": 59864,
              "end_line": 4,
              "end_column": 59999,
              "start_byte": 59864,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
              "start_line": 1567,
              "start_column": 60005,
              "end_line": 4,
              "end_column": 60189,
              "start_byte": 60005,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
              "start_line": 1573,
              "start_column": 60195,
              "end_line": 4,
              "end_column": 61273,
              "start_byte": 60195,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.Function.repr_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
              "start_line": 1595,
              "start_column": 61335,
              "end_line": 4,
              "end_column": 61637,
              "start_byte": 61335,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition",
              "file_path": "src/_pytest/python.py",
              "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
              "start_line": 1604,
              "start_column": 61640,
              "end_line": 0,
              "end_column": 61918,
              "start_byte": 61640,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.FunctionDefinition.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
              "start_line": 1610,
              "start_column": 61792,
              "end_line": 4,
              "end_column": 61897,
              "start_byte": 61792,
              "end_byte": 4
            },
            {
              "name": "_pytest.python.FunctionDefinition.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "setup = runtest",
              "start_line": 1613,
              "start_column": 61903,
              "end_line": 4,
              "end_column": 61918,
              "start_byte": 61903,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction",
              "file_path": "src/_pytest/python.py",
              "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
              "start_line": 141,
              "start_column": 4727,
              "end_line": 0,
              "end_column": 10680,
              "start_byte": 4727,
              "end_byte": 0
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
              "file_path": "src/_pytest/python.py",
              "file_content": "nly one name \"\n  ",
              "start_line": 142,
              "start_column": 4765,
              "end_line": 4,
              "end_column": 4782,
              "start_byte": 4765,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._excinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": " \"or a list of ",
              "start_line": 143,
              "start_column": 4787,
              "end_line": 4,
              "end_column": 4802,
              "start_byte": 4787,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._testcase",
              "file_path": "src/_pytest/python.py",
              "file_content": "       \"Example:",
              "start_line": 144,
              "start_column": 4860,
              "end_line": 4,
              "end_column": 4876,
              "start_byte": 4860,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.setup",
              "file_path": "src/_pytest/python.py",
              "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
              "start_line": 146,
              "start_column": 4919,
              "end_line": 4,
              "end_column": 5357,
              "start_byte": 4919,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.teardown",
              "file_path": "src/_pytest/python.py",
              "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
              "start_line": 155,
              "start_column": 5363,
              "end_line": 4,
              "end_column": 5574,
              "start_byte": 5363,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.startTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
              "start_line": 162,
              "start_column": 5580,
              "end_line": 4,
              "end_column": 5652,
              "start_byte": 5580,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
              "file_path": "src/_pytest/python.py",
              "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
              "start_line": 165,
              "start_column": 5658,
              "end_line": 4,
              "end_column": 7099,
              "start_byte": 5658,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addError",
              "file_path": "src/_pytest/python.py",
              "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
              "start_line": 198,
              "start_column": 7105,
              "end_line": 4,
              "end_column": 7399,
              "start_byte": 7105,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
              "start_line": 208,
              "start_column": 7405,
              "end_line": 4,
              "end_column": 7547,
              "start_byte": 7405,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSkip",
              "file_path": "src/_pytest/python.py",
              "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
              "start_line": 213,
              "start_column": 7553,
              "end_line": 4,
              "end_column": 7789,
              "start_byte": 7553,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
              "file_path": "src/_pytest/python.py",
              "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
              "start_line": 220,
              "start_column": 7795,
              "end_line": 4,
              "end_column": 8072,
              "start_byte": 7795,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
              "start_line": 231,
              "start_column": 8078,
              "end_line": 4,
              "end_column": 8232,
              "start_byte": 8078,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.addSuccess",
              "file_path": "src/_pytest/python.py",
              "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
              "start_line": 236,
              "start_column": 8238,
              "end_line": 4,
              "end_column": 8311,
              "start_byte": 8238,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.stopTest",
              "file_path": "src/_pytest/python.py",
              "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
              "start_line": 239,
              "start_column": 8317,
              "end_line": 4,
              "end_column": 8388,
              "start_byte": 8317,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
              "file_path": "src/_pytest/python.py",
              "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
              "start_line": 242,
              "start_column": 8394,
              "end_line": 4,
              "end_column": 8842,
              "start_byte": 8394,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction.runtest",
              "file_path": "src/_pytest/python.py",
              "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
              "start_line": 251,
              "start_column": 8848,
              "end_line": 4,
              "end_column": 10372,
              "start_byte": 8848,
              "end_byte": 4
            },
            {
              "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
              "file_path": "src/_pytest/python.py",
              "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
              "start_line": 281,
              "start_column": 10378,
              "end_line": 4,
              "end_column": 10680,
              "start_byte": 10378,
              "end_byte": 4
            },
            {
              "name": "_pytest.runner.runtestprotocol",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
              "start_line": 104,
              "start_column": 3022,
              "end_line": 0,
              "end_column": 3927,
              "start_byte": 3022,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.call_and_report",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)  # type: TestReport\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
              "start_line": 203,
              "start_column": 6228,
              "end_line": 0,
              "end_column": 6718,
              "start_byte": 6228,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.check_interactive_exception",
              "file_path": "src/_pytest/runner.py",
              "file_content": "def check_interactive_exception(call: \"CallInfo\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
              "start_line": 216,
              "start_column": 6721,
              "end_line": 0,
              "end_column": 7203,
              "start_byte": 6721,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The user is reporting an issue with Pytest 6 where dynamically adding an xfail marker to a test no longer ignores failures as it did in Pytest 5.\n2. In Pytest 5.x, dynamically adding an xfail marker treated failing tests like tests marked statically with xfail, including raising exceptions.\n3. Expected behavior is for dynamic xfail markers to ignore test failures.\n4. There is no specific suggestion from the user except expecting previous behavior from version 5.x.\n5. The solution may involve handling test markers more consistently, especially for dynamically added xfail markers. \n6. Symbols possibly related to this issue involve implementation and handling of markers and their effects during test execution.",
          "symbols": [
            {
              "name": "_pytest.nodes.Node.add_marker",
              "file_path": "src/_pytest/nodes.py",
              "reason": "The function `add_marker` is directly involved in adding markers to nodes during a test, including the xfail marker mentioned in the issue."
            },
            {
              "name": "_pytest.skipping.evaluate_xfail_marks",
              "file_path": "src/_pytest/skipping.py",
              "reason": "This function evaluates the xfail markers and needs to handle dynamic xfail markers correctly according to the described problem."
            },
            {
              "name": "_pytest.skipping.pytest_runtest_call",
              "file_path": "src/_pytest/skipping.py",
              "reason": "This hook implementation involves running tests and handling skip and xfail logic, which is directly related to the issue described."
            },
            {
              "name": "_pytest.skipping.pytest_runtest_makereport",
              "file_path": "src/_pytest/skipping.py",
              "reason": "It appears to influence the outcome recorded when there's an xfail, something that is clearly described in the issue context, including re-evaluation of outcomes and proper marking."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The symbol `_pytest.nodes.Node.add_marker` is involved in how markers, including xfail, are applied to test nodes. This is relevant because the complaint is about how xfail markers affect the test outcome, which starts with how they are added.",
            "The symbol `_pytest.skipping.evaluate_xfail_marks` deals with appraising whether an xfail should be applied to a test. This correlates to the issue since there may be a mismatch in expected outcomes when dynamically adding an xfail.",
            "The symbol `_pytest.skipping.pytest_runtest_call` should oversee how tests are executed in light of xfail or skip conditions, key to understanding where the behavior deviates from expectations.",
            "The symbol `_pytest.skipping.pytest_runtest_makereport` gathers test results and marks that are confirmed or modified in the process, which encompass xfail handling, requiring inspecting for correct behavior application."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/nodes.py",
          "src/_pytest/skipping.py"
        ],
        "symbols": [
          "_pytest.nodes.Node.add_marker",
          "_pytest.skipping.evaluate_xfail_marks",
          "_pytest.skipping.pytest_runtest_call",
          "_pytest.skipping.pytest_runtest_makereport"
        ],
        "code_spans": {
          "_pytest.debugging.PdbTrace.pytest_pyfunc_call": {
            "name": "_pytest.debugging.PdbTrace.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "  def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if n",
            "start_line": 293,
            "start_column": 9927,
            "end_line": 4,
            "end_column": 10098,
            "start_byte": 9927,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_pyfunc_call": {
            "name": "_pytest.hookspec.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "\n        compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n        if isinstance(compat_co_firstlineno, int):\n            # nose compatibility\n            file_path = sys.modules[o",
            "start_line": 338,
            "start_column": 11720,
            "end_line": 0,
            "end_column": 11918,
            "start_byte": 11720,
            "end_byte": 0
          },
          "_pytest.python.pytest_pyfunc_call": {
            "name": "_pytest.python.pytest_pyfunc_call",
            "file_path": "src/_pytest/python.py",
            "file_content": "@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True",
            "start_line": 171,
            "start_column": 5901,
            "end_line": 0,
            "end_column": 6398,
            "start_byte": 5901,
            "end_byte": 0
          },
          "_pytest.python.Metafunc": {
            "name": "_pytest.python.Metafunc",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Metafunc:\n    \"\"\"\n    Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n    They help to inspect a test function and to generate tests according to\n    test configuration or values specified in the class or module where a\n    test function is defined.\n    \"\"\"\n\n    def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls\n\n    def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)\n\n    def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids\n\n    def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes\n\n    def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 872,
            "start_column": 33237,
            "end_line": 0,
            "end_column": 45943,
            "start_byte": 33237,
            "end_byte": 0
          },
          "_pytest.python.Metafunc.__init__": {
            "name": "_pytest.python.Metafunc.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        definition: \"FunctionDefinition\",\n        fixtureinfo: fixtures.FuncFixtureInfo,\n        config: Config,\n        cls=None,\n        module=None,\n    ) -> None:\n        self.definition = definition\n\n        #: access to the :class:`_pytest.config.Config` object for the test session\n        self.config = config\n\n        #: the module object where the test function is defined in.\n        self.module = module\n\n        #: underlying python test function\n        self.function = definition.obj\n\n        #: set of fixture names required by the test function\n        self.fixturenames = fixtureinfo.names_closure\n\n        #: class object where the test function is defined in or ``None``.\n        self.cls = cls\n\n        self._calls = []  # type: List[CallSpec2]\n        self._arg2fixturedefs = fixtureinfo.name2fixturedefs",
            "start_line": 880,
            "start_column": 33570,
            "end_line": 4,
            "end_column": 34424,
            "start_byte": 33570,
            "end_byte": 4
          },
          "_pytest.python.Metafunc.funcargnames": {
            "name": "_pytest.python.Metafunc.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 908,
            "start_column": 34430,
            "end_line": 4,
            "end_column": 34641,
            "start_byte": 34430,
            "end_byte": 4
          },
          "_pytest.python.Metafunc.parametrize": {
            "name": "_pytest.python.Metafunc.parametrize",
            "file_path": "src/_pytest/python.py",
            "file_content": "def parametrize(\n        self,\n        argnames: Union[str, List[str], Tuple[str, ...]],\n        argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]],\n        indirect: Union[bool, typing.Sequence[str]] = False,\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ] = None,\n        scope: \"Optional[_Scope]\" = None,\n        *,\n        _param_mark: Optional[Mark] = None\n    ) -> None:\n        \"\"\" Add new invocations to the underlying test function using the list\n        of argvalues for the given argnames.  Parametrization is performed\n        during the collection phase.  If you need to setup expensive resources\n        see about setting indirect to do it rather at test setup time.\n\n        :arg argnames: a comma-separated string denoting one or more argument\n                       names, or a list/tuple of argument strings.\n\n        :arg argvalues: The list of argvalues determines how often a\n            test is invoked with different argument values.  If only one\n            argname was specified argvalues is a list of values.  If N\n            argnames were specified, argvalues must be a list of N-tuples,\n            where each tuple-element specifies a value for its respective\n            argname.\n\n        :arg indirect: The list of argnames or boolean. A list of arguments'\n            names (subset of argnames). If True the list contains all names from\n            the argnames. Each argvalue corresponding to an argname in this list will\n            be passed as request.param to its respective argname fixture\n            function so that it can perform more expensive setups during the\n            setup phase of a test rather than at collection time.\n\n        :arg ids: sequence of (or generator for) ids for ``argvalues``,\n              or a callable to return part of the id for each argvalue.\n\n            With sequences (and generators like ``itertools.count()``) the\n            returned ids should be of type ``string``, ``int``, ``float``,\n            ``bool``, or ``None``.\n            They are mapped to the corresponding index in ``argvalues``.\n            ``None`` means to use the auto-generated id.\n\n            If it is a callable it will be called for each entry in\n            ``argvalues``, and the return value is used as part of the\n            auto-generated id for the whole set (where parts are joined with\n            dashes (\"-\")).\n            This is useful to provide more specific ids for certain items, e.g.\n            dates.  Returning ``None`` will use an auto-generated id.\n\n            If no ids are provided they will be generated automatically from\n            the argvalues.\n\n        :arg scope: if specified it denotes the scope of the parameters.\n            The scope is used for grouping tests by parameter instances.\n            It will also override any fixture-function defined scope, allowing\n            to set a dynamic scope using test context or configuration.\n        \"\"\"\n        from _pytest.fixtures import scope2index\n\n        argnames, parameters = ParameterSet._for_parametrize(\n            argnames,\n            argvalues,\n            self.function,\n            self.config,\n            nodeid=self.definition.nodeid,\n        )\n        del argvalues\n\n        if \"request\" in argnames:\n            fail(\n                \"'request' is a reserved name and cannot be used in @pytest.mark.parametrize\",\n                pytrace=False,\n            )\n\n        if scope is None:\n            scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n\n        self._validate_if_using_arg_names(argnames, indirect)\n\n        arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n\n        # Use any already (possibly) generated ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from:\n            generated_ids = _param_mark._param_ids_from._param_ids_generated\n            if generated_ids is not None:\n                ids = generated_ids\n\n        ids = self._resolve_arg_ids(\n            argnames, ids, parameters, nodeid=self.definition.nodeid\n        )\n\n        # Store used (possibly generated) ids with parametrize Marks.\n        if _param_mark and _param_mark._param_ids_from and generated_ids is None:\n            object.__setattr__(_param_mark._param_ids_from, \"_param_ids_generated\", ids)\n\n        scopenum = scope2index(\n            scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n        )\n\n        # create the new calls: if we are parametrize() multiple times (by applying the decorator\n        # more than once) then we accumulate those calls generating the cartesian product\n        # of all calls\n        newcalls = []\n        for callspec in self._calls or [CallSpec2(self)]:\n            for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n                newcallspec = callspec.copy()\n                newcallspec.setmulti2(\n                    arg_values_types,\n                    argnames,\n                    param_set.values,\n                    param_id,\n                    param_set.marks,\n                    scopenum,\n                    param_index,\n                )\n                newcalls.append(newcallspec)\n        self._calls = newcalls",
            "start_line": 914,
            "start_column": 34647,
            "end_line": 4,
            "end_column": 40044,
            "start_byte": 34647,
            "end_byte": 4
          },
          "_pytest.python.Metafunc._resolve_arg_ids": {
            "name": "_pytest.python.Metafunc._resolve_arg_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_ids(\n        self,\n        argnames: typing.Sequence[str],\n        ids: Optional[\n            Union[\n                Iterable[Union[None, str, float, int, bool]],\n                Callable[[object], Optional[object]],\n            ]\n        ],\n        parameters: typing.Sequence[ParameterSet],\n        nodeid: str,\n    ) -> List[str]:\n        \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n        to ``parametrize``.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param ids: the ids parameter of the parametrized call (see docs).\n        :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n        :param str str: the nodeid of the item that generated this parametrized call.\n        :rtype: List[str]\n        :return: the list of ids for each argname given\n        \"\"\"\n        if ids is None:\n            idfn = None\n            ids_ = None\n        elif callable(ids):\n            idfn = ids\n            ids_ = None\n        else:\n            idfn = None\n            ids_ = self._validate_ids(ids, parameters, self.function.__name__)\n        return idmaker(argnames, parameters, idfn, ids_, self.config, nodeid=nodeid)",
            "start_line": 1036,
            "start_column": 40050,
            "end_line": 4,
            "end_column": 41319,
            "start_byte": 40050,
            "end_byte": 4
          },
          "_pytest.python.Metafunc._validate_ids": {
            "name": "_pytest.python.Metafunc._validate_ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_ids(\n        self,\n        ids: Iterable[Union[None, str, float, int, bool]],\n        parameters: typing.Sequence[ParameterSet],\n        func_name: str,\n    ) -> List[Union[None, str]]:\n        try:\n            num_ids = len(ids)  # type: ignore[arg-type]\n        except TypeError:\n            try:\n                iter(ids)\n            except TypeError as e:\n                raise TypeError(\"ids must be a callable or an iterable\") from e\n            num_ids = len(parameters)\n\n        # num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849\n        if num_ids != len(parameters) and num_ids != 0:\n            msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n            fail(msg.format(func_name, len(parameters), num_ids), pytrace=False)\n\n        new_ids = []\n        for idx, id_value in enumerate(itertools.islice(ids, num_ids)):\n            if id_value is None or isinstance(id_value, str):\n                new_ids.append(id_value)\n            elif isinstance(id_value, (float, int, bool)):\n                new_ids.append(str(id_value))\n            else:\n                msg = \"In {}: ids must be list of string/float/int/bool, found: {} (type: {!r}) at index {}\"\n                fail(\n                    msg.format(func_name, saferepr(id_value), type(id_value), idx),\n                    pytrace=False,\n                )\n        return new_ids",
            "start_line": 1069,
            "start_column": 41325,
            "end_line": 4,
            "end_column": 42745,
            "start_byte": 41325,
            "end_byte": 4
          },
          "_pytest.python.Metafunc._resolve_arg_value_types": {
            "name": "_pytest.python.Metafunc._resolve_arg_value_types",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _resolve_arg_value_types(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> Dict[str, \"Literal['params', 'funcargs']\"]:\n        \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n        to the function, based on the ``indirect`` parameter of the parametrized() call.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :rtype: Dict[str, str]\n            A dict mapping each arg name to either:\n            * \"params\" if the argname should be the parameter of a fixture of the same name.\n            * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n        \"\"\"\n        if isinstance(indirect, bool):\n            valtypes = dict.fromkeys(\n                argnames, \"params\" if indirect else \"funcargs\"\n            )  # type: Dict[str, Literal[\"params\", \"funcargs\"]]\n        elif isinstance(indirect, Sequence):\n            valtypes = dict.fromkeys(argnames, \"funcargs\")\n            for arg in indirect:\n                if arg not in argnames:\n                    fail(\n                        \"In {}: indirect fixture '{}' doesn't exist\".format(\n                            self.function.__name__, arg\n                        ),\n                        pytrace=False,\n                    )\n                valtypes[arg] = \"params\"\n        else:\n            fail(\n                \"In {func}: expected Sequence or boolean for indirect, got {type}\".format(\n                    type=type(indirect).__name__, func=self.function.__name__\n                ),\n                pytrace=False,\n            )\n        return valtypes",
            "start_line": 1103,
            "start_column": 42751,
            "end_line": 4,
            "end_column": 44544,
            "start_byte": 42751,
            "end_byte": 4
          },
          "_pytest.python.Metafunc._validate_if_using_arg_names": {
            "name": "_pytest.python.Metafunc._validate_if_using_arg_names",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _validate_if_using_arg_names(\n        self,\n        argnames: typing.Sequence[str],\n        indirect: Union[bool, typing.Sequence[str]],\n    ) -> None:\n        \"\"\"\n        Check if all argnames are being used, by default values, or directly/indirectly.\n\n        :param List[str] argnames: list of argument names passed to ``parametrize()``.\n        :param indirect: same ``indirect`` parameter of ``parametrize()``.\n        :raise ValueError: if validation fails.\n        \"\"\"\n        default_arg_names = set(get_default_arg_names(self.function))\n        func_name = self.function.__name__\n        for arg in argnames:\n            if arg not in self.fixturenames:\n                if arg in default_arg_names:\n                    fail(\n                        \"In {}: function already takes an argument '{}' with a default value\".format(\n                            func_name, arg\n                        ),\n                        pytrace=False,\n                    )\n                else:\n                    if isinstance(indirect, Sequence):\n                        name = \"fixture\" if arg in indirect else \"argument\"\n                    else:\n                        name = \"fixture\" if indirect else \"argument\"\n                    fail(\n                        \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n                        pytrace=False,\n                    )",
            "start_line": 1142,
            "start_column": 44550,
            "end_line": 4,
            "end_column": 45943,
            "start_byte": 44550,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker": {
            "name": "_pytest.fixtures.FixtureFunctionMarker",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 )\n\n\ndef _find_parametrized_scope(\n    argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typing.Sequence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n) -> \"fixtures._Scope\":\n    \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fixtures), return the most narrow scope based on the fixtures used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1174,
            "start_column": 45925,
            "end_line": 0,
            "end_column": 47430,
            "start_byte": 45925,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureFunctionMarker.scope": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.scope",
            "file_path": "src/_pytest/python.py",
            "file_content": " argnames: typing.Sequence[str],\n    arg2fixturedefs: Mapping[str, typ",
            "start_line": 1176,
            "start_column": 45979,
            "end_line": 4,
            "end_column": 46049,
            "start_byte": 45979,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.params": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.params",
            "file_path": "src/_pytest/python.py",
            "file_content": "equence[fixtures.FixtureDef]],\n    indirect: Union[bool, typing.Sequence[str]],\n",
            "start_line": 1177,
            "start_column": 46054,
            "end_line": 4,
            "end_column": 46134,
            "start_byte": 46054,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.autouse": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.autouse",
            "file_path": "src/_pytest/python.py",
            "file_content": "\"fixtures._Scope\":\n    \"\"\"Find the most app",
            "start_line": 1178,
            "start_column": 46139,
            "end_line": 4,
            "end_column": 46182,
            "start_byte": 46139,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.ids": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.ids",
            "file_path": "src/_pytest/python.py",
            "file_content": "ate scope for a parametrized call based on its arguments.\n\n    When there's at least one direct argument, always use \"function\" scope.\n\n    When a test function is parametrized and all its arguments are indirect\n    (e.g. fi",
            "start_line": 1179,
            "start_column": 46187,
            "end_line": 4,
            "end_column": 46411,
            "start_byte": 46187,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.name": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.name",
            "file_path": "src/_pytest/python.py",
            "file_content": "s), return the most narrow scope based on the fi",
            "start_line": 1187,
            "start_column": 46416,
            "end_line": 4,
            "end_column": 46464,
            "start_byte": 46416,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureFunctionMarker.__call__": {
            "name": "_pytest.fixtures.FixtureFunctionMarker.__call__",
            "file_path": "src/_pytest/python.py",
            "file_content": " used.\n\n    Related to issue #1832, based on code posted by @Kingdread.\n    \"\"\"\n    if isinstance(indirect, Sequence):\n        all_arguments_are_fixtures = len(indirect) == len(argnames)\n    else:\n        all_arguments_are_fixtures = bool(indirect)\n\n    if all_arguments_are_fixtures:\n        fixturedefs = arg2fixturedefs or {}\n        used_scopes = [\n            fixturedef[0].scope\n            for name, fixturedef in fixturedefs.items()\n            if name in argnames\n        ]\n        if used_scopes:\n            # Takes the most narrow scope from used fixtures\n            for scope in reversed(fixtures.scopes):\n                if scope in used_scopes:\n                    return scope\n\n    return \"function\"\n\n\ndef _ascii_escaped_by_config(val: Union[str, bytes], config: Optional[Config]) -> str:\n    if config is None:\n        escape_option = False\n    else:\n        escape_option = config.getini(\n            \"disable_test_id_escaping_and_forfeit_al",
            "start_line": 1189,
            "start_column": 46470,
            "end_line": 4,
            "end_column": 47430,
            "start_byte": 46470,
            "end_byte": 4
          },
          "_pytest.mark.MarkMatcher": {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "lf.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
          },
          "_pytest.mark.MarkMatcher.own_mark_names": {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": " Mark.\n\n        Combines b",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
          },
          "_pytest.mark.MarkMatcher.from_item": {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "nding args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert s",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
          },
          "_pytest.mark.MarkMatcher.__call__": {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "me == other.name\n\n        # Remember source of ids with parametrize Marks.\n      ",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
          },
          "_pytest.mark.Mark": {
            "name": "_pytest.mark.Mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s(frozen=True)\nclass Mark:\n    #: Name of the mark.\n    name = attr.ib(type=str)\n    #: Positional arguments of the mark decorator.\n    args = attr.ib(type=Tuple[Any, ...])\n    #: Keyword arguments of the mark decorator.\n    kwargs = attr.ib(type=Mapping[str, Any])\n\n    #: Source Mark for ids with parametrize Marks.\n    _param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)\n    #: Resolved/generated ids with parametrize Marks.\n    _param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )\n\n    def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4\n\n    def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 195,
            "start_column": 6452,
            "end_line": 0,
            "end_column": 7948,
            "start_byte": 6452,
            "end_byte": 0
          },
          "_pytest.mark.Mark.name": {
            "name": "_pytest.mark.Mark.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "name = attr.ib(type=str)",
            "start_line": 198,
            "start_column": 6514,
            "end_line": 4,
            "end_column": 6538,
            "start_byte": 6514,
            "end_byte": 4
          },
          "_pytest.mark.Mark.args": {
            "name": "_pytest.mark.Mark.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "args = attr.ib(type=Tuple[Any, ...])",
            "start_line": 200,
            "start_column": 6594,
            "end_line": 4,
            "end_column": 6630,
            "start_byte": 6594,
            "end_byte": 4
          },
          "_pytest.mark.Mark.kwargs": {
            "name": "_pytest.mark.Mark.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "kwargs = attr.ib(type=Mapping[str, Any])",
            "start_line": 202,
            "start_column": 6683,
            "end_line": 4,
            "end_column": 6723,
            "start_byte": 6683,
            "end_byte": 4
          },
          "_pytest.mark.Mark._param_ids_from": {
            "name": "_pytest.mark.Mark._param_ids_from",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_from = attr.ib(type=Optional[\"Mark\"], default=None, repr=False)",
            "start_line": 205,
            "start_column": 6780,
            "end_line": 4,
            "end_column": 6854,
            "start_byte": 6780,
            "end_byte": 4
          },
          "_pytest.mark.Mark._param_ids_generated": {
            "name": "_pytest.mark.Mark._param_ids_generated",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_param_ids_generated = attr.ib(\n        type=Optional[Sequence[str]], default=None, repr=False\n    )",
            "start_line": 207,
            "start_column": 6913,
            "end_line": 4,
            "end_column": 7013,
            "start_byte": 6913,
            "end_byte": 4
          },
          "_pytest.mark.Mark._has_param_ids": {
            "name": "_pytest.mark.Mark._has_param_ids",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _has_param_ids(self) -> bool:\n        return \"ids\" in self.kwargs or len(self.args) >= 4",
            "start_line": 211,
            "start_column": 7019,
            "end_line": 4,
            "end_column": 7111,
            "start_byte": 7019,
            "end_byte": 4
          },
          "_pytest.mark.Mark.combined_with": {
            "name": "_pytest.mark.Mark.combined_with",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def combined_with(self, other: \"Mark\") -> \"Mark\":\n        \"\"\"Return a new Mark which is a combination of this\n        Mark and another Mark.\n\n        Combines by appending args and merging kwargs.\n\n        :param other: The mark to combine with.\n        :type other: Mark\n        :rtype: Mark\n        \"\"\"\n        assert self.name == other.name\n\n        # Remember source of ids with parametrize Marks.\n        param_ids_from = None  # type: Optional[Mark]\n        if self.name == \"parametrize\":\n            if other._has_param_ids():\n                param_ids_from = other\n            elif self._has_param_ids():\n                param_ids_from = self\n\n        return Mark(\n            self.name,\n            self.args + other.args,\n            dict(self.kwargs, **other.kwargs),\n            param_ids_from=param_ids_from,\n        )",
            "start_line": 214,
            "start_column": 7117,
            "end_line": 4,
            "end_column": 7948,
            "start_byte": 7117,
            "end_byte": 4
          },
          "_pytest.mark._Markable": {
            "name": "_pytest.mark._Markable",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_Markable = TypeVar(\"_Markable\", bound=Union[Callable[..., object], type])",
            "start_line": 245,
            "start_column": 8132,
            "end_line": 0,
            "end_column": 8206,
            "start_byte": 8132,
            "end_byte": 0
          },
          "_pytest.mark.MarkDecorator": {
            "name": "_pytest.mark.MarkDecorator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@attr.s\nclass MarkDecorator:\n    \"\"\"A decorator for applying a mark on test functions and classes.\n\n    MarkDecorators are created with ``pytest.mark``::\n\n        mark1 = pytest.mark.NAME              # Simple MarkDecorator\n        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator\n\n    and can then be applied as decorators to test functions::\n\n        @mark2\n        def test_function():\n            pass\n\n    When a MarkDecorator is called it does the following:\n\n    1. If called with a single class as its only positional argument and no\n       additional keyword arguments, it attaches the mark to the class so it\n       gets applied automatically to all test cases found in that class.\n\n    2. If called with a single function as its only positional argument and\n       no additional keyword arguments, it attaches the mark to the function,\n       containing all the arguments already stored internally in the\n       MarkDecorator.\n\n    3. When called in any other case, it returns a new MarkDecorator instance\n       with the original MarkDecorator's content updated with the arguments\n       passed to this call.\n\n    Note: The rules above prevent MarkDecorators from storing only a single\n    function or class reference as their positional argument with no\n    additional keyword or positional arguments. You can work around this by\n    using `with_args()`.\n    \"\"\"\n\n    mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name\n\n    @property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args\n\n    @property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs\n\n    @property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)\n\n    def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)\n\n    def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))\n\n    # Type ignored because the overloads overlap with an incompatible\n    # return type. Not much we can do about that. Thankfully mypy picks\n    # the first match so it works out even if we break the rules.\n    @overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()\n\n    def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 248,
            "start_column": 8209,
            "end_line": 0,
            "end_column": 11549,
            "start_byte": 8209,
            "end_byte": 0
          },
          "_pytest.mark.MarkDecorator.mark": {
            "name": "_pytest.mark.MarkDecorator.mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "mark = attr.ib(type=Mark, validator=attr.validators.instance_of(Mark))",
            "start_line": 284,
            "start_column": 9608,
            "end_line": 4,
            "end_column": 9678,
            "start_byte": 9608,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.name": {
            "name": "_pytest.mark.MarkDecorator.name",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def name(self) -> str:\n        \"\"\"Alias for mark.name.\"\"\"\n        return self.mark.name",
            "start_line": 286,
            "start_column": 9684,
            "end_line": 4,
            "end_column": 9785,
            "start_byte": 9684,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.args": {
            "name": "_pytest.mark.MarkDecorator.args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def args(self) -> Tuple[Any, ...]:\n        \"\"\"Alias for mark.args.\"\"\"\n        return self.mark.args",
            "start_line": 291,
            "start_column": 9791,
            "end_line": 4,
            "end_column": 9904,
            "start_byte": 9791,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.kwargs": {
            "name": "_pytest.mark.MarkDecorator.kwargs",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def kwargs(self) -> Mapping[str, Any]:\n        \"\"\"Alias for mark.kwargs.\"\"\"\n        return self.mark.kwargs",
            "start_line": 296,
            "start_column": 9910,
            "end_line": 4,
            "end_column": 10031,
            "start_byte": 9910,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.markname": {
            "name": "_pytest.mark.MarkDecorator.markname",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@property\n    def markname(self) -> str:\n        return self.name  # for backward-compat (2.4.1 had this attr)",
            "start_line": 301,
            "start_column": 10037,
            "end_line": 4,
            "end_column": 10147,
            "start_byte": 10037,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.__repr__": {
            "name": "_pytest.mark.MarkDecorator.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<MarkDecorator {!r}>\".format(self.mark)",
            "start_line": 305,
            "start_column": 10153,
            "end_line": 4,
            "end_column": 10235,
            "start_byte": 10153,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.with_args": {
            "name": "_pytest.mark.MarkDecorator.with_args",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def with_args(self, *args: object, **kwargs: object) -> \"MarkDecorator\":\n        \"\"\"Return a MarkDecorator with extra arguments added.\n\n        Unlike calling the MarkDecorator, with_args() can be used even\n        if the sole argument is a callable/class.\n\n        :return: MarkDecorator\n        \"\"\"\n        mark = Mark(self.name, args, kwargs)\n        return self.__class__(self.mark.combined_with(mark))",
            "start_line": 308,
            "start_column": 10241,
            "end_line": 4,
            "end_column": 10647,
            "start_byte": 10241,
            "end_byte": 4
          },
          "_pytest.mark.MarkDecorator.__call__": {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
          },
          "_pytest.mark.get_unpacked_marks": {
            "name": "_pytest.mark.get_unpacked_marks",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def get_unpacked_marks(obj) -> List[Mark]:\n    \"\"\"\n    obtain the unpacked marks that are stored on an object\n    \"\"\"\n    mark_list = getattr(obj, \"pytestmark\", [])\n    if not isinstance(mark_list, list):\n        mark_list = [mark_list]\n    return normalize_mark_list(mark_list)",
            "start_line": 343,
            "start_column": 11552,
            "end_line": 0,
            "end_column": 11830,
            "start_byte": 11552,
            "end_byte": 0
          },
          "_pytest.mark.normalize_mark_list": {
            "name": "_pytest.mark.normalize_mark_list",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def normalize_mark_list(mark_list: Iterable[Union[Mark, MarkDecorator]]) -> List[Mark]:\n    \"\"\"\n    normalizes marker decorating helpers to mark objects\n\n    :type mark_list: List[Union[Mark, Markdecorator]]\n    :rtype: List[Mark]\n    \"\"\"\n    extracted = [\n        getattr(mark, \"mark\", mark) for mark in mark_list\n    ]  # unpack MarkDecorator\n    for mark in extracted:\n        if not isinstance(mark, Mark):\n            raise TypeError(\"got {!r} instead of Mark\".format(mark))\n    return [x for x in extracted if isinstance(x, Mark)]",
            "start_line": 353,
            "start_column": 11833,
            "end_line": 0,
            "end_column": 12369,
            "start_byte": 11833,
            "end_byte": 0
          },
          "_pytest.mark.store_mark": {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
          },
          "_pytest.mark.MarkGenerator": {
            "name": "_pytest.mark.MarkGenerator",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class MarkGenerator:\n    \"\"\"Factory for :class:`MarkDecorator` objects - exposed as\n    a ``pytest.mark`` singleton instance.\n\n    Example::\n\n         import pytest\n\n         @pytest.mark.slowtest\n         def test_function():\n            pass\n\n    applies a 'slowtest' :class:`Mark` on ``test_function``.\n    \"\"\"\n\n    _config = None  # type: Optional[Config]\n    _markers = set()  # type: Set[str]\n\n    # See TYPE_CHECKING above.\n    if TYPE_CHECKING:\n        # Using casts instead of type comments intentionally - issue #7473.\n        # TODO(py36): Change to builtin annotation syntax.\n        skip = cast(_SkipMarkDecorator, None)\n        skipif = cast(_SkipifMarkDecorator, None)\n        xfail = cast(_XfailMarkDecorator, None)\n        parametrize = cast(_ParametrizeMarkDecorator, None)\n        usefixtures = cast(_UsefixturesMarkDecorator, None)\n        filterwarnings = cast(_FilterwarningsMarkDecorator, None)\n\n    def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 450,
            "start_column": 15252,
            "end_line": 0,
            "end_column": 18166,
            "start_byte": 15252,
            "end_byte": 0
          },
          "_pytest.mark.MarkGenerator._config": {
            "name": "_pytest.mark.MarkGenerator._config",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_config = None",
            "start_line": 465,
            "start_column": 15571,
            "end_line": 4,
            "end_column": 15585,
            "start_byte": 15571,
            "end_byte": 4
          },
          "_pytest.mark.MarkGenerator._markers": {
            "name": "_pytest.mark.MarkGenerator._markers",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "_markers = set()",
            "start_line": 466,
            "start_column": 15616,
            "end_line": 4,
            "end_column": 15632,
            "start_byte": 15616,
            "end_byte": 4
          },
          "_pytest.mark.MarkGenerator.__getattr__": {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
          },
          "_pytest.mark.MARK_GEN": {
            "name": "_pytest.mark.MARK_GEN",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "MARK_GEN = MarkGenerator()",
            "start_line": 520,
            "start_column": 18169,
            "end_line": 0,
            "end_column": 18195,
            "start_byte": 18169,
            "end_byte": 0
          },
          "_pytest.mark.NodeKeywords": {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "class NodeKeywords(collections.abc.MutableMapping):\n    def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}\n\n    def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]\n\n    def __setitem__(self, key, value):\n        self._markers[key] = value\n\n    def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")\n\n    def __iter__(self):\n        seen = self._seen()\n        return iter(seen)\n\n    def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen\n\n    def __len__(self) -> int:\n        return len(self._seen())\n\n    def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 523,
            "start_column": 18198,
            "end_line": 0,
            "end_column": 19158,
            "start_byte": 18198,
            "end_byte": 0
          },
          "_pytest.mark.NodeKeywords.__init__": {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __init__(self, node):\n        self.node = node\n        self.parent = node.parent\n        self._markers = {node.name: True}",
            "start_line": 524,
            "start_column": 18254,
            "end_line": 4,
            "end_column": 18380,
            "start_byte": 18254,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__getitem__": {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getitem__(self, key):\n        try:\n            return self._markers[key]\n        except KeyError:\n            if self.parent is None:\n                raise\n            return self.parent.keywords[key]",
            "start_line": 529,
            "start_column": 18386,
            "end_line": 4,
            "end_column": 18592,
            "start_byte": 18386,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__setitem__": {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __setitem__(self, key, value):\n        self._markers[key] = value",
            "start_line": 537,
            "start_column": 18598,
            "end_line": 4,
            "end_column": 18667,
            "start_byte": 18598,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__delitem__": {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __delitem__(self, key):\n        raise ValueError(\"cannot delete key in keywords dict\")",
            "start_line": 540,
            "start_column": 18673,
            "end_line": 4,
            "end_column": 18763,
            "start_byte": 18673,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__iter__": {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __iter__(self):\n        seen = self._seen()\n        return iter(seen)",
            "start_line": 543,
            "start_column": 18769,
            "end_line": 4,
            "end_column": 18842,
            "start_byte": 18769,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords._seen": {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def _seen(self):\n        seen = set(self._markers)\n        if self.parent is not None:\n            seen.update(self.parent.keywords)\n        return seen",
            "start_line": 547,
            "start_column": 18848,
            "end_line": 4,
            "end_column": 19000,
            "start_byte": 18848,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__len__": {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __len__(self) -> int:\n        return len(self._seen())",
            "start_line": 553,
            "start_column": 19006,
            "end_line": 4,
            "end_column": 19064,
            "start_byte": 19006,
            "end_byte": 4
          },
          "_pytest.mark.NodeKeywords.__repr__": {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<NodeKeywords for node {}>\".format(self.node)",
            "start_line": 556,
            "start_column": 19070,
            "end_line": 4,
            "end_column": 19158,
            "start_byte": 19070,
            "end_byte": 4
          },
          "_pytest.warning_types.PytestUnknownMarkWarning": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "\"values\", Sequence[Union[object, NotSetType]]),\n            (\"marks\", \"typing.Collection[Union[MarkDecorator, Mark]]\"),\n            (\"id\", Optional[str]),\n        ],\n    )\n):\n    @classmethod\n    d",
            "start_line": 77,
            "start_column": 1903,
            "end_line": 0,
            "end_column": 2100,
            "start_byte": 1903,
            "end_byte": 0
          },
          "_pytest.warning_types.PytestUnknownMarkWarning.__module__": {
            "name": "_pytest.warning_types.PytestUnknownMarkWarning.__module__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "   @classmethod\n    d",
            "start_line": 83,
            "start_column": 2079,
            "end_line": 4,
            "end_column": 2100,
            "start_byte": 2079,
            "end_byte": 4
          },
          "_pytest.capture.CaptureManager.pytest_runtest_call": {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 740,
            "start_column": 23827,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 23827,
            "end_byte": 4
          },
          "_pytest.hookspec.pytest_runtest_call": {
            "name": "_pytest.hookspec.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16497,
            "end_line": 0,
            "end_column": 16671,
            "start_byte": 16497,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_runtest_makereport": {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_call": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 698,
            "start_column": 25610,
            "end_line": 4,
            "end_column": 25826,
            "start_byte": 25610,
            "end_byte": 4
          },
          "_pytest.runner.pytest_runtest_call": {
            "name": "_pytest.runner.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "        msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n           ",
            "start_line": 143,
            "start_column": 4461,
            "end_line": 0,
            "end_column": 4996,
            "start_byte": 4461,
            "end_byte": 0
          },
          "_pytest.runner.pytest_runtest_makereport": {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          "_pytest.skipping.evaluate_xfail_marks": {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_call": {
            "name": "_pytest.skipping.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    if xfailed is None:\n        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield",
            "start_line": 246,
            "start_column": 8107,
            "end_line": 0,
            "end_column": 8487,
            "start_byte": 8107,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_runtest_makereport": {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          "_pytest.unittest.pytest_runtest_makereport": {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          },
          "_pytest.nodes.Node.add_marker": {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureRequest.applymarker": {
            "name": "_pytest.fixtures.FixtureRequest.applymarker",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def applymarker(self, marker) -> None:\n        \"\"\" Apply a marker to a single test function invocation.\n        This method is useful if you don't want to have a keyword/marker\n        on all function invocations.\n\n        :arg marker: a :py:class:`_pytest.mark.MarkDecorator` object\n            created by a call to ``pytest.mark.NAME(...)``.\n        \"\"\"\n        self.node.add_marker(marker)",
            "start_line": 548,
            "start_column": 21159,
            "end_line": 4,
            "end_column": 21551,
            "start_byte": 21159,
            "end_byte": 4
          },
          "_pytest.runner.SetupState": {
            "name": "_pytest.runner.SetupState",
            "file_path": "src/_pytest/runner.py",
            "file_content": "class SetupState:\n    \"\"\" shared state for setting up/tearing down test items or collectors. \"\"\"\n\n    def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]\n\n    def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)\n\n    def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)\n\n    def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack\n\n    def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers\n\n    def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)\n\n    def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc\n\n    def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 353,
            "start_column": 11976,
            "end_line": 0,
            "end_column": 14977,
            "start_byte": 11976,
            "end_byte": 0
          },
          "_pytest.runner.SetupState.__init__": {
            "name": "_pytest.runner.SetupState.__init__",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def __init__(self):\n        self.stack = []  # type: List[Node]\n        self._finalizers = {}  # type: Dict[Node, List[Callable[[], object]]]",
            "start_line": 356,
            "start_column": 12078,
            "end_line": 4,
            "end_column": 12219,
            "start_byte": 12078,
            "end_byte": 4
          },
          "_pytest.runner.SetupState.addfinalizer": {
            "name": "_pytest.runner.SetupState.addfinalizer",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def addfinalizer(self, finalizer: Callable[[], object], colitem) -> None:\n        \"\"\" attach a finalizer to the given colitem. \"\"\"\n        assert colitem and not isinstance(colitem, tuple)\n        assert callable(finalizer)\n        # assert colitem in self.stack  # some unit tests don't setup stack :/\n        self._finalizers.setdefault(colitem, []).append(finalizer)",
            "start_line": 360,
            "start_column": 12225,
            "end_line": 4,
            "end_column": 12594,
            "start_byte": 12225,
            "end_byte": 4
          },
          "_pytest.runner.SetupState._pop_and_teardown": {
            "name": "_pytest.runner.SetupState._pop_and_teardown",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _pop_and_teardown(self):\n        colitem = self.stack.pop()\n        self._teardown_with_finalization(colitem)",
            "start_line": 367,
            "start_column": 12600,
            "end_line": 4,
            "end_column": 12713,
            "start_byte": 12600,
            "end_byte": 4
          },
          "_pytest.runner.SetupState._callfinalizers": {
            "name": "_pytest.runner.SetupState._callfinalizers",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _callfinalizers(self, colitem) -> None:\n        finalizers = self._finalizers.pop(colitem, None)\n        exc = None\n        while finalizers:\n            fin = finalizers.pop()\n            try:\n                fin()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 371,
            "start_column": 12719,
            "end_line": 4,
            "end_column": 13193,
            "start_byte": 12719,
            "end_byte": 4
          },
          "_pytest.runner.SetupState._teardown_with_finalization": {
            "name": "_pytest.runner.SetupState._teardown_with_finalization",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_with_finalization(self, colitem) -> None:\n        self._callfinalizers(colitem)\n        colitem.teardown()\n        for colitem in self._finalizers:\n            assert colitem in self.stack",
            "start_line": 386,
            "start_column": 13199,
            "end_line": 4,
            "end_column": 13401,
            "start_byte": 13199,
            "end_byte": 4
          },
          "_pytest.runner.SetupState.teardown_all": {
            "name": "_pytest.runner.SetupState.teardown_all",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_all(self) -> None:\n        while self.stack:\n            self._pop_and_teardown()\n        for key in list(self._finalizers):\n            self._teardown_with_finalization(key)\n        assert not self._finalizers",
            "start_line": 392,
            "start_column": 13407,
            "end_line": 4,
            "end_column": 13630,
            "start_byte": 13407,
            "end_byte": 4
          },
          "_pytest.runner.SetupState.teardown_exact": {
            "name": "_pytest.runner.SetupState.teardown_exact",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def teardown_exact(self, item, nextitem) -> None:\n        needed_collectors = nextitem and nextitem.listchain() or []\n        self._teardown_towards(needed_collectors)",
            "start_line": 399,
            "start_column": 13636,
            "end_line": 4,
            "end_column": 13803,
            "start_byte": 13636,
            "end_byte": 4
          },
          "_pytest.runner.SetupState._teardown_towards": {
            "name": "_pytest.runner.SetupState._teardown_towards",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def _teardown_towards(self, needed_collectors) -> None:\n        exc = None\n        while self.stack:\n            if self.stack == needed_collectors[: len(self.stack)]:\n                break\n            try:\n                self._pop_and_teardown()\n            except TEST_OUTCOME as e:\n                # XXX Only first exception will be seen by user,\n                #     ideally all should be reported.\n                if exc is None:\n                    exc = e\n        if exc:\n            raise exc",
            "start_line": 403,
            "start_column": 13809,
            "end_line": 4,
            "end_column": 14311,
            "start_byte": 13809,
            "end_byte": 4
          },
          "_pytest.runner.SetupState.prepare": {
            "name": "_pytest.runner.SetupState.prepare",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def prepare(self, colitem) -> None:\n        \"\"\"Setup objects along the collector chain to the test-method.\"\"\"\n\n        # check if the last collection node has raised an error\n        for col in self.stack:\n            if hasattr(col, \"_prepare_exc\"):\n                exc = col._prepare_exc  # type: ignore[attr-defined]\n                raise exc\n\n        needed_collectors = colitem.listchain()\n        for col in needed_collectors[len(self.stack) :]:\n            self.stack.append(col)\n            try:\n                col.setup()\n            except TEST_OUTCOME as e:\n                col._prepare_exc = e  # type: ignore[attr-defined]\n                raise e",
            "start_line": 418,
            "start_column": 14317,
            "end_line": 4,
            "end_column": 14977,
            "start_byte": 14317,
            "end_byte": 4
          },
          "_pytest.fixtures._FixtureFunction": {
            "name": "_pytest.fixtures._FixtureFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "types import PytestUnhandledCoroutineWarning\n\nif TYPE_CHECKING:\n    from ty",
            "start_line": 73,
            "start_column": 2273,
            "end_line": 0,
            "end_column": 2348,
            "start_byte": 2273,
            "end_byte": 0
          },
          "_pytest.python.Function": {
            "name": "_pytest.python.Function",
            "file_path": "src/_pytest/python.py",
            "file_content": "class Function(PyobjMixin, nodes.Item):\n    \"\"\" a Function Item is responsible for setting up and executing a\n    Python test function.\n    \"\"\"\n\n    # disable since functions handle it themselves\n    _ALLOW_MARKERS = False\n\n    def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()\n\n    @classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)\n\n    def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)\n\n    @property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)\n\n    def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]\n\n    @property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self\n\n    @property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames\n\n    def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n\n    def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()\n\n    def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")\n\n    # TODO: Type ignored -- breaks Liskov Substitution.\n    def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1444,
            "start_column": 55214,
            "end_line": 0,
            "end_column": 61637,
            "start_byte": 55214,
            "end_byte": 0
          },
          "_pytest.python.Function._ALLOW_MARKERS": {
            "name": "_pytest.python.Function._ALLOW_MARKERS",
            "file_path": "src/_pytest/python.py",
            "file_content": "_ALLOW_MARKERS = False",
            "start_line": 1450,
            "start_column": 55414,
            "end_line": 4,
            "end_column": 55436,
            "start_byte": 55414,
            "end_byte": 4
          },
          "_pytest.python.Function.__init__": {
            "name": "_pytest.python.Function.__init__",
            "file_path": "src/_pytest/python.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent,\n        config: Optional[Config] = None,\n        callspec: Optional[CallSpec2] = None,\n        callobj=NOTSET,\n        keywords=None,\n        session: Optional[Session] = None,\n        fixtureinfo: Optional[FuncFixtureInfo] = None,\n        originalname: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        param name: the full function name, including any decorations like those\n            added by parametrization (``my_func[my_param]``).\n        param parent: the parent Node.\n        param config: the pytest Config object\n        param callspec: if given, this is function has been parametrized and the callspec contains\n            meta information about the parametrization.\n        param callobj: if given, the object which will be called when the Function is invoked,\n            otherwise the callobj will be obtained from ``parent`` using ``originalname``\n        param keywords: keywords bound to the function object for \"-k\" matching.\n        param session: the pytest Session object\n        param fixtureinfo: fixture information already resolved at this fixture node.\n        param originalname:\n            The attribute name to use for accessing the underlying function object.\n            Defaults to ``name``. Set this if name is different from the original name,\n            for example when it contains decorations like those added by parametrization\n            (``my_func[my_param]``).\n        \"\"\"\n        super().__init__(name, parent, config=config, session=session)\n\n        if callobj is not NOTSET:\n            self.obj = callobj\n\n        #: Original function name, without any decorations (for example\n        #: parametrization adds a ``\"[...]\"`` suffix to function names), used to access\n        #: the underlying function object from ``parent`` (in case ``callobj`` is not given\n        #: explicitly).\n        #:\n        #: .. versionadded:: 3.0\n        self.originalname = originalname or name\n\n        # note: when FunctionDefinition is introduced, we should change ``originalname``\n        # to a readonly property that returns FunctionDefinition.name\n\n        self.keywords.update(self.obj.__dict__)\n        self.own_markers.extend(get_unpacked_marks(self.obj))\n        if callspec:\n            self.callspec = callspec\n            # this is total hostile and a mess\n            # keywords are broken by design by now\n            # this will be redeemed later\n            for mark in callspec.marks:\n                # feel free to cry, this was broken for years before\n                # and keywords cant fix it per design\n                self.keywords[mark.name] = mark\n            self.own_markers.extend(normalize_mark_list(callspec.marks))\n        if keywords:\n            self.keywords.update(keywords)\n\n        # todo: this is a hell of a hack\n        # https://github.com/pytest-dev/pytest/issues/4569\n\n        self.keywords.update(\n            {\n                mark.name: True\n                for mark in self.iter_markers()\n                if mark.name not in self.keywords\n            }\n        )\n\n        if fixtureinfo is None:\n            fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n                self, self.obj, self.cls, funcargs=True\n            )\n        self._fixtureinfo = fixtureinfo  # type: FuncFixtureInfo\n        self.fixturenames = fixtureinfo.names_closure\n        self._initrequest()",
            "start_line": 1452,
            "start_column": 55442,
            "end_line": 4,
            "end_column": 58875,
            "start_byte": 55442,
            "end_byte": 4
          },
          "_pytest.python.Function.from_parent": {
            "name": "_pytest.python.Function.from_parent",
            "file_path": "src/_pytest/python.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n        \"\"\"\n        The public  constructor\n        \"\"\"\n        return super().from_parent(parent=parent, **kw)",
            "start_line": 1532,
            "start_column": 58881,
            "end_line": 4,
            "end_column": 59087,
            "start_byte": 58881,
            "end_byte": 4
          },
          "_pytest.python.Function._initrequest": {
            "name": "_pytest.python.Function._initrequest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _initrequest(self) -> None:\n        self.funcargs = {}  # type: Dict[str, object]\n        self._request = fixtures.FixtureRequest(self)",
            "start_line": 1539,
            "start_column": 59093,
            "end_line": 4,
            "end_column": 59232,
            "start_byte": 59093,
            "end_byte": 4
          },
          "_pytest.python.Function.function": {
            "name": "_pytest.python.Function.function",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def function(self):\n        \"underlying python 'function' object\"\n        return getimfunc(self.obj)",
            "start_line": 1543,
            "start_column": 59238,
            "end_line": 4,
            "end_column": 59352,
            "start_byte": 59238,
            "end_byte": 4
          },
          "_pytest.python.Function._getobj": {
            "name": "_pytest.python.Function._getobj",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _getobj(self):\n        assert self.parent is not None\n        return getattr(self.parent.obj, self.originalname)  # type: ignore[attr-defined]",
            "start_line": 1548,
            "start_column": 59358,
            "end_line": 4,
            "end_column": 59504,
            "start_byte": 59358,
            "end_byte": 4
          },
          "_pytest.python.Function._pyfuncitem": {
            "name": "_pytest.python.Function._pyfuncitem",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def _pyfuncitem(self):\n        \"(compatonly) for code expecting pytest-2.2 style request objects\"\n        return self",
            "start_line": 1552,
            "start_column": 59510,
            "end_line": 4,
            "end_column": 59641,
            "start_byte": 59510,
            "end_byte": 4
          },
          "_pytest.python.Function.funcargnames": {
            "name": "_pytest.python.Function.funcargnames",
            "file_path": "src/_pytest/python.py",
            "file_content": "@property\n    def funcargnames(self) -> List[str]:\n        \"\"\" alias attribute for ``fixturenames`` for pre-2.3 compatibility\"\"\"\n        warnings.warn(FUNCARGNAMES, stacklevel=2)\n        return self.fixturenames",
            "start_line": 1557,
            "start_column": 59647,
            "end_line": 4,
            "end_column": 59858,
            "start_byte": 59647,
            "end_byte": 4
          },
          "_pytest.python.Function.runtest": {
            "name": "_pytest.python.Function.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        \"\"\" execute the underlying test function. \"\"\"\n        self.ihook.pytest_pyfunc_call(pyfuncitem=self)",
            "start_line": 1563,
            "start_column": 59864,
            "end_line": 4,
            "end_column": 59999,
            "start_byte": 59864,
            "end_byte": 4
          },
          "_pytest.python.Function.setup": {
            "name": "_pytest.python.Function.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "def setup(self) -> None:\n        if isinstance(self.parent, Instance):\n            self.parent.newinstance()\n            self.obj = self._getobj()\n        self._request._fillfixtures()",
            "start_line": 1567,
            "start_column": 60005,
            "end_line": 4,
            "end_column": 60189,
            "start_byte": 60005,
            "end_byte": 4
          },
          "_pytest.python.Function._prunetraceback": {
            "name": "_pytest.python.Function._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "def _prunetraceback(self, excinfo: ExceptionInfo) -> None:\n        if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n            code = _pytest._code.Code(get_real_func(self.obj))\n            path, firstlineno = code.path, code.firstlineno\n            traceback = excinfo.traceback\n            ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n            if ntraceback == traceback:\n                ntraceback = ntraceback.cut(path=path)\n                if ntraceback == traceback:\n                    ntraceback = ntraceback.filter(filter_traceback)\n                    if not ntraceback:\n                        ntraceback = traceback\n\n            excinfo.traceback = ntraceback.filter()\n            # issue364: mark all but first and last frames to\n            # only show a single-line message for each frame\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n                if len(excinfo.traceback) > 2:\n                    for entry in excinfo.traceback[1:-1]:\n                        entry.set_repr_style(\"short\")",
            "start_line": 1573,
            "start_column": 60195,
            "end_line": 4,
            "end_column": 61273,
            "start_byte": 60195,
            "end_byte": 4
          },
          "_pytest.python.Function.repr_failure": {
            "name": "_pytest.python.Function.repr_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "def repr_failure(  # type: ignore[override]\n        self, excinfo: ExceptionInfo[BaseException],\n    ) -> Union[str, TerminalRepr]:\n        style = self.config.getoption(\"tbstyle\", \"auto\")\n        if style == \"auto\":\n            style = \"long\"\n        return self._repr_failure_py(excinfo, style=style)",
            "start_line": 1595,
            "start_column": 61335,
            "end_line": 4,
            "end_column": 61637,
            "start_byte": 61335,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition": {
            "name": "_pytest.python.FunctionDefinition",
            "file_path": "src/_pytest/python.py",
            "file_content": "class FunctionDefinition(Function):\n    \"\"\"\n    internal hack until we get actual definition nodes instead of the\n    crappy metafunc hack\n    \"\"\"\n\n    def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")\n\n    setup = runtest",
            "start_line": 1604,
            "start_column": 61640,
            "end_line": 0,
            "end_column": 61918,
            "start_byte": 61640,
            "end_byte": 0
          },
          "_pytest.python.FunctionDefinition.runtest": {
            "name": "_pytest.python.FunctionDefinition.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "def runtest(self) -> None:\n        raise RuntimeError(\"function definitions are not supposed to be used\")",
            "start_line": 1610,
            "start_column": 61792,
            "end_line": 4,
            "end_column": 61897,
            "start_byte": 61792,
            "end_byte": 4
          },
          "_pytest.python.FunctionDefinition.setup": {
            "name": "_pytest.python.FunctionDefinition.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "setup = runtest",
            "start_line": 1613,
            "start_column": 61903,
            "end_line": 4,
            "end_column": 61918,
            "start_byte": 61903,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction": {
            "name": "_pytest.unittest.TestCaseFunction",
            "file_path": "src/_pytest/python.py",
            "file_content": "list of values if argnames specifies only one name \"\n        \"or a list of tuples of values if argnames specifies multiple names. \"\n        \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#usefixtures \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for your async framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n    msg += \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"\n    return any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(parent, fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: object):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj, name):\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mock.patch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n            warnings.warn_explicit(\n                message=PytestCollectionWarning(\n                    \"cannot collect %r because it is not a function.\" % name\n                ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instance collector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 141,
            "start_column": 4727,
            "end_line": 0,
            "end_column": 10680,
            "start_byte": 4727,
            "end_byte": 0
          },
          "_pytest.unittest.TestCaseFunction.nofuncargs": {
            "name": "_pytest.unittest.TestCaseFunction.nofuncargs",
            "file_path": "src/_pytest/python.py",
            "file_content": "nly one name \"\n  ",
            "start_line": 142,
            "start_column": 4765,
            "end_line": 4,
            "end_column": 4782,
            "start_byte": 4765,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._excinfo": {
            "name": "_pytest.unittest.TestCaseFunction._excinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": " \"or a list of ",
            "start_line": 143,
            "start_column": 4787,
            "end_line": 4,
            "end_column": 4802,
            "start_byte": 4787,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._testcase": {
            "name": "_pytest.unittest.TestCaseFunction._testcase",
            "file_path": "src/_pytest/python.py",
            "file_content": "       \"Example:",
            "start_line": 144,
            "start_column": 4860,
            "end_line": 4,
            "end_column": 4876,
            "start_byte": 4860,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.setup": {
            "name": "_pytest.unittest.TestCaseFunction.setup",
            "file_path": "src/_pytest/python.py",
            "file_content": "two calls of the \"\n        \"decorated test function, one with arg1=1 and another with arg1=2.\"\n        \"see https://docs.pytest.org/en/stable/parametrize.html for more info \"\n        \"and examples.\",\n    )\n    config.addinivalue_line(\n        \"markers\",\n        \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n        \"all of the specified fixtures. see \"\n        \"https://docs.pytest.org/en/stable/fixture.html#use",
            "start_line": 146,
            "start_column": 4919,
            "end_line": 4,
            "end_column": 5357,
            "start_byte": 4919,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.teardown": {
            "name": "_pytest.unittest.TestCaseFunction.teardown",
            "file_path": "src/_pytest/python.py",
            "file_content": "es \",\n    )\n\n\ndef async_warn_and_skip(nodeid: str) -> None:\n    msg = \"async def functions are not natively supported and have been skipped.\\n\"\n    msg += (\n        \"You need to install a suitable plugin for you",
            "start_line": 155,
            "start_column": 5363,
            "end_line": 4,
            "end_column": 5574,
            "start_byte": 5363,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.startTest": {
            "name": "_pytest.unittest.TestCaseFunction.startTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "c framework, for example:\\n\"\n    )\n    msg += \"  - pytest-asyncio\\n\"\n   ",
            "start_line": 162,
            "start_column": 5580,
            "end_line": 4,
            "end_column": 5652,
            "start_byte": 5580,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._addexcinfo": {
            "name": "_pytest.unittest.TestCaseFunction._addexcinfo",
            "file_path": "src/_pytest/python.py",
            "file_content": "= \"  - pytest-trio\\n\"\n    msg += \"  - pytest-tornasync\\n\"\n    msg += \"  - pytest-twisted\"\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\n    skip(msg=\"async def function and no async plugin installed (see warnings)\")\n\n\n@hookimpl(trylast=True)\ndef pytest_pyfunc_call(pyfuncitem: \"Function\") -> Optional[object]:\n    testfunction = pyfuncitem.obj\n    if is_async_function(testfunction):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    funcargs = pyfuncitem.funcargs\n    testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n    result = testfunction(**testargs)\n    if hasattr(result, \"__await__\") or hasattr(result, \"__aiter__\"):\n        async_warn_and_skip(pyfuncitem.nodeid)\n    return True\n\n\ndef pytest_collect_file(path: py.path.local, parent) -> Optional[\"Module\"]:\n    ext = path.ext\n    if ext == \".py\":\n        if not parent.session.isinitpath(path):\n            if not path_matches_patterns(\n                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n            ):\n                return None\n        ihook = parent.session.gethookproxy(path)\n        module = ihook.pytest_pycollect_makemodule(\n            path=path, parent=parent\n        )  # type: Module\n        return module\n    return None\n\n\ndef path_matches_patterns(path: py.path.local, patterns: Iterable[str]) -> bool:\n    \"\"\"Returns True if path matches any of the patterns in the list of globs given.\"\"\"",
            "start_line": 165,
            "start_column": 5658,
            "end_line": 4,
            "end_column": 7099,
            "start_byte": 5658,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addError": {
            "name": "_pytest.unittest.TestCaseFunction.addError",
            "file_path": "src/_pytest/python.py",
            "file_content": "eturn any(path.fnmatch(pattern) for pattern in patterns)\n\n\ndef pytest_pycollect_makemodule(path: py.path.local, parent) -> \"Module\":\n    if path.basename == \"__init__.py\":\n        pkg = Package.from_parent(parent, fspath=path)  # type: Package\n        return pkg\n    mod = Module.from_parent(pa",
            "start_line": 198,
            "start_column": 7105,
            "end_line": 4,
            "end_column": 7399,
            "start_byte": 7105,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": "fspath=path)  # type: Module\n    return mod\n\n\n@hookimpl(trylast=True)\ndef pytest_pycollect_makeitem(collector: \"PyCollector\", name: str, obj: ",
            "start_line": 208,
            "start_column": 7405,
            "end_line": 4,
            "end_column": 7547,
            "start_byte": 7405,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSkip": {
            "name": "_pytest.unittest.TestCaseFunction.addSkip",
            "file_path": "src/_pytest/python.py",
            "file_content": "):\n    # nothing was collected elsewhere, let's do it here\n    if safe_isclass(obj):\n        if collector.istestclass(obj, name):\n            return Class.from_parent(collector, name=name, obj=obj)\n    elif collector.istestfunction(obj,",
            "start_line": 213,
            "start_column": 7553,
            "end_line": 4,
            "end_column": 7789,
            "start_byte": 7553,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addExpectedFailure": {
            "name": "_pytest.unittest.TestCaseFunction.addExpectedFailure",
            "file_path": "src/_pytest/python.py",
            "file_content": ":\n        # mock seems to store unbound methods (issue473), normalize it\n        obj = getattr(obj, \"__func__\", obj)\n        # We need to try and unwrap the function if it's a functools.partial\n        # or a functools.wrapped.\n        # We mustn't if it's been wrapped with mo",
            "start_line": 220,
            "start_column": 7795,
            "end_line": 4,
            "end_column": 8072,
            "start_byte": 7795,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addUnexpectedSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "ch (python 2 only)\n        if not (inspect.isfunction(obj) or inspect.isfunction(get_real_func(obj))):\n            filename, lineno = getfslineno(obj)\n   ",
            "start_line": 231,
            "start_column": 8078,
            "end_line": 4,
            "end_column": 8232,
            "start_byte": 8078,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.addSuccess": {
            "name": "_pytest.unittest.TestCaseFunction.addSuccess",
            "file_path": "src/_pytest/python.py",
            "file_content": "   warnings.warn_explicit(\n                message=PytestCollectionWarnin",
            "start_line": 236,
            "start_column": 8238,
            "end_line": 4,
            "end_column": 8311,
            "start_byte": 8238,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.stopTest": {
            "name": "_pytest.unittest.TestCaseFunction.stopTest",
            "file_path": "src/_pytest/python.py",
            "file_content": "                 \"cannot collect %r because it is not a function.\" % na",
            "start_line": 239,
            "start_column": 8317,
            "end_line": 4,
            "end_column": 8388,
            "start_byte": 8317,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._expecting_failure": {
            "name": "_pytest.unittest.TestCaseFunction._expecting_failure",
            "file_path": "src/_pytest/python.py",
            "file_content": "             ),\n                category=None,\n                filename=str(filename),\n                lineno=lineno + 1,\n            )\n        elif getattr(obj, \"__test__\", True):\n            if is_generator(obj):\n                res = Function.from_parent(collector, name=name)\n                reason = \"yield tests were removed in pytest 4.0 - {name} will be ignored\".format(\n                    name=name\n                )\n                res.a",
            "start_line": 242,
            "start_column": 8394,
            "end_line": 4,
            "end_column": 8842,
            "start_byte": 8394,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction.runtest": {
            "name": "_pytest.unittest.TestCaseFunction.runtest",
            "file_path": "src/_pytest/python.py",
            "file_content": "ker(MARK_GEN.xfail(run=False, reason=reason))\n                res.warn(PytestCollectionWarning(reason))\n            else:\n                res = list(collector._genfunctions(name, obj))\n            return res\n\n\nclass PyobjMixin:\n    _ALLOW_MARKERS = True\n\n    # Function and attributes that the mixin needs (for type-checking only).\n    if TYPE_CHECKING:\n        name = \"\"  # type: str\n        parent = None  # type: Optional[nodes.Node]\n        own_markers = []  # type: List[Mark]\n\n        def getparent(self, cls: Type[nodes._NodeType]) -> Optional[nodes._NodeType]:\n            ...\n\n        def listchain(self) -> List[nodes.Node]:\n            ...\n\n    @property\n    def module(self):\n        \"\"\"Python module object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Module)\n        return node.obj if node is not None else None\n\n    @property\n    def cls(self):\n        \"\"\"Python class object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Class)\n        return node.obj if node is not None else None\n\n    @property\n    def instance(self):\n        \"\"\"Python instance object this node was collected from (can be None).\"\"\"\n        node = self.getparent(Instance)\n        return node.obj if node is not None else None\n\n    @property\n    def obj(self):\n        \"\"\"Underlying Python object.\"\"\"\n        obj = getattr(self, \"_obj\", None)\n        if obj is None:\n            self._obj = obj = self._getobj()\n            # XXX evil hack\n            # used to avoid Instanc",
            "start_line": 251,
            "start_column": 8848,
            "end_line": 4,
            "end_column": 10372,
            "start_byte": 8848,
            "end_byte": 4
          },
          "_pytest.unittest.TestCaseFunction._prunetraceback": {
            "name": "_pytest.unittest.TestCaseFunction._prunetraceback",
            "file_path": "src/_pytest/python.py",
            "file_content": "ector marker duplication\n            if self._ALLOW_MARKERS:\n                self.own_markers.extend(get_unpacked_marks(self.obj))\n        return obj\n\n    @obj.setter\n    def obj(self, value):\n        self._obj = value\n\n    def _getobj(self):\n        \"\"\"Gets the underlying Python object. May be overwr",
            "start_line": 281,
            "start_column": 10378,
            "end_line": 4,
            "end_column": 10680,
            "start_byte": 10378,
            "end_byte": 4
          },
          "_pytest.runner.runtestprotocol": {
            "name": "_pytest.runner.runtestprotocol",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def runtestprotocol(\n    item: Item, log: bool = True, nextitem: Optional[Item] = None\n) -> List[TestReport]:\n    hasrequest = hasattr(item, \"_request\")\n    if hasrequest and not item._request:  # type: ignore[attr-defined]\n        item._initrequest()  # type: ignore[attr-defined]\n    rep = call_and_report(item, \"setup\", log)\n    reports = [rep]\n    if rep.passed:\n        if item.config.getoption(\"setupshow\", False):\n            show_test_item(item)\n        if not item.config.getoption(\"setuponly\", False):\n            reports.append(call_and_report(item, \"call\", log))\n    reports.append(call_and_report(item, \"teardown\", log, nextitem=nextitem))\n    # after all teardown hooks have been called\n    # want funcargs and request info to go away\n    if hasrequest:\n        item._request = False  # type: ignore[attr-defined]\n        item.funcargs = None  # type: ignore[attr-defined]\n    return reports",
            "start_line": 104,
            "start_column": 3022,
            "end_line": 0,
            "end_column": 3927,
            "start_byte": 3022,
            "end_byte": 0
          },
          "_pytest.runner.call_and_report": {
            "name": "_pytest.runner.call_and_report",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def call_and_report(\n    item: Item, when: \"Literal['setup', 'call', 'teardown']\", log: bool = True, **kwds\n) -> TestReport:\n    call = call_runtest_hook(item, when, **kwds)\n    hook = item.ihook\n    report = hook.pytest_runtest_makereport(item=item, call=call)  # type: TestReport\n    if log:\n        hook.pytest_runtest_logreport(report=report)\n    if check_interactive_exception(call, report):\n        hook.pytest_exception_interact(node=item, call=call, report=report)\n    return report",
            "start_line": 203,
            "start_column": 6228,
            "end_line": 0,
            "end_column": 6718,
            "start_byte": 6228,
            "end_byte": 0
          },
          "_pytest.runner.check_interactive_exception": {
            "name": "_pytest.runner.check_interactive_exception",
            "file_path": "src/_pytest/runner.py",
            "file_content": "def check_interactive_exception(call: \"CallInfo\", report: BaseReport) -> bool:\n    \"\"\"Check whether the call raised an exception that should be reported as\n    interactive.\"\"\"\n    if call.excinfo is None:\n        # Didn't raise.\n        return False\n    if hasattr(report, \"wasxfail\"):\n        # Exception was expected.\n        return False\n    if isinstance(call.excinfo.value, (Skipped, bdb.BdbQuit)):\n        # Special control flow exception.\n        return False\n    return True",
            "start_line": 216,
            "start_column": 6721,
            "end_line": 0,
            "end_column": 7203,
            "start_byte": 6721,
            "end_byte": 0
          }
        }
      }
    }
  ]
}