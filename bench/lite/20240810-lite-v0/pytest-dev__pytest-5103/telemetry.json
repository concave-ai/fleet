{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5103",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:09:00.252261",
        "usage": "1400.8867740631104 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "getlocals",
          "delattr",
          "disabled",
          "compile",
          "fullsource",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "_some_str",
          "MODULE_NOT_FOUND_ERROR",
          "_match_lines",
          "run",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "_is_setup_py",
          "BOM_UTF8",
          "_getnextfixturedef",
          "append_skipped",
          "REPORT_COLLECTING_RESOLUTION",
          "PYTEST_CONFIG_GLOBAL",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_inject_setup_function_fixture",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "PY36",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "cached_result",
          "visit_Call_legacy",
          "ApproxDecimal",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "applymarker",
          "_check_all_skipped",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "check_xfail_no_run",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "__setattr__",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "get_terminal_writer",
          "exec_",
          "inline_genitems",
          "writeorg",
          "RAISES_MESSAGE_PARAMETER",
          "__eq__",
          "update_testcase_duration",
          "_callhelper",
          "USAGE_MSG",
          "collect_one_node",
          "_code",
          "PYTEST_ENSURETEMP",
          "append_pass",
          "N",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "value",
          "consider_preparse",
          "unittest",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "_exec_lsof",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "RaisesContext",
          "_get_non_fixture_func",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "junitxml",
          "_mk_tmp",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "PYTEST_LOGWARNING",
          "LEVELNAME_FMT_REGEX",
          "RN",
          "_get_pos",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "_log_cli_enabled",
          "processoption",
          "_config",
          "getfuncargvalue",
          "TestCaseFunction",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "location",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "unary_map",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "_check_record_param_type",
          "format_explanation",
          "makeconftest",
          "alias",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "repr_unicode",
          "doctest",
          "fileno",
          "setns",
          "_validate_usepdb_cls",
          "Class",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "pytest_itemstart",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "last_failed_paths",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "families",
          "pytest_terminal_summary",
          "__nonzero__",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "_get_marks",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "done",
          "add_report_section",
          "PytestPluginManager",
          "getnode",
          "YIELD_TESTS",
          "update",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "PrintHelp",
          "MyOptionParser",
          "parseconfig",
          "pytest_doctest_prepare_content",
          "pyobj_property",
          "find_module",
          "scope2index",
          "getbasetemp",
          "EXIT_TESTSFAILED",
          "_addexcinfo",
          "_width_of_current_line",
          "NodeMarkers",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "is_true",
          "_ConfigDeprecated",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "errors",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "short_test_summary",
          "_call_and_format_exception",
          "parse_num",
          "_checkargnotcontained",
          "python_keywords_allowed_list",
          "collect_by_name",
          "parsefactories",
          "_ensure_only_one_capture_fixture",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "ASCII_IS_DEFAULT_ENCODING",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "repr",
          "SEP",
          "matchkeyword",
          "SubRequest",
          "load_module",
          "EXIT_INTERNALERROR",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_handle_skip",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "_getglobals",
          "generic_visit",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "autouse",
          "_importconftest",
          "args",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "exc_clear",
          "PytestDeprecationWarning",
          "pytest_logwarning",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "visit_Call_35",
          "__array_ufunc__",
          "MarkMapping",
          "summary_errors",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "format_exception_only",
          "MARK_GEN",
          "fspath",
          "_opentestcase",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "syspath_prepend",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "NoneType",
          "find_suffixes",
          "syspathinsert",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "istrue",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "set_when",
          "delenv",
          "_perform_collect",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "raiseerror",
          "fnmatch_ex",
          "_runtest_for_main",
          "Traceback",
          "pytest_runtestloop",
          "item_capture",
          "TestReport",
          "capfd",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "PyobjContext",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "cls",
          "getlocation",
          "isclass",
          "parseconfigure",
          "repr_locals",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "visit_Name",
          "report_collect",
          "finish",
          "getdecoded",
          "_compilecounter",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "_get_line_with_reprcrash_message",
          "AssertionState",
          "_find_last_non_hidden_frame",
          "ihook",
          "call_optional",
          "_get_override_ini_value",
          "ExceptionRepr",
          "putaround",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "_install_capture_fixture_on_item",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "_write_pyc",
          "__len__",
          "summary_stats",
          "__next__",
          "getrawcode",
          "find",
          "_initrequest",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_callfinalizers",
          "CollectErrorRepr",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "RemovedInPytest4Warning",
          "extract_suffixes",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "isiterable",
          "FSCollector",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "ensure_newline",
          "saferepr",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "_getcapture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "mode",
          "CaptureResult",
          "str",
          "isparseable",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "OptionGroup",
          "error",
          "_is_capturing",
          "_attempt_to_close_capture_file",
          "FixtureRequest",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "ReprFileLocation",
          "PY35",
          "format",
          "isfunction",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "scopeproperty",
          "getitem",
          "ensuretemp",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "_is_unittest_unexpected_success_a_failure",
          "initialnames",
          "LogXML",
          "__getitem__",
          "FIXTURE_NAMED_REQUEST",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "exists",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "patchsysdict",
          "start_global_capturing",
          "_fix_spoof_python2",
          "record_testsuite_property",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "compile_",
          "assert_contains_lines",
          "Entry",
          "chain",
          "setall",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "_teardown_towards",
          "capture_fixtures",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "safe_text_dupfile",
          "MoreQuietAction",
          "LineMatcher",
          "context",
          "fixtures",
          "__call__",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "matchmark",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "_PY3",
          "freeze_support",
          "params",
          "isnosetest",
          "_PY2",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "_register_with_pkg_resources",
          "mkdir",
          "own_markers",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "EXIT_INTERRUPTED",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "readlines",
          "inline_runsource",
          "cmdline",
          "__delitem__",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "FunctionMixin",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "_show_fixtures_per_test",
          "collect",
          "winpymap",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "MarkEvaluator",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "_setup_collect_fakemodule",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "cached_eval",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "FixtureFunctionMarker",
          "__bool__",
          "_parse_lsof_output",
          "_import_pdbcls",
          "_format_final_exc_line",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "writelines",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "_warn_if_env_name_is_not_str",
          "restore",
          "runpytest",
          "__exit__",
          "_get_allow_unicode_flag",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_is_mocked",
          "_showfixtures_main",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "_setoption",
          "Node",
          "parametrize",
          "_setup_cli_logging",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "ReprEntry",
          "EXIT_USAGEERROR",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "_typ_map",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "defaultfuncargprefixmarker",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "is_package",
          "Interrupted",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "rmtree",
          "strip",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "getexplanation",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "_fix_unittest_skip_decorator",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "dummy_context_manager",
          "Exit",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "getcfg",
          "exit",
          "_imp_find_module",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "NoCapture",
          "_rewrite_test",
          "raise_on_kwargs",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "_get_xunit_setup_teardown",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "ecu",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "_patched_find_module",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "warn_about_none_ast",
          "wasvalid",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "cookie_re",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "__version__",
          "RAISES_EXEC",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "getslaveinfoline",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "FIXTURE_FUNCTION_CALL",
          "_test_pytest_function",
          "_preparse",
          "idmaker",
          "FDCaptureBinary",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "with_args",
          "EXIT_NOTESTSCOLLECTED",
          "_get_active_fixturedef",
          "yield_fixture",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "ApproxBase",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "check_strict_xfail",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "_state",
          "_PLUGGY_DIR",
          "get_actual_log_level",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "get_skip_exceptions",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "_prunetraceback",
          "addinivalue_line",
          "EXIT_OK",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "WARNS_EXEC",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "runitem",
          "_istrue",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "call_and_report",
          "nofuncargs",
          "Config",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "invalidraise",
          "Module",
          "KeywordMapping",
          "Item",
          "_idvalset",
          "pytest_addhooks",
          "__all__",
          "matchnodes",
          "read_global_capture",
          "_getini",
          "_pdb_cls",
          "istestfunction",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "FuncargnamesCompatAttr",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "addhooks",
          "GETFUNCARGVALUE",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "_cmp_raises_type_error",
          "nodes",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "binop_map",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "write",
          "get_fslocation_from_item",
          "session",
          "out",
          "deselect_by_mark",
          "__unicode__",
          "spawn_pytest",
          "scopenum_function",
          "_matchnodes",
          "import_plugin",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "builtin",
          "_collectfile",
          "addFailure",
          "catching_logs",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "PYTESTER_COPY_EXAMPLE",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "AssertionRewriter",
          "assertrepr_compare",
          "rewrite_asserts",
          "repr_failure",
          "repr_traceback",
          "compare",
          "explanation",
          "format_explanation",
          "assertion"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:09:01.653187",
        "usage": "258.2719326019287 ms"
      },
      "request": {
        "tokens": [
          "AssertionRewriter",
          "assertrepr_compare",
          "rewrite_asserts",
          "repr_failure",
          "repr_traceback",
          "compare",
          "explanation",
          "format_explanation",
          "assertion"
        ]
      },
      "response": {
        "results": {
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "assertion": [
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/freeze_support.py"
          ],
          "explanation": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/skipping.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/hookspec.py"
          ],
          "repr_traceback": [
            "src/_pytest/_code/code.py"
          ],
          "compare": [
            "src/_pytest/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python_api.py"
          ],
          "format_explanation": [
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/__init__.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "rewrite_asserts": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:09:01.911473",
        "usage": "4747.851133346558 ms"
      },
      "request": {
        "keyword_search_results": {
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "assertion": [
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/freeze_support.py"
          ],
          "explanation": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/skipping.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/hookspec.py"
          ],
          "repr_traceback": [
            "src/_pytest/_code/code.py"
          ],
          "compare": [
            "src/_pytest/__init__.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python_api.py"
          ],
          "format_explanation": [
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/assertion/__init__.py"
          ],
          "assertrepr_compare": [
            "src/_pytest/assertion/util.py",
            "src/_pytest/assertion/__init__.py"
          ],
          "AssertionRewriter": [
            "src/_pytest/assertion/rewrite.py"
          ],
          "rewrite_asserts": [
            "src/_pytest/assertion/rewrite.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue revolves around improving the error reporting when using `all` or `any` in assertions. The current failure messages using these functions are not very helpful. The reporter suggests improving the assertion mechanism by unrolling the iterator, similar to how a for loop might provide more meaningful feedback.\n\nTo address this, we need to look into areas in the codebase where assertion rewriting takes place or where assertions are handled, specifically related to unrolling or providing explanatory error handling.\n\n1. **assertion/rewrite.py** has keywords like 'AssertionRewriter' and 'rewrite_asserts' which imply it relates to rewriting assertions. This could be where unrolling or adjusting assertions for better reporting is implemented, making it highly relevant.\n\n2. **assertion/util.py** also appears to deal with assertion utilities. This might be relevant for utility functions related to assertions.\n\n3. **assertion/truncate.py** might relate to truncating assertion outputs, possibly to make them more comprehensible, but it's less likely to be directly involved in the rewrite itself.\n\nGiven the task to improve assertion messages specifically for iterable unrolling in functions like `all` and `any`, my focus is on `rewrite.py`, with some consideration for potential roles of `util.py`.",
        "file_paths": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/util.py",
          "src/_pytest/assertion/truncate.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:09:06.659351",
        "usage": "7268.1310176849365 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/rewrite.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 What issue is the user describing?\nThe user describes an issue with Python's `all` and `any` functions when used for assertions. The functions do not provide meaningful error messages when an assertion fails, especially when compared to assertions done inside a `for` loop.\n\n1.2 Does the user provide reproduction steps?\nYes, the user provides example test functions that illustrate the issue using `all`, both with a generator and list comprehension, and a more verbose but informative assertion within a `for` loop.\n\n1.3 How was this issue caused?\nThe issue is caused by the lack of detailed error information from the `all`/`any` functions when used with assertions, because they don't provide specifics about which item in the iterable failed the assertion.\n\n1.4 Summary of user expectation: \nThe user expects the assertion rewriter to \"unroll\" assertions using `all`/`any` into the more verbose `for` loop-style assertions to give detailed information about which specific item failed, making use of the existing detailed assertion error reports.\n\n1.6 Possible solutions:\nModify the assertion rewriting mechanism to transform `all`/`any` expressions so that an equivalent `for` loop that checks each condition and logs detailed information is generated.\n\n2. Evaluate <file_content>:\nThis file appears to deal with AST-based assertion rewriting for pytest, which is relevant as we want assertions using `all`/`any` to be handled more verbosely. Specific methods like `AssertionRewriter` class and its methods are highly relevant.\n\nIdentified relevant methods and classes:\n- `AssertionRewriter` class: In general, as it is involved in rewriting assertions.\n- `visit_Assert`: This could be expanded to handle `all`/`any` expressions.\n- General mechanism of AST manipulation and how assertions are rewritten in this module is of utmost importance here, especially if syntactic transformations are to be introduced.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "AssertionRewriter",
          "AssertionRewriter.visit_Assert",
          "rewrite_asserts"
        ],
        "root_cause_symbols": [
          "AssertionRewriter",
          "AssertionRewriter.visit_Assert",
          "rewrite_asserts"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:09:13.927538",
        "usage": "9045.988082885742 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/util.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user describes an issue with assertion error messages when using Python's built-in `all` and `any` functions in tests. Specifically, the failure messages lack clarity and do not indicate which specific element caused the failure. The user proposes modifying the assertion mechanism to \"unroll\" the iterators, thus providing more informative messages similar to those given by a manual for loop.\n1.2 The user provides three code snippets illustrating the issue: using `all` with a generator, a list comprehension, and a for loop. The issue arises with the first two examples where a failure does not clarify which element in the iterable caused the issue.\n1.3 The issue is caused by the nature of Python's `all` and `any` functions, which do not provide specific insights about which element failed the predicate check, they only return False/True based on the truthiness or falsiness of the yielded values.\n1.4 User expectation: Assertions using `all` or `any` should provide detailed failure reports similar to those provided by a for loop, which pinpoints the failure better.\n1.6 Possible solutions: A potential solution could involve modifying how assertions are evaluated for the `all` and `any` functions, possibly by expanding the iteration into individual assertions prior to evaluation.\n\n2. Make File Evaluation:\n2.1 The file appears to deal with utilities for debugging assertions in pytest, including formatting explanations and handling iterable comparisons.\n2.2 The symbols related to iterables, like `isiterable`, `assertrepr_compare`, `_compare_eq_iterable`, may be relevant, since enhancing assertions for `all`/`any` could involve iterating over the items and comparing them.\n2.3 The functions `assertrepr_compare`, `_compare_eq_iterable`, and `isiterable` are particularly relevant as they seem to handle comparisons and checks on iterables, which is what the issue is about.\n2.4 The file may need enhancements to expand `all`/`any` into individual assertions, which could be implemented or influenced by methods like `assertrepr_compare`.\n2.5 There is a mention of `assertion rewriter`, which might be a hook for modifying assertion behavior, possibly located in another file responsible for assertion rewriting.\n2.6 The file is related to assertions but might not be the root cause of the current lack of detailed iterable failure reports, as it appears to focus on formatting rather than modifying logic applied to iterables.\n\nOutput Decision: This file appears relevant but does not contain the root functionality causing the issue. It potentially requires collaboration with components actually rewriting or handling the core assertion logic for `all`/`any`.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/assertion/plugin.py",
          "src/_pytest/assertion/hooks.py"
        ],
        "relevant_symbols": [
          "assertrepr_compare",
          "isiterable",
          "_compare_eq_iterable"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:09:22.973554",
        "usage": "7551.526069641113 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/truncate.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user is describing an issue with the built-in Python functions `all()` and `any()`. When they fail during assertions in tests, the failure messages are not informative enough. Examples were provided using generator expressions, list comprehensions, and for loops, showing that only the for loop provides detailed failure information.\n1.2 User provided reproduction steps using generator expressions, list comprehensions, and for loops in function assertions. The steps lead to the issue because built-in functions `all()` and `any()` do not provide information on which specific element caused the assertion to fail.\n1.3 The issue is caused by the limitation of `all()` and `any()` functions in terms of failure reporting, where they only report a boolean result but not specific failure context.\n1.4 The user expects the assertion rewrites to generate more informative failure messages automatically by effectively converting the `all()`/`any()` logic to a for loop style.\n1.6 Potential solution might involve modifying pytest's assertion rewriting system to \"unroll\" the iterables inside `all()` and `any()` calls to equivalent explicit iteration (e.g., for loop), capturing more descriptive failure information.\n\n2. Make file evaluation:\n2.1 Analyzing the file `src/_pytest/assertion/truncate.py`, which is focused on truncating assertion explanations to make outputs concise for terminal displays.\n2.2 Key functions include `truncate_if_required()` and `_truncate_explanation()`, among others, which are used to truncate or format the output after assertions.\n2.3 The file deals with formatting output and not with assertion logic or the core mechanics of how assertions are evaluated.\n2.4 No relevant symbols for directly addressing the issue of improving assertion messages for the `all()`/`any()` functions are present.\n2.5 This file does not manage assertion mechanics directly and is not modifying message generation but rather message truncation for display.\n2.6 Therefore, it is unlikely related to the core issue related to modifying or unrolling assertions.\n\n3. Output Your Decision:",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/assertion/rewrite.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:09:30.525102",
        "usage": "151.1068344116211 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/assertion/rewrite.py",
            "relevant_symbol_keys": [
              "AssertionRewriter",
              "AssertionRewriter.visit_Assert",
              "rewrite_asserts"
            ],
            "root_cause_symbol_keys": [
              "AssertionRewriter",
              "AssertionRewriter.visit_Assert",
              "rewrite_asserts"
            ]
          },
          {
            "file_path": "src/_pytest/assertion/util.py",
            "relevant_symbol_keys": [
              "assertrepr_compare",
              "isiterable",
              "_compare_eq_iterable"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/truncate.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "n is not None:\n                        explanation.",
            "start_line": 154,
            "start_column": 5119,
            "end_line": 0,
            "end_column": 5170,
            "start_byte": 5119,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.isiterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def isiterable(obj):\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False",
            "start_line": 129,
            "start_column": 3518,
            "end_line": 0,
            "end_column": 3639,
            "start_byte": 3518,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = u\"%s %s %s\" % (ecu(left_repr), op, ecu(right_repr))\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            u\"(pytest_assertion plugin: representation of details failed.  \"\n            u\"Probably an object has a faulty __repr__.)\",\n            six.text_type(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 3642,
            "end_line": 0,
            "end_column": 5775,
            "start_byte": 3642,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._compare_eq_iterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_iterable(left, right, verbose=0):\n    if not verbose:\n        return [u\"Use -v to get the full diff\"]\n    # dynamic import to speedup pytest\n    import difflib\n\n    try:\n        left_formatting = pprint.pformat(left).splitlines()\n        right_formatting = pprint.pformat(right).splitlines()\n        explanation = [u\"Full diff:\"]\n    except Exception:\n        # hack: PrettyPrinter.pformat() in python 2 fails when formatting items that can't be sorted(), ie, calling\n        # sorted() on a list would raise. See issue #718.\n        # As a workaround, the full diff is generated by using the repr() string of each item of each container.\n        left_formatting = sorted(repr(x) for x in left)\n        right_formatting = sorted(repr(x) for x in right)\n        explanation = [u\"Full diff (fallback to calling repr on each item):\"]\n    explanation.extend(\n        line.strip() for line in difflib.ndiff(left_formatting, right_formatting)\n    )\n    return explanation",
            "start_line": 262,
            "start_column": 8366,
            "end_line": 0,
            "end_column": 9347,
            "start_byte": 8366,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(mod, module_path=None, config=None):\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config).run(mod)",
            "start_line": 465,
            "start_column": 17515,
            "end_line": 0,
            "end_column": 17671,
            "start_byte": 17515,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :on_failure: The AST statements which will be executed if the\n       assertion test fails.  This is the code which will construct\n       the failure message and raises the AssertionError.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    This state is reset on every new assert statement visited and used\n    by the other visitors.\n\n    \"\"\"\n\n    def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config\n\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)\n\n    @staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())\n\n    def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])\n\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n\n    def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"\n\n    def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)\n\n    def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))\n\n    def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements\n\n    def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])\n\n    def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)\n\n    def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n\n    def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)\n\n    def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation\n\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    # ast.Call signature changed on 3.5,\n    # conditionally change  which methods is named\n    # visit_Call depending on Python version\n    if sys.version_info >= (3, 5):\n        visit_Call = visit_Call_35\n    else:\n        visit_Call = visit_Call_legacy\n\n    def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl\n\n    def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 607,
            "start_column": 21534,
            "end_line": 0,
            "end_column": 41271,
            "start_byte": 21534,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.__init__",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config",
            "start_line": 659,
            "start_column": 23944,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 23944,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 664,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 26514,
            "start_byte": 24108,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.is_rewrite_disabled",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring",
            "start_line": 729,
            "start_column": 26520,
            "end_line": 4,
            "end_column": 26623,
            "start_byte": 26520,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.variable",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name",
            "start_line": 733,
            "start_column": 26629,
            "end_line": 4,
            "end_column": 26876,
            "start_byte": 26629,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.assign",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())",
            "start_line": 740,
            "start_column": 26882,
            "end_line": 4,
            "end_column": 27092,
            "start_byte": 26882,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.display",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)",
            "start_line": 746,
            "start_column": 27098,
            "end_line": 4,
            "end_column": 27215,
            "start_byte": 27098,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.helper",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])",
            "start_line": 750,
            "start_column": 27221,
            "end_line": 4,
            "end_column": 27450,
            "start_byte": 27221,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.builtin",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())",
            "start_line": 756,
            "start_column": 27456,
            "end_line": 4,
            "end_column": 27649,
            "start_byte": 27456,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.explanation_param",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"",
            "start_line": 761,
            "start_column": 27655,
            "end_line": 4,
            "end_column": 28188,
            "start_byte": 27655,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.push_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)",
            "start_line": 774,
            "start_column": 28194,
            "end_line": 4,
            "end_column": 28732,
            "start_byte": 28194,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.pop_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())",
            "start_line": 788,
            "start_column": 28738,
            "end_line": 4,
            "end_column": 29612,
            "start_byte": 28738,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))",
            "start_line": 807,
            "start_column": 29618,
            "end_line": 4,
            "end_column": 29848,
            "start_byte": 29618,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 813,
            "start_column": 29854,
            "end_line": 4,
            "end_column": 32649,
            "start_byte": 29854,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.warn_about_none_ast",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])",
            "start_line": 880,
            "start_column": 32655,
            "end_line": 4,
            "end_column": 33624,
            "start_byte": 32655,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)",
            "start_line": 907,
            "start_column": 33630,
            "end_line": 4,
            "end_column": 34144,
            "start_byte": 33630,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)",
            "start_line": 917,
            "start_column": 34150,
            "end_line": 4,
            "end_column": 35744,
            "start_byte": 34150,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)",
            "start_line": 952,
            "start_column": 35750,
            "end_line": 4,
            "end_column": 35999,
            "start_byte": 35750,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 958,
            "start_column": 36005,
            "end_line": 4,
            "end_column": 36363,
            "start_byte": 36005,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 966,
            "start_column": 36369,
            "end_line": 4,
            "end_column": 37404,
            "start_byte": 36369,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl",
            "start_line": 993,
            "start_column": 37410,
            "end_line": 4,
            "end_column": 37652,
            "start_byte": 37410,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_legacy",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 999,
            "start_column": 37658,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 37658,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl",
            "start_line": 1037,
            "start_column": 39105,
            "end_line": 4,
            "end_column": 39536,
            "start_byte": 39105,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 1047,
            "start_column": 39542,
            "end_line": 4,
            "end_column": 41271,
            "start_byte": 39542,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T12:09:30.676216",
        "usage": "18254.283905029297 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "n is not None:\n                        explanation.",
            "start_line": 154,
            "start_column": 5119,
            "end_line": 0,
            "end_column": 5170,
            "start_byte": 5119,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.isiterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def isiterable(obj):\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False",
            "start_line": 129,
            "start_column": 3518,
            "end_line": 0,
            "end_column": 3639,
            "start_byte": 3518,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = u\"%s %s %s\" % (ecu(left_repr), op, ecu(right_repr))\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            u\"(pytest_assertion plugin: representation of details failed.  \"\n            u\"Probably an object has a faulty __repr__.)\",\n            six.text_type(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 3642,
            "end_line": 0,
            "end_column": 5775,
            "start_byte": 3642,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._compare_eq_iterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_iterable(left, right, verbose=0):\n    if not verbose:\n        return [u\"Use -v to get the full diff\"]\n    # dynamic import to speedup pytest\n    import difflib\n\n    try:\n        left_formatting = pprint.pformat(left).splitlines()\n        right_formatting = pprint.pformat(right).splitlines()\n        explanation = [u\"Full diff:\"]\n    except Exception:\n        # hack: PrettyPrinter.pformat() in python 2 fails when formatting items that can't be sorted(), ie, calling\n        # sorted() on a list would raise. See issue #718.\n        # As a workaround, the full diff is generated by using the repr() string of each item of each container.\n        left_formatting = sorted(repr(x) for x in left)\n        right_formatting = sorted(repr(x) for x in right)\n        explanation = [u\"Full diff (fallback to calling repr on each item):\"]\n    explanation.extend(\n        line.strip() for line in difflib.ndiff(left_formatting, right_formatting)\n    )\n    return explanation",
            "start_line": 262,
            "start_column": 8366,
            "end_line": 0,
            "end_column": 9347,
            "start_byte": 8366,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(mod, module_path=None, config=None):\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config).run(mod)",
            "start_line": 465,
            "start_column": 17515,
            "end_line": 0,
            "end_column": 17671,
            "start_byte": 17515,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :on_failure: The AST statements which will be executed if the\n       assertion test fails.  This is the code which will construct\n       the failure message and raises the AssertionError.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    This state is reset on every new assert statement visited and used\n    by the other visitors.\n\n    \"\"\"\n\n    def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config\n\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)\n\n    @staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())\n\n    def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])\n\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n\n    def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"\n\n    def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)\n\n    def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))\n\n    def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements\n\n    def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])\n\n    def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)\n\n    def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n\n    def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)\n\n    def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation\n\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    # ast.Call signature changed on 3.5,\n    # conditionally change  which methods is named\n    # visit_Call depending on Python version\n    if sys.version_info >= (3, 5):\n        visit_Call = visit_Call_35\n    else:\n        visit_Call = visit_Call_legacy\n\n    def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl\n\n    def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 607,
            "start_column": 21534,
            "end_line": 0,
            "end_column": 41271,
            "start_byte": 21534,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.__init__",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config",
            "start_line": 659,
            "start_column": 23944,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 23944,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 664,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 26514,
            "start_byte": 24108,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.is_rewrite_disabled",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring",
            "start_line": 729,
            "start_column": 26520,
            "end_line": 4,
            "end_column": 26623,
            "start_byte": 26520,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.variable",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name",
            "start_line": 733,
            "start_column": 26629,
            "end_line": 4,
            "end_column": 26876,
            "start_byte": 26629,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.assign",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())",
            "start_line": 740,
            "start_column": 26882,
            "end_line": 4,
            "end_column": 27092,
            "start_byte": 26882,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.display",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)",
            "start_line": 746,
            "start_column": 27098,
            "end_line": 4,
            "end_column": 27215,
            "start_byte": 27098,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.helper",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])",
            "start_line": 750,
            "start_column": 27221,
            "end_line": 4,
            "end_column": 27450,
            "start_byte": 27221,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.builtin",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())",
            "start_line": 756,
            "start_column": 27456,
            "end_line": 4,
            "end_column": 27649,
            "start_byte": 27456,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.explanation_param",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"",
            "start_line": 761,
            "start_column": 27655,
            "end_line": 4,
            "end_column": 28188,
            "start_byte": 27655,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.push_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)",
            "start_line": 774,
            "start_column": 28194,
            "end_line": 4,
            "end_column": 28732,
            "start_byte": 28194,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.pop_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())",
            "start_line": 788,
            "start_column": 28738,
            "end_line": 4,
            "end_column": 29612,
            "start_byte": 28738,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))",
            "start_line": 807,
            "start_column": 29618,
            "end_line": 4,
            "end_column": 29848,
            "start_byte": 29618,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 813,
            "start_column": 29854,
            "end_line": 4,
            "end_column": 32649,
            "start_byte": 29854,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.warn_about_none_ast",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])",
            "start_line": 880,
            "start_column": 32655,
            "end_line": 4,
            "end_column": 33624,
            "start_byte": 32655,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)",
            "start_line": 907,
            "start_column": 33630,
            "end_line": 4,
            "end_column": 34144,
            "start_byte": 33630,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)",
            "start_line": 917,
            "start_column": 34150,
            "end_line": 4,
            "end_column": 35744,
            "start_byte": 34150,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)",
            "start_line": 952,
            "start_column": 35750,
            "end_line": 4,
            "end_column": 35999,
            "start_byte": 35750,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 958,
            "start_column": 36005,
            "end_line": 4,
            "end_column": 36363,
            "start_byte": 36005,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 966,
            "start_column": 36369,
            "end_line": 4,
            "end_column": 37404,
            "start_byte": 36369,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl",
            "start_line": 993,
            "start_column": 37410,
            "end_line": 4,
            "end_column": 37652,
            "start_byte": 37410,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_legacy",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 999,
            "start_column": 37658,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 37658,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl",
            "start_line": 1037,
            "start_column": 39105,
            "end_line": 4,
            "end_column": 39536,
            "start_byte": 39105,
            "end_byte": 4
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 1047,
            "start_column": 39542,
            "end_line": 4,
            "end_column": 41271,
            "start_byte": 39542,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue describes the lack of useful error messages when assertions with `all` or `any` functions fail in tests. \n1.2 The issue is caused due to the way assertions are rewritten, not breaking down iterable checks made by `all` or `any` into individual meaningful checks, leading to non-informative assertion failures.\n1.3 The expected result should output which exact item in the iterable caused the assertion to fail, similar to breaking down the iteration into separate assertions.\n1.4 The expected result should provide detailed error messages indicating the first failure in the iterable.\n1.5 The solution should involve improving the assertion rewriting mechanism to \"unroll\" iterables in `all`/`any`, checking each item individually and providing detailed assertion failure messages.\n\n2. Make the evaluate:\n2.1. Analyzing provided symbols to determine relevant parts for the required enhancement.\n2.2. The main symbol dealing with the assertion rewriting logic is `AssertionRewriter`, particularly methods handling `assert` statements, like `visit_Assert`.\n2.3. This issue is related to how we handle `ast.Call` expressions, as `all` and `any` are function calls.\n2.4. To address the issue, visitor methods like `visit_Call_35` inside `AssertionRewriter` should enhance processing for specific function calls to `all` or `any`. We need to check if calls involve these functions and proceed to unroll them.\n2.5. If symbols handling specific nodes related to `all`/`any` were present, it would be apparent.\n2.6. Request more information if there's lack of clarity on parts that involve recognizing and rewriting function calls specifically for `all` and `any`.",
        "symbols": [
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "The `visit_Assert` method is responsible for rewriting assertion statements. To improve assertion messages involving `all` and `any`, this method needs to be adjusted to recognize when these functions are used and unroll the checks within."
          },
          {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "reason": "The `visit_Call_35` method processes function calls. To implement the unrolling of `all` and `any`, this method must be adapted to recognize calls to these functions and process their iterable arguments, generating individual assertions."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "The `rewrite_asserts` function calls `AssertionRewriter.run`. It's the entry point for rewriting assertions, but no specific logic for handling `all` or `any` directly needs changes here.",
          "The `AssertionRewriter` class is the core logic for rewriting assertions. The focus would be on identifying `all` and `any` calls and handling them differently for detailed reporting.",
          "The constructor initializes the class and sets some state, no changes needed here for the requested feature.",
          "The `run` method goes through the AST nodes, collecting `asserts` for rewriting, but doesn't handle the specific logic for `all/any`. It is a starting point but not where detailed changes occur.",
          "This method checks if rewriting should be bypassed based on docstrings, unrelated to `all/any` handling.",
          "This method generates fresh identifiers for variable handling during rewriting. Unrelated to `all`/`any` handling.",
          "Used to assign expressions to variables. Part of general AST manipulation, not directly related to `all/any`.",
          "Handles displaying expressions. Useful for creating error messages but not directly for `all/any`.",
          "Calls helpers within the module. Indirectly useful if creating helper functions for `all/any` logic.",
          "Used to refer to built-in functions. Could involve redirecting `all`/`any` to custom handlers, indirectly related.",
          "Creates placeholders for formatted explanations. Indirectly affects how results are shown, not `all/any` logic per se.",
          "Manages format context stacks, ensuring explanations are consistent. Indirectly relevant if creating elaborate error messages.",
          "Pulls from formatting contexts to create messages. Useful if extending how failures in `all`/`any` are explained.",
          "A minimal visitor for nodes not deeply custom-handled. If `all`/`any` don't get special handling, may default here.",
          "The core method for rewriting assertions. Will need to specifically enhance this to handle `all`/`any` cases as described in the issue.",
          "Warns on `None` in assertions. Indirect, but shows how AST nodes can trigger warnings, which might inspire similar checks for `all`/`any`.",
          "Deals with individual names, formatting them for output. Indirectly useful for error message enhancement.",
          "Rewrites boolean operations in assertions, indirectly related by showcasing how complex operations get expanded for better reporting.",
          "Handles unary operations, unrelated to `all`/`any`.",
          "Handles binary operations in asserts. Related conceptually but not for `all`/`any` unrolling.",
          "Processes function calls, crucial for addressing `all`/`any` unrolling to check iterable entries.",
          "Handles starred arguments in calls, enlightening approach but peripheral here.",
          "Legacy support for calls pre-Python 3.5, ensures old call styles are handled too.",
          "Visits attributes, explaining them. Indirect unless attributes factor hugely into `all`/`any`.",
          "Compares values, necessary for asserts as they often form conditions within or around `all`/`any`.",
          "Implementation here addresses specialized compare assertions. Could be leveraged to differentiate `all`/`any` comparisons."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T12:09:48.930526",
        "usage": "2.7968883514404297 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "n is not None:\n                        explanation.",
              "start_line": 154,
              "start_column": 5119,
              "end_line": 0,
              "end_column": 5170,
              "start_byte": 5119,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.isiterable",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def isiterable(obj):\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False",
              "start_line": 129,
              "start_column": 3518,
              "end_line": 0,
              "end_column": 3639,
              "start_byte": 3518,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = u\"%s %s %s\" % (ecu(left_repr), op, ecu(right_repr))\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            u\"(pytest_assertion plugin: representation of details failed.  \"\n            u\"Probably an object has a faulty __repr__.)\",\n            six.text_type(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
              "start_line": 137,
              "start_column": 3642,
              "end_line": 0,
              "end_column": 5775,
              "start_byte": 3642,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._compare_eq_iterable",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "def _compare_eq_iterable(left, right, verbose=0):\n    if not verbose:\n        return [u\"Use -v to get the full diff\"]\n    # dynamic import to speedup pytest\n    import difflib\n\n    try:\n        left_formatting = pprint.pformat(left).splitlines()\n        right_formatting = pprint.pformat(right).splitlines()\n        explanation = [u\"Full diff:\"]\n    except Exception:\n        # hack: PrettyPrinter.pformat() in python 2 fails when formatting items that can't be sorted(), ie, calling\n        # sorted() on a list would raise. See issue #718.\n        # As a workaround, the full diff is generated by using the repr() string of each item of each container.\n        left_formatting = sorted(repr(x) for x in left)\n        right_formatting = sorted(repr(x) for x in right)\n        explanation = [u\"Full diff (fallback to calling repr on each item):\"]\n    explanation.extend(\n        line.strip() for line in difflib.ndiff(left_formatting, right_formatting)\n    )\n    return explanation",
              "start_line": 262,
              "start_column": 8366,
              "end_line": 0,
              "end_column": 9347,
              "start_byte": 8366,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_assertrepr_compare",
              "file_path": "src/_pytest/assertion/util.py",
              "file_content": "",
              "start_line": 475,
              "start_column": 15508,
              "end_line": 0,
              "end_column": 16001,
              "start_byte": 15508,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.assertion.rewrite_asserts",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def rewrite_asserts(mod, module_path=None, config=None):\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config).run(mod)",
              "start_line": 465,
              "start_column": 17515,
              "end_line": 0,
              "end_column": 17671,
              "start_byte": 17515,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewriter",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :on_failure: The AST statements which will be executed if the\n       assertion test fails.  This is the code which will construct\n       the failure message and raises the AssertionError.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    This state is reset on every new assert statement visited and used\n    by the other visitors.\n\n    \"\"\"\n\n    def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config\n\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)\n\n    @staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())\n\n    def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])\n\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n\n    def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"\n\n    def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)\n\n    def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))\n\n    def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements\n\n    def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])\n\n    def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)\n\n    def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n\n    def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)\n\n    def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation\n\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    # ast.Call signature changed on 3.5,\n    # conditionally change  which methods is named\n    # visit_Call depending on Python version\n    if sys.version_info >= (3, 5):\n        visit_Call = visit_Call_35\n    else:\n        visit_Call = visit_Call_legacy\n\n    def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl\n\n    def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
              "start_line": 607,
              "start_column": 21534,
              "end_line": 0,
              "end_column": 41271,
              "start_byte": 21534,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.__init__",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config",
              "start_line": 659,
              "start_column": 23944,
              "end_line": 4,
              "end_column": 24102,
              "start_byte": 23944,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.run",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
              "start_line": 664,
              "start_column": 24108,
              "end_line": 4,
              "end_column": 26514,
              "start_byte": 24108,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.is_rewrite_disabled",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "@staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring",
              "start_line": 729,
              "start_column": 26520,
              "end_line": 4,
              "end_column": 26623,
              "start_byte": 26520,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.variable",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name",
              "start_line": 733,
              "start_column": 26629,
              "end_line": 4,
              "end_column": 26876,
              "start_byte": 26629,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.assign",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())",
              "start_line": 740,
              "start_column": 26882,
              "end_line": 4,
              "end_column": 27092,
              "start_byte": 26882,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.display",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)",
              "start_line": 746,
              "start_column": 27098,
              "end_line": 4,
              "end_column": 27215,
              "start_byte": 27098,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.helper",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])",
              "start_line": 750,
              "start_column": 27221,
              "end_line": 4,
              "end_column": 27450,
              "start_byte": 27221,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.builtin",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())",
              "start_line": 756,
              "start_column": 27456,
              "end_line": 4,
              "end_column": 27649,
              "start_byte": 27456,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.explanation_param",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"",
              "start_line": 761,
              "start_column": 27655,
              "end_line": 4,
              "end_column": 28188,
              "start_byte": 27655,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.push_format_context",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)",
              "start_line": 774,
              "start_column": 28194,
              "end_line": 4,
              "end_column": 28732,
              "start_byte": 28194,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.pop_format_context",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())",
              "start_line": 788,
              "start_column": 28738,
              "end_line": 4,
              "end_column": 29612,
              "start_byte": 28738,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.generic_visit",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))",
              "start_line": 807,
              "start_column": 29618,
              "end_line": 4,
              "end_column": 29848,
              "start_byte": 29618,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
              "start_line": 813,
              "start_column": 29854,
              "end_line": 4,
              "end_column": 32649,
              "start_byte": 29854,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.warn_about_none_ast",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])",
              "start_line": 880,
              "start_column": 32655,
              "end_line": 4,
              "end_column": 33624,
              "start_byte": 32655,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Name",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)",
              "start_line": 907,
              "start_column": 33630,
              "end_line": 4,
              "end_column": 34144,
              "start_byte": 33630,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)",
              "start_line": 917,
              "start_column": 34150,
              "end_line": 4,
              "end_column": 35744,
              "start_byte": 34150,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)",
              "start_line": 952,
              "start_column": 35750,
              "end_line": 4,
              "end_column": 35999,
              "start_byte": 35750,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
              "start_line": 958,
              "start_column": 36005,
              "end_line": 4,
              "end_column": 36363,
              "start_byte": 36005,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
              "start_line": 966,
              "start_column": 36369,
              "end_line": 4,
              "end_column": 37404,
              "start_byte": 36369,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl",
              "start_line": 993,
              "start_column": 37410,
              "end_line": 4,
              "end_column": 37652,
              "start_byte": 37410,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Call_legacy",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
              "start_line": 999,
              "start_column": 37658,
              "end_line": 4,
              "end_column": 38842,
              "start_byte": 37658,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl",
              "start_line": 1037,
              "start_column": 39105,
              "end_line": 4,
              "end_column": 39536,
              "start_byte": 39105,
              "end_byte": 4
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
              "start_line": 1047,
              "start_column": 39542,
              "end_line": 4,
              "end_column": 41271,
              "start_byte": 39542,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze User Instructions:\n1.1 The issue describes the lack of useful error messages when assertions with `all` or `any` functions fail in tests. \n1.2 The issue is caused due to the way assertions are rewritten, not breaking down iterable checks made by `all` or `any` into individual meaningful checks, leading to non-informative assertion failures.\n1.3 The expected result should output which exact item in the iterable caused the assertion to fail, similar to breaking down the iteration into separate assertions.\n1.4 The expected result should provide detailed error messages indicating the first failure in the iterable.\n1.5 The solution should involve improving the assertion rewriting mechanism to \"unroll\" iterables in `all`/`any`, checking each item individually and providing detailed assertion failure messages.\n\n2. Make the evaluate:\n2.1. Analyzing provided symbols to determine relevant parts for the required enhancement.\n2.2. The main symbol dealing with the assertion rewriting logic is `AssertionRewriter`, particularly methods handling `assert` statements, like `visit_Assert`.\n2.3. This issue is related to how we handle `ast.Call` expressions, as `all` and `any` are function calls.\n2.4. To address the issue, visitor methods like `visit_Call_35` inside `AssertionRewriter` should enhance processing for specific function calls to `all` or `any`. We need to check if calls involve these functions and proceed to unroll them.\n2.5. If symbols handling specific nodes related to `all`/`any` were present, it would be apparent.\n2.6. Request more information if there's lack of clarity on parts that involve recognizing and rewriting function calls specifically for `all` and `any`.",
          "symbols": [
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "The `visit_Assert` method is responsible for rewriting assertion statements. To improve assertion messages involving `all` and `any`, this method needs to be adjusted to recognize when these functions are used and unroll the checks within."
            },
            {
              "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
              "file_path": "src/_pytest/assertion/rewrite.py",
              "reason": "The `visit_Call_35` method processes function calls. To implement the unrolling of `all` and `any`, this method must be adapted to recognize calls to these functions and process their iterable arguments, generating individual assertions."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "The `rewrite_asserts` function calls `AssertionRewriter.run`. It's the entry point for rewriting assertions, but no specific logic for handling `all` or `any` directly needs changes here.",
            "The `AssertionRewriter` class is the core logic for rewriting assertions. The focus would be on identifying `all` and `any` calls and handling them differently for detailed reporting.",
            "The constructor initializes the class and sets some state, no changes needed here for the requested feature.",
            "The `run` method goes through the AST nodes, collecting `asserts` for rewriting, but doesn't handle the specific logic for `all/any`. It is a starting point but not where detailed changes occur.",
            "This method checks if rewriting should be bypassed based on docstrings, unrelated to `all/any` handling.",
            "This method generates fresh identifiers for variable handling during rewriting. Unrelated to `all`/`any` handling.",
            "Used to assign expressions to variables. Part of general AST manipulation, not directly related to `all/any`.",
            "Handles displaying expressions. Useful for creating error messages but not directly for `all/any`.",
            "Calls helpers within the module. Indirectly useful if creating helper functions for `all/any` logic.",
            "Used to refer to built-in functions. Could involve redirecting `all`/`any` to custom handlers, indirectly related.",
            "Creates placeholders for formatted explanations. Indirectly affects how results are shown, not `all/any` logic per se.",
            "Manages format context stacks, ensuring explanations are consistent. Indirectly relevant if creating elaborate error messages.",
            "Pulls from formatting contexts to create messages. Useful if extending how failures in `all`/`any` are explained.",
            "A minimal visitor for nodes not deeply custom-handled. If `all`/`any` don't get special handling, may default here.",
            "The core method for rewriting assertions. Will need to specifically enhance this to handle `all`/`any` cases as described in the issue.",
            "Warns on `None` in assertions. Indirect, but shows how AST nodes can trigger warnings, which might inspire similar checks for `all`/`any`.",
            "Deals with individual names, formatting them for output. Indirectly useful for error message enhancement.",
            "Rewrites boolean operations in assertions, indirectly related by showcasing how complex operations get expanded for better reporting.",
            "Handles unary operations, unrelated to `all`/`any`.",
            "Handles binary operations in asserts. Related conceptually but not for `all`/`any` unrolling.",
            "Processes function calls, crucial for addressing `all`/`any` unrolling to check iterable entries.",
            "Handles starred arguments in calls, enlightening approach but peripheral here.",
            "Legacy support for calls pre-Python 3.5, ensures old call styles are handled too.",
            "Visits attributes, explaining them. Indirect unless attributes factor hugely into `all`/`any`.",
            "Compares values, necessary for asserts as they often form conditions within or around `all`/`any`.",
            "Implementation here addresses specialized compare assertions. Could be leveraged to differentiate `all`/`any` comparisons."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/assertion/rewrite.py"
        ],
        "symbols": [
          "_pytest.assertion.AssertionRewriter.visit_Assert",
          "_pytest.assertion.AssertionRewriter.visit_Call_35"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_assertrepr_compare": {
            "name": "_pytest.assertion.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "n is not None:\n                        explanation.",
            "start_line": 154,
            "start_column": 5119,
            "end_line": 0,
            "end_column": 5170,
            "start_byte": 5119,
            "end_byte": 0
          },
          "_pytest.assertion.isiterable": {
            "name": "_pytest.assertion.isiterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def isiterable(obj):\n    try:\n        iter(obj)\n        return not istext(obj)\n    except TypeError:\n        return False",
            "start_line": 129,
            "start_column": 3518,
            "end_line": 0,
            "end_column": 3639,
            "start_byte": 3518,
            "end_byte": 0
          },
          "_pytest.assertion.assertrepr_compare": {
            "name": "_pytest.assertion.assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def assertrepr_compare(config, op, left, right):\n    \"\"\"Return specialised explanations for some operators/operands\"\"\"\n    width = 80 - 15 - len(op) - 2  # 15 chars indentation, 1 space around op\n    left_repr = saferepr(left, maxsize=int(width // 2))\n    right_repr = saferepr(right, maxsize=width - len(left_repr))\n\n    summary = u\"%s %s %s\" % (ecu(left_repr), op, ecu(right_repr))\n\n    verbose = config.getoption(\"verbose\")\n    explanation = None\n    try:\n        if op == \"==\":\n            if istext(left) and istext(right):\n                explanation = _diff_text(left, right, verbose)\n            else:\n                if issequence(left) and issequence(right):\n                    explanation = _compare_eq_sequence(left, right, verbose)\n                elif isset(left) and isset(right):\n                    explanation = _compare_eq_set(left, right, verbose)\n                elif isdict(left) and isdict(right):\n                    explanation = _compare_eq_dict(left, right, verbose)\n                elif type(left) == type(right) and (isdatacls(left) or isattrs(left)):\n                    type_fn = (isdatacls, isattrs)\n                    explanation = _compare_eq_cls(left, right, verbose, type_fn)\n                elif verbose > 0:\n                    explanation = _compare_eq_verbose(left, right)\n                if isiterable(left) and isiterable(right):\n                    expl = _compare_eq_iterable(left, right, verbose)\n                    if explanation is not None:\n                        explanation.extend(expl)\n                    else:\n                        explanation = expl\n        elif op == \"not in\":\n            if istext(left) and istext(right):\n                explanation = _notin_text(left, right, verbose)\n    except outcomes.Exit:\n        raise\n    except Exception:\n        explanation = [\n            u\"(pytest_assertion plugin: representation of details failed.  \"\n            u\"Probably an object has a faulty __repr__.)\",\n            six.text_type(_pytest._code.ExceptionInfo.from_current()),\n        ]\n\n    if not explanation:\n        return None\n\n    return [summary] + explanation",
            "start_line": 137,
            "start_column": 3642,
            "end_line": 0,
            "end_column": 5775,
            "start_byte": 3642,
            "end_byte": 0
          },
          "_pytest.assertion._compare_eq_iterable": {
            "name": "_pytest.assertion._compare_eq_iterable",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "def _compare_eq_iterable(left, right, verbose=0):\n    if not verbose:\n        return [u\"Use -v to get the full diff\"]\n    # dynamic import to speedup pytest\n    import difflib\n\n    try:\n        left_formatting = pprint.pformat(left).splitlines()\n        right_formatting = pprint.pformat(right).splitlines()\n        explanation = [u\"Full diff:\"]\n    except Exception:\n        # hack: PrettyPrinter.pformat() in python 2 fails when formatting items that can't be sorted(), ie, calling\n        # sorted() on a list would raise. See issue #718.\n        # As a workaround, the full diff is generated by using the repr() string of each item of each container.\n        left_formatting = sorted(repr(x) for x in left)\n        right_formatting = sorted(repr(x) for x in right)\n        explanation = [u\"Full diff (fallback to calling repr on each item):\"]\n    explanation.extend(\n        line.strip() for line in difflib.ndiff(left_formatting, right_formatting)\n    )\n    return explanation",
            "start_line": 262,
            "start_column": 8366,
            "end_line": 0,
            "end_column": 9347,
            "start_byte": 8366,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_assertrepr_compare": {
            "name": "_pytest.hookspec.pytest_assertrepr_compare",
            "file_path": "src/_pytest/assertion/util.py",
            "file_content": "",
            "start_line": 475,
            "start_column": 15508,
            "end_line": 0,
            "end_column": 16001,
            "start_byte": 15508,
            "end_byte": 0
          },
          "_pytest.assertion.rewrite_asserts": {
            "name": "_pytest.assertion.rewrite_asserts",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def rewrite_asserts(mod, module_path=None, config=None):\n    \"\"\"Rewrite the assert statements in mod.\"\"\"\n    AssertionRewriter(module_path, config).run(mod)",
            "start_line": 465,
            "start_column": 17515,
            "end_line": 0,
            "end_column": 17671,
            "start_byte": 17515,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter": {
            "name": "_pytest.assertion.AssertionRewriter",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "class AssertionRewriter(ast.NodeVisitor):\n    \"\"\"Assertion rewriting implementation.\n\n    The main entrypoint is to call .run() with an ast.Module instance,\n    this will then find all the assert statements and rewrite them to\n    provide intermediate values and a detailed assertion error.  See\n    http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n    for an overview of how this works.\n\n    The entry point here is .run() which will iterate over all the\n    statements in an ast.Module and for each ast.Assert statement it\n    finds call .visit() with it.  Then .visit_Assert() takes over and\n    is responsible for creating new ast statements to replace the\n    original assert statement: it rewrites the test of an assertion\n    to provide intermediate values and replace it with an if statement\n    which raises an assertion error with a detailed explanation in\n    case the expression is false.\n\n    For this .visit_Assert() uses the visitor pattern to visit all the\n    AST nodes of the ast.Assert.test field, each visit call returning\n    an AST node and the corresponding explanation string.  During this\n    state is kept in several instance attributes:\n\n    :statements: All the AST statements which will replace the assert\n       statement.\n\n    :variables: This is populated by .variable() with each variable\n       used by the statements so that they can all be set to None at\n       the end of the statements.\n\n    :variable_counter: Counter to create new unique variables needed\n       by statements.  Variables are created using .variable() and\n       have the form of \"@py_assert0\".\n\n    :on_failure: The AST statements which will be executed if the\n       assertion test fails.  This is the code which will construct\n       the failure message and raises the AssertionError.\n\n    :explanation_specifiers: A dict filled by .explanation_param()\n       with %-formatting placeholders and their corresponding\n       expressions to use in the building of an assertion message.\n       This is used by .pop_format_context() to build a message.\n\n    :stack: A stack of the explanation_specifiers dicts maintained by\n       .push_format_context() and .pop_format_context() which allows\n       to build another %-formatted string while already building one.\n\n    This state is reset on every new assert statement visited and used\n    by the other visitors.\n\n    \"\"\"\n\n    def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config\n\n    def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)\n\n    @staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring\n\n    def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name\n\n    def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())\n\n    def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)\n\n    def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])\n\n    def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())\n\n    def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"\n\n    def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)\n\n    def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())\n\n    def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))\n\n    def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements\n\n    def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])\n\n    def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)\n\n    def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n\n    def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)\n\n    def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation\n\n    def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl\n\n    def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl\n\n    # ast.Call signature changed on 3.5,\n    # conditionally change  which methods is named\n    # visit_Call depending on Python version\n    if sys.version_info >= (3, 5):\n        visit_Call = visit_Call_35\n    else:\n        visit_Call = visit_Call_legacy\n\n    def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl\n\n    def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 607,
            "start_column": 21534,
            "end_line": 0,
            "end_column": 41271,
            "start_byte": 21534,
            "end_byte": 0
          },
          "_pytest.assertion.AssertionRewriter.__init__": {
            "name": "_pytest.assertion.AssertionRewriter.__init__",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def __init__(self, module_path, config):\n        super(AssertionRewriter, self).__init__()\n        self.module_path = module_path\n        self.config = config",
            "start_line": 659,
            "start_column": 23944,
            "end_line": 4,
            "end_column": 24102,
            "start_byte": 23944,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.run": {
            "name": "_pytest.assertion.AssertionRewriter.run",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def run(self, mod):\n        \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n        if not mod.body:\n            # Nothing to do.\n            return\n        # Insert some special imports at the top of the module but after any\n        # docstrings and __future__ imports.\n        aliases = [\n            ast.alias(six.moves.builtins.__name__, \"@py_builtins\"),\n            ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n        ]\n        doc = getattr(mod, \"docstring\", None)\n        expect_docstring = doc is None\n        if doc is not None and self.is_rewrite_disabled(doc):\n            return\n        pos = 0\n        lineno = 1\n        for item in mod.body:\n            if (\n                expect_docstring\n                and isinstance(item, ast.Expr)\n                and isinstance(item.value, ast.Str)\n            ):\n                doc = item.value.s\n                if self.is_rewrite_disabled(doc):\n                    return\n                expect_docstring = False\n            elif (\n                not isinstance(item, ast.ImportFrom)\n                or item.level > 0\n                or item.module != \"__future__\"\n            ):\n                lineno = item.lineno\n                break\n            pos += 1\n        else:\n            lineno = item.lineno\n        imports = [\n            ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n        ]\n        mod.body[pos:pos] = imports\n        # Collect asserts.\n        nodes = [mod]\n        while nodes:\n            node = nodes.pop()\n            for name, field in ast.iter_fields(node):\n                if isinstance(field, list):\n                    new = []\n                    for i, child in enumerate(field):\n                        if isinstance(child, ast.Assert):\n                            # Transform assert.\n                            new.extend(self.visit(child))\n                        else:\n                            new.append(child)\n                            if isinstance(child, ast.AST):\n                                nodes.append(child)\n                    setattr(node, name, new)\n                elif (\n                    isinstance(field, ast.AST)\n                    # Don't recurse into expressions as they can't contain\n                    # asserts.\n                    and not isinstance(field, ast.expr)\n                ):\n                    nodes.append(field)",
            "start_line": 664,
            "start_column": 24108,
            "end_line": 4,
            "end_column": 26514,
            "start_byte": 24108,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.is_rewrite_disabled": {
            "name": "_pytest.assertion.AssertionRewriter.is_rewrite_disabled",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "@staticmethod\n    def is_rewrite_disabled(docstring):\n        return \"PYTEST_DONT_REWRITE\" in docstring",
            "start_line": 729,
            "start_column": 26520,
            "end_line": 4,
            "end_column": 26623,
            "start_byte": 26520,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.variable": {
            "name": "_pytest.assertion.AssertionRewriter.variable",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def variable(self):\n        \"\"\"Get a new variable.\"\"\"\n        # Use a character invalid in python identifiers to avoid clashing.\n        name = \"@py_assert\" + str(next(self.variable_counter))\n        self.variables.append(name)\n        return name",
            "start_line": 733,
            "start_column": 26629,
            "end_line": 4,
            "end_column": 26876,
            "start_byte": 26629,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.assign": {
            "name": "_pytest.assertion.AssertionRewriter.assign",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def assign(self, expr):\n        \"\"\"Give *expr* a name.\"\"\"\n        name = self.variable()\n        self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n        return ast.Name(name, ast.Load())",
            "start_line": 740,
            "start_column": 26882,
            "end_line": 4,
            "end_column": 27092,
            "start_byte": 26882,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.display": {
            "name": "_pytest.assertion.AssertionRewriter.display",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def display(self, expr):\n        \"\"\"Call saferepr on the expression.\"\"\"\n        return self.helper(\"_saferepr\", expr)",
            "start_line": 746,
            "start_column": 27098,
            "end_line": 4,
            "end_column": 27215,
            "start_byte": 27098,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.helper": {
            "name": "_pytest.assertion.AssertionRewriter.helper",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def helper(self, name, *args):\n        \"\"\"Call a helper in this module.\"\"\"\n        py_name = ast.Name(\"@pytest_ar\", ast.Load())\n        attr = ast.Attribute(py_name, name, ast.Load())\n        return ast_Call(attr, list(args), [])",
            "start_line": 750,
            "start_column": 27221,
            "end_line": 4,
            "end_column": 27450,
            "start_byte": 27221,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.builtin": {
            "name": "_pytest.assertion.AssertionRewriter.builtin",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def builtin(self, name):\n        \"\"\"Return the builtin called *name*.\"\"\"\n        builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n        return ast.Attribute(builtin_name, name, ast.Load())",
            "start_line": 756,
            "start_column": 27456,
            "end_line": 4,
            "end_column": 27649,
            "start_byte": 27456,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.explanation_param": {
            "name": "_pytest.assertion.AssertionRewriter.explanation_param",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def explanation_param(self, expr):\n        \"\"\"Return a new named %-formatting placeholder for expr.\n\n        This creates a %-formatting placeholder for expr in the\n        current formatting context, e.g. ``%(py0)s``.  The placeholder\n        and expr are placed in the current format context so that it\n        can be used on the next call to .pop_format_context().\n\n        \"\"\"\n        specifier = \"py\" + str(next(self.variable_counter))\n        self.explanation_specifiers[specifier] = expr\n        return \"%(\" + specifier + \")s\"",
            "start_line": 761,
            "start_column": 27655,
            "end_line": 4,
            "end_column": 28188,
            "start_byte": 27655,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.push_format_context": {
            "name": "_pytest.assertion.AssertionRewriter.push_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def push_format_context(self):\n        \"\"\"Create a new formatting context.\n\n        The format context is used for when an explanation wants to\n        have a variable value formatted in the assertion message.  In\n        this case the value required can be added using\n        .explanation_param().  Finally .pop_format_context() is used\n        to format a string of %-formatted values as added by\n        .explanation_param().\n\n        \"\"\"\n        self.explanation_specifiers = {}\n        self.stack.append(self.explanation_specifiers)",
            "start_line": 774,
            "start_column": 28194,
            "end_line": 4,
            "end_column": 28732,
            "start_byte": 28194,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.pop_format_context": {
            "name": "_pytest.assertion.AssertionRewriter.pop_format_context",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def pop_format_context(self, expl_expr):\n        \"\"\"Format the %-formatted string with current format context.\n\n        The expl_expr should be an ast.Str instance constructed from\n        the %-placeholders created by .explanation_param().  This will\n        add the required code to format said string to .on_failure and\n        return the ast.Name instance of the formatted string.\n\n        \"\"\"\n        current = self.stack.pop()\n        if self.stack:\n            self.explanation_specifiers = self.stack[-1]\n        keys = [ast.Str(key) for key in current.keys()]\n        format_dict = ast.Dict(keys, list(current.values()))\n        form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n        name = \"@py_format\" + str(next(self.variable_counter))\n        self.on_failure.append(ast.Assign([ast.Name(name, ast.Store())], form))\n        return ast.Name(name, ast.Load())",
            "start_line": 788,
            "start_column": 28738,
            "end_line": 4,
            "end_column": 29612,
            "start_byte": 28738,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.generic_visit": {
            "name": "_pytest.assertion.AssertionRewriter.generic_visit",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def generic_visit(self, node):\n        \"\"\"Handle expressions we don't have custom code for.\"\"\"\n        assert isinstance(node, ast.expr)\n        res = self.assign(node)\n        return res, self.explanation_param(self.display(res))",
            "start_line": 807,
            "start_column": 29618,
            "end_line": 4,
            "end_column": 29848,
            "start_byte": 29618,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Assert": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Assert",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Assert(self, assert_):\n        \"\"\"Return the AST statements to replace the ast.Assert instance.\n\n        This rewrites the test of an assertion to provide\n        intermediate values and replace it with an if statement which\n        raises an assertion error with a detailed explanation in case\n        the expression is false.\n\n        \"\"\"\n        if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n            from _pytest.warning_types import PytestAssertRewriteWarning\n            import warnings\n\n            warnings.warn_explicit(\n                PytestAssertRewriteWarning(\n                    \"assertion is always true, perhaps remove parentheses?\"\n                ),\n                category=None,\n                filename=str(self.module_path),\n                lineno=assert_.lineno,\n            )\n\n        self.statements = []\n        self.variables = []\n        self.variable_counter = itertools.count()\n        self.stack = []\n        self.on_failure = []\n        self.push_format_context()\n        # Rewrite assert into a bunch of statements.\n        top_condition, explanation = self.visit(assert_.test)\n        # If in a test module, check if directly asserting None, in order to warn [Issue #3191]\n        if self.module_path is not None:\n            self.statements.append(\n                self.warn_about_none_ast(\n                    top_condition, module_path=self.module_path, lineno=assert_.lineno\n                )\n            )\n        # Create failure message.\n        body = self.on_failure\n        negation = ast.UnaryOp(ast.Not(), top_condition)\n        self.statements.append(ast.If(negation, body, []))\n        if assert_.msg:\n            assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n            explanation = \"\\n>assert \" + explanation\n        else:\n            assertmsg = ast.Str(\"\")\n            explanation = \"assert \" + explanation\n        template = ast.BinOp(assertmsg, ast.Add(), ast.Str(explanation))\n        msg = self.pop_format_context(template)\n        fmt = self.helper(\"_format_explanation\", msg)\n        err_name = ast.Name(\"AssertionError\", ast.Load())\n        exc = ast_Call(err_name, [fmt], [])\n        if sys.version_info[0] >= 3:\n            raise_ = ast.Raise(exc, None)\n        else:\n            raise_ = ast.Raise(exc, None, None)\n        body.append(raise_)\n        # Clear temporary variables by setting them to None.\n        if self.variables:\n            variables = [ast.Name(name, ast.Store()) for name in self.variables]\n            clear = ast.Assign(variables, _NameConstant(None))\n            self.statements.append(clear)\n        # Fix line numbers.\n        for stmt in self.statements:\n            set_location(stmt, assert_.lineno, assert_.col_offset)\n        return self.statements",
            "start_line": 813,
            "start_column": 29854,
            "end_line": 4,
            "end_column": 32649,
            "start_byte": 29854,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.warn_about_none_ast": {
            "name": "_pytest.assertion.AssertionRewriter.warn_about_none_ast",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def warn_about_none_ast(self, node, module_path, lineno):\n        \"\"\"\n        Returns an AST issuing a warning if the value of node is `None`.\n        This is used to warn the user when asserting a function that asserts\n        internally already.\n        See issue #3191 for more details.\n        \"\"\"\n\n        # Using parse because it is different between py2 and py3.\n        AST_NONE = ast.parse(\"None\").body[0].value\n        val_is_none = ast.Compare(node, [ast.Is()], [AST_NONE])\n        send_warning = ast.parse(\n            \"\"\"\nfrom _pytest.warning_types import PytestAssertRewriteWarning\nfrom warnings import warn_explicit\nwarn_explicit(\n    PytestAssertRewriteWarning('asserting the value None, please use \"assert is None\"'),\n    category=None,\n    filename={filename!r},\n    lineno={lineno},\n)\n            \"\"\".format(\n                filename=module_path.strpath, lineno=lineno\n            )\n        ).body\n        return ast.If(val_is_none, send_warning, [])",
            "start_line": 880,
            "start_column": 32655,
            "end_line": 4,
            "end_column": 33624,
            "start_byte": 32655,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Name": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Name",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Name(self, name):\n        # Display the repr of the name if it's a local variable or\n        # _should_repr_global_name() thinks it's acceptable.\n        locs = ast_Call(self.builtin(\"locals\"), [], [])\n        inlocs = ast.Compare(ast.Str(name.id), [ast.In()], [locs])\n        dorepr = self.helper(\"_should_repr_global_name\", name)\n        test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n        expr = ast.IfExp(test, self.display(name), ast.Str(name.id))\n        return name, self.explanation_param(expr)",
            "start_line": 907,
            "start_column": 33630,
            "end_line": 4,
            "end_column": 34144,
            "start_byte": 33630,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_BoolOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_BoolOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BoolOp(self, boolop):\n        res_var = self.variable()\n        expl_list = self.assign(ast.List([], ast.Load()))\n        app = ast.Attribute(expl_list, \"append\", ast.Load())\n        is_or = int(isinstance(boolop.op, ast.Or))\n        body = save = self.statements\n        fail_save = self.on_failure\n        levels = len(boolop.values) - 1\n        self.push_format_context()\n        # Process each operand, short-circuting if needed.\n        for i, v in enumerate(boolop.values):\n            if i:\n                fail_inner = []\n                # cond is set in a prior loop iteration below\n                self.on_failure.append(ast.If(cond, fail_inner, []))  # noqa\n                self.on_failure = fail_inner\n            self.push_format_context()\n            res, expl = self.visit(v)\n            body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n            expl_format = self.pop_format_context(ast.Str(expl))\n            call = ast_Call(app, [expl_format], [])\n            self.on_failure.append(ast.Expr(call))\n            if i < levels:\n                cond = res\n                if is_or:\n                    cond = ast.UnaryOp(ast.Not(), cond)\n                inner = []\n                self.statements.append(ast.If(cond, inner, []))\n                self.statements = body = inner\n        self.statements = save\n        self.on_failure = fail_save\n        expl_template = self.helper(\"_format_boolop\", expl_list, ast.Num(is_or))\n        expl = self.pop_format_context(expl_template)\n        return ast.Name(res_var, ast.Load()), self.explanation_param(expl)",
            "start_line": 917,
            "start_column": 34150,
            "end_line": 4,
            "end_column": 35744,
            "start_byte": 34150,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_UnaryOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_UnaryOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_UnaryOp(self, unary):\n        pattern = unary_map[unary.op.__class__]\n        operand_res, operand_expl = self.visit(unary.operand)\n        res = self.assign(ast.UnaryOp(unary.op, operand_res))\n        return res, pattern % (operand_expl,)",
            "start_line": 952,
            "start_column": 35750,
            "end_line": 4,
            "end_column": 35999,
            "start_byte": 35750,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_BinOp": {
            "name": "_pytest.assertion.AssertionRewriter.visit_BinOp",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_BinOp(self, binop):\n        symbol = binop_map[binop.op.__class__]\n        left_expr, left_expl = self.visit(binop.left)\n        right_expr, right_expl = self.visit(binop.right)\n        explanation = \"(%s %s %s)\" % (left_expl, symbol, right_expl)\n        res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n        return res, explanation",
            "start_line": 958,
            "start_column": 36005,
            "end_line": 4,
            "end_column": 36363,
            "start_byte": 36005,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Call_35": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_35",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_35(self, call):\n        \"\"\"\n        visit `ast.Call` nodes on Python3.5 and after\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            arg_expls.append(expl)\n            new_args.append(res)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            if keyword.arg:\n                arg_expls.append(keyword.arg + \"=\" + expl)\n            else:  # **args have `arg` keywords with an .arg of None\n                arg_expls.append(\"**\" + expl)\n\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 966,
            "start_column": 36369,
            "end_line": 4,
            "end_column": 37404,
            "start_byte": 36369,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Starred": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Starred",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Starred(self, starred):\n        # From Python 3.5, a Starred node can appear in a function call\n        res, expl = self.visit(starred.value)\n        new_starred = ast.Starred(res, starred.ctx)\n        return new_starred, \"*\" + expl",
            "start_line": 993,
            "start_column": 37410,
            "end_line": 4,
            "end_column": 37652,
            "start_byte": 37410,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Call_legacy": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Call_legacy",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Call_legacy(self, call):\n        \"\"\"\n        visit `ast.Call nodes on 3.4 and below`\n        \"\"\"\n        new_func, func_expl = self.visit(call.func)\n        arg_expls = []\n        new_args = []\n        new_kwargs = []\n        new_star = new_kwarg = None\n        for arg in call.args:\n            res, expl = self.visit(arg)\n            new_args.append(res)\n            arg_expls.append(expl)\n        for keyword in call.keywords:\n            res, expl = self.visit(keyword.value)\n            new_kwargs.append(ast.keyword(keyword.arg, res))\n            arg_expls.append(keyword.arg + \"=\" + expl)\n        if call.starargs:\n            new_star, expl = self.visit(call.starargs)\n            arg_expls.append(\"*\" + expl)\n        if call.kwargs:\n            new_kwarg, expl = self.visit(call.kwargs)\n            arg_expls.append(\"**\" + expl)\n        expl = \"%s(%s)\" % (func_expl, \", \".join(arg_expls))\n        new_call = ast.Call(new_func, new_args, new_kwargs, new_star, new_kwarg)\n        res = self.assign(new_call)\n        res_expl = self.explanation_param(self.display(res))\n        outer_expl = \"%s\\n{%s = %s\\n}\" % (res_expl, res_expl, expl)\n        return res, outer_expl",
            "start_line": 999,
            "start_column": 37658,
            "end_line": 4,
            "end_column": 38842,
            "start_byte": 37658,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Attribute": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Attribute",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Attribute(self, attr):\n        if not isinstance(attr.ctx, ast.Load):\n            return self.generic_visit(attr)\n        value, value_expl = self.visit(attr.value)\n        res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n        res_expl = self.explanation_param(self.display(res))\n        pat = \"%s\\n{%s = %s.%s\\n}\"\n        expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n        return res, expl",
            "start_line": 1037,
            "start_column": 39105,
            "end_line": 4,
            "end_column": 39536,
            "start_byte": 39105,
            "end_byte": 4
          },
          "_pytest.assertion.AssertionRewriter.visit_Compare": {
            "name": "_pytest.assertion.AssertionRewriter.visit_Compare",
            "file_path": "src/_pytest/assertion/rewrite.py",
            "file_content": "def visit_Compare(self, comp):\n        self.push_format_context()\n        left_res, left_expl = self.visit(comp.left)\n        if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n            left_expl = \"({})\".format(left_expl)\n        res_variables = [self.variable() for i in range(len(comp.ops))]\n        load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n        store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n        it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n        expls = []\n        syms = []\n        results = [left_res]\n        for i, op, next_operand in it:\n            next_res, next_expl = self.visit(next_operand)\n            if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n                next_expl = \"({})\".format(next_expl)\n            results.append(next_res)\n            sym = binop_map[op.__class__]\n            syms.append(ast.Str(sym))\n            expl = \"%s %s %s\" % (left_expl, sym, next_expl)\n            expls.append(ast.Str(expl))\n            res_expr = ast.Compare(left_res, [op], [next_res])\n            self.statements.append(ast.Assign([store_names[i]], res_expr))\n            left_res, left_expl = next_res, next_expl\n        # Use pytest.assertion.util._reprcompare if that's available.\n        expl_call = self.helper(\n            \"_call_reprcompare\",\n            ast.Tuple(syms, ast.Load()),\n            ast.Tuple(load_names, ast.Load()),\n            ast.Tuple(expls, ast.Load()),\n            ast.Tuple(results, ast.Load()),\n        )\n        if len(comp.ops) > 1:\n            res = ast.BoolOp(ast.And(), load_names)\n        else:\n            res = load_names[0]\n        return res, self.explanation_param(self.pop_format_context(expl_call))",
            "start_line": 1047,
            "start_column": 39542,
            "end_line": 4,
            "end_column": 41271,
            "start_byte": 39542,
            "end_byte": 4
          }
        }
      }
    }
  ]
}