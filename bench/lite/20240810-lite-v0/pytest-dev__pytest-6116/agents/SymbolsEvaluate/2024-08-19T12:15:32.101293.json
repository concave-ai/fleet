{
  "name": "SymbolsEvaluate",
  "model": "gpt-4o-2024-08-06",
  "metadata": {
    "token_count": 0,
    "cost": 0
  },
  "issue": "<description>:pytest --collect-only needs a one char shortcut command\nI find myself needing to run `--collect-only` very often and that cli argument is a very long to type one. \r\n\r\nI do think that it would be great to allocate a character for it, not sure which one yet. Please use up/down thumbs to vote if you would find it useful or not and eventually proposing which char should be used. \r\n\r\nClearly this is a change very easy to implement but first I want to see if others would find it useful or not.\npytest --collect-only needs a one char shortcut command\nI find myself needing to run `--collect-only` very often and that cli argument is a very long to type one. \r\n\r\nI do think that it would be great to allocate a character for it, not sure which one yet. Please use up/down thumbs to vote if you would find it useful or not and eventually proposing which char should be used. \r\n\r\nClearly this is a change very easy to implement but first I want to see if others would find it useful or not.\n</description>",
  "request": {
    "related_symbols": [
      {
        "name": "_pytest.cacheprovider.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.f",
        "start_line": 359,
        "start_column": 12994,
        "end_line": 0,
        "end_column": 13152,
        "start_byte": 12994,
        "end_byte": 0
      },
      {
        "name": "_pytest.config.ConftestImportFailure",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]",
        "start_line": 52,
        "start_column": 1308,
        "end_line": 0,
        "end_column": 1548,
        "start_byte": 1308,
        "end_byte": 0
      },
      {
        "name": "_pytest.config.ConftestImportFailure.__init__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]",
        "start_line": 53,
        "start_column": 1352,
        "end_line": 4,
        "end_column": 1548,
        "start_byte": 1352,
        "end_byte": 4
      },
      {
        "name": "_pytest.config.main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def main(args=None, plugins=None) -> \"Union[int, _pytest.main.ExitCode]\":\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret = config.hook.pytest_cmdline_main(\n                    config=config\n                )  # type: Union[ExitCode, int]\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR",
        "start_line": 59,
        "start_column": 1551,
        "end_line": 0,
        "end_column": 3219,
        "start_byte": 1551,
        "end_byte": 0
      },
      {
        "name": "_pytest.config.cmdline.main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "main = staticmethod(main)",
        "start_line": 107,
        "start_column": 3268,
        "end_line": 4,
        "end_column": 3293,
        "start_byte": 3268,
        "end_byte": 4
      },
      {
        "name": "_pytest.config.PytestPluginManager.parse_hookimpl_opts",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts",
        "start_line": 285,
        "start_column": 8611,
        "end_line": 4,
        "end_column": 9762,
        "start_byte": 8611,
        "end_byte": 4
      },
      {
        "name": "_pytest.config.Config.get_terminal_writer",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw",
        "start_line": 737,
        "start_column": 25195,
        "end_line": 4,
        "end_column": 25294,
        "start_byte": 25195,
        "end_byte": 4
      },
      {
        "name": "_pytest.helpconfig.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ormat(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plu",
        "start_line": 127,
        "start_column": 3839,
        "end_line": 0,
        "end_column": 4085,
        "start_byte": 3839,
        "end_byte": 0
      },
      {
        "name": "_pytest.hookspec.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "upplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (), plugins=pl",
        "start_line": 127,
        "start_column": 4435,
        "end_line": 0,
        "end_column": 4879,
        "start_byte": 4435,
        "end_byte": 0
      },
      {
        "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only a",
        "start_line": 613,
        "start_column": 21281,
        "end_line": 4,
        "end_column": 22348,
        "start_byte": 21281,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "on\n\nimport attr\nimport py\nfrom packaging.version import Version\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\nimport _pytest._code\nimport _pytest.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom",
        "start_line": 22,
        "start_column": 487,
        "end_line": 0,
        "end_column": 966,
        "start_byte": 487,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.ExitCode.OK",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "import",
        "start_line": 32,
        "start_column": 699,
        "end_line": 4,
        "end_column": 705,
        "start_byte": 699,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode.TESTS_FAILED",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "t _pytest.hooksp",
        "start_line": 34,
        "start_column": 730,
        "end_line": 4,
        "end_column": 746,
        "start_byte": 730,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode.INTERRUPTED",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ns\nfrom .except",
        "start_line": 36,
        "start_column": 781,
        "end_line": 4,
        "end_column": 796,
        "start_byte": 781,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode.INTERNAL_ERROR",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " UsageError\nfrom .",
        "start_line": 38,
        "start_column": 841,
        "end_line": 4,
        "end_column": 859,
        "start_byte": 841,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode.USAGE_ERROR",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "p\nfrom .findpat",
        "start_line": 40,
        "start_column": 890,
        "end_line": 4,
        "end_column": 905,
        "start_byte": 890,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.ExitCode.NO_TESTS_COLLECTED",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ort ExceptionInfo\nfrom",
        "start_line": 42,
        "start_column": 944,
        "end_line": 4,
        "end_column": 966,
        "start_byte": 944,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.pytest_addoption",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.warning_types import PytestConfigWarning\n\nif False:  # TYPE_CHECKING\n    from typing import Type\n\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]\n\n\ndef main(args=None, plugins=None) -> \"Union[int, _pytest.main.ExitCode]\":\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret = config.hook.pytest_cmdline_main(\n                    config=config\n                )  # type: Union[ExitCode, int]\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"report_log\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (), plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        plugin",
        "start_line": 45,
        "start_column": 969,
        "end_line": 0,
        "end_column": 5086,
        "start_byte": 969,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.wrap_session",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclas",
        "start_line": 183,
        "start_column": 5089,
        "end_line": 0,
        "end_column": 6930,
        "start_byte": 5089,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pl",
        "start_line": 230,
        "start_column": 6933,
        "end_line": 0,
        "end_column": 7004,
        "start_byte": 6933,
        "end_byte": 0
      },
      {
        "name": "_pytest.main._main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "y.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loading during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"pytest\")\n        # The objects are mod",
        "start_line": 234,
        "start_column": 7007,
        "end_line": 0,
        "end_column": 7388,
        "start_byte": 7007,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_collection",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " objects, only used generically.\n        self._conftest_plugins = se",
        "start_line": 246,
        "start_column": 7391,
        "end_line": 0,
        "end_column": 7459,
        "start_byte": 7391,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_runtestloop",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "  # type: Set[object]\n\n        # state related to local conftest plugins\n        # Maps a py.path.local to a list of module objects.\n        self._dirpath2confmods = {}  # type: Dict[Any, List[object]]\n        # Maps a py.path.local to a module object.\n        self._conftestpath2mod = {}  # type: Dict[Any, object]\n        self._confcutdir = None\n        self._noconftest = False\n        # Set of py.path.local's.\n        self._duplicatepaths = set()  # type: Set[Any]\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err = sys.stderr\n            encoding = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=enc",
        "start_line": 250,
        "start_column": 7462,
        "end_line": 0,
        "end_column": 8204,
        "start_byte": 7462,
        "end_byte": 0
      },
      {
        "name": "_pytest.main._in_venv",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ng)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid acc",
        "start_line": 270,
        "start_column": 8207,
        "end_line": 0,
        "end_column": 8737,
        "start_byte": 8207,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_ignore_collect",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ing possibly non-readable attributes\n        # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalh",
        "start_line": 287,
        "start_column": 8740,
        "end_line": 0,
        "end_column": 9637,
        "start_byte": 8740,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_collection_modifyitems",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues",
        "start_line": 315,
        "start_column": 9640,
        "end_line": 0,
        "end_column": 10119,
        "start_byte": 9640,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.FSHookProxy",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "62\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"hist",
        "start_line": 333,
        "start_column": 10122,
        "end_line": 0,
        "end_column": 10439,
        "start_byte": 10122,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.FSHookProxy.__init__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "n_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(met",
        "start_line": 334,
        "start_column": 10145,
        "end_line": 4,
        "end_column": 10278,
        "start_byte": 10145,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.FSHookProxy.__getattr__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"hist",
        "start_line": 339,
        "start_column": 10284,
        "end_line": 4,
        "end_column": 10439,
        "start_byte": 10284,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.NoMatch",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "c\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin,",
        "start_line": 345,
        "start_column": 10442,
        "end_line": 0,
        "end_column": 10530,
        "start_byte": 10442,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.Interrupted",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "me=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                Py",
        "start_line": 349,
        "start_column": 10533,
        "end_line": 0,
        "end_column": 10655,
        "start_byte": 10533,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.Interrupted.__module__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " warnings.warn(\n       ",
        "start_line": 352,
        "start_column": 10621,
        "end_line": 4,
        "end_column": 10644,
        "start_byte": 10621,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Failed",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "tConfigWarning(\n                    \"{} plugin has been merged into the",
        "start_line": 355,
        "start_column": 10658,
        "end_line": 0,
        "end_column": 10729,
        "start_byte": 10658,
        "end_byte": 0
      },
      {
        "name": "_pytest.main._bestrelpath_cache",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "re, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n  ",
        "start_line": 359,
        "start_column": 10732,
        "end_line": 0,
        "end_column": 10931,
        "start_byte": 10732,
        "end_byte": 0
      },
      {
        "name": "_pytest.main._bestrelpath_cache.path",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "from your requir",
        "start_line": 361,
        "start_column": 10776,
        "end_line": 4,
        "end_column": 10792,
        "start_byte": 10776,
        "end_byte": 4
      },
      {
        "name": "_pytest.main._bestrelpath_cache.__missing__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": ".\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n  ",
        "start_line": 363,
        "start_column": 10798,
        "end_line": 4,
        "end_column": 10931,
        "start_byte": 10798,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "   ret = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            current.join(namespace.confcutdir, abs=True)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.realpath().parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use a resolved Path object as key to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = Path(str(conftestpath)).resolve()\n        try:\n            return self._conftestpath2mod[key]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[key] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: tuple of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        plugins = attr.ib()\n        dir = attr.ib(type=Path)\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warni",
        "start_line": 369,
        "start_column": 10934,
        "end_line": 0,
        "end_column": 24760,
        "start_byte": 10934,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.Session.Interrupted",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": ")\n        if ret:\n       ",
        "start_line": 370,
        "start_column": 10972,
        "end_line": 4,
        "end_column": 10997,
        "start_byte": 10972,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.Failed",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "self.hook.pytes",
        "start_line": 371,
        "start_column": 11002,
        "end_line": 4,
        "end_column": 11017,
        "start_byte": 11002,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._setupstate",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "gin_registered.cal",
        "start_line": 372,
        "start_column": 11022,
        "end_line": 4,
        "end_column": 11040,
        "start_byte": 11022,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.__init__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "  kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        confi",
        "start_line": 374,
        "start_column": 11066,
        "end_line": 4,
        "end_column": 11933,
        "start_byte": 11066,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.__repr__",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "nivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plug",
        "start_line": 396,
        "start_column": 11939,
        "end_line": 4,
        "end_column": 12219,
        "start_byte": 11939,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._node_location_to_relpath",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "dling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest",
        "start_line": 405,
        "start_column": 12225,
        "end_line": 4,
        "end_column": 12380,
        "start_byte": 12225,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.pytest_collectstart",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, ho",
        "start_line": 409,
        "start_column": 12386,
        "end_line": 4,
        "end_column": 12600,
        "start_byte": 12386,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.pytest_runtest_logreport",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            current.join(namespace.confcutdir, abs=True)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n    ",
        "start_line": 416,
        "start_column": 12606,
        "end_line": 4,
        "end_column": 12968,
        "start_byte": 12606,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.pytest_collectreport",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "stpaths = namespace.file_or_dir\n        foundan",
        "start_line": 424,
        "start_column": 12974,
        "end_line": 4,
        "end_column": 13021,
        "start_byte": 12974,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.isinitpath",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": " False\n        for path in testpaths:\n            path = str(path)\n  ",
        "start_line": 426,
        "start_column": 13027,
        "end_line": 4,
        "end_column": 13096,
        "start_byte": 13027,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.gethookproxy",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "    # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdi",
        "start_line": 429,
        "start_column": 13102,
        "end_line": 4,
        "end_column": 13675,
        "start_byte": 13102,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.perform_collect",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "t*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # di",
        "start_line": 443,
        "start_column": 13681,
        "end_line": 4,
        "end_column": 14149,
        "start_byte": 13681,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._perform_collect",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ies instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.realpath().parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use a resolved Path object as key to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file syste",
        "start_line": 456,
        "start_column": 14155,
        "end_line": 4,
        "end_column": 15295,
        "start_byte": 14155,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.collect",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "792)\n        key = Path(str(conftestpath)).resolve()\n        try:\n            return self._conftestpath2mod[key]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_o",
        "start_line": 487,
        "start_column": 15301,
        "end_line": 4,
        "end_column": 15856,
        "start_byte": 15301,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._collect",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[key] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.",
        "start_line": 501,
        "start_column": 15862,
        "end_line": 4,
        "end_column": 19549,
        "start_byte": 15862,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._collectfile",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "e_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        el",
        "start_line": 583,
        "start_column": 19555,
        "end_line": 4,
        "end_column": 20389,
        "start_byte": 19555,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._recurse",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "          mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        ",
        "start_line": 605,
        "start_column": 20395,
        "end_line": 4,
        "end_column": 20891,
        "start_byte": 20395,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._visit_filter",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "nstance(specs, str):\n            specs = specs.split(\",\") if specs els",
        "start_line": 618,
        "start_column": 20897,
        "end_line": 4,
        "end_column": 20967,
        "start_byte": 20897,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._tryconvertpyarg",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "       if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn",
        "start_line": 622,
        "start_column": 20973,
        "end_line": 4,
        "end_column": 21577,
        "start_byte": 20973,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._parsearg",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the par",
        "start_line": 638,
        "start_column": 21583,
        "end_line": 4,
        "end_column": 22247,
        "start_byte": 21583,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.matchnodes",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "s regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: tuple of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:",
        "start_line": 654,
        "start_column": 22253,
        "end_line": 4,
        "end_column": 22637,
        "start_byte": 22253,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session._matchnodes",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "   \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        plugins = attr.ib()\n        dir = attr.ib(type=Path)\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n    @",
        "start_line": 665,
        "start_column": 22643,
        "end_line": 4,
        "end_column": 24285,
        "start_byte": 22643,
        "end_byte": 4
      },
      {
        "name": "_pytest.main.Session.genitems",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "ty\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warni",
        "start_line": 702,
        "start_column": 24291,
        "end_line": 4,
        "end_column": 24760,
        "start_byte": 24291,
        "end_byte": 4
      },
      {
        "name": "_pytest.mark.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename argumen",
        "start_line": 77,
        "start_column": 2848,
        "end_line": 0,
        "end_column": 3381,
        "start_byte": 2848,
        "end_byte": 0
      },
      {
        "name": "_pytest.python.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(pat",
        "start_line": 111,
        "start_column": 3391,
        "end_line": 0,
        "end_column": 3605,
        "start_byte": 3391,
        "end_byte": 0
      },
      {
        "name": "_pytest.python._showfixtures_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "",
        "start_line": 1262,
        "start_column": 48095,
        "end_line": 0,
        "end_column": 49952,
        "start_byte": 48095,
        "end_byte": 0
      },
      {
        "name": "_pytest.setuponly.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "c_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_",
        "start_line": 74,
        "start_column": 2319,
        "end_line": 0,
        "end_column": 2454,
        "start_byte": 2319,
        "end_byte": 0
      },
      {
        "name": "_pytest.setupplan.pytest_cmdline_main",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "er\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\nimport _pytest._code\nimport _pytest.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the ",
        "start_line": 22,
        "start_column": 582,
        "end_line": 0,
        "end_column": 756,
        "start_byte": 582,
        "end_byte": 0
      },
      {
        "name": "_pytest.terminal._get_main_color",
        "file_path": "src/_pytest/config/__init__.py",
        "file_content": "TESTS WILL PASS.  Are you\"\n                \" using python -O?\"\n            )\n        else:\n            sys.stderr.write(\n                \"WARNING: assertions not in test modules or\"\n                \" plugins will be ignored\"\n                \" because assert statements are not executed \"\n                \"by the underlying Python interpreter \"\n                \"(are you using python -O?)\\n\"\n            )\n\n\ndef setns(obj, dic):\n    import pytest\n\n    for name, value in dic.items():\n        if isinstance(value, dict):\n            mod = getattr(obj, name, None)\n            if mod is None:\n                modname = \"pytest.%s\" % name\n                mod = types.ModuleType(modname)\n                sys.modules[modname] = mod\n            ",
        "start_line": 1082,
        "start_column": 38590,
        "end_line": 0,
        "end_column": 39328,
        "start_byte": 38590,
        "end_byte": 0
      },
      {
        "name": "_pytest.assertion.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "----------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
        "start_line": 11,
        "start_column": 229,
        "end_line": 0,
        "end_column": 1052,
        "start_byte": 229,
        "end_byte": 0
      },
      {
        "name": "_pytest.cacheprovider.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytes",
        "start_line": 301,
        "start_column": 11226,
        "end_line": 0,
        "end_column": 12991,
        "start_byte": 11226,
        "end_byte": 0
      },
      {
        "name": "_pytest.capture.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "-----------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a n",
        "start_line": 19,
        "start_column": 345,
        "end_line": 0,
        "end_column": 824,
        "start_byte": 345,
        "end_byte": 0
      },
      {
        "name": "_pytest.debugging.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "cs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginn",
        "start_line": 21,
        "start_column": 539,
        "end_line": 0,
        "end_column": 1237,
        "start_byte": 539,
        "end_byte": 0
      },
      {
        "name": "_pytest.doctest.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "t directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and ",
        "start_line": 50,
        "start_column": 1390,
        "end_line": 0,
        "end_column": 2808,
        "start_byte": 1390,
        "end_byte": 0
      },
      {
        "name": "_pytest.faulthandler.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "ked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# --------------",
        "start_line": 7,
        "start_column": 48,
        "end_line": 0,
        "end_column": 303,
        "start_byte": 48,
        "end_byte": 0
      },
      {
        "name": "_pytest.fixtures.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "",
        "start_line": 1190,
        "start_column": 44317,
        "end_line": 0,
        "end_column": 44505,
        "start_byte": 44317,
        "end_byte": 0
      },
      {
        "name": "_pytest.helpconfig.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "le options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attr",
        "start_line": 38,
        "start_column": 1168,
        "end_line": 0,
        "end_column": 2482,
        "start_byte": 1168,
        "end_byte": 0
      },
      {
        "name": "_pytest.hookspec.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"",
        "start_line": 36,
        "start_column": 1070,
        "end_line": 0,
        "end_column": 2624,
        "start_byte": 1070,
        "end_byte": 0
      },
      {
        "name": "_pytest.junitxml.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "elating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\" called after fixture teardown, but before the cache is cleared so\n    the fixture result cache ``fixturedef.cached_result`` can\n    still be accessed.\"\"\"\n\n\n# -------------------------------------------------",
        "start_line": 382,
        "start_column": 12558,
        "end_line": 0,
        "end_column": 13941,
        "start_byte": 12558,
        "end_byte": 0
      },
      {
        "name": "_pytest.logging.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "onfig.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or N",
        "start_line": 171,
        "start_column": 6052,
        "end_line": 0,
        "end_column": 8708,
        "start_byte": 6052,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not ",
        "start_line": 45,
        "start_column": 969,
        "end_line": 0,
        "end_column": 5086,
        "start_byte": 969,
        "end_byte": 0
      },
      {
        "name": "_pytest.mark.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "on should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after comma",
        "start_line": 36,
        "start_column": 1291,
        "end_line": 0,
        "end_column": 2845,
        "start_byte": 1291,
        "end_byte": 0
      },
      {
        "name": "_pytest.pastebin.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"ca",
        "start_line": 6,
        "start_column": 107,
        "end_line": 0,
        "end_column": 435,
        "start_byte": 107,
        "end_byte": 0
      },
      {
        "name": "_pytest.pytester.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": " pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_p",
        "start_line": 46,
        "start_column": 1098,
        "end_line": 0,
        "end_column": 1709,
        "start_byte": 1098,
        "end_byte": 0
      },
      {
        "name": "_pytest.python.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "t.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult",
        "start_line": 56,
        "start_column": 1713,
        "end_line": 0,
        "end_column": 3388,
        "start_byte": 1713,
        "end_byte": 0
      },
      {
        "name": "_pytest.runner.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPlugin",
        "start_line": 29,
        "start_column": 633,
        "end_line": 0,
        "end_column": 945,
        "start_byte": 633,
        "end_byte": 0
      },
      {
        "name": "_pytest.setuponly.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(plugi",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 415,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.setupplan.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ----",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 293,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.skipping.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "nitialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=",
        "start_line": 8,
        "start_column": 243,
        "end_line": 0,
        "end_column": 723,
        "start_byte": 243,
        "end_byte": 0
      },
      {
        "name": "_pytest.stepwise.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow ad",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 479,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.terminal.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecate",
        "start_line": 56,
        "start_column": 1402,
        "end_line": 0,
        "end_column": 4066,
        "start_byte": 1402,
        "end_byte": 0
      },
      {
        "name": "_pytest.warnings.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "lugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plug",
        "start_line": 31,
        "start_column": 870,
        "end_line": 0,
        "end_column": 1328,
        "start_byte": 870,
        "end_byte": 0
      },
      {
        "name": "_pytest.report_log.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "om main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ------------------------------------------------------------------",
        "start_line": 6,
        "start_column": 54,
        "end_line": 0,
        "end_column": 355,
        "start_byte": 54,
        "end_byte": 0
      },
      {
        "name": "_pytest.resultlog.pytest_addoption",
        "file_path": "src/_pytest/hookspec.py",
        "file_content": "rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager",
        "start_line": 8,
        "start_column": 107,
        "end_line": 0,
        "end_column": 423,
        "start_byte": 107,
        "end_byte": 0
      }
    ],
    "root_caused_symbols": [
      {
        "name": "_pytest.assertion.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"",
        "start_line": 11,
        "start_column": 229,
        "end_line": 0,
        "end_column": 1052,
        "start_byte": 229,
        "end_byte": 0
      },
      {
        "name": "_pytest.cacheprovider.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep",
        "start_line": 301,
        "start_column": 11226,
        "end_line": 0,
        "end_column": 12991,
        "start_byte": 11226,
        "end_byte": 0
      },
      {
        "name": "_pytest.capture.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go",
        "start_line": 19,
        "start_column": 345,
        "end_line": 0,
        "end_column": 824,
        "start_byte": 345,
        "end_byte": 0
      },
      {
        "name": "_pytest.debugging.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t",
        "start_line": 21,
        "start_column": 539,
        "end_line": 0,
        "end_column": 1237,
        "start_byte": 539,
        "end_byte": 0
      },
      {
        "name": "_pytest.doctest.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": " default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol",
        "start_line": 50,
        "start_column": 1390,
        "end_line": 0,
        "end_column": 2808,
        "start_byte": 1390,
        "end_byte": 0
      },
      {
        "name": "_pytest.faulthandler.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": ", session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py",
        "start_line": 7,
        "start_column": 48,
        "end_line": 0,
        "end_column": 303,
        "start_byte": 48,
        "end_byte": 0
      },
      {
        "name": "_pytest.fixtures.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "",
        "start_line": 1190,
        "start_column": 44317,
        "end_line": 0,
        "end_column": 44505,
        "start_byte": 44317,
        "end_byte": 0
      },
      {
        "name": "_pytest.helpconfig.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_",
        "start_line": 38,
        "start_column": 1168,
        "end_line": 0,
        "end_column": 2482,
        "start_byte": 1168,
        "end_byte": 0
      },
      {
        "name": "_pytest.hookspec.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": " to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n",
        "start_line": 36,
        "start_column": 1070,
        "end_line": 0,
        "end_column": 2624,
        "start_byte": 1070,
        "end_byte": 0
      },
      {
        "name": "_pytest.junitxml.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  ",
        "start_line": 382,
        "start_column": 12558,
        "end_line": 0,
        "end_column": 13941,
        "start_byte": 12558,
        "end_byte": 0
      },
      {
        "name": "_pytest.logging.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo",
        "start_line": 171,
        "start_column": 6052,
        "end_line": 0,
        "end_column": 8708,
        "start_byte": 6052,
        "end_byte": 0
      },
      {
        "name": "_pytest.main.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )",
        "start_line": 45,
        "start_column": 969,
        "end_line": 0,
        "end_column": 5086,
        "start_byte": 969,
        "end_byte": 0
      },
      {
        "name": "_pytest.mark.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path",
        "start_line": 36,
        "start_column": 1291,
        "end_line": 0,
        "end_column": 2845,
        "start_byte": 1291,
        "end_byte": 0
      },
      {
        "name": "_pytest.pastebin.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle",
        "start_line": 6,
        "start_column": 107,
        "end_line": 0,
        "end_column": 435,
        "start_byte": 107,
        "end_byte": 0
      },
      {
        "name": "_pytest.pytester.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       ",
        "start_line": 46,
        "start_column": 1098,
        "end_line": 0,
        "end_column": 1709,
        "start_byte": 1098,
        "end_byte": 0
      },
      {
        "name": "_pytest.python.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle",
        "start_line": 56,
        "start_column": 1713,
        "end_line": 0,
        "end_column": 3388,
        "start_byte": 1713,
        "end_byte": 0
      },
      {
        "name": "_pytest.runner.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N",
        "start_line": 29,
        "start_column": 633,
        "end_line": 0,
        "end_column": 945,
        "start_byte": 633,
        "end_byte": 0
      },
      {
        "name": "_pytest.setuponly.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 415,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.setupplan.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 293,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.skipping.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail",
        "start_line": 8,
        "start_column": 243,
        "end_line": 0,
        "end_column": 723,
        "start_byte": 243,
        "end_byte": 0
      },
      {
        "name": "_pytest.stepwise.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup",
        "start_line": 3,
        "start_column": 16,
        "end_line": 0,
        "end_column": 479,
        "start_byte": 16,
        "end_byte": 0
      },
      {
        "name": "_pytest.terminal.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel",
        "start_line": 56,
        "start_column": 1402,
        "end_line": 0,
        "end_column": 4066,
        "start_byte": 1402,
        "end_byte": 0
      },
      {
        "name": "_pytest.warnings.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given ",
        "start_line": 31,
        "start_column": 870,
        "end_line": 0,
        "end_column": 1328,
        "start_byte": 870,
        "end_byte": 0
      },
      {
        "name": "_pytest.report_log.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo",
        "start_line": 6,
        "start_column": 54,
        "end_line": 0,
        "end_column": 355,
        "start_byte": 54,
        "end_byte": 0
      },
      {
        "name": "_pytest.resultlog.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "file_content": "ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner ",
        "start_line": 8,
        "start_column": 107,
        "end_line": 0,
        "end_column": 423,
        "start_byte": 107,
        "end_byte": 0
      }
    ]
  },
  "response": {
    "scratch_pad": "1. Analyze User Instructions:\n- The issue is the need for a shorter form (a single-character shortcut) for the `--collect-only` command line argument in pytest.\n- This is likely caused by the current argument being long and cumbersome to type frequently.\n- The expected result is a shorter, more convenient command to achieve the same functionality as `--collect-only`.\n- The ideal resolution would be allowing users to achieve the collect-only behavior with just a single-character option.\n\n2. Examine the Symbols Provided:\n- The symbols are related to the `pytest_addoption` function which is used to add command line options and configure pytest.\n- To achieve the desired outcome of creating a shortcut, changes or additions need to be made around where options are defined in these functions.\n- Since the main feature addition is a CLI interface addition, these pytest_addoption functions would need to be reviewed and modified accordingly.\n\n3. Determine the Relevant Symbols:\n- Since the task is to add a shorter alias for an option, we can focus on the symbol(s) that are responsible for parsing or defining options.\n- The main symbol to change would be where `--collect-only` is being added, ensuring that the addition of a new shortcut option links to the same action.",
    "symbols": [
      {
        "name": "_pytest.main.pytest_addoption",
        "file_path": "src/_pytest/main.py",
        "reason": "This symbol is where the command line options are being set for pytest. To provide a new shortcut, a modification needs to include the new option here."
      }
    ],
    "more_info": [],
    "is_done": false,
    "symbols_scratch_pad": [
      "This symbol, `_pytest.assertion.pytest_addoption`, seems related to adding options, but the content is incomplete or not directly relevant to collect-only functionality.",
      "The content seems to be part of an internal implementation related to test collection and running (like fail cases, not adding/changing options).",
      "This is partial and likely irrelevant as it doesn't show option handling for collection or CLI adjustments.",
      "Again, partial content, not related to CLI configurations.",
      "Content incomplete, probably doesn't help in finding where to add CLI shortcuts.",
      "The start of an option is viewable but cut off; looks like a continuation of command setup where the focus could be around.",
      "Various parts repeat without full context, can't determine CLI option setup from this portion alone.",
      "This portion doesn't seem relevant as it includes logic related to handling test logs rather than option setup.",
      "Involved with handling session or logging, no context for CLI options noted in this part.",
      "This symbol is irrelevant as it doesn't contain CLI setup, partial parts of another context unrelated directly.",
      "Too fragmented to determine importance, no CLI handling seen.",
      "These fragments do not show context for CLI options or addition points for a collector only shortcut.",
      "This has context needed: shows where CLI options are set. Add 'c' or similar here for new shortcut.",
      "Part of logging perhaps, session management... not directly impactful for CLI.",
      "Description hints at plugins or session, which isn't the target of modification.",
      "Once again command line setup pertinent to collection show here - partial overlaps, continue exploration and correlation needed.",
      "Shows where help config and terminal might set options -- seems like it is a culminating area for adding commands.",
      "This main holding the do_configure segment strongly implies relevant intercept for config, though scattered.",
      "CLI involvement and framework plugin setup here; logic known might be referenced in modification. ",
      "Ultimately where code paths meet is here, thus target point to intercept for mods."
    ]
  },
  "messages": [
    {
      "role": "system",
      "content": "You are an autonomous AI assistant tasked with finding relevant code in an existing \ncodebase based on a reported issue. \nYour task is base on the symbol code to identify how many symbols need to be change to resolve the issue. \n#Input Structure:\n\n* <issue>: Contains the reported issue.\n* <symbol>: the code might to be relevant to the issue.\n\n# Your Task:\n\n1. Analyze User Instructions:\nCarefully read the reported issue within the <issue> tag.\nthink step by step and write out your thoughts in the scratch_pad field.\n1.1 What issue is the user describing?\n1.2 How was this issue caused?\n1.3 If the user described the expected result, what should it be fixed to?\n1.4 If the user did not provide an expected result, what should the expectation be?\n1.5 How should the issue be fixed to meet the expectation?\n\n2. Make the evaluate:\n2.1. Thoroughly analyze each lines in the <symbol> and <symbol> tags.\n2.2. Match the symbol/code/pattern with the key elements, functions, variables, or patterns identified in the reported issue.\n2.3. Evaluate the relevance of each symbol based on how well it aligns with the reported issue and current file context.\n2.4. make the decision how many symbols need to be change to resolve the issue.\n2.5. if you need more file content or symbol information, you can ask the user for more information.\n2.6. relative symbol means, He might be the root cause of the problem, or he could be a part of the process that reproduces the issue.\n\nThink step by step and write out your thoughts in the scratch_pad field.  \n"
    },
    {
      "role": "user",
      "content": "<issue><description>:pytest --collect-only needs a one char shortcut command\nI find myself needing to run `--collect-only` very often and that cli argument is a very long to type one. \r\n\r\nI do think that it would be great to allocate a character for it, not sure which one yet. Please use up/down thumbs to vote if you would find it useful or not and eventually proposing which char should be used. \r\n\r\nClearly this is a change very easy to implement but first I want to see if others would find it useful or not.\npytest --collect-only needs a one char shortcut command\nI find myself needing to run `--collect-only` very often and that cli argument is a very long to type one. \r\n\r\nI do think that it would be great to allocate a character for it, not sure which one yet. Please use up/down thumbs to vote if you would find it useful or not and eventually proposing which char should be used. \r\n\r\nClearly this is a change very easy to implement but first I want to see if others would find it useful or not.\n</description></issue>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.assertion.pytest_addoption</name><path>src/_pytest/main.py</path><content>rom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.cacheprovider.pytest_addoption</name><path>src/_pytest/main.py</path><content>        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self._norecursepatterns = config.getini(\"norecursedirs\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._node_cache = {}\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[str, str]\n        # Dirnames of pkgs with dunder-init files.\n        self._pkg_roots = {}\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: str) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectrep</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.capture.pytest_addoption</name><path>src/_pytest/main.py</path><content>onfig import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error go</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.debugging.pytest_addoption</name><path>src/_pytest/main.py</path><content>added:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"t</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.doctest.pytest_addoption</name><path>src/_pytest/main.py</path><content> default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absol</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.faulthandler.pytest_addoption</name><path>src/_pytest/main.py</path><content>, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _py</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.fixtures.pytest_addoption</name><path>src/_pytest/main.py</path><content></content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.helpconfig.pytest_addoption</name><path>src/_pytest/main.py</path><content>rcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.hookspec.pytest_addoption</name><path>src/_pytest/main.py</path><content> to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.junitxml.pytest_addoption</name><path>src/_pytest/main.py</path><content>   raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(fspath)\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(fspath, pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n  </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.logging.pytest_addoption</name><path>src/_pytest/main.py</path><content>r.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            config.notify_exception(excinfo, config.option)\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            if excinfo.errisinstance(SystemExit):\n                sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        excinfo = None  # Explicitly break reference cycle.\n        session.startdir.chdir()\n        if initstate >= 2:\n            config.hook.pytest_sessionfinish(\n                session=session, exitstatus=session.exitstatus\n            )\n        config._ensure_unconfigure()\n    return session.exitstatus\n\n\ndef pytest_cmdline_main(config):\n    return wrap_session(config, _main)\n\n\ndef _main(config, session):\n    \"\"\" default command line protocol for initialization, session,\n    running tests and reporting. \"\"\"\n    config.hook.pytest_collection(session=session)\n    config.hook.pytest_runtestloop(session=session)\n\n    if session.testsfailed:\n        return ExitCode.TESTS_FAILED\n    elif session.testscollected == 0:\n        return ExitCode.NO_TESTS_COLLECTED\n\n\ndef pytest_collection(session):\n    return session.perform_collect()\n\n\ndef pytest_runtestloop(session):\n    if session.testsfailed and not session.config.option.continue_on_collection_errors:\n        raise session.Interrupted(\n            \"%d error%s during collection\"\n            % (session.testsfailed, \"s\" if session.testsfailed != 1 else \"\")\n        )\n\n    if session.config.option.collectonly:\n        return True\n\n    for i, item in enumerate(session.items):\n        nextitem = session.items[i + 1] if i + 1 < len(session.items) else None\n        item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)\n        if session.shouldfail:\n            raise session.Failed(session.shouldfail)\n        if session.shouldstop:\n            raise session.Interrupted(session.shouldstop)\n    return True\n\n\ndef _in_venv(path):\n    \"\"\"Attempts to detect if ``path`` is the root of a Virtual Environment by\n    checking for the existence of the appropriate activate script\"\"\"\n    bindir = path.join(\"Scripts\" if sys.platform.startswith(\"win\") else \"bin\")\n    if not bindir.isdir():\n        return False\n    activates = (\n        \"activate\",\n        \"activate.csh\",\n        \"activate.fish\",\n        \"Activate\",\n        \"Activate.bat\",\n        \"Activate.ps1\",\n    )\n    return any([fname.basename in activates fo</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_addoption</name><path>src/_pytest/main.py</path><content>def pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        help=\"only load conftest.py's relative to specified dir.\",\n    )\n    group.addoption(\n        \"--noconftest\",\n        action=\"store_true\",\n        dest=\"noconftest\",\n        default=False,\n        help=\"Don't load any conftest.py files.\",\n    )\n    group.addoption(\n        \"--keepduplicates\",\n        \"--keep-duplicates\",\n        action=\"store_true\",\n        dest=\"keepduplicates\",\n        default=False,\n        help=\"Keep duplicate tests.\",\n    )\n    group.addoption(\n        \"--collect-in-virtualenv\",\n        action=\"store_true\",\n        dest=\"collect_in_virtualenv\",\n        default=False,\n        help=\"Don't ignore tests in a local virtualenv directory\",\n    )\n\n    group = parser.getgroup(\"debugconfig\", \"test session debugging and configuration\")\n    group.addoption(\n        \"--basetemp\",\n        dest=\"basetemp\",\n        default=None,\n        metavar=\"dir\",\n        help=(\n            \"base temporary directory for this test run.\"\n            \"(warning: this directory is removed if it exists)\"\n        ),\n    )</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.mark.pytest_addoption</name><path>src/_pytest/main.py</path><content>en no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.pastebin.pytest_addoption</name><path>src/_pytest/main.py</path><content>ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import colle</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.pytester.pytest_addoption</name><path>src/_pytest/main.py</path><content>      type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given in the \"\n        \"command line.\",\n        type=\"args\",\n        default=[],\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n       </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.python.pytest_addoption</name><path>src/_pytest/main.py</path><content>maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during colle</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.runner.pytest_addoption</name><path>src/_pytest/main.py</path><content>supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests failed\n    TESTS_FAILED = 1\n    #: pytest was interrupted\n    INTERRUPTED = 2\n    #: an internal error got in the way\n    INTERNAL_ERROR = 3\n    #: pytest was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    N</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setuponly.pytest_addoption</name><path>src/_pytest/main.py</path><content>ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setupplan.pytest_addoption</name><path>src/_pytest/main.py</path><content>ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_ar</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.skipping.pytest_addoption</name><path>src/_pytest/main.py</path><content>port nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import SetupState\n\n\nclass ExitCode(enum.IntEnum):\n    \"\"\"\n    .. versionadded:: 5.0\n\n    Encodes the valid exit codes by pytest.\n\n    Currently users and plugins may supply other exit codes as well.\n    \"\"\"\n\n    #: tests passed\n    OK = 0\n    #: tests fail</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.stepwise.pytest_addoption</name><path>src/_pytest/main.py</path><content>ntation of testing process: init, session, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner import collect_one_node\nfrom _pytest.runner import Setup</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.terminal.pytest_addoption</name><path>src/_pytest/main.py</path><content>\n    )\n    group = parser.getgroup(\"general\", \"running and selection options\")\n    group._addoption(\n        \"-x\",\n        \"--exitfirst\",\n        action=\"store_const\",\n        dest=\"maxfail\",\n        const=1,\n        help=\"exit instantly on first error or failed test.\",\n    ),\n    group._addoption(\n        \"--maxfail\",\n        metavar=\"num\",\n        action=\"store\",\n        type=int,\n        dest=\"maxfail\",\n        default=0,\n        help=\"exit after first num failures or errors.\",\n    )\n    group._addoption(\n        \"--strict-markers\",\n        \"--strict\",\n        action=\"store_true\",\n        help=\"markers not registered in the `markers` section of the configuration file raise errors.\",\n    )\n    group._addoption(\n        \"-c\",\n        metavar=\"file\",\n        type=str,\n        dest=\"inifilename\",\n        help=\"load configuration from `file` instead of trying to locate one of the implicit \"\n        \"configuration files.\",\n    )\n    group._addoption(\n        \"--continue-on-collection-errors\",\n        action=\"store_true\",\n        default=False,\n        dest=\"continue_on_collection_errors\",\n        help=\"Force test execution even if collection errors occur.\",\n    )\n    group._addoption(\n        \"--rootdir\",\n        action=\"store\",\n        dest=\"rootdir\",\n        help=\"Define root directory for tests. Can be relative path: 'root_dir', './root_dir', \"\n        \"'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: \"\n        \"'$HOME/root_dir'.\",\n    )\n\n    group = parser.getgroup(\"collect\", \"collection\")\n    group.addoption(\n        \"--collectonly\",\n        \"--collect-only\",\n        action=\"store_true\",\n        help=\"only collect tests, don't execute them.\",\n    ),\n    group.addoption(\n        \"--pyargs\",\n        action=\"store_true\",\n        help=\"try to interpret all arguments as python packages.\",\n    )\n    group.addoption(\n        \"--ignore\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--ignore-glob\",\n        action=\"append\",\n        metavar=\"path\",\n        help=\"ignore path pattern during collection (multi-allowed).\",\n    )\n    group.addoption(\n        \"--deselect\",\n        action=\"append\",\n        metavar=\"nodeid_prefix\",\n        help=\"deselect item during collection (multi-allowed).\",\n    )\n    # when changing this to --conf-cut-dir, config.py Conftest.setinitial\n    # needs upgrading as well\n    group.addoption(\n        \"--confcutdir\",\n        dest=\"confcutdir\",\n        default=None,\n        metavar=\"dir\",\n        type=functools.partial(directory_arg, optname=\"--confcutdir\"),\n        hel</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.warnings.pytest_addoption</name><path>src/_pytest/main.py</path><content>est was misused\n    USAGE_ERROR = 4\n    #: pytest couldn't find tests\n    NO_TESTS_COLLECTED = 5\n\n\ndef pytest_addoption(parser):\n    parser.addini(\n        \"norecursedirs\",\n        \"directory patterns to avoid for recursion\",\n        type=\"args\",\n        default=[\".*\", \"build\", \"dist\", \"CVS\", \"_darcs\", \"{arch}\", \"*.egg\", \"venv\"],\n    )\n    parser.addini(\n        \"testpaths\",\n        \"directories to search for tests when no files or directories are given </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.report_log.pytest_addoption</name><path>src/_pytest/main.py</path><content>ion, runtest loop. \"\"\"\nimport enum\nimport fnmatch\nimport functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config impo</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.resultlog.pytest_addoption</name><path>src/_pytest/main.py</path><content>ort functools\nimport importlib\nimport os\nimport sys\nfrom typing import Dict\n\nimport attr\nimport py\n\nimport _pytest._code\nfrom _pytest import nodes\nfrom _pytest.config import directory_arg\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.outcomes import exit\nfrom _pytest.runner </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.cacheprovider.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.f</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.ConftestImportFailure</name><path>src/_pytest/config/__init__.py</path><content>class ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.ConftestImportFailure.__init__</name><path>src/_pytest/config/__init__.py</path><content>def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.main</name><path>src/_pytest/config/__init__.py</path><content>def main(args=None, plugins=None) -> \"Union[int, _pytest.main.ExitCode]\":\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret = config.hook.pytest_cmdline_main(\n                    config=config\n                )  # type: Union[ExitCode, int]\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.cmdline.main</name><path>src/_pytest/config/__init__.py</path><content>main = staticmethod(main)</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.PytestPluginManager.parse_hookimpl_opts</name><path>src/_pytest/config/__init__.py</path><content>def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid accessing possibly non-readable attributes\n        # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.config.Config.get_terminal_writer</name><path>src/_pytest/config/__init__.py</path><content>def get_terminal_writer(self):\n        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.helpconfig.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>ormat(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plu</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.hookspec.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>upplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (), plugins=pl</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.logging.LoggingPlugin._runtest_for_main</name><path>src/_pytest/config/__init__.py</path><content>(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only a</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode</name><path>src/_pytest/config/__init__.py</path><content>on\n\nimport attr\nimport py\nfrom packaging.version import Version\nfrom pluggy import HookimplMarker\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\nimport _pytest._code\nimport _pytest.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the extension point definitions\nfrom .exceptions import PrintHelp\nfrom .exceptions import UsageError\nfrom .findpaths import determine_setup\nfrom .findpaths import exists\nfrom _pytest._code import ExceptionInfo\nfrom</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.OK</name><path>src/_pytest/config/__init__.py</path><content>import</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.TESTS_FAILED</name><path>src/_pytest/config/__init__.py</path><content>t _pytest.hooksp</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.INTERRUPTED</name><path>src/_pytest/config/__init__.py</path><content>ns\nfrom .except</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.INTERNAL_ERROR</name><path>src/_pytest/config/__init__.py</path><content> UsageError\nfrom .</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.USAGE_ERROR</name><path>src/_pytest/config/__init__.py</path><content>p\nfrom .findpat</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.ExitCode.NO_TESTS_COLLECTED</name><path>src/_pytest/config/__init__.py</path><content>ort ExceptionInfo\nfrom</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_addoption</name><path>src/_pytest/config/__init__.py</path><content>ytest._code import filter_traceback\nfrom _pytest.compat import importlib_metadata\nfrom _pytest.outcomes import fail\nfrom _pytest.outcomes import Skipped\nfrom _pytest.warning_types import PytestConfigWarning\n\nif False:  # TYPE_CHECKING\n    from typing import Type\n\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n        Exception.__init__(self, path, excinfo)\n        self.path = path\n        self.excinfo = excinfo  # type: Tuple[Type[Exception], Exception, TracebackType]\n\n\ndef main(args=None, plugins=None) -> \"Union[int, _pytest.main.ExitCode]\":\n    \"\"\" return exit code, after performing an in-process test run.\n\n    :arg args: list of command line arguments.\n\n    :arg plugins: list of plugin objects to be auto-registered during\n                  initialization.\n    \"\"\"\n    from _pytest.main import ExitCode\n\n    try:\n        try:\n            config = _prepareconfig(args, plugins)\n        except ConftestImportFailure as e:\n            exc_info = ExceptionInfo(e.excinfo)\n            tw = py.io.TerminalWriter(sys.stderr)\n            tw.line(\n                \"ImportError while loading conftest '{e.path}'.\".format(e=e), red=True\n            )\n            exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n            exc_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_info.exconly()\n            )\n            formatted_tb = str(exc_repr)\n            for line in formatted_tb.splitlines():\n                tw.line(line.rstrip(), red=True)\n            return ExitCode.USAGE_ERROR\n        else:\n            try:\n                ret = config.hook.pytest_cmdline_main(\n                    config=config\n                )  # type: Union[ExitCode, int]\n                try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename arguments.\n\n    :path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(path, optname):\n    \"\"\"Argparse type validator for directory arguments.\n\n    :path: path of directory\n    :optname: name of the option\n    \"\"\"\n    if not os.path.isdir(path):\n        raise UsageError(\"{} must be a directory, given: {}\".format(optname, path))\n    return path\n\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (  # fmt: off\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)  # fmt: on\n\ndefault_plugins = essential_plugins + (\n    \"python\",\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"report_log\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n    \"faulthandler\",\n)\n\nbuiltin_plugins = set(default_plugins)\nbuiltin_plugins.add(\"pytester\")\n\n\ndef get_config(args=None, plugins=None):\n    # subsequent calls to main will create a fresh instance\n    pluginmanager = PytestPluginManager()\n    config = Config(\n        pluginmanager,\n        invocation_params=Config.InvocationParams(\n            args=args or (), plugins=plugins, dir=Path().resolve()\n        ),\n    )\n\n    if args is not None:\n        # Handle any \"-p no:plugin\" args.\n        pluginmanager.consider_preparse(args)\n\n    for spec in default_plugins:\n        plugin</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.wrap_session</name><path>src/_pytest/config/__init__.py</path><content>ager.import_plugin(spec)\n    return config\n\n\ndef get_plugin_manager():\n    \"\"\"\n    Obtain a new instance of the\n    :py:class:`_pytest.config.PytestPluginManager`, with default plugins\n    already loaded.\n\n    This function can be used by integration with other tools, like hooking\n    into pytest to run tests into an IDE.\n    \"\"\"\n    return get_config().pluginmanager\n\n\ndef _prepareconfig(args=None, plugins=None):\n    if args is None:\n        args = sys.argv[1:]\n    elif isinstance(args, py.path.local):\n        args = [str(args)]\n    elif not isinstance(args, (tuple, list)):\n        msg = \"`args` parameter expected to be a list or tuple of strings, got: {!r} (type: {})\"\n        raise TypeError(msg.format(args, type(args)))\n\n    config = get_config(args, plugins)\n    pluginmanager = config.pluginmanager\n    try:\n        if plugins:\n            for plugin in plugins:\n                if isinstance(plugin, str):\n                    pluginmanager.consider_pluginarg(plugin)\n                else:\n                    pluginmanager.register(plugin)\n        return pluginmanager.hook.pytest_cmdline_parse(\n            pluginmanager=pluginmanager, args=args\n        )\n    except BaseException:\n        config._ensure_unconfigure()\n        raise\n\n\ndef _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):\n    msg = (\n        \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n        \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n        \"  {}\\n\"\n        \"Please move it to a top level conftest file at the rootdir:\\n\"\n        \"  {}\\n\"\n        \"For more information, visit:\\n\"\n        \"  https://docs.pytest.org/en/latest/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n    )\n    fail(msg.format(conftestpath, confcutdir), pytrace=False)\n\n\nclas</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>ytestPluginManager(PluginManager):\n    \"\"\"\n    Overwrites :py:class:`pl</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main._main</name><path>src/_pytest/config/__init__.py</path><content>y.PluginManager <pluggy.PluginManager>` to add pytest-specific\n    functionality:\n\n    * loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n      ``pytest_plugins`` global variables found in plugins being loaded;\n    * ``conftest.py`` loading during start-up;\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"pytest\")\n        # The objects are mod</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_collection</name><path>src/_pytest/config/__init__.py</path><content> objects, only used generically.\n        self._conftest_plugins = se</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_runtestloop</name><path>src/_pytest/config/__init__.py</path><content>  # type: Set[object]\n\n        # state related to local conftest plugins\n        # Maps a py.path.local to a list of module objects.\n        self._dirpath2confmods = {}  # type: Dict[Any, List[object]]\n        # Maps a py.path.local to a module object.\n        self._conftestpath2mod = {}  # type: Dict[Any, object]\n        self._confcutdir = None\n        self._noconftest = False\n        # Set of py.path.local's.\n        self._duplicatepaths = set()  # type: Set[Any]\n\n        self.add_hookspecs(_pytest.hookspec)\n        self.register(self)\n        if os.environ.get(\"PYTEST_DEBUG\"):\n            err = sys.stderr\n            encoding = getattr(err, \"encoding\", \"utf8\")\n            try:\n                err = py.io.dupfile(err, encoding=enc</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main._in_venv</name><path>src/_pytest/config/__init__.py</path><content>ng)\n            except Exception:\n                pass\n            self.trace.root.setwriter(err.write)\n            self.enable_tracing()\n\n        # Config._consider_importhook will set a real object if required.\n        self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n        # Used to know when we are importing conftests after the pytest_configure stage\n        self._configured = False\n\n    def parse_hookimpl_opts(self, plugin, name):\n        # pytest hooks are always prefixed with pytest_\n        # so we avoid acc</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_ignore_collect</name><path>src/_pytest/config/__init__.py</path><content>ing possibly non-readable attributes\n        # (see issue #1073)\n        if not name.startswith(\"pytest_\"):\n            return\n        # ignore names which can not be hooks\n        if name == \"pytest_plugins\":\n            return\n\n        method = getattr(plugin, name)\n        opts = super().parse_hookimpl_opts(plugin, name)\n\n        # consider only actual functions for hooks (#3775)\n        if not inspect.isroutine(method):\n            return\n\n        # collect unmarked hooks as long as they have the `pytest_' prefix\n        if opts is None and name.startswith(\"pytest_\"):\n            opts = {}\n        if opts is not None:\n            # TODO: DeprecationWarning, people should use hookimpl\n            # https://github.com/pytest-dev/pytest/issues/4562\n            known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n\n            for name in (\"tryfirst\", \"trylast\", \"optionalh</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_collection_modifyitems</name><path>src/_pytest/config/__init__.py</path><content>\", \"hookwrapper\"):\n                opts.setdefault(name, hasattr(method, name) or name in known_marks)\n        return opts\n\n    def parse_hookspec_opts(self, module_or_class, name):\n        opts = super().parse_hookspec_opts(module_or_class, name)\n        if opts is None:\n            method = getattr(module_or_class, name)\n\n            if name.startswith(\"pytest_\"):\n                # todo: deprecate hookspec hacks\n                # https://github.com/pytest-dev/pytest/issues</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.FSHookProxy</name><path>src/_pytest/config/__init__.py</path><content>62\n                known_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(method, \"firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"hist</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.FSHookProxy.__init__</name><path>src/_pytest/config/__init__.py</path><content>n_marks = {m.name for m in getattr(method, \"pytestmark\", [])}\n                opts = {\n                    \"firstresult\": hasattr(met</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.FSHookProxy.__getattr__</name><path>src/_pytest/config/__init__.py</path><content>firstresult\")\n                    or \"firstresult\" in known_marks,\n                    \"historic\": hasattr(method, \"historic\")\n                    or \"hist</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.NoMatch</name><path>src/_pytest/config/__init__.py</path><content>c\" in known_marks,\n                }\n        return opts\n\n    def register(self, plugin,</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Interrupted</name><path>src/_pytest/config/__init__.py</path><content>me=None):\n        if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n            warnings.warn(\n                Py</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Interrupted.__module__</name><path>src/_pytest/config/__init__.py</path><content> warnings.warn(\n       </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Failed</name><path>src/_pytest/config/__init__.py</path><content>tConfigWarning(\n                    \"{} plugin has been merged into the</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main._bestrelpath_cache</name><path>src/_pytest/config/__init__.py</path><content>re, \"\n                    \"please remove it from your requirements.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n  </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main._bestrelpath_cache.path</name><path>src/_pytest/config/__init__.py</path><content>from your requir</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main._bestrelpath_cache.__missing__</name><path>src/_pytest/config/__init__.py</path><content>.\".format(\n                        name.replace(\"_\", \"-\")\n                    )\n                )\n            )\n            return\n  </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session</name><path>src/_pytest/config/__init__.py</path><content>   ret = super().register(plugin, name)\n        if ret:\n            self.hook.pytest_plugin_registered.call_historic(\n                kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        config.addinivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest files may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, however, so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            current.join(namespace.confcutdir, abs=True)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n        testpaths = namespace.file_or_dir\n        foundanchor = False\n        for path in testpaths:\n            path = str(path)\n            # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdir(\"test*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # directories instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.realpath().parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use a resolved Path object as key to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file systems (#5792)\n        key = Path(str(conftestpath)).resolve()\n        try:\n            return self._conftestpath2mod[key]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_on_non_top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[key] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.rewrite_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        else:\n            mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        if isinstance(specs, str):\n            specs = specs.split(\",\") if specs else []\n        if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the parameters regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: tuple of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:\n        \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        plugins = attr.ib()\n        dir = attr.ib(type=Path)\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n    @property\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warni</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.Interrupted</name><path>src/_pytest/config/__init__.py</path><content>)\n        if ret:\n       </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.Failed</name><path>src/_pytest/config/__init__.py</path><content>self.hook.pytes</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._setupstate</name><path>src/_pytest/config/__init__.py</path><content>gin_registered.cal</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.__init__</name><path>src/_pytest/config/__init__.py</path><content>  kwargs=dict(plugin=plugin, manager=self)\n            )\n\n            if isinstance(plugin, types.ModuleType):\n                self.consider_module(plugin)\n        return ret\n\n    def getplugin(self, name):\n        # support deprecated naming because plugins (xdist e.g.) use it\n        return self.get_plugin(name)\n\n    def hasplugin(self, name):\n        \"\"\"Return True if the plugin with the given name is registered.\"\"\"\n        return bool(self.get_plugin(name))\n\n    def pytest_configure(self, config):\n        # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n        # we should remove tryfirst/trylast as markers\n        config.addinivalue_line(\n            \"markers\",\n            \"tryfirst: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it first/as early as possible.\",\n        )\n        confi</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.__repr__</name><path>src/_pytest/config/__init__.py</path><content>nivalue_line(\n            \"markers\",\n            \"trylast: mark a hook implementation function such that the \"\n            \"plugin machinery will try to call it last/as late as possible.\",\n        )\n        self._configured = True\n\n    #\n    # internal API for local conftest plug</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._node_location_to_relpath</name><path>src/_pytest/config/__init__.py</path><content>dling\n    #\n    def _set_initial_conftests(self, namespace):\n        \"\"\" load initial conftest files given a preparsed \"namespace\".\n            As conftest</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.pytest_collectstart</name><path>src/_pytest/config/__init__.py</path><content> may add their own command line options\n            which have arguments ('--my-opt somepath') we might get some\n            false positives.  All builtin and 3rd party plugins will have\n            been loaded, ho</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.pytest_runtest_logreport</name><path>src/_pytest/config/__init__.py</path><content> so common options will not confuse our logic\n            here.\n        \"\"\"\n        current = py.path.local()\n        self._confcutdir = (\n            current.join(namespace.confcutdir, abs=True)\n            if namespace.confcutdir\n            else None\n        )\n        self._noconftest = namespace.noconftest\n        self._using_pyargs = namespace.pyargs\n    </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.pytest_collectreport</name><path>src/_pytest/config/__init__.py</path><content>stpaths = namespace.file_or_dir\n        foundan</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.isinitpath</name><path>src/_pytest/config/__init__.py</path><content> False\n        for path in testpaths:\n            path = str(path)\n  </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.gethookproxy</name><path>src/_pytest/config/__init__.py</path><content>    # remove node-id syntax\n            i = path.find(\"::\")\n            if i != -1:\n                path = path[:i]\n            anchor = current.join(path, abs=1)\n            if exists(anchor):  # we found some file object\n                self._try_load_conftest(anchor)\n                foundanchor = True\n        if not foundanchor:\n            self._try_load_conftest(current)\n\n    def _try_load_conftest(self, anchor):\n        self._getconftestmodules(anchor)\n        # let's also consider test* subdirs\n        if anchor.check(dir=1):\n            for x in anchor.listdi</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.perform_collect</name><path>src/_pytest/config/__init__.py</path><content>t*\"):\n                if x.check(dir=1):\n                    self._getconftestmodules(x)\n\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n        if self._noconftest:\n            return []\n\n        if path.isfile():\n            directory = path.dirpath()\n        else:\n            directory = path\n\n        # XXX these days we may rather want to use config.rootdir\n        # and allow users to opt into looking into the rootdir parent\n        # di</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._perform_collect</name><path>src/_pytest/config/__init__.py</path><content>ies instead of requiring to specify confcutdir\n        clist = []\n        for parent in directory.realpath().parts():\n            if self._confcutdir and self._confcutdir.relto(parent):\n                continue\n            conftestpath = parent.join(\"conftest.py\")\n            if conftestpath.isfile():\n                mod = self._importconftest(conftestpath)\n                clist.append(mod)\n        self._dirpath2confmods[directory] = clist\n        return clist\n\n    def _rget_with_confmod(self, name, path):\n        modules = self._getconftestmodules(path)\n        for mod in reversed(modules):\n            try:\n                return mod, getattr(mod, name)\n            except AttributeError:\n                continue\n        raise KeyError(name)\n\n    def _importconftest(self, conftestpath):\n        # Use a resolved Path object as key to avoid loading the same conftest twice\n        # with build systems that create build directories containing\n        # symlinks to actual files.\n        # Using Path().resolve() is better than py.path.realpath because\n        # it resolves to the correct path/drive in case-insensitive file syste</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.collect</name><path>src/_pytest/config/__init__.py</path><content>792)\n        key = Path(str(conftestpath)).resolve()\n        try:\n            return self._conftestpath2mod[key]\n        except KeyError:\n            pkgpath = conftestpath.pypkgpath()\n            if pkgpath is None:\n                _ensure_removed_sysmodule(conftestpath.purebasename)\n            try:\n                mod = conftestpath.pyimport()\n                if (\n                    hasattr(mod, \"pytest_plugins\")\n                    and self._configured\n                    and not self._using_pyargs\n                ):\n                    _fail_o</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._collect</name><path>src/_pytest/config/__init__.py</path><content>top_pytest_plugins(conftestpath, self._confcutdir)\n            except Exception:\n                raise ConftestImportFailure(conftestpath, sys.exc_info())\n\n            self._conftest_plugins.add(mod)\n            self._conftestpath2mod[key] = mod\n            dirpath = conftestpath.dirpath()\n            if dirpath in self._dirpath2confmods:\n                for path, mods in self._dirpath2confmods.items():\n                    if path and path.relto(dirpath) or path == dirpath:\n                        assert mod not in mods\n                        mods.append(mod)\n            self.trace(\"loaded conftestmodule %r\" % (mod))\n            self.consider_conftest(mod)\n            return mod\n\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n        i = 0\n        n = len(args)\n        while i < n:\n            opt = args[i]\n            i += 1\n            if isinstance(opt, str):\n                if opt == \"-p\":\n                    try:\n                        parg = args[i]\n                    except IndexError:\n                        return\n                    i += 1\n                elif opt.startswith(\"-p\"):\n                    parg = opt[2:]\n                else:\n                    continue\n                self.consider_pluginarg(parg)\n\n    def consider_pluginarg(self, arg):\n        if arg.startswith(\"no:\"):\n            name = arg[3:]\n            if name in essential_plugins:\n                raise UsageError(\"plugin %s cannot be disabled\" % name)\n\n            # PR #4304 : remove stepwise if cacheprovider is blocked\n            if name == \"cacheprovider\":\n                self.set_blocked(\"stepwise\")\n                self.set_blocked(\"pytest_stepwise\")\n\n            self.set_blocked(name)\n            if not name.startswith(\"pytest_\"):\n                self.set_blocked(\"pytest_\" + name)\n        else:\n            name = arg\n            # Unblock the plugin.  None indicates that it has been blocked.\n            # There is no interface with pluggy for this.\n            if self._name2plugin.get(name, -1) is None:\n                del self._name2plugin[name]\n            if not name.startswith(\"pytest_\"):\n                if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n                    del self._name2plugin[\"pytest_\" + name]\n            self.import_plugin(arg, consider_entry_points=True)\n\n    def consider_conftest(self, conftestmodule):\n        self.register(conftestmodule, name=conftestmodule.__file__)\n\n    def consider_env(self):\n        self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n\n    def consider_module(self, mod):\n        self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n\n    def _import_plugin_specs(self, spec):\n        plugins = _get_plugin_specs_as_list(spec)\n        for import_spec in plugins:\n            self.import_plugin(import_spec)\n\n    def import_plugin(self, modname, consider_entry_points=False):\n        \"\"\"\n        Imports a plugin with ``modname``. If ``consider_entry_points`` is True, entry point\n        names are also considered to find a plugin.\n        \"\"\"\n        # most often modname refers to builtin modules, e.g. \"pytester\",\n        # \"terminal\" or \"capture\".  Those plugins are registered under their\n        # basename for historic purposes but must be imported with the\n        # _pytest prefix.\n        assert isinstance(modname, str), (\n            \"module name as text required, got %r\" % modname\n        )\n        modname = str(modname)\n        if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n            return\n\n        importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n        self.</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._collectfile</name><path>src/_pytest/config/__init__.py</path><content>e_hook.mark_rewrite(importspec)\n\n        if consider_entry_points:\n            loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n            if loaded:\n                return\n\n        try:\n            __import__(importspec)\n        except ImportError as e:\n            new_exc_message = 'Error importing plugin \"{}\": {}'.format(\n                modname, str(e.args[0])\n            )\n            new_exc = ImportError(new_exc_message)\n            tb = sys.exc_info()[2]\n\n            raise new_exc.with_traceback(tb)\n\n        except Skipped as e:\n            from _pytest.warnings import _issue_warning_captured\n\n            _issue_warning_captured(\n                PytestConfigWarning(\"skipped plugin {!r}: {}\".format(modname, e.msg)),\n                self.hook,\n                stacklevel=1,\n            )\n        el</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._recurse</name><path>src/_pytest/config/__init__.py</path><content>          mod = sys.modules[importspec]\n            self.register(mod, modname)\n\n\ndef _get_plugin_specs_as_list(specs):\n    \"\"\"\n    Parses a list of \"plugin specs\" and returns a list of plugin names.\n\n    Plugin specs can be given as a list of strings separated by \",\" or already as a list/tuple in\n    which case it is returned as a list. Specs can also be `None` in which case an\n    empty list is returned.\n    \"\"\"\n    if specs is not None and not isinstance(specs, types.ModuleType):\n        </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._visit_filter</name><path>src/_pytest/config/__init__.py</path><content>nstance(specs, str):\n            specs = specs.split(\",\") if specs els</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._tryconvertpyarg</name><path>src/_pytest/config/__init__.py</path><content>       if not isinstance(specs, (list, tuple)):\n            raise UsageError(\n                \"Plugin specs must be a ','-separated string or a \"\n                \"list/tuple of strings for plugin names. Given: %r\" % specs\n            )\n        return list(specs)\n    return []\n\n\ndef _ensure_removed_sysmodule(modname):\n    try:\n        del sys.modules[modname]\n    except KeyError:\n        pass\n\n\nclass Notset:\n    def __repr__(self):\n        return \"<NOTSET>\"\n\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n    for fn in package_files:\n        is_simple_module = \"/\" not in fn and fn</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._parsearg</name><path>src/_pytest/config/__init__.py</path><content>ith(\".py\")\n        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n        if is_simple_module:\n            module_name, _ = os.path.splitext(fn)\n            yield module_name\n        elif is_package:\n            package_name = os.path.dirname(fn)\n            yield package_name\n\n\nclass Config:\n    \"\"\"\n    Access to configuration values, pluginmanager and plugin hooks.\n\n    :ivar PytestPluginManager pluginmanager: the plugin manager handles plugin registration and hook invocation.\n\n    :ivar argparse.Namespace option: access to command line option as attributes.\n\n    :ivar InvocationParams invocation_params:\n\n        Object containing the par</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.matchnodes</name><path>src/_pytest/config/__init__.py</path><content>s regarding the ``pytest.main``\n        invocation.\n\n        Contains the following read-only attributes:\n\n        * ``args``: tuple of command-line arguments as passed to ``pytest.main()``.\n        * ``plugins``: list of extra plugins, might be None.\n        * ``dir``: directory where ``pytest.main()`` was invoked from.\n    \"\"\"\n\n    @attr.s(frozen=True)\n    class InvocationParams:</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session._matchnodes</name><path>src/_pytest/config/__init__.py</path><content>   \"\"\"Holds parameters passed during ``pytest.main()``\n\n        .. versionadded:: 5.1\n\n        .. note::\n\n            Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n            ini option are handled by pytest, not being included in the ``args`` attribute.\n\n            Plugins accessing ``InvocationParams`` must be aware of that.\n        \"\"\"\n\n        args = attr.ib(converter=tuple)\n        plugins = attr.ib()\n        dir = attr.ib(type=Path)\n\n    def __init__(self, pluginmanager, *, invocation_params=None):\n        from .argparsing import Parser, FILE_OR_DIR\n\n        if invocation_params is None:\n            invocation_params = self.InvocationParams(\n                args=(), plugins=None, dir=Path().resolve()\n            )\n\n        self.option = argparse.Namespace()\n        self.invocation_params = invocation_params\n\n        _a = FILE_OR_DIR\n        self._parser = Parser(\n            usage=\"%(prog)s [options] [{}] [{}] [...]\".format(_a, _a),\n            processopt=self._processopt,\n        )\n        self.pluginmanager = pluginmanager\n        self.trace = self.pluginmanager.trace.root.get(\"config\")\n        self.hook = self.pluginmanager.hook\n        self._inicache = {}  # type: Dict[str, Any]\n        self._override_ini = ()  # type: Sequence[str]\n        self._opt2dest = {}  # type: Dict[str, str]\n        self._cleanup = []  # type: List[Callable[[], None]]\n        self.pluginmanager.register(self, \"pytestconfig\")\n        self._configured = False\n        self.hook.pytest_addoption.call_historic(\n            kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n        )\n\n    @</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.Session.genitems</name><path>src/_pytest/config/__init__.py</path><content>ty\n    def invocation_dir(self):\n        \"\"\"Backward compatibility\"\"\"\n        return py.path.local(str(self.invocation_params.dir))\n\n    def add_cleanup(self, func):\n        \"\"\" Add a function to be called when the config object gets out of\n        use (usually coninciding with pytest_unconfigure).\"\"\"\n        self._cleanup.append(func)\n\n    def _do_configure(self):\n        assert not self._configured\n        self._configured = True\n        with warnings.catch_warni</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.mark.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>try:\n                    return ExitCode(ret)\n                except ValueError:\n                    return ret\n            finally:\n                config._ensure_unconfigure()\n    except UsageError as e:\n        tw = py.io.TerminalWriter(sys.stderr)\n        for msg in e.args:\n            tw.line(\"ERROR: {}\\n\".format(msg), red=True)\n        return ExitCode.USAGE_ERROR\n\n\nclass cmdline:  # compatibility namespace\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n    \"\"\" Argparse type validator for filename argumen</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.python.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>path: path of filename\n    :optname: name of the option\n    \"\"\"\n    if os.path.isdir(path):\n        raise UsageError(\"{} must be a filename, given: {}\".format(optname, path))\n    return path\n\n\ndef directory_arg(pat</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.python._showfixtures_main</name><path>src/_pytest/config/__init__.py</path><content></content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setuponly.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>c_repr = (\n                exc_info.getrepr(style=\"short\", chain=False)\n                if exc_info.traceback\n                else exc_</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setupplan.pytest_cmdline_main</name><path>src/_pytest/config/__init__.py</path><content>er\nfrom pluggy import HookspecMarker\nfrom pluggy import PluginManager\n\nimport _pytest._code\nimport _pytest.assertion\nimport _pytest.deprecated\nimport _pytest.hookspec  # the </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.terminal._get_main_color</name><path>src/_pytest/config/__init__.py</path><content>TESTS WILL PASS.  Are you\"\n                \" using python -O?\"\n            )\n        else:\n            sys.stderr.write(\n                \"WARNING: assertions not in test modules or\"\n                \" plugins will be ignored\"\n                \" because assert statements are not executed \"\n                \"by the underlying Python interpreter \"\n                \"(are you using python -O?)\\n\"\n            )\n\n\ndef setns(obj, dic):\n    import pytest\n\n    for name, value in dic.items():\n        if isinstance(value, dict):\n            mod = getattr(obj, name, None)\n            if mod is None:\n                modname = \"pytest.%s\" % name\n                mod = types.ModuleType(modname)\n                sys.modules[modname] = mod\n            </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.assertion.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>----------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.cacheprovider.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>_logfinish(nodeid, location):\n    \"\"\" signal the complete finish of running a single test item.\n\n    This hook will be called **after** :func:`pytest_runtest_setup`, :func:`pytest_runtest_call` and\n    :func:`pytest_runtest_teardown` hooks.\n\n    :param str nodeid: full id of the item\n    :param location: a triple of ``(filename, linenum, testname)``\n    \"\"\"\n\n\ndef pytest_runtest_setup(item):\n    \"\"\" called before ``pytest_runtest_call(item)``. \"\"\"\n\n\ndef pytest_runtest_call(item):\n    \"\"\" called to execute the test ``item``. \"\"\"\n\n\ndef pytest_runtest_teardown(item, nextitem):\n    \"\"\" called after ``pytest_runtest_call``.\n\n    :arg nextitem: the scheduled-to-be-next test item (None if no further\n                   test item is scheduled).  This argument can be used to\n                   perform exact teardowns, i.e. calling just enough finalizers\n                   so that nextitem only needs to call setup-functions.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_runtest_makereport(item, call):\n    \"\"\" return a :py:class:`_pytest.runner.TestReport` object\n    for the given :py:class:`pytest.Item <_pytest.main.Item>` and\n    :py:class:`_pytest.runner.CallInfo`.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\ndef pytest_runtest_logreport(report):\n    \"\"\" process a test setup/call/teardown report relating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytes</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.capture.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>-----------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a n</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.debugging.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>cs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginn</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.doctest.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>t directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.faulthandler.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>ked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# --------------</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.fixtures.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content></content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.helpconfig.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>le options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attr</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.hookspec.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.junitxml.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>elating to\n    the respective phase of executing a test. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_to_serializable(config, report):\n    \"\"\"\n    Serializes the given report object into a data structure suitable for sending\n    over the wire, e.g. converted to JSON.\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_report_from_serializable(config, data):\n    \"\"\"\n    Restores a report object previously serialized with pytest_report_to_serializable().\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Fixture related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_fixture_setup(fixturedef, request):\n    \"\"\" performs fixture setup execution.\n\n    :return: The return value of the call to the fixture function\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        If the fixture function returns None, other implementations of\n        this hook function will continue to be called, according to the\n        behavior of the :ref:`firstresult` option.\n    \"\"\"\n\n\ndef pytest_fixture_post_finalizer(fixturedef, request):\n    \"\"\" called after fixture teardown, but before the cache is cleared so\n    the fixture result cache ``fixturedef.cached_result`` can\n    still be accessed.\"\"\"\n\n\n# -------------------------------------------------</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.logging.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>onfig.Config config: pytest config object\n    :param List[_pytest.nodes.Item] items: list of item objects\n    \"\"\"\n\n\ndef pytest_collection_finish(session):\n    \"\"\" called after collection has been performed and modified.\n\n    :param _pytest.main.Session session: the pytest session object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_ignore_collect(path, config):\n    \"\"\" return True to prevent considering this path for collection.\n    This hook is consulted for all files and directories prior to calling\n    more specific hooks.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_collect_directory(path, parent):\n    \"\"\" called before traversing a directory for collection files.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path to analyze\n    \"\"\"\n\n\ndef pytest_collect_file(path, parent):\n    \"\"\" return collection Node or None for the given path. Any new node\n    needs to have the specified ``parent`` as a parent.\n\n    :param path: a :py:class:`py.path.local` - the path to collect\n    \"\"\"\n\n\n# logging hooks for collection\n\n\ndef pytest_collectstart(collector):\n    \"\"\" collector starts collecting. \"\"\"\n\n\ndef pytest_itemcollected(item):\n    \"\"\" we just collected a test item. \"\"\"\n\n\ndef pytest_collectreport(report):\n    \"\"\" collector finished collecting. \"\"\"\n\n\ndef pytest_deselected(items):\n    \"\"\" called for test items deselected, e.g. by keyword. \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_make_collect_report(collector):\n    \"\"\" perform ``collector.collect()`` and return a CollectReport.\n\n    Stops at first non-None result, see :ref:`firstresult` \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Python test function related hooks\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makemodule(path, parent):\n    \"\"\" return a Module collector or None for the given path.\n    This hook will be called for each matching test module path.\n    The pytest_collect_file hook needs to be used if you want to\n    create test modules for files that do not match as a test module.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param path: a :py:class:`py.path.local` - the path of module to collect\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_pycollect_makeitem(collector, name, obj):\n    \"\"\" return custom item/collector for a python object in a module, or N</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.main.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecated and will be removed in a future pytest version. Consider\n    using :func:`pytest_load_initial_conftests` instead.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    :param _pytest.config.Config config: pytest config object\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_main(config):\n    \"\"\" called for performing the main command line action. The default\n    implementation will invoke the configure hooks and runtest_mainloop.\n\n    .. note::\n        This hook will not be called for ``conftest.py`` files, only for setuptools plugins.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    :param _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\ndef pytest_load_initial_conftests(early_config, parser, args):\n    \"\"\" implements the loading of initial conftest files ahead\n    of command line option parsing.\n\n    .. note::\n        This hook will not </content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.mark.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>on should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after comma</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.pastebin.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"ca</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.pytester.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content> pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plugins or ``conftest.py``\n        files situated at the tests root directory due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_p</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.python.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>t.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.runner.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_plugin_registered(plugin, manager):\n    \"\"\" a new pytest plugin got registered.\n\n    :param plugin: the plugin module or instance\n    :param _pytest.config.PytestPlugin</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setuponly.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(plugi</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.setupplan.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ----</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.skipping.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>nitialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow adding new hooks via a call to\n    ``pluginmanager.add_hookspecs(module_or_class, prefix)``.\n\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.stepwise.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>cations for pytest plugins, invoked from main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager):\n    \"\"\"called at plugin registration time to allow ad</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.terminal.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>due to how pytest\n        :ref:`discovers plugins during startup <pluginorder>`.\n\n    :arg _pytest.config.Parser parser: To add command line options, call\n        :py:func:`parser.addoption(...) <_pytest.config.Parser.addoption>`.\n        To add ini-file values call :py:func:`parser.addini(...)\n        <_pytest.config.Parser.addini>`.\n\n    :arg _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager,\n        which can be used to install :py:func:`hookspec`'s or :py:func:`hookimpl`'s\n        and allow one plugin to call another plugin's hooks to change how\n        command line options are added.\n\n    Options can later be accessed through the\n    :py:class:`config <_pytest.config.Config>` object, respectively:\n\n    - :py:func:`config.getoption(name) <_pytest.config.Config.getoption>` to\n      retrieve the value of a command line option.\n\n    - :py:func:`config.getini(name) <_pytest.config.Config.getini>` to retrieve\n      a value read from an ini-style file.\n\n    The config object is passed around on many internal objects via the ``.config``\n    attribute or can be retrieved as the ``pytestconfig`` fixture.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_configure(config):\n    \"\"\"\n    Allows plugins and conftest files to perform initial configuration.\n\n    This hook is called for every plugin and initial conftest file\n    after command line options have been parsed.\n\n    After that, the hook is called for other conftest files as they are\n    imported.\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n\n    :arg _pytest.config.Config config: pytest config object\n    \"\"\"\n\n\n# -------------------------------------------------------------------------\n# Bootstrapping hooks called for plugins registered early enough:\n# internal and 3rd party plugins.\n# -------------------------------------------------------------------------\n\n\n@hookspec(firstresult=True)\ndef pytest_cmdline_parse(pluginmanager, args):\n    \"\"\"return initialized config object, parsing the specified args.\n\n    Stops at first non-None result, see :ref:`firstresult`\n\n    .. note::\n        This hook will only be called for plugin classes passed to the ``plugins`` arg when using `pytest.main`_ to\n        perform an in-process test run.\n\n    :param _pytest.config.PytestPluginManager pluginmanager: pytest plugin manager\n    :param list[str] args: list of arguments passed on the command line\n    \"\"\"\n\n\ndef pytest_cmdline_preparse(config, args):\n    \"\"\"(**Deprecated**) modify command line arguments before option parsing.\n\n    This hook is considered deprecate</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.warnings.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>lugin: the plugin module or instance\n    :param _pytest.config.PytestPluginManager manager: pytest plugin manager\n\n    .. note::\n        This hook is incompatible with ``hookwrapper=True``.\n    \"\"\"\n\n\n@hookspec(historic=True)\ndef pytest_addoption(parser, pluginmanager):\n    \"\"\"register argparse-style options and ini-style config values,\n    called once at the beginning of a test run.\n\n    .. note::\n\n        This function should be implemented only in plug</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.report_log.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>om main.py and builtin plugins.  \"\"\"\nfrom pluggy import HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# ------------------------------------------------------------------</content></symbol>"
    },
    {
      "role": "user",
      "content": "<symbol><name>_pytest.resultlog.pytest_addoption</name><path>src/_pytest/hookspec.py</path><content>rt HookspecMarker\n\n\nhookspec = HookspecMarker(\"pytest\")\n\n# -------------------------------------------------------------------------\n# Initialization hooks called for every plugin\n# -------------------------------------------------------------------------\n\n\n@hookspec(historic=True)\ndef pytest_addhooks(pluginmanager</content></symbol>"
    }
  ],
  "completion": {
    "id": "chatcmpl-9y28VA3tvJiRWp540Fzckr05mnzm7",
    "choices": [
      {
        "finish_reason": "stop",
        "index": 0,
        "logprobs": null,
        "message": {
          "content": "{\"scratch_pad\":\"1. Analyze User Instructions:\\n- The issue is the need for a shorter form (a single-character shortcut) for the `--collect-only` command line argument in pytest.\\n- This is likely caused by the current argument being long and cumbersome to type frequently.\\n- The expected result is a shorter, more convenient command to achieve the same functionality as `--collect-only`.\\n- The ideal resolution would be allowing users to achieve the collect-only behavior with just a single-character option.\\n\\n2. Examine the Symbols Provided:\\n- The symbols are related to the `pytest_addoption` function which is used to add command line options and configure pytest.\\n- To achieve the desired outcome of creating a shortcut, changes or additions need to be made around where options are defined in these functions.\\n- Since the main feature addition is a CLI interface addition, these pytest_addoption functions would need to be reviewed and modified accordingly.\\n\\n3. Determine the Relevant Symbols:\\n- Since the task is to add a shorter alias for an option, we can focus on the symbol(s) that are responsible for parsing or defining options.\\n- The main symbol to change would be where `--collect-only` is being added, ensuring that the addition of a new shortcut option links to the same action.\",\"symbols\":[{\"name\":\"_pytest.main.pytest_addoption\",\"file_path\":\"src/_pytest/main.py\",\"reason\":\"This symbol is where the command line options are being set for pytest. To provide a new shortcut, a modification needs to include the new option here.\"}],\"more_info\":[],\"is_done\":false,\"symbols_scratch_pad\":[\"This symbol, `_pytest.assertion.pytest_addoption`, seems related to adding options, but the content is incomplete or not directly relevant to collect-only functionality.\",\"The content seems to be part of an internal implementation related to test collection and running (like fail cases, not adding/changing options).\",\"This is partial and likely irrelevant as it doesn't show option handling for collection or CLI adjustments.\",\"Again, partial content, not related to CLI configurations.\",\"Content incomplete, probably doesn't help in finding where to add CLI shortcuts.\",\"The start of an option is viewable but cut off; looks like a continuation of command setup where the focus could be around.\",\"Various parts repeat without full context, can't determine CLI option setup from this portion alone.\",\"This portion doesn't seem relevant as it includes logic related to handling test logs rather than option setup.\",\"Involved with handling session or logging, no context for CLI options noted in this part.\",\"This symbol is irrelevant as it doesn't contain CLI setup, partial parts of another context unrelated directly.\",\"Too fragmented to determine importance, no CLI handling seen.\",\"These fragments do not show context for CLI options or addition points for a collector only shortcut.\",\"This has context needed: shows where CLI options are set. Add 'c' or similar here for new shortcut.\",\"Part of logging perhaps, session management... not directly impactful for CLI.\",\"Description hints at plugins or session, which isn't the target of modification.\",\"Once again command line setup pertinent to collection show here - partial overlaps, continue exploration and correlation needed.\",\"Shows where help config and terminal might set options -- seems like it is a culminating area for adding commands.\",\"This main holding the do_configure segment strongly implies relevant intercept for config, though scattered.\",\"CLI involvement and framework plugin setup here; logic known might be referenced in modification. \",\"Ultimately where code paths meet is here, thus target point to intercept for mods.\"]}",
          "refusal": null,
          "role": "assistant",
          "function_call": null,
          "tool_calls": [],
          "parsed": {
            "scratch_pad": "1. Analyze User Instructions:\n- The issue is the need for a shorter form (a single-character shortcut) for the `--collect-only` command line argument in pytest.\n- This is likely caused by the current argument being long and cumbersome to type frequently.\n- The expected result is a shorter, more convenient command to achieve the same functionality as `--collect-only`.\n- The ideal resolution would be allowing users to achieve the collect-only behavior with just a single-character option.\n\n2. Examine the Symbols Provided:\n- The symbols are related to the `pytest_addoption` function which is used to add command line options and configure pytest.\n- To achieve the desired outcome of creating a shortcut, changes or additions need to be made around where options are defined in these functions.\n- Since the main feature addition is a CLI interface addition, these pytest_addoption functions would need to be reviewed and modified accordingly.\n\n3. Determine the Relevant Symbols:\n- Since the task is to add a shorter alias for an option, we can focus on the symbol(s) that are responsible for parsing or defining options.\n- The main symbol to change would be where `--collect-only` is being added, ensuring that the addition of a new shortcut option links to the same action.",
            "symbols": [
              {
                "name": "_pytest.main.pytest_addoption",
                "file_path": "src/_pytest/main.py",
                "reason": "This symbol is where the command line options are being set for pytest. To provide a new shortcut, a modification needs to include the new option here."
              }
            ],
            "more_info": [],
            "is_done": false,
            "symbols_scratch_pad": [
              "This symbol, `_pytest.assertion.pytest_addoption`, seems related to adding options, but the content is incomplete or not directly relevant to collect-only functionality.",
              "The content seems to be part of an internal implementation related to test collection and running (like fail cases, not adding/changing options).",
              "This is partial and likely irrelevant as it doesn't show option handling for collection or CLI adjustments.",
              "Again, partial content, not related to CLI configurations.",
              "Content incomplete, probably doesn't help in finding where to add CLI shortcuts.",
              "The start of an option is viewable but cut off; looks like a continuation of command setup where the focus could be around.",
              "Various parts repeat without full context, can't determine CLI option setup from this portion alone.",
              "This portion doesn't seem relevant as it includes logic related to handling test logs rather than option setup.",
              "Involved with handling session or logging, no context for CLI options noted in this part.",
              "This symbol is irrelevant as it doesn't contain CLI setup, partial parts of another context unrelated directly.",
              "Too fragmented to determine importance, no CLI handling seen.",
              "These fragments do not show context for CLI options or addition points for a collector only shortcut.",
              "This has context needed: shows where CLI options are set. Add 'c' or similar here for new shortcut.",
              "Part of logging perhaps, session management... not directly impactful for CLI.",
              "Description hints at plugins or session, which isn't the target of modification.",
              "Once again command line setup pertinent to collection show here - partial overlaps, continue exploration and correlation needed.",
              "Shows where help config and terminal might set options -- seems like it is a culminating area for adding commands.",
              "This main holding the do_configure segment strongly implies relevant intercept for config, though scattered.",
              "CLI involvement and framework plugin setup here; logic known might be referenced in modification. ",
              "Ultimately where code paths meet is here, thus target point to intercept for mods."
            ]
          }
        }
      }
    ],
    "created": 1724094919,
    "model": "gpt-4o-2024-08-06",
    "object": "chat.completion",
    "service_tier": null,
    "system_fingerprint": "fp_2a322c9ffc",
    "usage": {
      "completion_tokens": 715,
      "prompt_tokens": 26617,
      "total_tokens": 27332
    }
  }
}