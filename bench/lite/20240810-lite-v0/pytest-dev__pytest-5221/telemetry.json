{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5221",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:10:05.548236",
        "usage": "1311.9847774505615 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "getlocals",
          "delattr",
          "disabled",
          "compile",
          "fullsource",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "_some_str",
          "MODULE_NOT_FOUND_ERROR",
          "_match_lines",
          "run",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "_is_setup_py",
          "BOM_UTF8",
          "_getnextfixturedef",
          "append_skipped",
          "REPORT_COLLECTING_RESOLUTION",
          "PYTEST_CONFIG_GLOBAL",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_inject_setup_function_fixture",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "PY36",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "cached_result",
          "visit_Call_legacy",
          "ApproxDecimal",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "applymarker",
          "_check_all_skipped",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "check_xfail_no_run",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "__setattr__",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "get_terminal_writer",
          "exec_",
          "inline_genitems",
          "writeorg",
          "RAISES_MESSAGE_PARAMETER",
          "__eq__",
          "update_testcase_duration",
          "_callhelper",
          "USAGE_MSG",
          "collect_one_node",
          "_code",
          "PYTEST_ENSURETEMP",
          "append_pass",
          "N",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "value",
          "consider_preparse",
          "unittest",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "_exec_lsof",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "RaisesContext",
          "_get_non_fixture_func",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "junitxml",
          "_mk_tmp",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "PYTEST_LOGWARNING",
          "LEVELNAME_FMT_REGEX",
          "RN",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "_log_cli_enabled",
          "processoption",
          "_config",
          "getfuncargvalue",
          "TestCaseFunction",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "location",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "unary_map",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "format_explanation",
          "makeconftest",
          "alias",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "repr_unicode",
          "doctest",
          "fileno",
          "setns",
          "_validate_usepdb_cls",
          "Class",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "pytest_itemstart",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "last_failed_paths",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "families",
          "pytest_terminal_summary",
          "__nonzero__",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "_get_marks",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "done",
          "add_report_section",
          "PytestPluginManager",
          "getnode",
          "YIELD_TESTS",
          "update",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "PrintHelp",
          "MyOptionParser",
          "parseconfig",
          "pytest_doctest_prepare_content",
          "pyobj_property",
          "find_module",
          "scope2index",
          "getbasetemp",
          "EXIT_TESTSFAILED",
          "_addexcinfo",
          "_width_of_current_line",
          "NodeMarkers",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "is_true",
          "_ConfigDeprecated",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "errors",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "short_test_summary",
          "_call_and_format_exception",
          "parse_num",
          "_checkargnotcontained",
          "python_keywords_allowed_list",
          "collect_by_name",
          "parsefactories",
          "_ensure_only_one_capture_fixture",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "ASCII_IS_DEFAULT_ENCODING",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "repr",
          "SEP",
          "matchkeyword",
          "SubRequest",
          "load_module",
          "EXIT_INTERNALERROR",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_handle_skip",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "_getglobals",
          "generic_visit",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "autouse",
          "_importconftest",
          "args",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "exc_clear",
          "PytestDeprecationWarning",
          "pytest_logwarning",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "visit_Call_35",
          "__array_ufunc__",
          "MarkMapping",
          "summary_errors",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "format_exception_only",
          "MARK_GEN",
          "fspath",
          "_opentestcase",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "syspath_prepend",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "NoneType",
          "find_suffixes",
          "syspathinsert",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "istrue",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "set_when",
          "delenv",
          "_perform_collect",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "raiseerror",
          "fnmatch_ex",
          "_runtest_for_main",
          "Traceback",
          "pytest_runtestloop",
          "item_capture",
          "TestReport",
          "capfd",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "PyobjContext",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "cls",
          "getlocation",
          "isclass",
          "parseconfigure",
          "repr_locals",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "visit_Name",
          "report_collect",
          "finish",
          "getdecoded",
          "_compilecounter",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "AssertionState",
          "_find_last_non_hidden_frame",
          "ihook",
          "call_optional",
          "_get_override_ini_value",
          "ExceptionRepr",
          "putaround",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "_install_capture_fixture_on_item",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "_write_pyc",
          "__len__",
          "summary_stats",
          "__next__",
          "getrawcode",
          "find",
          "_initrequest",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_callfinalizers",
          "CollectErrorRepr",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "RemovedInPytest4Warning",
          "extract_suffixes",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "isiterable",
          "FSCollector",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "ensure_newline",
          "saferepr",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "_getcapture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "CaptureResult",
          "str",
          "isparseable",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "OptionGroup",
          "error",
          "_is_capturing",
          "_attempt_to_close_capture_file",
          "FixtureRequest",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "ReprFileLocation",
          "PY35",
          "format",
          "isfunction",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "scopeproperty",
          "getitem",
          "ensuretemp",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "_is_unittest_unexpected_success_a_failure",
          "initialnames",
          "LogXML",
          "__getitem__",
          "FIXTURE_NAMED_REQUEST",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "exists",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "patchsysdict",
          "start_global_capturing",
          "_fix_spoof_python2",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "compile_",
          "assert_contains_lines",
          "Entry",
          "chain",
          "setall",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "_teardown_towards",
          "capture_fixtures",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "safe_text_dupfile",
          "MoreQuietAction",
          "LineMatcher",
          "context",
          "fixtures",
          "__call__",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "matchmark",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "_PY3",
          "freeze_support",
          "params",
          "isnosetest",
          "_PY2",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "_register_with_pkg_resources",
          "mkdir",
          "own_markers",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "EXIT_INTERRUPTED",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "readlines",
          "inline_runsource",
          "cmdline",
          "__delitem__",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "FunctionMixin",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "_show_fixtures_per_test",
          "collect",
          "winpymap",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "MarkEvaluator",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "_setup_collect_fakemodule",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "cached_eval",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "FixtureFunctionMarker",
          "__bool__",
          "_parse_lsof_output",
          "_import_pdbcls",
          "_format_final_exc_line",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "writelines",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "_warn_if_env_name_is_not_str",
          "restore",
          "runpytest",
          "__exit__",
          "_get_allow_unicode_flag",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_is_mocked",
          "_showfixtures_main",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "_setoption",
          "Node",
          "parametrize",
          "_setup_cli_logging",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "ReprEntry",
          "EXIT_USAGEERROR",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "_typ_map",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "defaultfuncargprefixmarker",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "is_package",
          "Interrupted",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "rmtree",
          "strip",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "getexplanation",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "_fix_unittest_skip_decorator",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "dummy_context_manager",
          "Exit",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "getcfg",
          "exit",
          "_imp_find_module",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "NoCapture",
          "_rewrite_test",
          "raise_on_kwargs",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "_get_xunit_setup_teardown",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "ecu",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "_patched_find_module",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "warn_about_none_ast",
          "wasvalid",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "cookie_re",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "__version__",
          "RAISES_EXEC",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "getslaveinfoline",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "FIXTURE_FUNCTION_CALL",
          "_test_pytest_function",
          "_preparse",
          "idmaker",
          "FDCaptureBinary",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "with_args",
          "EXIT_NOTESTSCOLLECTED",
          "_get_active_fixturedef",
          "yield_fixture",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "ApproxBase",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "check_strict_xfail",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "_state",
          "_PLUGGY_DIR",
          "get_actual_log_level",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "get_skip_exceptions",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "_prunetraceback",
          "addinivalue_line",
          "EXIT_OK",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "WARNS_EXEC",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "runitem",
          "_istrue",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "call_and_report",
          "nofuncargs",
          "Config",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "invalidraise",
          "Module",
          "KeywordMapping",
          "Item",
          "_idvalset",
          "pytest_addhooks",
          "__all__",
          "matchnodes",
          "read_global_capture",
          "_getini",
          "_pdb_cls",
          "istestfunction",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "FuncargnamesCompatAttr",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "addhooks",
          "GETFUNCARGVALUE",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "_cmp_raises_type_error",
          "nodes",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "binop_map",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "write",
          "get_fslocation_from_item",
          "session",
          "out",
          "deselect_by_mark",
          "__unicode__",
          "spawn_pytest",
          "scopenum_function",
          "_matchnodes",
          "import_plugin",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "builtin",
          "_collectfile",
          "addFailure",
          "catching_logs",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "PYTESTER_COPY_EXAMPLE",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "pytest_fixture_setup",
          "fixture",
          "FixtureManager",
          "getfixtureinfo",
          "scope",
          "name2fixturedefs",
          "fixture",
          "scopes",
          "getfixturedefs",
          "pytest_collection_modifyitems"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:10:06.860236",
        "usage": "263.05484771728516 ms"
      },
      "request": {
        "tokens": [
          "pytest_fixture_setup",
          "fixture",
          "FixtureManager",
          "getfixtureinfo",
          "scope",
          "name2fixturedefs",
          "fixture",
          "scopes",
          "getfixturedefs",
          "pytest_collection_modifyitems"
        ]
      },
      "response": {
        "results": {
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py"
          ],
          "fixture": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/setuponly.py",
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py"
          ],
          "scope": [
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py"
          ],
          "getfixtureinfo": [
            "src/_pytest/fixtures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/unittest.py"
          ],
          "pytest_fixture_setup": [
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py"
          ],
          "name2fixturedefs": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py"
          ],
          "scopes": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "FixtureManager": [
            "src/_pytest/fixtures.py"
          ],
          "getfixturedefs": [
            "src/_pytest/fixtures.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:10:07.123306",
        "usage": "4913.291931152344 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_collection_modifyitems": [
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/main.py"
          ],
          "fixture": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/setuponly.py",
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py"
          ],
          "scope": [
            "src/_pytest/fixtures.py",
            "src/_pytest/nodes.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/terminal.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py"
          ],
          "getfixtureinfo": [
            "src/_pytest/fixtures.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/unittest.py"
          ],
          "pytest_fixture_setup": [
            "src/_pytest/fixtures.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/setupplan.py"
          ],
          "name2fixturedefs": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/runner.py"
          ],
          "scopes": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "FixtureManager": [
            "src/_pytest/fixtures.py"
          ],
          "getfixturedefs": [
            "src/_pytest/fixtures.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue is about enhancing the pytest output to include the scope of fixtures when using the command `pytest --fixtures`. This suggests that files responsible for managing fixtures, especially their scopes, are relevant.\n\n1. The presence of the keyword 'fixture' and 'scope' in `src/_pytest/fixtures.py` indicates it is a primary candidate, as it likely contains code related to fixture management.\n2. The keyword 'scopes' further narrows down the critical role of this file (`src/_pytest/fixtures.py`) because managing or retrieving the scope of a fixture is essential to this issue.\n3. The `FixtureManager` and other related keywords like `getfixturedefs` suggest that `src/_pytest/fixtures.py` handles the important logic related to fixtures.\n4. The file `src/_pytest/hookspec.py` is mentioned alongside `pytest_fixture_setup`, which may play a role in defining hooks for fixture setups, potentially intersecting with fixture scopes. Therefore, it could be somewhat relevant.\n5. None of the other files appear to focus specifically on the issue at hand as much as these do, given the keywords provided.\n\nTherefore, the files that should be investigated further to potentially resolve the issue are prioritized below.",
        "file_paths": [
          "src/_pytest/fixtures.py",
          "src/_pytest/hookspec.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:10:12.036612",
        "usage": "10307.635068893433 ms"
      },
      "request": {
        "file_path": "src/_pytest/fixtures.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:**\n    - The reported issue is that when using `pytest --fixtures`, it does not display the scope of each fixture. The only way to find out the fixture scope currently is to look into the documentation or the source code directly.\n    \n2. **User Reproduction Steps Insight:**\n    - The steps might involve running pytest with `--fixtures` to list all fixtures. The expectation is for this listing to include the scope of each fixture.\n    \n3. **Cause of the Issue:**\n    - The code responsible for managing fixtures doesn't seem to include logic to output the scope of fixtures when listing them. The code in charge of fixture management handles definitions, caching, and instantiation but lacks a mechanism to include scope information in fixture listings.\n\n4. **Expected Functionality:**\n    - Users expect `pytest --fixtures` to display scope information for each fixture in the list.\n    - Currently, the necessary scope data is processed but not displayed to the user as part of the `--fixtures` option.\n\n5. **Potential Solutions:**\n    - The code responsible for `--fixtures` output should be modified to include the scope attribute for each fixture. This likely involves updating the mechanism that formats and presents fixture information to the user.\n    - We should identify parts of the code where fixture data is logged or output and ensure that `fixturedef.scope` is included in the output.\n\n### File Content Analysis\n1. **Relevant Symbols and Classes**:\n    - `FixtureManager`: Manages fixture definitions and information.\n    - `FixtureDef`: Encapsulates fixture properties including scope.\n    - `getfixtureinfo`, `getfixtureclosure`: These manipulate fixture data which include scopes, crucial for tracing scope lines.\n\n2. **Functionality Review**:\n    - `FixtureManager` initializes and tracks all fixture-related data.\n    - `FixtureDef` objects within `FixtureManager` carry the scope as a property but don't seem to output them for `--fixtures`.\n\n3. **Hypothesis on How to Include Scope:**\n    - Modify `--fixtures` display function(s) to include `FixtureDef.scope` data when presenting fixture information.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/terminal.py"
        ],
        "relevant_symbols": [
          "FixtureManager",
          "FixtureDef",
          "FixtureDef.scope"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:10:22.344271",
        "usage": "6677.68669128418 ms"
      },
      "request": {
        "file_path": "src/_pytest/hookspec.py"
      },
      "response": {
        "scratch_pad": "1. The issue reported is about displaying the scope of fixtures when using `pytest --fixtures`. Currently, there is no direct way to see the scope of a fixture through this command, and users have to check documentation or source code to determine the scope.\n\n2. The user's expectation is likely that when they run `pytest --fixtures`, the output should include information about each fixture's scope in addition to the other details currently displayed.\n\n3. In the provided file, `src/_pytest/hookspec.py`, various hook specifications for pytest are defined, which are used by plugins. However, there's no direct reference to fixture display handling or enhancement of the output of `pytest --fixtures`.\n\n4. The root cause of the issue could be the absence of a hook or mechanism within pytest's core or plugins that augments the output of the `pytest --fixtures` command to include fixture scope information.\n\n5. A potential solution would be to introduce a hook or modify an existing one related to displaying fixtures, which would inject scope information into the output.\n\n6. In the file `src/_pytest/hookspec.py`, there's a section for \"Fixture related hooks\" but it does not have any functionality specifically for output enhancement for `pytest --fixtures`. \n\n7. The provided file is not immediately relevant in terms of being the root cause or directly implementing a solution. However, it might be part of the broader context where such capabilities should be added, specifically within fixture hooks.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/fixtures.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:10:29.022060",
        "usage": "90.38400650024414 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/fixtures.py",
            "relevant_symbol_keys": [
              "FixtureManager",
              "FixtureDef",
              "FixtureDef.scope"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/hookspec.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T12:10:29.112452",
        "usage": "13058.818817138672 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": []
      },
      "response": {
        "scratch_pad": "1. Analyze the Issue:\nThe user wants to display fixture scopes when using `pytest --fixtures`. Currently, the fixture scope is not displayed, and the only way to find out the scope is by checking the documentation or the source code.\n\n1.1 The issue describes a missing feature: displaying fixture scopes using the pytest CLI command.\n1.2 The issue could be because the current implementation does not include a mechanism to fetch and show the scope information.\n1.3 The user expects that running `pytest --fixtures` should show each fixture's scope.\n1.4 The expected result is that the pytest command will list fixtures with their respective scopes.\n\n2. Evaluate the Symbols:\n- The relevant process should involve any functionality related to fixture definitions, handling, and displaying them.\n\n2.1 PseudoFixtureDef:\n- This class is a placeholder for fixture definitions.\n- It has a scope attribute which might be what we need to display.\n\n2.2 FixtureDef:\n- This class contains scope information ('self.scope').\n- Relevant for defining factories and possibly where we should integrate the displaying mechanism.\n\n2.3 FixtureManager:\n- Manages fixture definitions and fixture framework handling.\n- It is crucial in understanding and potentially altering how fixtures are collected and may hold methods that could be enhanced to show scope.\n\n2.3a Methods like getfixtureinfo, getfixtureclosure, etc., might be places to enhance since they deal with fixture setup and management.\n\nConclusion:\n- The FixtureManager's interaction with FixtureDef or PseudoFixtureDef is where changes are needed.\n- We potentially need better integration with the CLI to show scopes when listing fixtures.",
        "symbols": [
          {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "reason": "The FixtureDef class houses the definition of fixtures, including scopes that need displaying."
          },
          {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "reason": "Handles collecting fixture details which may be altered to include scope display."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "PseudoFixtureDef: This class is used as a placeholder or a representation for fixture definitions. It contains a 'scope' attribute which may relate to the fixture scope that the user wants to display in the CLI. It's likely part of the internal handling rather than the output system.",
          "PseudoFixtureDef.cached_result: It's not necessarily related to the scope or displaying it, hence doesn't need to change here.",
          "PseudoFixtureDef.scope: Represents fixture scope, confirming we are targeting the right data but doesn't tell how to output this info.",
          "FixtureDef: A class for fixture objects with a 'scope' attribute among others. It represents the actionable objects where scope info is stored. Needs modification to expose scope info externally.",
          "FixtureDef.__init__: Part of building a FixtureDef object; here scope is set but irrelevant to how we output its data.",
          "FixtureDef.addfinalizer: Deals with finalizing operations on a fixture. Not relevant for the display issue.",
          "FixtureDef.finish: Concerned with cleanup. Not related to the display requirement.",
          "FixtureDef.execute: This handles fixture resolution which isn't related to displaying fixture's scope.",
          "FixtureDef.__repr__: Outputs basic info about a FixtureDef object and is a candidate location to include scope in the representation if not already present.",
          "FixtureManager: Central to managing fixture definitions, hence is the likely candidate for where scope-enhanced output should be manipulated.",
          "FixtureManager.__init__: It sets up basic management configurations but isn\u2019t related to the display logic directly.",
          "FixtureManager.getfixtureinfo: Retrieves fixture-related information which might need extending to print out the scope.",
          "FixtureManager.pytest_plugin_registered: Sets up plugins, likely unrelated unless scope info is in plugins.",
          "FixtureManager._getautousenames: Retrieves usenames for fixtures. Potentially related if these operations are seen in output.",
          "FixtureManager.getfixtureclosure: Collects fixture info and could be enhanced to include scopes for fixtures when outputting.",
          "FixtureManager.pytest_generate_tests: Deals with test generation logic, unlikely to be modified unless scope is part of test-gen info.",
          "FixtureManager.pytest_collection_modifyitems: This modifies test items, unlikely to include scope.",
          "FixtureManager.parsefactories: Parses and forms fixture data structures, possibly a point to ensure scope is available for display.",
          "FixtureManager.getfixturedefs: Retrieves fixture definitions which indicate possibilities to enhance displayed info.",
          "FixtureManager._matchfactories: Matches function factories and fixtures. Potentially related if display includes matching info."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T12:10:42.171306",
        "usage": "1.7981529235839844 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.fixtures.PseudoFixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
              "start_line": 41,
              "start_column": 1200,
              "end_line": 0,
              "end_column": 1304,
              "start_byte": 1200,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "cached_result = attr.ib()",
              "start_line": 43,
              "start_column": 1257,
              "end_line": 4,
              "end_column": 1282,
              "start_byte": 1257,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.PseudoFixtureDef.scope",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "scope = attr.ib()",
              "start_line": 44,
              "start_column": 1287,
              "end_line": 4,
              "end_column": 1304,
              "start_byte": 1287,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
              "start_line": 810,
              "start_column": 30838,
              "end_line": 0,
              "end_column": 34055,
              "start_byte": 30838,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
              "start_line": 813,
              "start_column": 30919,
              "end_line": 4,
              "end_column": 31651,
              "start_byte": 30919,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.addfinalizer",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
              "start_line": 841,
              "start_column": 31657,
              "end_line": 4,
              "end_column": 31734,
              "start_byte": 31657,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.finish",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
              "start_line": 844,
              "start_column": 31740,
              "end_line": 4,
              "end_column": 32769,
              "start_byte": 31740,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.execute",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
              "start_line": 871,
              "start_column": 32775,
              "end_line": 4,
              "end_column": 33881,
              "start_byte": 32775,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureDef.__repr__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
              "start_line": 896,
              "start_column": 33887,
              "end_line": 4,
              "end_column": 34055,
              "start_byte": 33887,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1077,
              "start_column": 40663,
              "end_line": 0,
              "end_column": 50680,
              "start_byte": 40663,
              "end_byte": 0
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupError = FixtureLookupError",
              "start_line": 1109,
              "start_column": 41972,
              "end_line": 4,
              "end_column": 42011,
              "start_byte": 41972,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
              "start_line": 1110,
              "start_column": 42016,
              "end_line": 4,
              "end_column": 42063,
              "start_byte": 42016,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.__init__",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
              "start_line": 1112,
              "start_column": 42069,
              "end_line": 4,
              "end_column": 42414,
              "start_byte": 42069,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
              "start_line": 1121,
              "start_column": 42420,
              "end_line": 4,
              "end_column": 43070,
              "start_byte": 42420,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
              "start_line": 1136,
              "start_column": 43076,
              "end_line": 4,
              "end_column": 43711,
              "start_byte": 43076,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._getautousenames",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
              "start_line": 1153,
              "start_column": 43717,
              "end_line": 4,
              "end_column": 44222,
              "start_byte": 43717,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
              "start_line": 1166,
              "start_column": 44228,
              "end_line": 4,
              "end_column": 46132,
              "start_byte": 44228,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
              "start_line": 1212,
              "start_column": 46138,
              "end_line": 4,
              "end_column": 47495,
              "start_byte": 46138,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
              "start_line": 1242,
              "start_column": 47501,
              "end_line": 4,
              "end_column": 47627,
              "start_byte": 47501,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.parsefactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
              "start_line": 1246,
              "start_column": 47633,
              "end_line": 4,
              "end_column": 50003,
              "start_byte": 47633,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
              "start_line": 1306,
              "start_column": 50009,
              "end_line": 4,
              "end_column": 50494,
              "start_byte": 50009,
              "end_byte": 4
            },
            {
              "name": "_pytest.fixtures.FixtureManager._matchfactories",
              "file_path": "src/_pytest/fixtures.py",
              "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
              "start_line": 1320,
              "start_column": 50500,
              "end_line": 4,
              "end_column": 50680,
              "start_byte": 50500,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": []
        },
        "symbols_evaluate": {
          "scratch_pad": "1. Analyze the Issue:\nThe user wants to display fixture scopes when using `pytest --fixtures`. Currently, the fixture scope is not displayed, and the only way to find out the scope is by checking the documentation or the source code.\n\n1.1 The issue describes a missing feature: displaying fixture scopes using the pytest CLI command.\n1.2 The issue could be because the current implementation does not include a mechanism to fetch and show the scope information.\n1.3 The user expects that running `pytest --fixtures` should show each fixture's scope.\n1.4 The expected result is that the pytest command will list fixtures with their respective scopes.\n\n2. Evaluate the Symbols:\n- The relevant process should involve any functionality related to fixture definitions, handling, and displaying them.\n\n2.1 PseudoFixtureDef:\n- This class is a placeholder for fixture definitions.\n- It has a scope attribute which might be what we need to display.\n\n2.2 FixtureDef:\n- This class contains scope information ('self.scope').\n- Relevant for defining factories and possibly where we should integrate the displaying mechanism.\n\n2.3 FixtureManager:\n- Manages fixture definitions and fixture framework handling.\n- It is crucial in understanding and potentially altering how fixtures are collected and may hold methods that could be enhanced to show scope.\n\n2.3a Methods like getfixtureinfo, getfixtureclosure, etc., might be places to enhance since they deal with fixture setup and management.\n\nConclusion:\n- The FixtureManager's interaction with FixtureDef or PseudoFixtureDef is where changes are needed.\n- We potentially need better integration with the CLI to show scopes when listing fixtures.",
          "symbols": [
            {
              "name": "_pytest.fixtures.FixtureDef",
              "file_path": "src/_pytest/fixtures.py",
              "reason": "The FixtureDef class houses the definition of fixtures, including scopes that need displaying."
            },
            {
              "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
              "file_path": "src/_pytest/fixtures.py",
              "reason": "Handles collecting fixture details which may be altered to include scope display."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "PseudoFixtureDef: This class is used as a placeholder or a representation for fixture definitions. It contains a 'scope' attribute which may relate to the fixture scope that the user wants to display in the CLI. It's likely part of the internal handling rather than the output system.",
            "PseudoFixtureDef.cached_result: It's not necessarily related to the scope or displaying it, hence doesn't need to change here.",
            "PseudoFixtureDef.scope: Represents fixture scope, confirming we are targeting the right data but doesn't tell how to output this info.",
            "FixtureDef: A class for fixture objects with a 'scope' attribute among others. It represents the actionable objects where scope info is stored. Needs modification to expose scope info externally.",
            "FixtureDef.__init__: Part of building a FixtureDef object; here scope is set but irrelevant to how we output its data.",
            "FixtureDef.addfinalizer: Deals with finalizing operations on a fixture. Not relevant for the display issue.",
            "FixtureDef.finish: Concerned with cleanup. Not related to the display requirement.",
            "FixtureDef.execute: This handles fixture resolution which isn't related to displaying fixture's scope.",
            "FixtureDef.__repr__: Outputs basic info about a FixtureDef object and is a candidate location to include scope in the representation if not already present.",
            "FixtureManager: Central to managing fixture definitions, hence is the likely candidate for where scope-enhanced output should be manipulated.",
            "FixtureManager.__init__: It sets up basic management configurations but isn\u2019t related to the display logic directly.",
            "FixtureManager.getfixtureinfo: Retrieves fixture-related information which might need extending to print out the scope.",
            "FixtureManager.pytest_plugin_registered: Sets up plugins, likely unrelated unless scope info is in plugins.",
            "FixtureManager._getautousenames: Retrieves usenames for fixtures. Potentially related if these operations are seen in output.",
            "FixtureManager.getfixtureclosure: Collects fixture info and could be enhanced to include scopes for fixtures when outputting.",
            "FixtureManager.pytest_generate_tests: Deals with test generation logic, unlikely to be modified unless scope is part of test-gen info.",
            "FixtureManager.pytest_collection_modifyitems: This modifies test items, unlikely to include scope.",
            "FixtureManager.parsefactories: Parses and forms fixture data structures, possibly a point to ensure scope is available for display.",
            "FixtureManager.getfixturedefs: Retrieves fixture definitions which indicate possibilities to enhance displayed info.",
            "FixtureManager._matchfactories: Matches function factories and fixtures. Potentially related if display includes matching info."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/fixtures.py"
        ],
        "symbols": [
          "_pytest.fixtures.FixtureDef",
          "_pytest.fixtures.FixtureManager.getfixtureclosure"
        ],
        "code_spans": {
          "_pytest.fixtures.PseudoFixtureDef": {
            "name": "_pytest.fixtures.PseudoFixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "@attr.s(frozen=True)\nclass PseudoFixtureDef(object):\n    cached_result = attr.ib()\n    scope = attr.ib()",
            "start_line": 41,
            "start_column": 1200,
            "end_line": 0,
            "end_column": 1304,
            "start_byte": 1200,
            "end_byte": 0
          },
          "_pytest.fixtures.PseudoFixtureDef.cached_result": {
            "name": "_pytest.fixtures.PseudoFixtureDef.cached_result",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "cached_result = attr.ib()",
            "start_line": 43,
            "start_column": 1257,
            "end_line": 4,
            "end_column": 1282,
            "start_byte": 1257,
            "end_byte": 4
          },
          "_pytest.fixtures.PseudoFixtureDef.scope": {
            "name": "_pytest.fixtures.PseudoFixtureDef.scope",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "scope = attr.ib()",
            "start_line": 44,
            "start_column": 1287,
            "end_line": 4,
            "end_column": 1304,
            "start_byte": 1287,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef": {
            "name": "_pytest.fixtures.FixtureDef",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureDef(object):\n    \"\"\" A container for a factory definition. \"\"\"\n\n    def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []\n\n    def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)\n\n    def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []\n\n    def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)\n\n    def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 810,
            "start_column": 30838,
            "end_line": 0,
            "end_column": 34055,
            "start_byte": 30838,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureDef.__init__": {
            "name": "_pytest.fixtures.FixtureDef.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(\n        self,\n        fixturemanager,\n        baseid,\n        argname,\n        func,\n        scope,\n        params,\n        unittest=False,\n        ids=None,\n    ):\n        self._fixturemanager = fixturemanager\n        self.baseid = baseid or \"\"\n        self.has_location = baseid is not None\n        self.func = func\n        self.argname = argname\n        self.scope = scope\n        self.scopenum = scope2index(\n            scope or \"function\",\n            descr=\"Fixture '{}'\".format(func.__name__),\n            where=baseid,\n        )\n        self.params = params\n        self.argnames = getfuncargnames(func, is_method=unittest)\n        self.unittest = unittest\n        self.ids = ids\n        self._finalizers = []",
            "start_line": 813,
            "start_column": 30919,
            "end_line": 4,
            "end_column": 31651,
            "start_byte": 30919,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.addfinalizer": {
            "name": "_pytest.fixtures.FixtureDef.addfinalizer",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def addfinalizer(self, finalizer):\n        self._finalizers.append(finalizer)",
            "start_line": 841,
            "start_column": 31657,
            "end_line": 4,
            "end_column": 31734,
            "start_byte": 31657,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.finish": {
            "name": "_pytest.fixtures.FixtureDef.finish",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def finish(self, request):\n        exceptions = []\n        try:\n            while self._finalizers:\n                try:\n                    func = self._finalizers.pop()\n                    func()\n                except:  # noqa\n                    exceptions.append(sys.exc_info())\n            if exceptions:\n                e = exceptions[0]\n                del (\n                    exceptions\n                )  # ensure we don't keep all frames alive because of the traceback\n                six.reraise(*e)\n\n        finally:\n            hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n            hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n            # even if finalization fails, we invalidate\n            # the cached fixture value and remove\n            # all finalizers because they may be bound methods which will\n            # keep instances alive\n            if hasattr(self, \"cached_result\"):\n                del self.cached_result\n            self._finalizers = []",
            "start_line": 844,
            "start_column": 31740,
            "end_line": 4,
            "end_column": 32769,
            "start_byte": 31740,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.execute": {
            "name": "_pytest.fixtures.FixtureDef.execute",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def execute(self, request):\n        # get required arguments and register our own finish()\n        # with their finalization\n        for argname in self.argnames:\n            fixturedef = request._get_active_fixturedef(argname)\n            if argname != \"request\":\n                fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n\n        my_cache_key = request.param_index\n        cached_result = getattr(self, \"cached_result\", None)\n        if cached_result is not None:\n            result, cache_key, err = cached_result\n            if my_cache_key == cache_key:\n                if err is not None:\n                    six.reraise(*err)\n                else:\n                    return result\n            # we have a previous but differently parametrized fixture instance\n            # so we need to tear it down before creating a new one\n            self.finish(request)\n            assert not hasattr(self, \"cached_result\")\n\n        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n        return hook.pytest_fixture_setup(fixturedef=self, request=request)",
            "start_line": 871,
            "start_column": 32775,
            "end_line": 4,
            "end_column": 33881,
            "start_byte": 32775,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureDef.__repr__": {
            "name": "_pytest.fixtures.FixtureDef.__repr__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __repr__(self):\n        return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n            self.argname,\n            self.scope,\n            self.baseid,\n        )",
            "start_line": 896,
            "start_column": 33887,
            "end_line": 4,
            "end_column": 34055,
            "start_byte": 33887,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager": {
            "name": "_pytest.fixtures.FixtureManager",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "class FixtureManager(object):\n    \"\"\"\n    pytest fixtures definitions and information is stored and managed\n    from this class.\n\n    During collection fm.parsefactories() is called multiple times to parse\n    fixture function definitions into FixtureDef objects and internal\n    data structures.\n\n    During collection of test functions, metafunc-mechanics instantiate\n    a FuncFixtureInfo object which is cached per node/func-name.\n    This FuncFixtureInfo object is later retrieved by Function nodes\n    which themselves offer a fixturenames attribute.\n\n    The FuncFixtureInfo object holds information about fixtures and FixtureDefs\n    relevant for a particular function.  An initial list of fixtures is\n    assembled like this:\n\n    - ini-defined usefixtures\n    - autouse-marked fixtures along the collection chain up from the function\n    - usefixtures markers at module/class/function level\n    - test function funcargs\n\n    Subsequently the funcfixtureinfo.fixturenames attribute is computed\n    as the closure of the fixtures needed to setup the initial fixtures,\n    i. e. fixtures needed by fixture functions themselves are appended\n    to the fixturenames list.\n\n    Upon the test-setup phases all fixturenames are instantiated, retrieved\n    by a lookup of their FuncFixtureInfo.\n    \"\"\"\n\n    FixtureLookupError = FixtureLookupError\n    FixtureLookupErrorRepr = FixtureLookupErrorRepr\n\n    def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")\n\n    def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)\n\n    def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)\n\n    def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames\n\n    def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs\n\n    def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time\n\n    def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)\n\n    def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))\n\n    def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))\n\n    def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1077,
            "start_column": 40663,
            "end_line": 0,
            "end_column": 50680,
            "start_byte": 40663,
            "end_byte": 0
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupError": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupError",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupError = FixtureLookupError",
            "start_line": 1109,
            "start_column": 41972,
            "end_line": 4,
            "end_column": 42011,
            "start_byte": 41972,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr": {
            "name": "_pytest.fixtures.FixtureManager.FixtureLookupErrorRepr",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "FixtureLookupErrorRepr = FixtureLookupErrorRepr",
            "start_line": 1110,
            "start_column": 42016,
            "end_line": 4,
            "end_column": 42063,
            "start_byte": 42016,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.__init__": {
            "name": "_pytest.fixtures.FixtureManager.__init__",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def __init__(self, session):\n        self.session = session\n        self.config = session.config\n        self._arg2fixturedefs = {}\n        self._holderobjseen = set()\n        self._arg2finish = {}\n        self._nodeid_and_autousenames = [(\"\", self.config.getini(\"usefixtures\"))]\n        session.config.pluginmanager.register(self, \"funcmanage\")",
            "start_line": 1112,
            "start_column": 42069,
            "end_line": 4,
            "end_column": 42414,
            "start_byte": 42069,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureinfo": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureinfo",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureinfo(self, node, func, cls, funcargs=True):\n        if funcargs and not getattr(node, \"nofuncargs\", False):\n            argnames = getfuncargnames(func, cls=cls)\n        else:\n            argnames = ()\n        usefixtures = itertools.chain.from_iterable(\n            mark.args for mark in node.iter_markers(name=\"usefixtures\")\n        )\n        initialnames = tuple(usefixtures) + argnames\n        fm = node.session._fixturemanager\n        initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(\n            initialnames, node\n        )\n        return FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)",
            "start_line": 1121,
            "start_column": 42420,
            "end_line": 4,
            "end_column": 43070,
            "start_byte": 42420,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_plugin_registered": {
            "name": "_pytest.fixtures.FixtureManager.pytest_plugin_registered",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_plugin_registered(self, plugin):\n        nodeid = None\n        try:\n            p = py.path.local(plugin.__file__).realpath()\n        except AttributeError:\n            pass\n        else:\n            # construct the base nodeid which is later used to check\n            # what fixtures are visible for particular tests (as denoted\n            # by their test id)\n            if p.basename.startswith(\"conftest.py\"):\n                nodeid = p.dirpath().relto(self.config.rootdir)\n                if p.sep != nodes.SEP:\n                    nodeid = nodeid.replace(p.sep, nodes.SEP)\n\n        self.parsefactories(plugin, nodeid)",
            "start_line": 1136,
            "start_column": 43076,
            "end_line": 4,
            "end_column": 43711,
            "start_byte": 43076,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._getautousenames": {
            "name": "_pytest.fixtures.FixtureManager._getautousenames",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _getautousenames(self, nodeid):\n        \"\"\" return a tuple of fixture names to be used. \"\"\"\n        autousenames = []\n        for baseid, basenames in self._nodeid_and_autousenames:\n            if nodeid.startswith(baseid):\n                if baseid:\n                    i = len(baseid)\n                    nextchar = nodeid[i : i + 1]\n                    if nextchar and nextchar not in \":/\":\n                        continue\n                autousenames.extend(basenames)\n        return autousenames",
            "start_line": 1153,
            "start_column": 43717,
            "end_line": 4,
            "end_column": 44222,
            "start_byte": 43717,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixtureclosure": {
            "name": "_pytest.fixtures.FixtureManager.getfixtureclosure",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixtureclosure(self, fixturenames, parentnode):\n        # collect the closure of all fixtures , starting with the given\n        # fixturenames as the initial set.  As we have to visit all\n        # factory definitions anyway, we also return an arg2fixturedefs\n        # mapping so that the caller can reuse it and does not have\n        # to re-discover fixturedefs again for each fixturename\n        # (discovering matching fixtures for a given name/node is expensive)\n\n        parentid = parentnode.nodeid\n        fixturenames_closure = self._getautousenames(parentid)\n\n        def merge(otherlist):\n            for arg in otherlist:\n                if arg not in fixturenames_closure:\n                    fixturenames_closure.append(arg)\n\n        merge(fixturenames)\n\n        # at this point, fixturenames_closure contains what we call \"initialnames\",\n        # which is a set of fixturenames the function immediately requests. We\n        # need to return it as well, so save this.\n        initialnames = tuple(fixturenames_closure)\n\n        arg2fixturedefs = {}\n        lastlen = -1\n        while lastlen != len(fixturenames_closure):\n            lastlen = len(fixturenames_closure)\n            for argname in fixturenames_closure:\n                if argname in arg2fixturedefs:\n                    continue\n                fixturedefs = self.getfixturedefs(argname, parentid)\n                if fixturedefs:\n                    arg2fixturedefs[argname] = fixturedefs\n                    merge(fixturedefs[-1].argnames)\n\n        def sort_by_scope(arg_name):\n            try:\n                fixturedefs = arg2fixturedefs[arg_name]\n            except KeyError:\n                return scopes.index(\"function\")\n            else:\n                return fixturedefs[-1].scopenum\n\n        fixturenames_closure.sort(key=sort_by_scope)\n        return initialnames, fixturenames_closure, arg2fixturedefs",
            "start_line": 1166,
            "start_column": 44228,
            "end_line": 4,
            "end_column": 46132,
            "start_byte": 44228,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_generate_tests": {
            "name": "_pytest.fixtures.FixtureManager.pytest_generate_tests",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_generate_tests(self, metafunc):\n        for argname in metafunc.fixturenames:\n            faclist = metafunc._arg2fixturedefs.get(argname)\n            if faclist:\n                fixturedef = faclist[-1]\n                if fixturedef.params is not None:\n                    markers = list(metafunc.definition.iter_markers(\"parametrize\"))\n                    for parametrize_mark in markers:\n                        if \"argnames\" in parametrize_mark.kwargs:\n                            argnames = parametrize_mark.kwargs[\"argnames\"]\n                        else:\n                            argnames = parametrize_mark.args[0]\n\n                        if not isinstance(argnames, (tuple, list)):\n                            argnames = [\n                                x.strip() for x in argnames.split(\",\") if x.strip()\n                            ]\n                        if argname in argnames:\n                            break\n                    else:\n                        metafunc.parametrize(\n                            argname,\n                            fixturedef.params,\n                            indirect=True,\n                            scope=fixturedef.scope,\n                            ids=fixturedef.ids,\n                        )\n            else:\n                continue  # will raise FixtureLookupError at setup time",
            "start_line": 1212,
            "start_column": 46138,
            "end_line": 4,
            "end_column": 47495,
            "start_byte": 46138,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems": {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def pytest_collection_modifyitems(self, items):\n        # separate parametrized setups\n        items[:] = reorder_items(items)",
            "start_line": 1242,
            "start_column": 47501,
            "end_line": 4,
            "end_column": 47627,
            "start_byte": 47501,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.parsefactories": {
            "name": "_pytest.fixtures.FixtureManager.parsefactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def parsefactories(self, node_or_obj, nodeid=NOTSET, unittest=False):\n        if nodeid is not NOTSET:\n            holderobj = node_or_obj\n        else:\n            holderobj = node_or_obj.obj\n            nodeid = node_or_obj.nodeid\n        if holderobj in self._holderobjseen:\n            return\n\n        self._holderobjseen.add(holderobj)\n        autousenames = []\n        for name in dir(holderobj):\n            # The attribute can be an arbitrary descriptor, so the attribute\n            # access below can raise. safe_getatt() ignores such exceptions.\n            obj = safe_getattr(holderobj, name, None)\n            marker = getfixturemarker(obj)\n            if not isinstance(marker, FixtureFunctionMarker):\n                # magic globals  with __getattr__ might have got us a wrong\n                # fixture attribute\n                continue\n\n            if marker.name:\n                name = marker.name\n\n            # during fixture definition we wrap the original fixture function\n            # to issue a warning if called directly, so here we unwrap it in order to not emit the warning\n            # when pytest itself calls the fixture function\n            if six.PY2 and unittest:\n                # hack on Python 2 because of the unbound methods\n                obj = get_real_func(obj)\n            else:\n                obj = get_real_method(obj, holderobj)\n\n            fixture_def = FixtureDef(\n                self,\n                nodeid,\n                name,\n                obj,\n                marker.scope,\n                marker.params,\n                unittest=unittest,\n                ids=marker.ids,\n            )\n\n            faclist = self._arg2fixturedefs.setdefault(name, [])\n            if fixture_def.has_location:\n                faclist.append(fixture_def)\n            else:\n                # fixturedefs with no location are at the front\n                # so this inserts the current fixturedef after the\n                # existing fixturedefs from external plugins but\n                # before the fixturedefs provided in conftests.\n                i = len([f for f in faclist if not f.has_location])\n                faclist.insert(i, fixture_def)\n            if marker.autouse:\n                autousenames.append(name)\n\n        if autousenames:\n            self._nodeid_and_autousenames.append((nodeid or \"\", autousenames))",
            "start_line": 1246,
            "start_column": 47633,
            "end_line": 4,
            "end_column": 50003,
            "start_byte": 47633,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager.getfixturedefs": {
            "name": "_pytest.fixtures.FixtureManager.getfixturedefs",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def getfixturedefs(self, argname, nodeid):\n        \"\"\"\n        Gets a list of fixtures which are applicable to the given node id.\n\n        :param str argname: name of the fixture to search for\n        :param str nodeid: full node id of the requesting test.\n        :return: list[FixtureDef]\n        \"\"\"\n        try:\n            fixturedefs = self._arg2fixturedefs[argname]\n        except KeyError:\n            return None\n        return tuple(self._matchfactories(fixturedefs, nodeid))",
            "start_line": 1306,
            "start_column": 50009,
            "end_line": 4,
            "end_column": 50494,
            "start_byte": 50009,
            "end_byte": 4
          },
          "_pytest.fixtures.FixtureManager._matchfactories": {
            "name": "_pytest.fixtures.FixtureManager._matchfactories",
            "file_path": "src/_pytest/fixtures.py",
            "file_content": "def _matchfactories(self, fixturedefs, nodeid):\n        for fixturedef in fixturedefs:\n            if nodes.ischildnode(fixturedef.baseid, nodeid):\n                yield fixturedef",
            "start_line": 1320,
            "start_column": 50500,
            "end_line": 4,
            "end_column": 50680,
            "start_byte": 50500,
            "end_byte": 4
          }
        }
      }
    }
  ]
}