{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7168",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:15:46.102172",
        "usage": "2074.8143196105957 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "delattr",
          "_assertion_pass",
          "disabled",
          "compile",
          "fullsource",
          "_ensure_relative_to_basetemp",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "find_spec",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "exitstatus",
          "MODULE_NOT_FOUND_ERROR",
          "reprtraceback",
          "_match_lines",
          "run",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "STRING_TYPES",
          "_is_setup_py",
          "_visit_filter",
          "_getnextfixturedef",
          "append_skipped",
          "REPORT_COLLECTING_RESOLUTION",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_E",
          "_inject_setup_function_fixture",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "pytest",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "_find_spec",
          "cached_result",
          "ApproxDecimal",
          "_parse_parametrize_args",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "_with_exception",
          "applymarker",
          "_check_all_skipped",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "check_xfail_no_run",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "FUNCARGNAMES",
          "INTERNAL_ERROR",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "_get_pdb_wrapper_class",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "_write_pyc_fp",
          "get_terminal_writer",
          "_param_ids_from",
          "exec_",
          "visit_Call",
          "inline_genitems",
          "writeorg",
          "__eq__",
          "update_testcase_duration",
          "USAGE_MSG",
          "_init_checker_class",
          "collect_one_node",
          "_code",
          "append_pass",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "_determine_main_color",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "value",
          "consider_preparse",
          "unittest",
          "_param_ids_generated",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "exec_module",
          "InvocationParams",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "_pformat_dispatch",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "from_parent",
          "_exec_lsof",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "RaisesContext",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "junitxml",
          "_mk_tmp",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "NODE_USE_FROM_PARENT",
          "pytest_assertion_pass",
          "LEVELNAME_FMT_REGEX",
          "_get_pos",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "T",
          "_log_cli_enabled",
          "on_rm_rf_error",
          "processoption",
          "_config",
          "LFPluginCollSkipfiles",
          "TestCaseFunction",
          "PYTESTER_COPY_EXAMPLE",
          "__contains__",
          "get_timeout_config_value",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "PYTEST_COLLECT_MODULE",
          "location",
          "_report_kwargs_from_json",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "_check_record_param_type",
          "format_explanation",
          "makeconftest",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "doctest",
          "fileno",
          "_validate_usepdb_cls",
          "Class",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "reprentries",
          "old_mark_config_key",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "families",
          "pytest_terminal_summary",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "_get_marks",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "map_fixname_class",
          "done",
          "_get_teardown_reports",
          "add_report_section",
          "PytestPluginManager",
          "getnode",
          "COLLECT_DIRECTORY_HOOK",
          "try_makedirs",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "D",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "PrintHelp",
          "MyOptionParser",
          "_gethookproxy",
          "parseconfig",
          "pytest_doctest_prepare_content",
          "pyobj_property",
          "scope2index",
          "getbasetemp",
          "_parse_fixture_args",
          "_addexcinfo",
          "_width_of_current_line",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "is_true",
          "evalcache_key",
          "_fail_on_non_top_pytest_plugins",
          "_format",
          "format_session_duration",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "FaultHandlerHooks",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "get_use_fixtures_for_node",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "wrap_pytest_function_for_tracing",
          "short_test_summary",
          "parse_num",
          "_checkargnotcontained",
          "python_keywords_allowed_list",
          "collect_by_name",
          "parsefactories",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "TeeCaptureIO",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "_add_stats",
          "repr",
          "SEP",
          "matchkeyword",
          "SubRequest",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "_ET",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_get_main_color",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "_capturing_for_request",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "_expecting_failure",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "cache_key",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "_getglobals",
          "generic_visit",
          "_W",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "StoreKey",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "_assert_expr_to_lineno",
          "autouse",
          "_importconftest",
          "PYTEST_TAG",
          "args",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "PytestDeprecationWarning",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "_has_param_ids",
          "__array_ufunc__",
          "MarkMapping",
          "AlwaysDispatchingPrettyPrinter",
          "summary_errors",
          "_ellipsize",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "__attrs_post_init__",
          "MARK_GEN",
          "fspath",
          "USAGE_ERROR",
          "_opentestcase",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "syspath_prepend",
          "rm_rf",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "find_suffixes",
          "fill_unfilled",
          "syspathinsert",
          "_S",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "istrue",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "set_when",
          "delenv",
          "_perform_collect",
          "_format_repr_exception",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "fault_handler_stderr_key",
          "raiseerror",
          "fnmatch_ex",
          "_runtest_for_main",
          "reprfuncargs",
          "Traceback",
          "pytest_runtestloop",
          "_setupstate",
          "item_capture",
          "TestReport",
          "longrepr",
          "capfd",
          "_try_repr_or_str",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "_get_multicapture",
          "cls",
          "getlocation",
          "parseconfigure",
          "repr_locals",
          "TeeSysCapture",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "_validate_ids",
          "visit_Name",
          "report_collect",
          "finish",
          "NO_PRINT_LOGS",
          "_compilecounter",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "_get_line_with_reprcrash_message",
          "_validate_explicit_parameters",
          "AssertionState",
          "ihook",
          "call_optional",
          "_highlight",
          "_get_override_ini_value",
          "ExceptionRepr",
          "putaround",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "__len__",
          "_is_last_item",
          "summary_stats",
          "__next__",
          "getrawcode",
          "_initrequest",
          "_CACHE_PREFIX_DIRS",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_fail",
          "_callfinalizers",
          "CollectErrorRepr",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "_AnyPurePath",
          "extract_suffixes",
          "_color_for_type_default",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "isiterable",
          "FSCollector",
          "BINOP_MAP",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "_update_message",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "_bytes_to_ascii",
          "ensure_newline",
          "saferepr",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "_get_assertion_exprs",
          "Exception",
          "mode",
          "CaptureResult",
          "str",
          "isparseable",
          "OK",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "evalxfail_key",
          "OptionGroup",
          "error",
          "LFPluginCollWrapper",
          "NodeMeta",
          "_is_capturing",
          "FixtureRequest",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "extraline",
          "ReprFileLocation",
          "format",
          "reprlocals",
          "_ANSI_ESCAPE_SEQ",
          "_create",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "scopeproperty",
          "getitem",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "initialnames",
          "LogXML",
          "__getitem__",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "exists",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_get_auto_indent",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "patchsysdict",
          "start_global_capturing",
          "record_testsuite_property",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "compile_",
          "assert_contains_lines",
          "chain",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "_write_entry_lines",
          "_teardown_towards",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "async_warn_and_skip",
          "lineno",
          "MoreQuietAction",
          "LineMatcher",
          "context",
          "fixtures",
          "__call__",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "get_cache_dir",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "_import_pdb_cls",
          "matchmark",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "freeze_support",
          "CaptureIO",
          "params",
          "isnosetest",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "skipped_by_mark_key",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "TERMINALWRITER_WRITER",
          "mkdir",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "plugins",
          "setdefault",
          "FILLFUNCARGS",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "_handle_teardown_sections",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "_remove_ansi_escape_sequences",
          "readlines",
          "inline_runsource",
          "cmdline",
          "__delitem__",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "CHECKER_CLASS",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "NO_TESTS_COLLECTED",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "_show_fixtures_per_test",
          "collect",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "MarkEvaluator",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "cached_eval",
          "writer",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "__slots__",
          "FixtureFunctionMarker",
          "rex_session_duration",
          "__bool__",
          "_parse_lsof_output",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "_get_direct_parametrize_args",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "assertstate_key",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "_PluggyPlugin",
          "no_re_match_line",
          "restore",
          "runpytest",
          "__exit__",
          "is_async_function",
          "_get_allow_unicode_flag",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_no_match_line",
          "_showfixtures_main",
          "_is_mocked",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "_setoption",
          "Node",
          "parametrize",
          "_setup_cli_logging",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_names",
          "_write_source",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "ReprEntry",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "_fixturemanager",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "pastebinfile_key",
          "_report_to_json",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "ExitCode",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "lines",
          "_CACHE_PREFIX_VALUES",
          "Interrupted",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "strip",
          "_wrapped_pdb_cls",
          "JUNIT_XML_DEFAULT_FAMILY",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "getexplanation",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "_get_number_flag",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "_T",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "_check_if_assertion_pass_impl",
          "unexpectedsuccess_key",
          "Exit",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "getcfg",
          "exit",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "_parse_parametrize_parameters",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "NoCapture",
          "_rewrite_test",
          "PercentStyleMultiline",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "reprfileloc",
          "Store",
          "FakeCollectModule",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "_surrounding_parens_on_own_lines",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_call_assertion_pass",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "__dir__",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "INTERRUPTED",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "wasvalid",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "sections",
          "__version__",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "getslaveinfoline",
          "_make_plural",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "_create_formatter",
          "_F",
          "_preparse",
          "idmaker",
          "FDCaptureBinary",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "with_args",
          "_get_active_fixturedef",
          "yield_fixture",
          "ascii_escaped",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "_eval_scope_callable",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "duration",
          "ApproxBase",
          "_get_stderr_fileno",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "check_strict_xfail",
          "from_exc_info",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "KNOWN_TYPES",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "maybe_wrap_pytest_function_for_tracing",
          "_state",
          "_in_suspended",
          "_PLUGGY_DIR",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "_prunetraceback",
          "addinivalue_line",
          "faulthandler",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "_prepare_content",
          "runitem",
          "clear_cache",
          "_istrue",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "_REPORTCHARS_DEFAULT",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "create_module",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "dir",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "FIXTURE_ARGS_ORDER",
          "call_and_report",
          "nofuncargs",
          "Config",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "invalidraise",
          "Module",
          "KeywordMapping",
          "Item",
          "_idvalset",
          "pytest_addhooks",
          "no_fnmatch_line",
          "__all__",
          "xml_key",
          "matchnodes",
          "read_global_capture",
          "_color_for_type",
          "_getini",
          "istestfunction",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "_write_content",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "resultlog_key",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "nodes",
          "reprcrash",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "_done",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "UNARY_MAP",
          "write",
          "get_fslocation_from_item",
          "session",
          "store",
          "out",
          "deselect_by_mark",
          "TESTS_FAILED",
          "spawn_pytest",
          "scopenum_function",
          "_WithException",
          "_matchnodes",
          "import_plugin",
          "TerminalWriter",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "_set_main_color",
          "builtin",
          "get_last_failed_paths",
          "_collectfile",
          "addFailure",
          "catching_logs",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "_typ_map",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "repr_failure",
          "saferepr",
          "pytest_runtest_makereport",
          "__repr__",
          "INTERNAL_ERROR",
          "repr_instance",
          "reprtraceback",
          "pytest_runtest_protocol",
          "ExceptionRepr",
          "pytest_internalerror"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:15:48.177034",
        "usage": "267.7140235900879 ms"
      },
      "request": {
        "tokens": [
          "repr_failure",
          "saferepr",
          "pytest_runtest_makereport",
          "__repr__",
          "INTERNAL_ERROR",
          "repr_instance",
          "reprtraceback",
          "pytest_runtest_protocol",
          "ExceptionRepr",
          "pytest_internalerror"
        ]
      },
      "response": {
        "results": {
          "pytest_internalerror": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/skipping.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/main.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/unittest.py"
          ],
          "__repr__": [
            "src/_pytest/monkeypatch.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/main.py"
          ],
          "reprtraceback": [
            "src/_pytest/_code/code.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/reports.py",
            "src/_pytest/junitxml.py"
          ],
          "saferepr": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python.py"
          ],
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "INTERNAL_ERROR": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py"
          ],
          "repr_instance": [
            "src/_pytest/_io/saferepr.py"
          ],
          "ExceptionRepr": [
            "src/_pytest/_code/code.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:15:48.444773",
        "usage": "7730.060815811157 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest_internalerror": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/capture.py",
            "src/_pytest/debugging.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/terminal.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py"
          ],
          "pytest_runtest_makereport": [
            "src/_pytest/unittest.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/runner.py",
            "src/_pytest/skipping.py"
          ],
          "pytest_runtest_protocol": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/warnings.py",
            "src/_pytest/main.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/unittest.py"
          ],
          "__repr__": [
            "src/_pytest/monkeypatch.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/nodes.py",
            "src/_pytest/main.py"
          ],
          "reprtraceback": [
            "src/_pytest/_code/code.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/reports.py",
            "src/_pytest/junitxml.py"
          ],
          "saferepr": [
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/compat.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python.py"
          ],
          "repr_failure": [
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ],
          "INTERNAL_ERROR": [
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py"
          ],
          "repr_instance": [
            "src/_pytest/_io/saferepr.py"
          ],
          "ExceptionRepr": [
            "src/_pytest/_code/code.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue involves an INTERNALERROR with pytest that occurs when there's an exception raised during the __repr__ method of a class. The stack trace suggests the problem might be occurring in parts of the code related to saferepr and the SafeRepr class. \n\nI'll look at keywords related to __repr__, repr_failure, repr_instance, saferepr, and the INTERNALERROR since all these relate to the representation of exceptions and errors within pytest's codebase.\n\n1. **saferepr** - This is directly related to the safe representation of objects, which is involved in the stack trace's call sequence.\n   - **src/_pytest/_io/saferepr.py**: This file contains the saferepr function and is directly mentioned in the stack trace, so it's very relevant.\n\n2. **repr_instance** - Also directly involved in the process of handling exceptions in __repr__ during testing.\n   - **src/_pytest/_io/saferepr.py**: This file appears again here, which suggests it's highly relevant for more than one reason.\n\n3. **__repr__** - This keyword is crucial as it's part of the reported problem with exception handling.\n   - **src/_pytest/_code/code.py**: In the stack trace and potentially part of handling exception representation.\n   - **src/_pytest/_io/saferepr.py**: Once again, this file is implicated because of the significant role saferepr plays in the issue.\n\n4. **INTERNALERROR** - This keyword is linked to the root issue where pytest throws an internal error due to the exception in __repr__.\n   - **src/_pytest/main.py**: This file is specifically mentioned in the issue's stack trace, where the internal error occurs.\n\n5. Considering the relevance to the error handling and stack, these files should be checked in order of direct mention in the stack and relevance to saferepr since the problem seems deeply linked with how pytest deals with object representation internally.",
        "file_paths": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/main.py",
          "src/_pytest/_code/code.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:15:56.174858",
        "usage": "10944.418907165527 ms"
      },
      "request": {
        "file_path": "src/_pytest/_io/saferepr.py"
      },
      "response": {
        "scratch_pad": "## Step 1: Analyze User Instructions\n1.1 The user has reported an issue that arises as an INTERNALERROR when there's an exception in `__repr__`.\n1.2 The user provided a minimal code to reproduce that shows an exception is raised in `__repr__` and `__getattribute__` methods of a class.\n1.3 The issue causes an INTERNALERROR during pytest's test run session when exceptions are not properly handled in `__repr__`. The `repr_failure` mechanism in pytest was trying to get the representation of the exception, which itself raised an error.\n1.4 The expectation is that exceptions in `__repr__` should not cause INTERNALERROR in pytest. Instead, it should be caught and represented in some safe manner.\n1.5 The issue may be a result of improper handling of exceptions in the `_format_repr_exception` or similar functions designed to catch and format exceptions when `saferepr` is called.\n\n## Step 2: Make File Evaluation\n2.1 Review the file `saferepr.py` for the handling of exceptions in `repr` calls.\n2.2 Identify relevant functions:\n- `saferepr(obj: Any, maxsize: int = 240)`\n- `SafeRepr.repr`\n- `_format_repr_exception(exc: BaseException, obj: Any)`\n\n2.3 These functions are directly involved in capturing exceptions during `repr` calls and returning a safe representation of objects even when their `__repr__` method raises exceptions.\n2.4 `_format_repr_exception` is likely trying to construct a string with information about the exception raised, which could be improved to handle exceptions better.\n2.5 The file content matches and targets the root issue of unhandled exception propagation in the `repr` calls, which might be causing the internal error during exception repr failures in `_pytest/main.py` and related files.\n\n## Conclusion\nThe file `saferepr.py` is highly relevant and likely the root cause of the issue, based on its function definitions aligned with exception handling during `repr` errors.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "_try_repr_or_str",
          "_format_repr_exception",
          "SafeRepr.repr",
          "saferepr",
          "SafeRepr"
        ],
        "root_cause_symbols": [
          "_try_repr_or_str",
          "_format_repr_exception",
          "SafeRepr.repr",
          "saferepr",
          "SafeRepr"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:16:07.119311",
        "usage": "9116.703033447266 ms"
      },
      "request": {
        "file_path": "src/_pytest/main.py"
      },
      "response": {
        "scratch_pad": "1. User Instructions Analysis:\n   - The reported issue is an INTERNALERROR occurring when executing a test with pytest.\n   - The user provides a minimal reproducible example, which raises an exception in a class's `__repr__` method during a test run.\n   - The issue likely arises because pytest attempts to display information about the test object, and the `__repr__` method of the object raises an exception, leading to an internal error rather than a controlled test failure.\n   - The user expects that when `__repr__` raises an exception, it should be handled more gracefully, possibly logging a failure with relevant details rather than causing an internal pytest error.\n   - A possible solution could involve adding try-except blocks when calling `__repr__` and converting such exceptions to more user-friendly error messages or logs rather than crashing internally.\n\n2. File Evaluation:\n   - The file `src/_pytest/main.py` contains core implementations of testing processes like session initialization and test loops.\n   - The function `wrap_session` is involved in handling exceptions during the session, setting `session.exitstatus` based on the type of exception.\n   - The traceback provided in the issue report shows that the failure occurs when pytest tries to make a report (`pytest_runtest_makereport`), which indirectly calls `repr_failure` on the test item.\n   - `wrap_session` catches generic exceptions, sets `session.exitstatus` to `ExitCode.INTERNAL_ERROR`, and calls `config.notify_exception`.\n   - There's no explicit handling for exceptions within `__repr__` in this file, but `wrap_session` is crucial as it deals with session lifecycles and exception notification.\n\n3. Decision:\n   - This file is related to the issue but not the root cause. The root cause likely involves how pytest attempts to represent test objects using their `__repr__` methods in places like `_pytest/reports.py` or `_pytest/nodes.py`.\n   - We should dive deeper into the specific function or section that calls `__repr__` during the reporting to handle exceptions properly. The `saferepr` function in `_pytest/_io/saferepr.py` is directly mentioned in the traceback, suggesting that it could handle `__repr__` exceptions better.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "_pytest/_io/saferepr.py",
          "_pytest/reports.py",
          "_pytest/nodes.py"
        ],
        "relevant_symbols": [
          "wrap_session",
          "Session"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:16:16.236044",
        "usage": "9823.944091796875 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "Analyzing the issue:\n1. The user is experiencing an `INTERNALERROR` when there is an exception in the `__repr__` method of a class. The specific error provided in the traceback is `RuntimeError: No active exception to reraise`, which indicates that a `raise` statement is being used without an active exception context, particularly in the `__repr__` method of `SomeClass`.\n\n2. The minimal code provided by the user to reproduce the error is:\n   - A class `SomeClass` with an `__getattribute__` method and a `__repr__` method, both raising exceptions.\n   - The `test()` function attempts to access an attribute of `SomeClass`, triggering the error.\n\n3. The cause of the issue seems to be related to `pytest`'s handling of exceptions during testing, particularly when exceptions are raised without a proper context to reraise.\n\n4. User expectation is to handle exceptions in the `__repr__` method more gracefully, leading to a manageable error message rather than an `INTERNALERROR`.\n\n5. Possible solutions include tweaking how exceptions are captured, handled, or prevented during `__repr__` calls, possibly through modifying the exception handling in `pytest`, or ensuring that `__repr__` is never left unpredictable or user functions properly handle exceptions.\n\nFile Examination:\n- The file `src/_pytest/_code/code.py` contains error and exception handling functions, among other utilities.\n- The method `ExceptionInfo.getrepr` and related methods in the file are responsible for formatting and managing exception information.\n- Functions like `formattedExcinfo.repr_excinfo` and `saferepr` are used for creating safe string representations of exceptions.\n- These methods could be the location where the exceptions are not being correctly handled when triggered from `__repr__` methods if `raise` is improperly used.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_io/saferepr.py",
          "src/_pytest/main.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [
          "safeformat",
          "saferepr",
          "FormattedExcinfo.repr_excinfo",
          "ExceptionInfo.getrepr",
          "TracebackEntry.__repr__"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:16:26.060030",
        "usage": "152.9991626739502 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/_io/saferepr.py",
            "relevant_symbol_keys": [
              "_try_repr_or_str",
              "_format_repr_exception",
              "SafeRepr.repr",
              "saferepr",
              "SafeRepr"
            ],
            "root_cause_symbol_keys": [
              "_try_repr_or_str",
              "_format_repr_exception",
              "SafeRepr.repr",
              "saferepr",
              "SafeRepr"
            ]
          },
          {
            "file_path": "src/_pytest/main.py",
            "relevant_symbol_keys": [
              "wrap_session",
              "Session"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "safeformat",
              "saferepr",
              "FormattedExcinfo.repr_excinfo",
              "ExceptionInfo.getrepr",
              "TracebackEntry.__repr__"
            ],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.TracebackEntry.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<TracebackEntry %s:%d>\" % (self.frame.code.path, self.lineno + 1)",
            "start_line": 206,
            "start_column": 6201,
            "end_line": 4,
            "end_column": 6309,
            "start_byte": 6201,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, other):\n        return not self == other\n\n    @property\n    def path(self) -> Union[py.path.local, str]:\n        \"\"\" return a path object pointing to source code (or a str in case\n        of OSError / non-existing file).\n",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._try_repr_or_str",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _try_repr_or_str(obj):\n    try:\n        return repr(obj)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException:\n        return '{}(\"{}\")'.format(type(obj).__name__, obj)",
            "start_line": 5,
            "start_column": 54,
            "end_line": 0,
            "end_column": 256,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "class SafeRepr(reprlib.Repr):\n    \"\"\"subclass of repr.Repr that limits the resulting size of repr()\n    and includes information on exceptions raised during the call.\n    \"\"\"\n\n    def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize\n\n    def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)\n\n    def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 34,
            "start_column": 875,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 875,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.__init__",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize",
            "start_line": 39,
            "start_column": 1055,
            "end_line": 4,
            "end_column": 1187,
            "start_byte": 1055,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T12:16:26.213035",
        "usage": "22997.771978378296 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.TracebackEntry.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<TracebackEntry %s:%d>\" % (self.frame.code.path, self.lineno + 1)",
            "start_line": 206,
            "start_column": 6201,
            "end_line": 4,
            "end_column": 6309,
            "start_byte": 6201,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, other):\n        return not self == other\n\n    @property\n    def path(self) -> Union[py.path.local, str]:\n        \"\"\" return a path object pointing to source code (or a str in case\n        of OSError / non-existing file).\n",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest._io._try_repr_or_str",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _try_repr_or_str(obj):\n    try:\n        return repr(obj)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException:\n        return '{}(\"{}\")'.format(type(obj).__name__, obj)",
            "start_line": 5,
            "start_column": 54,
            "end_line": 0,
            "end_column": 256,
            "start_byte": 54,
            "end_byte": 0
          },
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "class SafeRepr(reprlib.Repr):\n    \"\"\"subclass of repr.Repr that limits the resulting size of repr()\n    and includes information on exceptions raised during the call.\n    \"\"\"\n\n    def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize\n\n    def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)\n\n    def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 34,
            "start_column": 875,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 875,
            "end_byte": 0
          },
          {
            "name": "_pytest._io.SafeRepr.__init__",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize",
            "start_line": 39,
            "start_column": 1055,
            "end_line": 4,
            "end_column": 1187,
            "start_byte": 1055,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "1.1 What issue is the user describing?\n- The issue is that an INTERNALERROR occurs when an exception is raised in the __repr__ method of a class during pytest execution.\n\n1.2 How was this issue caused?\n- When pytest tries to represent an object using __repr__, and the __repr__ method of the object raises an exception, it leads to an unhandled exception causing INTERNALERROR.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result should be that the exception in the __repr__ method should be handled gracefully by pytest without causing INTERNALERROR.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- Pytest should handle exceptions raised in __repr__ methods gracefully without causing an INTERNALERROR. A proper error message should be presented to the user indicating that __repr__ failed, instead of a cascade of internal errors.\n\n1.5 How should the issue be fixed to meet the expectation?\n- Modify the saferepr function in _pytest/_io/saferepr.py to ensure that exceptions, including ones without active exceptions to re-raise, are safely represented without causing an INTERNALERROR in pytest.\n\n2.1. Analyze lines in the <symbol>.\n2.2. Match the symbol with essential patterns in the issue.\n2.3. Evaluate each symbol's relevance in the context of the issue.\n2.4. Determine how many symbols need to be changed to solve the issue.\n\n- Analyzing the saferepr module where exceptions in __repr__ might be caught and transformed into a string representation:\n  - Symbols _try_repr_or_str, _format_repr_exception, and SafeRepr are likely part of the saferepr transformation logic.\n  - Symbols breaking the logic could lead to not catching exceptions cleanly during the saferepr transformation, potentially triggering INTERNALERROR when __repr__ fails.\n\n2.5. If more file content or symbol information is needed, request from the user. However, review provided symbols first.",
        "symbols": [
          {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "The repr_instance method utilizes repr, and the given exception handling only formats existing exceptions but does not handle cases where there are no active exceptions to re-raise. Since repr_instance is specifically provided in the traceback processing, it might be involved in repr handling during pytest tracing. It uses _format_repr_exception for formatting exceptions, which could contribute to errors if the original issue is pinpointed in the contents of _format_repr_exception or how exceptions are logged."
          },
          {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "The repr method is responsible for calling repr on objects and handling exceptions by using _format_repr_exception. It appears directly responsible for converting the object into a safe string representation for pytest internals and might need modification to handle non-standard exception flows."
          },
          {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This function likely needs to ensure it catches and formats exceptions raised in __repr__ functions without causing an internal error in pytest. It creates a SafeRepr instance and may be central to handling exceptions safely."
          },
          {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "reason": "This function deals with formatting exceptions when they occur in _try_repr_or_str. It formats exceptions raised during saferepr operations and may need to incorporate logic to handle cases where there is no active exception to re-raise, aligning with the issue described."
          }
        ],
        "more_info": [],
        "is_done": false,
        "symbols_scratch_pad": [
          "Symbol _pytest._io._try_repr_or_str doesn't directly engage in repr handling; it catches exceptions during repr conversion, returning a formatted string, likely necessary for debug logging or failure contexts in pytest. Though it formats exceptions when caught, it does not engage with flows causing internal errors. Skipped.",
          "Symbol _pytest._io._format_repr_exception is a key function that formats exceptions involving objects during saferepr operations. The issue might emerge here if base exceptions aren't handled, or if it's not properly dealing with exceptions where repr operations fail without active exceptions to re-raise.",
          "Symbol _pytest._io.SafeRepr encapsulates repr mechanisms using repr_instance and repr. It manages how objects are safely converted to strings while handling exceptions. Its operation directly impacts whether errors during __repr__ of user-defined objects cause safe failures or uncaught exceptions, suggesting modification areas if current mechanisms allow brief exceptions to cascade into INTERNALERROR.",
          "Symbol _pytest._io.SafeRepr.__init__ described method initializing SafeRepr's configuration. No obvious connection to the issue as it's a constructor method and doesn't manage object representation or exception handling interpreted by __repr__.",
          "Symbol _pytest._io.SafeRepr.repr surrounds the saferepr transformation. Depending on the SafeRepr mechanism using _format_repr_exception for managing exceptions in repr(), it could miss covering cases where exception handling should support operations like SystemExit or non-standard fails absence. This suggests repr alone might handle these exceptions differently leading to INTERNALERROR when executed conjunctively with __repr__ internally raising exceptions without active ones to catch.",
          "Symbol _pytest._io.SafeRepr.repr_instance processes safe_repr_plugin logic during object representation and exception incidents. More introspection needed, as intricacies in handling exceptions-related errors have yet to ensure safeguards in SecondaryExceptionInfo usage scenarios, especially given involved with the plugins and possibly implied hooking into saferepr processes.",
          "Symbol _pytest._io.saferepr operating as external point invoking SafeRepr. Its efficacy predicates on repr_instance and repr's functional encapsulation within SafeRepr capturing initialization-safe values and effectively managing carried over exceptions to convey fails safely; potential alteration to extend handling especially for active exceptions in repr results analysis suggested.",
          "Symbol _pytest.assertion._saferepr is an empty symbol lacking context, likely an oversight or placeholder within assertion frameworks. No evaluation can be constructed due to absent content or functionality information. Subsequently not relevant."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T12:16:49.210871",
        "usage": "3.4470558166503906 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.main.wrap_session",
              "file_path": "src/_pytest/main.py",
              "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
              "start_line": 177,
              "start_column": 5040,
              "end_line": 0,
              "end_column": 7567,
              "start_byte": 5040,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 367,
              "start_column": 11404,
              "end_line": 0,
              "end_column": 24571,
              "start_byte": 11404,
              "end_byte": 0
            },
            {
              "name": "_pytest.main.Session.Interrupted",
              "file_path": "src/_pytest/main.py",
              "file_content": "Interrupted = Interrupted",
              "start_line": 368,
              "start_column": 11442,
              "end_line": 4,
              "end_column": 11467,
              "start_byte": 11442,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.Failed",
              "file_path": "src/_pytest/main.py",
              "file_content": "Failed = Failed",
              "start_line": 369,
              "start_column": 11472,
              "end_line": 4,
              "end_column": 11487,
              "start_byte": 11472,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._setupstate",
              "file_path": "src/_pytest/main.py",
              "file_content": "_setupstate = None",
              "start_line": 371,
              "start_column": 11548,
              "end_line": 4,
              "end_column": 11566,
              "start_byte": 11548,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._fixturemanager",
              "file_path": "src/_pytest/main.py",
              "file_content": "_fixturemanager = None",
              "start_line": 373,
              "start_column": 11649,
              "end_line": 4,
              "end_column": 11671,
              "start_byte": 11649,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.exitstatus",
              "file_path": "src/_pytest/main.py",
              "file_content": "exitstatus = None",
              "start_line": 374,
              "start_column": 11700,
              "end_line": 4,
              "end_column": 11717,
              "start_byte": 11700,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__init__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
              "start_line": 376,
              "start_column": 11753,
              "end_line": 4,
              "end_column": 13031,
              "start_byte": 11753,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.from_config",
              "file_path": "src/_pytest/main.py",
              "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
              "start_line": 408,
              "start_column": 13037,
              "end_line": 4,
              "end_column": 13118,
              "start_byte": 13037,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.__repr__",
              "file_path": "src/_pytest/main.py",
              "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
              "start_line": 412,
              "start_column": 13124,
              "end_line": 4,
              "end_column": 13404,
              "start_byte": 13124,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._node_location_to_relpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
              "start_line": 421,
              "start_column": 13410,
              "end_line": 4,
              "end_column": 13575,
              "start_byte": 13410,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectstart",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
              "start_line": 425,
              "start_column": 13581,
              "end_line": 4,
              "end_column": 13795,
              "start_byte": 13581,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_runtest_logreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
              "start_line": 432,
              "start_column": 13801,
              "end_line": 4,
              "end_column": 14163,
              "start_byte": 13801,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.pytest_collectreport",
              "file_path": "src/_pytest/main.py",
              "file_content": "pytest_collectreport = pytest_runtest_logreport",
              "start_line": 440,
              "start_column": 14169,
              "end_line": 4,
              "end_column": 14216,
              "start_byte": 14169,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.isinitpath",
              "file_path": "src/_pytest/main.py",
              "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
              "start_line": 442,
              "start_column": 14222,
              "end_line": 4,
              "end_column": 14291,
              "start_byte": 14222,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.gethookproxy",
              "file_path": "src/_pytest/main.py",
              "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
              "start_line": 445,
              "start_column": 14297,
              "end_line": 4,
              "end_column": 14388,
              "start_byte": 14297,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
              "start_line": 448,
              "start_column": 14394,
              "end_line": 4,
              "end_column": 14862,
              "start_byte": 14394,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._perform_collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
              "start_line": 461,
              "start_column": 14868,
              "end_line": 4,
              "end_column": 16102,
              "start_byte": 14868,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
              "start_line": 492,
              "start_column": 16108,
              "end_line": 4,
              "end_column": 16843,
              "start_byte": 16108,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._collect",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
              "start_line": 510,
              "start_column": 16849,
              "end_line": 4,
              "end_column": 20645,
              "start_byte": 16849,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._visit_filter",
              "file_path": "src/_pytest/main.py",
              "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
              "start_line": 589,
              "start_column": 20651,
              "end_line": 4,
              "end_column": 20721,
              "start_byte": 20651,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._tryconvertpyarg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
              "start_line": 593,
              "start_column": 20727,
              "end_line": 4,
              "end_column": 21331,
              "start_byte": 20727,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._parsearg",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
              "start_line": 609,
              "start_column": 21337,
              "end_line": 4,
              "end_column": 22022,
              "start_byte": 21337,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
              "start_line": 625,
              "start_column": 22028,
              "end_line": 4,
              "end_column": 22412,
              "start_byte": 22028,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session._matchnodes",
              "file_path": "src/_pytest/main.py",
              "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
              "start_line": 636,
              "start_column": 22418,
              "end_line": 4,
              "end_column": 24096,
              "start_byte": 22418,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.Session.genitems",
              "file_path": "src/_pytest/main.py",
              "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
              "start_line": 673,
              "start_column": 24102,
              "end_line": 4,
              "end_column": 24571,
              "start_byte": 24102,
              "end_byte": 4
            },
            {
              "name": "_pytest.pytester.Testdir.Session",
              "file_path": "src/_pytest/main.py",
              "file_content": "",
              "start_line": 772,
              "start_column": 25095,
              "end_line": 4,
              "end_column": 25112,
              "start_byte": 25095,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.TracebackEntry.__repr__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __repr__(self) -> str:\n        return \"<TracebackEntry %s:%d>\" % (self.frame.code.path, self.lineno + 1)",
              "start_line": 206,
              "start_column": 6201,
              "end_line": 4,
              "end_column": 6309,
              "start_byte": 6201,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 577,
              "start_column": 19023,
              "end_line": 4,
              "end_column": 20900,
              "start_byte": 19023,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
              "start_line": 868,
              "start_column": 30141,
              "end_line": 4,
              "end_column": 32060,
              "start_byte": 30141,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.safeformat",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, other):\n        return not self == other\n\n    @property\n    def path(self) -> Union[py.path.local, str]:\n        \"\"\" return a path object pointing to source code (or a str in case\n        of OSError / non-existing file).\n",
              "start_line": 63,
              "start_column": 1751,
              "end_line": 0,
              "end_column": 2074,
              "start_byte": 1751,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "     \"\"\"\n        if not self.raw.co_filename:\n            return \"\"\n        try:\n            p = py.path.local(self.raw.co_filename)\n            # maybe don't try this checking\n            if not p.check():\n                raise OSError(\"py.path check failed.\")\n            return p\n        except OSError:\n            # XXX maybe try harder like the weird logic\n            # in the standard lib [linecache.updatecache] does?\n        ",
              "start_line": 74,
              "start_column": 2077,
              "end_line": 0,
              "end_column": 2512,
              "start_byte": 2077,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "y.frame.f_locals)\n        return None\n\n\nco_equal = compile(\n    \"__recursioncache_locals_1 == __recursioncache_locals_2\", \"?\", \"eval\"\n)\n\n\n_E = TypeVar(\"_E\", bound=BaseException)\n\n\n@attr.s(repr=False)\nclass ExceptionInfo(Generic[_E]):\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib(type=Optional[Tuple[\"Type[_E]\", \"_E\", TracebackType]])\n    _striptext = attr.ib(type=str, d",
              "start_line": 375,
              "start_column": 13624,
              "end_line": 0,
              "end_column": 14124,
              "start_byte": 13624,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest._io._try_repr_or_str",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _try_repr_or_str(obj):\n    try:\n        return repr(obj)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException:\n        return '{}(\"{}\")'.format(type(obj).__name__, obj)",
              "start_line": 5,
              "start_column": 54,
              "end_line": 0,
              "end_column": 256,
              "start_byte": 54,
              "end_byte": 0
            },
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
              "start_line": 14,
              "start_column": 259,
              "end_line": 0,
              "end_column": 665,
              "start_byte": 259,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.SafeRepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "class SafeRepr(reprlib.Repr):\n    \"\"\"subclass of repr.Repr that limits the resulting size of repr()\n    and includes information on exceptions raised during the call.\n    \"\"\"\n\n    def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize\n\n    def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)\n\n    def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 34,
              "start_column": 875,
              "end_line": 0,
              "end_column": 1748,
              "start_byte": 875,
              "end_byte": 0
            },
            {
              "name": "_pytest._io.SafeRepr.__init__",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize",
              "start_line": 39,
              "start_column": 1055,
              "end_line": 4,
              "end_column": 1187,
              "start_byte": 1055,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 44,
              "start_column": 1193,
              "end_line": 4,
              "end_column": 1461,
              "start_byte": 1193,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
              "start_line": 53,
              "start_column": 1467,
              "end_line": 4,
              "end_column": 1748,
              "start_byte": 1467,
              "end_byte": 4
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
              "start_line": 74,
              "start_column": 2077,
              "end_line": 0,
              "end_column": 2512,
              "start_byte": 2077,
              "end_byte": 0
            },
            {
              "name": "_pytest.assertion._saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "file_content": "",
              "start_line": 375,
              "start_column": 13624,
              "end_line": 0,
              "end_column": 14124,
              "start_byte": 13624,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1.1 What issue is the user describing?\n- The issue is that an INTERNALERROR occurs when an exception is raised in the __repr__ method of a class during pytest execution.\n\n1.2 How was this issue caused?\n- When pytest tries to represent an object using __repr__, and the __repr__ method of the object raises an exception, it leads to an unhandled exception causing INTERNALERROR.\n\n1.3 If the user described the expected result, what should it be fixed to?\n- The expected result should be that the exception in the __repr__ method should be handled gracefully by pytest without causing INTERNALERROR.\n\n1.4 If the user did not provide an expected result, what should the expectation be?\n- Pytest should handle exceptions raised in __repr__ methods gracefully without causing an INTERNALERROR. A proper error message should be presented to the user indicating that __repr__ failed, instead of a cascade of internal errors.\n\n1.5 How should the issue be fixed to meet the expectation?\n- Modify the saferepr function in _pytest/_io/saferepr.py to ensure that exceptions, including ones without active exceptions to re-raise, are safely represented without causing an INTERNALERROR in pytest.\n\n2.1. Analyze lines in the <symbol>.\n2.2. Match the symbol with essential patterns in the issue.\n2.3. Evaluate each symbol's relevance in the context of the issue.\n2.4. Determine how many symbols need to be changed to solve the issue.\n\n- Analyzing the saferepr module where exceptions in __repr__ might be caught and transformed into a string representation:\n  - Symbols _try_repr_or_str, _format_repr_exception, and SafeRepr are likely part of the saferepr transformation logic.\n  - Symbols breaking the logic could lead to not catching exceptions cleanly during the saferepr transformation, potentially triggering INTERNALERROR when __repr__ fails.\n\n2.5. If more file content or symbol information is needed, request from the user. However, review provided symbols first.",
          "symbols": [
            {
              "name": "_pytest._io.SafeRepr.repr_instance",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "The repr_instance method utilizes repr, and the given exception handling only formats existing exceptions but does not handle cases where there are no active exceptions to re-raise. Since repr_instance is specifically provided in the traceback processing, it might be involved in repr handling during pytest tracing. It uses _format_repr_exception for formatting exceptions, which could contribute to errors if the original issue is pinpointed in the contents of _format_repr_exception or how exceptions are logged."
            },
            {
              "name": "_pytest._io.SafeRepr.repr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "The repr method is responsible for calling repr on objects and handling exceptions by using _format_repr_exception. It appears directly responsible for converting the object into a safe string representation for pytest internals and might need modification to handle non-standard exception flows."
            },
            {
              "name": "_pytest._io.saferepr",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This function likely needs to ensure it catches and formats exceptions raised in __repr__ functions without causing an internal error in pytest. It creates a SafeRepr instance and may be central to handling exceptions safely."
            },
            {
              "name": "_pytest._io._format_repr_exception",
              "file_path": "src/_pytest/_io/saferepr.py",
              "reason": "This function deals with formatting exceptions when they occur in _try_repr_or_str. It formats exceptions raised during saferepr operations and may need to incorporate logic to handle cases where there is no active exception to re-raise, aligning with the issue described."
            }
          ],
          "more_info": [],
          "is_done": false,
          "symbols_scratch_pad": [
            "Symbol _pytest._io._try_repr_or_str doesn't directly engage in repr handling; it catches exceptions during repr conversion, returning a formatted string, likely necessary for debug logging or failure contexts in pytest. Though it formats exceptions when caught, it does not engage with flows causing internal errors. Skipped.",
            "Symbol _pytest._io._format_repr_exception is a key function that formats exceptions involving objects during saferepr operations. The issue might emerge here if base exceptions aren't handled, or if it's not properly dealing with exceptions where repr operations fail without active exceptions to re-raise.",
            "Symbol _pytest._io.SafeRepr encapsulates repr mechanisms using repr_instance and repr. It manages how objects are safely converted to strings while handling exceptions. Its operation directly impacts whether errors during __repr__ of user-defined objects cause safe failures or uncaught exceptions, suggesting modification areas if current mechanisms allow brief exceptions to cascade into INTERNALERROR.",
            "Symbol _pytest._io.SafeRepr.__init__ described method initializing SafeRepr's configuration. No obvious connection to the issue as it's a constructor method and doesn't manage object representation or exception handling interpreted by __repr__.",
            "Symbol _pytest._io.SafeRepr.repr surrounds the saferepr transformation. Depending on the SafeRepr mechanism using _format_repr_exception for managing exceptions in repr(), it could miss covering cases where exception handling should support operations like SystemExit or non-standard fails absence. This suggests repr alone might handle these exceptions differently leading to INTERNALERROR when executed conjunctively with __repr__ internally raising exceptions without active ones to catch.",
            "Symbol _pytest._io.SafeRepr.repr_instance processes safe_repr_plugin logic during object representation and exception incidents. More introspection needed, as intricacies in handling exceptions-related errors have yet to ensure safeguards in SecondaryExceptionInfo usage scenarios, especially given involved with the plugins and possibly implied hooking into saferepr processes.",
            "Symbol _pytest._io.saferepr operating as external point invoking SafeRepr. Its efficacy predicates on repr_instance and repr's functional encapsulation within SafeRepr capturing initialization-safe values and effectively managing carried over exceptions to convey fails safely; potential alteration to extend handling especially for active exceptions in repr results analysis suggested.",
            "Symbol _pytest.assertion._saferepr is an empty symbol lacking context, likely an oversight or placeholder within assertion frameworks. No evaluation can be constructed due to absent content or functionality information. Subsequently not relevant."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_io/saferepr.py"
        ],
        "symbols": [
          "_pytest._io.SafeRepr.repr_instance",
          "_pytest._io.SafeRepr.repr",
          "_pytest._io.saferepr",
          "_pytest._io._format_repr_exception"
        ],
        "code_spans": {
          "_pytest.main.wrap_session": {
            "name": "_pytest.main.wrap_session",
            "file_path": "src/_pytest/main.py",
            "file_content": "def wrap_session(\n    config: Config, doit: Callable[[Config, \"Session\"], Optional[Union[int, ExitCode]]]\n) -> Union[int, ExitCode]:\n    \"\"\"Skeleton command line program\"\"\"\n    session = Session.from_config(config)\n    session.exitstatus = ExitCode.OK\n    initstate = 0\n    try:\n        try:\n            config._do_configure()\n            initstate = 1\n            config.hook.pytest_sessionstart(session=session)\n            initstate = 2\n            session.exitstatus = doit(config, session) or 0\n        except UsageError:\n            session.exitstatus = ExitCode.USAGE_ERROR\n            raise\n        except Failed:\n            session.exitstatus = ExitCode.TESTS_FAILED\n        except (KeyboardInterrupt, exit.Exception):\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            exitstatus = ExitCode.INTERRUPTED  # type: Union[int, ExitCode]\n            if isinstance(excinfo.value, exit.Exception):\n                if excinfo.value.returncode is not None:\n                    exitstatus = excinfo.value.returncode\n                if initstate < 2:\n                    sys.stderr.write(\n                        \"{}: {}\\n\".format(excinfo.typename, excinfo.value.msg)\n                    )\n            config.hook.pytest_keyboard_interrupt(excinfo=excinfo)\n            session.exitstatus = exitstatus\n        except:  # noqa\n            session.exitstatus = ExitCode.INTERNAL_ERROR\n            excinfo = _pytest._code.ExceptionInfo.from_current()\n            try:\n                config.notify_exception(excinfo, config.option)\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n            else:\n                if excinfo.errisinstance(SystemExit):\n                    sys.stderr.write(\"mainloop: caught unexpected SystemExit!\\n\")\n\n    finally:\n        # Explicitly break reference cycle.\n        excinfo = None  # type: ignore\n        session.startdir.chdir()\n        if initstate >= 2:\n            try:\n                config.hook.pytest_sessionfinish(\n                    session=session, exitstatus=session.exitstatus\n                )\n            except exit.Exception as exc:\n                if exc.returncode is not None:\n                    session.exitstatus = exc.returncode\n                sys.stderr.write(\"{}: {}\\n\".format(type(exc).__name__, exc))\n        config._ensure_unconfigure()\n    return session.exitstatus",
            "start_line": 177,
            "start_column": 5040,
            "end_line": 0,
            "end_column": 7567,
            "start_byte": 5040,
            "end_byte": 0
          },
          "_pytest.main.Session": {
            "name": "_pytest.main.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "class Session(nodes.FSCollector):\n    Interrupted = Interrupted\n    Failed = Failed\n    # Set on the session by runner.pytest_sessionstart.\n    _setupstate = None  # type: SetupState\n    # Set on the session by fixtures.pytest_sessionstart.\n    _fixturemanager = None  # type: FixtureManager\n    exitstatus = None  # type: Union[int, ExitCode]\n\n    def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")\n\n    @classmethod\n    def from_config(cls, config):\n        return cls._create(config)\n\n    def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )\n\n    def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]\n\n    @hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)\n\n    @hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)\n\n    pytest_collectreport = pytest_runtest_logreport\n\n    def isinitpath(self, path):\n        return path in self._initialpaths\n\n    def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)\n\n    def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items\n\n    def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items\n\n    def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()\n\n    def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m\n\n    @staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)\n\n    def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin\n\n    def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)\n\n    def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes\n\n    def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes\n\n    def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 367,
            "start_column": 11404,
            "end_line": 0,
            "end_column": 24571,
            "start_byte": 11404,
            "end_byte": 0
          },
          "_pytest.main.Session.Interrupted": {
            "name": "_pytest.main.Session.Interrupted",
            "file_path": "src/_pytest/main.py",
            "file_content": "Interrupted = Interrupted",
            "start_line": 368,
            "start_column": 11442,
            "end_line": 4,
            "end_column": 11467,
            "start_byte": 11442,
            "end_byte": 4
          },
          "_pytest.main.Session.Failed": {
            "name": "_pytest.main.Session.Failed",
            "file_path": "src/_pytest/main.py",
            "file_content": "Failed = Failed",
            "start_line": 369,
            "start_column": 11472,
            "end_line": 4,
            "end_column": 11487,
            "start_byte": 11472,
            "end_byte": 4
          },
          "_pytest.main.Session._setupstate": {
            "name": "_pytest.main.Session._setupstate",
            "file_path": "src/_pytest/main.py",
            "file_content": "_setupstate = None",
            "start_line": 371,
            "start_column": 11548,
            "end_line": 4,
            "end_column": 11566,
            "start_byte": 11548,
            "end_byte": 4
          },
          "_pytest.main.Session._fixturemanager": {
            "name": "_pytest.main.Session._fixturemanager",
            "file_path": "src/_pytest/main.py",
            "file_content": "_fixturemanager = None",
            "start_line": 373,
            "start_column": 11649,
            "end_line": 4,
            "end_column": 11671,
            "start_byte": 11649,
            "end_byte": 4
          },
          "_pytest.main.Session.exitstatus": {
            "name": "_pytest.main.Session.exitstatus",
            "file_path": "src/_pytest/main.py",
            "file_content": "exitstatus = None",
            "start_line": 374,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11717,
            "start_byte": 11700,
            "end_byte": 4
          },
          "_pytest.main.Session.__init__": {
            "name": "_pytest.main.Session.__init__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __init__(self, config: Config) -> None:\n        nodes.FSCollector.__init__(\n            self, config.rootdir, parent=None, config=config, session=self, nodeid=\"\"\n        )\n        self.testsfailed = 0\n        self.testscollected = 0\n        self.shouldstop = False\n        self.shouldfail = False\n        self.trace = config.trace.root.get(\"collection\")\n        self.startdir = config.invocation_dir\n        self._initialpaths = frozenset()  # type: FrozenSet[py.path.local]\n\n        # Keep track of any collected nodes in here, so we don't duplicate fixtures\n        self._collection_node_cache1 = (\n            {}\n        )  # type: Dict[py.path.local, Sequence[nodes.Collector]]\n        self._collection_node_cache2 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], py.path.local], nodes.Collector]\n        self._collection_node_cache3 = (\n            {}\n        )  # type: Dict[Tuple[Type[nodes.Collector], str], CollectReport]\n\n        # Dirnames of pkgs with dunder-init files.\n        self._collection_pkg_roots = {}  # type: Dict[py.path.local, Package]\n\n        self._bestrelpathcache = _bestrelpath_cache(\n            config.rootdir\n        )  # type: Dict[py.path.local, str]\n\n        self.config.pluginmanager.register(self, name=\"session\")",
            "start_line": 376,
            "start_column": 11753,
            "end_line": 4,
            "end_column": 13031,
            "start_byte": 11753,
            "end_byte": 4
          },
          "_pytest.main.Session.from_config": {
            "name": "_pytest.main.Session.from_config",
            "file_path": "src/_pytest/main.py",
            "file_content": "@classmethod\n    def from_config(cls, config):\n        return cls._create(config)",
            "start_line": 408,
            "start_column": 13037,
            "end_line": 4,
            "end_column": 13118,
            "start_byte": 13037,
            "end_byte": 4
          },
          "_pytest.main.Session.__repr__": {
            "name": "_pytest.main.Session.__repr__",
            "file_path": "src/_pytest/main.py",
            "file_content": "def __repr__(self):\n        return \"<%s %s exitstatus=%r testsfailed=%d testscollected=%d>\" % (\n            self.__class__.__name__,\n            self.name,\n            getattr(self, \"exitstatus\", \"<UNSET>\"),\n            self.testsfailed,\n            self.testscollected,\n        )",
            "start_line": 412,
            "start_column": 13124,
            "end_line": 4,
            "end_column": 13404,
            "start_byte": 13124,
            "end_byte": 4
          },
          "_pytest.main.Session._node_location_to_relpath": {
            "name": "_pytest.main.Session._node_location_to_relpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _node_location_to_relpath(self, node_path: py.path.local) -> str:\n        # bestrelpath is a quite slow function\n        return self._bestrelpathcache[node_path]",
            "start_line": 421,
            "start_column": 13410,
            "end_line": 4,
            "end_column": 13575,
            "start_byte": 13410,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectstart": {
            "name": "_pytest.main.Session.pytest_collectstart",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_collectstart(self):\n        if self.shouldfail:\n            raise self.Failed(self.shouldfail)\n        if self.shouldstop:\n            raise self.Interrupted(self.shouldstop)",
            "start_line": 425,
            "start_column": 13581,
            "end_line": 4,
            "end_column": 13795,
            "start_byte": 13581,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_runtest_logreport": {
            "name": "_pytest.main.Session.pytest_runtest_logreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "@hookimpl(tryfirst=True)\n    def pytest_runtest_logreport(self, report):\n        if report.failed and not hasattr(report, \"wasxfail\"):\n            self.testsfailed += 1\n            maxfail = self.config.getvalue(\"maxfail\")\n            if maxfail and self.testsfailed >= maxfail:\n                self.shouldfail = \"stopping after %d failures\" % (self.testsfailed)",
            "start_line": 432,
            "start_column": 13801,
            "end_line": 4,
            "end_column": 14163,
            "start_byte": 13801,
            "end_byte": 4
          },
          "_pytest.main.Session.pytest_collectreport": {
            "name": "_pytest.main.Session.pytest_collectreport",
            "file_path": "src/_pytest/main.py",
            "file_content": "pytest_collectreport = pytest_runtest_logreport",
            "start_line": 440,
            "start_column": 14169,
            "end_line": 4,
            "end_column": 14216,
            "start_byte": 14169,
            "end_byte": 4
          },
          "_pytest.main.Session.isinitpath": {
            "name": "_pytest.main.Session.isinitpath",
            "file_path": "src/_pytest/main.py",
            "file_content": "def isinitpath(self, path):\n        return path in self._initialpaths",
            "start_line": 442,
            "start_column": 14222,
            "end_line": 4,
            "end_column": 14291,
            "start_byte": 14222,
            "end_byte": 4
          },
          "_pytest.main.Session.gethookproxy": {
            "name": "_pytest.main.Session.gethookproxy",
            "file_path": "src/_pytest/main.py",
            "file_content": "def gethookproxy(self, fspath: py.path.local):\n        return super()._gethookproxy(fspath)",
            "start_line": 445,
            "start_column": 14297,
            "end_line": 4,
            "end_column": 14388,
            "start_byte": 14297,
            "end_byte": 4
          },
          "_pytest.main.Session.perform_collect": {
            "name": "_pytest.main.Session.perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def perform_collect(self, args=None, genitems=True):\n        hook = self.config.hook\n        try:\n            items = self._perform_collect(args, genitems)\n            self.config.pluginmanager.check_pending()\n            hook.pytest_collection_modifyitems(\n                session=self, config=self.config, items=items\n            )\n        finally:\n            hook.pytest_collection_finish(session=self)\n        self.testscollected = len(items)\n        return items",
            "start_line": 448,
            "start_column": 14394,
            "end_line": 4,
            "end_column": 14862,
            "start_byte": 14394,
            "end_byte": 4
          },
          "_pytest.main.Session._perform_collect": {
            "name": "_pytest.main.Session._perform_collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _perform_collect(self, args, genitems):\n        if args is None:\n            args = self.config.args\n        self.trace(\"perform_collect\", self, args)\n        self.trace.root.indent += 1\n        self._notfound = []\n        initialpaths = []  # type: List[py.path.local]\n        self._initial_parts = []  # type: List[Tuple[py.path.local, List[str]]]\n        self.items = items = []\n        for arg in args:\n            fspath, parts = self._parsearg(arg)\n            self._initial_parts.append((fspath, parts))\n            initialpaths.append(fspath)\n        self._initialpaths = frozenset(initialpaths)\n        rep = collect_one_node(self)\n        self.ihook.pytest_collectreport(report=rep)\n        self.trace.root.indent -= 1\n        if self._notfound:\n            errors = []\n            for arg, exc in self._notfound:\n                line = \"(no name {!r} in any of {!r})\".format(arg, exc.args[0])\n                errors.append(\"not found: {}\\n{}\".format(arg, line))\n            raise UsageError(*errors)\n        if not genitems:\n            return rep.result\n        else:\n            if rep.passed:\n                for node in rep.result:\n                    self.items.extend(self.genitems(node))\n            return items",
            "start_line": 461,
            "start_column": 14868,
            "end_line": 4,
            "end_column": 16102,
            "start_byte": 14868,
            "end_byte": 4
          },
          "_pytest.main.Session.collect": {
            "name": "_pytest.main.Session.collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def collect(self):\n        for fspath, parts in self._initial_parts:\n            self.trace(\"processing argument\", (fspath, parts))\n            self.trace.root.indent += 1\n            try:\n                yield from self._collect(fspath, parts)\n            except NoMatch as exc:\n                report_arg = \"::\".join((str(fspath), *parts))\n                # we are inside a make_report hook so\n                # we cannot directly pass through the exception\n                self._notfound.append((report_arg, exc))\n\n            self.trace.root.indent -= 1\n        self._collection_node_cache1.clear()\n        self._collection_node_cache2.clear()\n        self._collection_node_cache3.clear()\n        self._collection_pkg_roots.clear()",
            "start_line": 492,
            "start_column": 16108,
            "end_line": 4,
            "end_column": 16843,
            "start_byte": 16108,
            "end_byte": 4
          },
          "_pytest.main.Session._collect": {
            "name": "_pytest.main.Session._collect",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _collect(self, argpath, names):\n        from _pytest.python import Package\n\n        # Start with a Session root, and delve to argpath item (dir or file)\n        # and stack all Packages found on the way.\n        # No point in finding packages when collecting doctests\n        if not self.config.getoption(\"doctestmodules\", False):\n            pm = self.config.pluginmanager\n            for parent in reversed(argpath.parts()):\n                if pm._confcutdir and pm._confcutdir.relto(parent):\n                    break\n\n                if parent.isdir():\n                    pkginit = parent.join(\"__init__.py\")\n                    if pkginit.isfile():\n                        if pkginit not in self._collection_node_cache1:\n                            col = self._collectfile(pkginit, handle_dupes=False)\n                            if col:\n                                if isinstance(col[0], Package):\n                                    self._collection_pkg_roots[parent] = col[0]\n                                # always store a list in the cache, matchnodes expects it\n                                self._collection_node_cache1[col[0].fspath] = [col[0]]\n\n        # If it's a directory argument, recurse and look for any Subpackages.\n        # Let the Package collector deal with subnodes, don't collect here.\n        if argpath.check(dir=1):\n            assert not names, \"invalid arg {!r}\".format((argpath, names))\n\n            seen_dirs = set()\n            for path in argpath.visit(\n                fil=self._visit_filter, rec=self._recurse, bf=True, sort=True\n            ):\n                dirpath = path.dirpath()\n                if dirpath not in seen_dirs:\n                    # Collect packages first.\n                    seen_dirs.add(dirpath)\n                    pkginit = dirpath.join(\"__init__.py\")\n                    if pkginit.exists():\n                        for x in self._collectfile(pkginit):\n                            yield x\n                            if isinstance(x, Package):\n                                self._collection_pkg_roots[dirpath] = x\n                if dirpath in self._collection_pkg_roots:\n                    # Do not collect packages here.\n                    continue\n\n                for x in self._collectfile(path):\n                    key = (type(x), x.fspath)\n                    if key in self._collection_node_cache2:\n                        yield self._collection_node_cache2[key]\n                    else:\n                        self._collection_node_cache2[key] = x\n                        yield x\n        else:\n            assert argpath.check(file=1)\n\n            if argpath in self._collection_node_cache1:\n                col = self._collection_node_cache1[argpath]\n            else:\n                collect_root = self._collection_pkg_roots.get(argpath.dirname, self)\n                col = collect_root._collectfile(argpath, handle_dupes=False)\n                if col:\n                    self._collection_node_cache1[argpath] = col\n            m = self.matchnodes(col, names)\n            # If __init__.py was the only file requested, then the matched node will be\n            # the corresponding Package, and the first yielded item will be the __init__\n            # Module itself, so just use that. If this special case isn't taken, then all\n            # the files in the package will be yielded.\n            if argpath.basename == \"__init__.py\":\n                try:\n                    yield next(m[0].collect())\n                except StopIteration:\n                    # The package collects nothing with only an __init__.py\n                    # file in it, which gets ignored by the default\n                    # \"python_files\" option.\n                    pass\n                return\n            yield from m",
            "start_line": 510,
            "start_column": 16849,
            "end_line": 4,
            "end_column": 20645,
            "start_byte": 16849,
            "end_byte": 4
          },
          "_pytest.main.Session._visit_filter": {
            "name": "_pytest.main.Session._visit_filter",
            "file_path": "src/_pytest/main.py",
            "file_content": "@staticmethod\n    def _visit_filter(f):\n        return f.check(file=1)",
            "start_line": 589,
            "start_column": 20651,
            "end_line": 4,
            "end_column": 20721,
            "start_byte": 20651,
            "end_byte": 4
          },
          "_pytest.main.Session._tryconvertpyarg": {
            "name": "_pytest.main.Session._tryconvertpyarg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _tryconvertpyarg(self, x):\n        \"\"\"Convert a dotted module name to path.\"\"\"\n        try:\n            spec = importlib.util.find_spec(x)\n        # AttributeError: looks like package module, but actually filename\n        # ImportError: module does not exist\n        # ValueError: not a module name\n        except (AttributeError, ImportError, ValueError):\n            return x\n        if spec is None or spec.origin in {None, \"namespace\"}:\n            return x\n        elif spec.submodule_search_locations:\n            return os.path.dirname(spec.origin)\n        else:\n            return spec.origin",
            "start_line": 593,
            "start_column": 20727,
            "end_line": 4,
            "end_column": 21331,
            "start_byte": 20727,
            "end_byte": 4
          },
          "_pytest.main.Session._parsearg": {
            "name": "_pytest.main.Session._parsearg",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _parsearg(self, arg):\n        \"\"\" return (fspath, names) tuple after checking the file exists. \"\"\"\n        strpath, *parts = str(arg).split(\"::\")\n        if self.config.option.pyargs:\n            strpath = self._tryconvertpyarg(strpath)\n        relpath = strpath.replace(\"/\", os.sep)\n        fspath = self.config.invocation_dir.join(relpath, abs=True)\n        if not fspath.check():\n            if self.config.option.pyargs:\n                raise UsageError(\n                    \"file or package not found: \" + arg + \" (missing __init__.py?)\"\n                )\n            raise UsageError(\"file not found: \" + arg)\n        fspath = fspath.realpath()\n        return (fspath, parts)",
            "start_line": 609,
            "start_column": 21337,
            "end_line": 4,
            "end_column": 22022,
            "start_byte": 21337,
            "end_byte": 4
          },
          "_pytest.main.Session.matchnodes": {
            "name": "_pytest.main.Session.matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def matchnodes(self, matching, names):\n        self.trace(\"matchnodes\", matching, names)\n        self.trace.root.indent += 1\n        nodes = self._matchnodes(matching, names)\n        num = len(nodes)\n        self.trace(\"matchnodes finished -> \", num, \"nodes\")\n        self.trace.root.indent -= 1\n        if num == 0:\n            raise NoMatch(matching, names[:1])\n        return nodes",
            "start_line": 625,
            "start_column": 22028,
            "end_line": 4,
            "end_column": 22412,
            "start_byte": 22028,
            "end_byte": 4
          },
          "_pytest.main.Session._matchnodes": {
            "name": "_pytest.main.Session._matchnodes",
            "file_path": "src/_pytest/main.py",
            "file_content": "def _matchnodes(self, matching, names):\n        if not matching or not names:\n            return matching\n        name = names[0]\n        assert name\n        nextnames = names[1:]\n        resultnodes = []\n        for node in matching:\n            if isinstance(node, nodes.Item):\n                if not names:\n                    resultnodes.append(node)\n                continue\n            assert isinstance(node, nodes.Collector)\n            key = (type(node), node.nodeid)\n            if key in self._collection_node_cache3:\n                rep = self._collection_node_cache3[key]\n            else:\n                rep = collect_one_node(node)\n                self._collection_node_cache3[key] = rep\n            if rep.passed:\n                has_matched = False\n                for x in rep.result:\n                    # TODO: remove parametrized workaround once collection structure contains parametrization\n                    if x.name == name or x.name.split(\"[\")[0] == name:\n                        resultnodes.extend(self.matchnodes([x], nextnames))\n                        has_matched = True\n                # XXX accept IDs that don't have \"()\" for class instances\n                if not has_matched and len(rep.result) == 1 and x.name == \"()\":\n                    nextnames.insert(0, name)\n                    resultnodes.extend(self.matchnodes([x], nextnames))\n            else:\n                # report collection failures here to avoid failing to run some test\n                # specified in the command line because the module could not be\n                # imported (#134)\n                node.ihook.pytest_collectreport(report=rep)\n        return resultnodes",
            "start_line": 636,
            "start_column": 22418,
            "end_line": 4,
            "end_column": 24096,
            "start_byte": 22418,
            "end_byte": 4
          },
          "_pytest.main.Session.genitems": {
            "name": "_pytest.main.Session.genitems",
            "file_path": "src/_pytest/main.py",
            "file_content": "def genitems(self, node):\n        self.trace(\"genitems\", node)\n        if isinstance(node, nodes.Item):\n            node.ihook.pytest_itemcollected(item=node)\n            yield node\n        else:\n            assert isinstance(node, nodes.Collector)\n            rep = collect_one_node(node)\n            if rep.passed:\n                for subnode in rep.result:\n                    yield from self.genitems(subnode)\n            node.ihook.pytest_collectreport(report=rep)",
            "start_line": 673,
            "start_column": 24102,
            "end_line": 4,
            "end_column": 24571,
            "start_byte": 24102,
            "end_byte": 4
          },
          "_pytest.pytester.Testdir.Session": {
            "name": "_pytest.pytester.Testdir.Session",
            "file_path": "src/_pytest/main.py",
            "file_content": "",
            "start_line": 772,
            "start_column": 25095,
            "end_line": 4,
            "end_column": 25112,
            "start_byte": 25095,
            "end_byte": 4
          },
          "_pytest._code.TracebackEntry.__repr__": {
            "name": "_pytest._code.TracebackEntry.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<TracebackEntry %s:%d>\" % (self.frame.code.path, self.lineno + 1)",
            "start_line": 206,
            "start_column": 6201,
            "end_line": 4,
            "end_column": 6309,
            "start_byte": 6201,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals: bool = False,\n        style: \"_TracebackStyle\" = \"long\",\n        abspath: bool = False,\n        tbfilter: bool = True,\n        funcargs: bool = False,\n        truncate_locals: bool = True,\n        chain: bool = True,\n    ) -> Union[\"ReprExceptionInfo\", \"ExceptionChainRepr\"]:\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 577,
            "start_column": 19023,
            "end_line": 4,
            "end_column": 20900,
            "start_byte": 19023,
            "end_byte": 4
          },
          "_pytest._code.FormattedExcinfo.repr_excinfo": {
            "name": "_pytest._code.FormattedExcinfo.repr_excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def repr_excinfo(self, excinfo: ExceptionInfo) -> \"ExceptionChainRepr\":\n        repr_chain = (\n            []\n        )  # type: List[Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]]\n        e = excinfo.value\n        excinfo_ = excinfo  # type: Optional[ExceptionInfo]\n        descr = None\n        seen = set()  # type: Set[int]\n        while e is not None and id(e) not in seen:\n            seen.add(id(e))\n            if excinfo_:\n                reprtraceback = self.repr_traceback(excinfo_)\n                reprcrash = excinfo_._getreprcrash()  # type: Optional[ReprFileLocation]\n            else:\n                # fallback to native repr if the exception doesn't have a traceback:\n                # ExceptionInfo objects require a full traceback to work\n                reprtraceback = ReprTracebackNative(\n                    traceback.format_exception(type(e), e, None)\n                )\n                reprcrash = None\n\n            repr_chain += [(reprtraceback, reprcrash, descr)]\n            if e.__cause__ is not None and self.chain:\n                e = e.__cause__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"The above exception was the direct cause of the following exception:\"\n            elif (\n                e.__context__ is not None and not e.__suppress_context__ and self.chain\n            ):\n                e = e.__context__\n                excinfo_ = (\n                    ExceptionInfo((type(e), e, e.__traceback__))\n                    if e.__traceback__\n                    else None\n                )\n                descr = \"During handling of the above exception, another exception occurred:\"\n            else:\n                e = None\n        repr_chain.reverse()\n        return ExceptionChainRepr(repr_chain)",
            "start_line": 868,
            "start_column": 30141,
            "end_line": 4,
            "end_column": 32060,
            "start_byte": 30141,
            "end_byte": 4
          },
          "_pytest._io.safeformat": {
            "name": "_pytest._io.safeformat",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "https://github.com/python/mypy/issues/4266.\n    __hash__ = None  # type: ignore\n\n    def __ne__(self, other):\n        return not self == other\n\n    @property\n    def path(self) -> Union[py.path.local, str]:\n        \"\"\" return a path object pointing to source code (or a str in case\n        of OSError / non-existing file).\n",
            "start_line": 63,
            "start_column": 1751,
            "end_line": 0,
            "end_column": 2074,
            "start_byte": 1751,
            "end_byte": 0
          },
          "_pytest._io.saferepr": {
            "name": "_pytest._io.saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def saferepr(obj: Any, maxsize: int = 240) -> str:\n    \"\"\"return a size-limited safe repr-string for the given object.\n    Failing __repr__ functions of user instances will be represented\n    with a short exception info and 'saferepr' generally takes\n    care to never raise exceptions itself.  This function is a wrapper\n    around the Repr/reprlib functionality of the standard 2.6 lib.\n    \"\"\"\n    return SafeRepr(maxsize).repr(obj)",
            "start_line": 74,
            "start_column": 2077,
            "end_line": 0,
            "end_column": 2512,
            "start_byte": 2077,
            "end_byte": 0
          },
          "_pytest.assertion._saferepr": {
            "name": "_pytest.assertion._saferepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "",
            "start_line": 375,
            "start_column": 13624,
            "end_line": 0,
            "end_column": 14124,
            "start_byte": 13624,
            "end_byte": 0
          },
          "_pytest._io._try_repr_or_str": {
            "name": "_pytest._io._try_repr_or_str",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _try_repr_or_str(obj):\n    try:\n        return repr(obj)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException:\n        return '{}(\"{}\")'.format(type(obj).__name__, obj)",
            "start_line": 5,
            "start_column": 54,
            "end_line": 0,
            "end_column": 256,
            "start_byte": 54,
            "end_byte": 0
          },
          "_pytest._io._format_repr_exception": {
            "name": "_pytest._io._format_repr_exception",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def _format_repr_exception(exc: BaseException, obj: Any) -> str:\n    try:\n        exc_info = _try_repr_or_str(exc)\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    except BaseException as exc:\n        exc_info = \"unpresentable exception ({})\".format(_try_repr_or_str(exc))\n    return \"<[{} raised in repr()] {} object at 0x{:x}>\".format(\n        exc_info, obj.__class__.__name__, id(obj)\n    )",
            "start_line": 14,
            "start_column": 259,
            "end_line": 0,
            "end_column": 665,
            "start_byte": 259,
            "end_byte": 0
          },
          "_pytest._io.SafeRepr": {
            "name": "_pytest._io.SafeRepr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "class SafeRepr(reprlib.Repr):\n    \"\"\"subclass of repr.Repr that limits the resulting size of repr()\n    and includes information on exceptions raised during the call.\n    \"\"\"\n\n    def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize\n\n    def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)\n\n    def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 34,
            "start_column": 875,
            "end_line": 0,
            "end_column": 1748,
            "start_byte": 875,
            "end_byte": 0
          },
          "_pytest._io.SafeRepr.__init__": {
            "name": "_pytest._io.SafeRepr.__init__",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def __init__(self, maxsize: int) -> None:\n        super().__init__()\n        self.maxstring = maxsize\n        self.maxsize = maxsize",
            "start_line": 39,
            "start_column": 1055,
            "end_line": 4,
            "end_column": 1187,
            "start_byte": 1055,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr": {
            "name": "_pytest._io.SafeRepr.repr",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr(self, x: Any) -> str:\n        try:\n            s = super().repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 44,
            "start_column": 1193,
            "end_line": 4,
            "end_column": 1461,
            "start_byte": 1193,
            "end_byte": 4
          },
          "_pytest._io.SafeRepr.repr_instance": {
            "name": "_pytest._io.SafeRepr.repr_instance",
            "file_path": "src/_pytest/_io/saferepr.py",
            "file_content": "def repr_instance(self, x: Any, level: int) -> str:\n        try:\n            s = repr(x)\n        except (KeyboardInterrupt, SystemExit):\n            raise\n        except BaseException as exc:\n            s = _format_repr_exception(exc, x)\n        return _ellipsize(s, self.maxsize)",
            "start_line": 53,
            "start_column": 1467,
            "end_line": 4,
            "end_column": 1748,
            "start_byte": 1467,
            "end_byte": 4
          }
        }
      }
    }
  ]
}