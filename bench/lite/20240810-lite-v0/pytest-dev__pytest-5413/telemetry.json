{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5413",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:11:36.133279",
        "usage": "1291.562795639038 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "getlocals",
          "delattr",
          "disabled",
          "compile",
          "fullsource",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "MODULE_NOT_FOUND_ERROR",
          "_match_lines",
          "run",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "STRING_TYPES",
          "_is_setup_py",
          "_visit_filter",
          "BOM_UTF8",
          "_getnextfixturedef",
          "append_skipped",
          "REPORT_COLLECTING_RESOLUTION",
          "PYTEST_CONFIG_GLOBAL",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_inject_setup_function_fixture",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "cached_result",
          "ApproxDecimal",
          "_parse_parametrize_args",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "applymarker",
          "_check_all_skipped",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "check_xfail_no_run",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "_get_pdb_wrapper_class",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "__setattr__",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "get_terminal_writer",
          "exec_",
          "visit_Call",
          "inline_genitems",
          "writeorg",
          "RAISES_MESSAGE_PARAMETER",
          "__eq__",
          "update_testcase_duration",
          "_callhelper",
          "USAGE_MSG",
          "collect_one_node",
          "_code",
          "PYTEST_ENSURETEMP",
          "append_pass",
          "N",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "value",
          "consider_preparse",
          "unittest",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "_exec_lsof",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "RaisesContext",
          "_get_non_fixture_func",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "junitxml",
          "_mk_tmp",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "PYTEST_LOGWARNING",
          "LEVELNAME_FMT_REGEX",
          "RN",
          "_get_pos",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "_log_cli_enabled",
          "processoption",
          "_config",
          "getfuncargvalue",
          "TestCaseFunction",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "location",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "unary_map",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "_check_record_param_type",
          "format_explanation",
          "makeconftest",
          "alias",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "repr_unicode",
          "doctest",
          "fileno",
          "setns",
          "_validate_usepdb_cls",
          "Class",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "pytest_itemstart",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "last_failed_paths",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "families",
          "pytest_terminal_summary",
          "__nonzero__",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "_get_marks",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "done",
          "add_report_section",
          "PytestPluginManager",
          "getnode",
          "YIELD_TESTS",
          "update",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "PrintHelp",
          "MyOptionParser",
          "parseconfig",
          "pytest_doctest_prepare_content",
          "pyobj_property",
          "find_module",
          "scope2index",
          "getbasetemp",
          "EXIT_TESTSFAILED",
          "_addexcinfo",
          "_width_of_current_line",
          "NodeMarkers",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "is_true",
          "_ConfigDeprecated",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "errors",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "short_test_summary",
          "_call_and_format_exception",
          "parse_num",
          "_checkargnotcontained",
          "python_keywords_allowed_list",
          "collect_by_name",
          "parsefactories",
          "_ensure_only_one_capture_fixture",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "repr",
          "SEP",
          "matchkeyword",
          "SubRequest",
          "load_module",
          "EXIT_INTERNALERROR",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_handle_skip",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "_getglobals",
          "generic_visit",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "autouse",
          "_importconftest",
          "args",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "exc_clear",
          "PytestDeprecationWarning",
          "pytest_logwarning",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "__array_ufunc__",
          "MarkMapping",
          "summary_errors",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "MARK_GEN",
          "fspath",
          "_opentestcase",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "syspath_prepend",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "find_suffixes",
          "syspathinsert",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "istrue",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "set_when",
          "delenv",
          "_perform_collect",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "raiseerror",
          "fnmatch_ex",
          "_runtest_for_main",
          "Traceback",
          "pytest_runtestloop",
          "item_capture",
          "TestReport",
          "capfd",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "PyobjContext",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "cls",
          "getlocation",
          "isclass",
          "parseconfigure",
          "repr_locals",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "visit_Name",
          "report_collect",
          "finish",
          "getdecoded",
          "_compilecounter",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "_get_line_with_reprcrash_message",
          "AssertionState",
          "ihook",
          "call_optional",
          "_get_override_ini_value",
          "ExceptionRepr",
          "putaround",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "_install_capture_fixture_on_item",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "_write_pyc",
          "__len__",
          "summary_stats",
          "__next__",
          "getrawcode",
          "find",
          "_initrequest",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_callfinalizers",
          "CollectErrorRepr",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "RemovedInPytest4Warning",
          "extract_suffixes",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "isiterable",
          "FSCollector",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "_update_message",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "_bytes_to_ascii",
          "ensure_newline",
          "saferepr",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "_getcapture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "mode",
          "CaptureResult",
          "str",
          "isparseable",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "OptionGroup",
          "error",
          "_is_capturing",
          "FixtureRequest",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "ReprFileLocation",
          "format",
          "_ANSI_ESCAPE_SEQ",
          "isfunction",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "scopeproperty",
          "getitem",
          "ensuretemp",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "initialnames",
          "LogXML",
          "__getitem__",
          "FIXTURE_NAMED_REQUEST",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "exists",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "patchsysdict",
          "start_global_capturing",
          "record_testsuite_property",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "compile_",
          "assert_contains_lines",
          "Entry",
          "chain",
          "setall",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "_teardown_towards",
          "capture_fixtures",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "safe_text_dupfile",
          "MoreQuietAction",
          "LineMatcher",
          "context",
          "fixtures",
          "__call__",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "_import_pdb_cls",
          "matchmark",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "freeze_support",
          "CaptureIO",
          "params",
          "isnosetest",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "mkdir",
          "own_markers",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "EXIT_INTERRUPTED",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "_remove_ansi_escape_sequences",
          "readlines",
          "inline_runsource",
          "cmdline",
          "__delitem__",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "FunctionMixin",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "_show_fixtures_per_test",
          "collect",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "MarkEvaluator",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "_setup_collect_fakemodule",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "cached_eval",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "FixtureFunctionMarker",
          "__bool__",
          "_parse_lsof_output",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "writelines",
          "_get_direct_parametrize_args",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "restore",
          "runpytest",
          "__exit__",
          "_get_allow_unicode_flag",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_is_mocked",
          "_showfixtures_main",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "_setoption",
          "Node",
          "parametrize",
          "_setup_cli_logging",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "ReprEntry",
          "EXIT_USAGEERROR",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "_typ_map",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "defaultfuncargprefixmarker",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "is_package",
          "Interrupted",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "rmtree",
          "strip",
          "_wrapped_pdb_cls",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "getexplanation",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "dummy_context_manager",
          "Exit",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "getcfg",
          "exit",
          "_imp_find_module",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "_parse_parametrize_parameters",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "NoCapture",
          "_rewrite_test",
          "PercentStyleMultiline",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "_get_xunit_setup_teardown",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "warn_about_none_ast",
          "wasvalid",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "cookie_re",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "__version__",
          "RAISES_EXEC",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "getslaveinfoline",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "FIXTURE_FUNCTION_CALL",
          "_create_formatter",
          "_test_pytest_function",
          "_preparse",
          "idmaker",
          "FDCaptureBinary",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "with_args",
          "EXIT_NOTESTSCOLLECTED",
          "_get_active_fixturedef",
          "yield_fixture",
          "ascii_escaped",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "ApproxBase",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "check_strict_xfail",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "_state",
          "_PLUGGY_DIR",
          "get_actual_log_level",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "get_skip_exceptions",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "_prunetraceback",
          "addinivalue_line",
          "EXIT_OK",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "WARNS_EXEC",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "runitem",
          "_istrue",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "call_and_report",
          "nofuncargs",
          "Config",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "invalidraise",
          "Module",
          "KeywordMapping",
          "Item",
          "_idvalset",
          "pytest_addhooks",
          "__all__",
          "matchnodes",
          "read_global_capture",
          "_getini",
          "istestfunction",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "FuncargnamesCompatAttr",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "addhooks",
          "GETFUNCARGVALUE",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "_cmp_raises_type_error",
          "nodes",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "binop_map",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "write",
          "get_fslocation_from_item",
          "session",
          "out",
          "deselect_by_mark",
          "spawn_pytest",
          "scopenum_function",
          "_matchnodes",
          "import_plugin",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "builtin",
          "_collectfile",
          "addFailure",
          "catching_logs",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "PYTESTER_COPY_EXAMPLE",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "pytest",
          "raises",
          "RaisesContext",
          "ExceptionInfo",
          "exception",
          "str",
          "str()",
          "LookupError"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:11:37.424887",
        "usage": "265.0001049041748 ms"
      },
      "request": {
        "tokens": [
          "pytest",
          "raises",
          "RaisesContext",
          "ExceptionInfo",
          "exception",
          "str",
          "str()",
          "LookupError"
        ]
      },
      "response": {
        "results": {
          "str": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/_version.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python_api.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "pytest": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "exception": [
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nose.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/unittest.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py"
          ],
          "raises": [
            "src/pytest.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/debugging.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/doctest.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python_api.py",
            "src/_pytest/deprecated.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/_code/__init__.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "RaisesContext": [
            "src/_pytest/python_api.py"
          ],
          "LookupError": [
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/pytester.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:11:37.689898",
        "usage": "6383.216142654419 ms"
      },
      "request": {
        "keyword_search_results": {
          "str": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/_version.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/_code/source.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/assertion/truncate.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/python_api.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "pytest": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/nose.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/mark/legacy.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/pytest.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "exception": [
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/helpconfig.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/python_api.py",
            "src/_pytest/nose.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/_io/saferepr.py",
            "src/_pytest/unittest.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/logging.py",
            "src/_pytest/debugging.py",
            "src/_pytest/hookspec.py"
          ],
          "raises": [
            "src/pytest.py",
            "src/_pytest/mark/evaluate.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/debugging.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/doctest.py",
            "src/_pytest/skipping.py",
            "src/_pytest/python_api.py",
            "src/_pytest/deprecated.py"
          ],
          "ExceptionInfo": [
            "src/_pytest/_code/__init__.py",
            "src/_pytest/unittest.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/doctest.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/python.py",
            "src/_pytest/main.py"
          ],
          "RaisesContext": [
            "src/_pytest/python_api.py"
          ],
          "LookupError": [
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/pytester.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "To solve this problem, we need to understand the difference in behavior between how normal exception handling and pytest's raise context variable works in the context of string conversion. \n\nHere's the step-by-step approach:\n\n1. **Understanding the context variable in `pytest.raises`:**\n   The issue highlights the different outputs when using the `str()` function on exceptions caught normally versus with `pytest.raises`. \n2. **Relevant keywords**:   \n   - `pytest` and `raises` are most relevant because the issue revolves around the behavior of the `pytest.raises` context.\n   - `ExceptionInfo` and `RaisesContext` could also be significant since they likely contribute to managing exceptions within pytest and could affect string conversion behavior.\n   - `str` or `exception` might not directly point to modifications, as it's a general function and concept, but specific implementations might be found.\n\n3. **File filtering based on keywords**:\n   - `src/_pytest/python_api.py` appears under `raises`, `pytest`, `ExceptionInfo`, and `RaisesContext`, indicating it might involve core pytest functionalities dealing with exception handling under pytest context.\n   - `src/_pytest/_code/code.py` appears under `raises`, `ExceptionInfo`, and `exception`, suggesting potential handling of exception structures and related string methods.\n   - `src/pytest.py` under `pytest` and `raises` - a top-level entry which might initialize how pytest hooks in with Python exceptions.\n   - `src/_pytest/runner.py` under `ExceptionInfo` indicates it might handle exceptions during test execution.\n   - `src/_pytest/assertion/util.py` listed under `ExceptionInfo` and `pytest` suggests it's involved when checking exceptions, possibly during assertions.\n\nFrom these observations, `src/_pytest/python_api.py` is likely the most relevant as it covers several aspects of handling pytest's `raises`. This is followed by `src/_pytest/_code/code.py` due to its involvement with code and exception handling, then `src/pytest.py`, `src/_pytest/runner.py`, and `src/_pytest/assertion/util.py` which are involved in handling exceptions, possibly affecting string conversion in outputs.",
        "file_paths": [
          "src/_pytest/python_api.py",
          "src/_pytest/_code/code.py",
          "src/pytest.py",
          "src/_pytest/runner.py",
          "src/_pytest/assertion/util.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:11:44.073140",
        "usage": "9067.229986190796 ms"
      },
      "request": {
        "file_path": "src/_pytest/python_api.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:**\n   - The user is reporting a discrepancy in behavior when handling exceptions between a standard try-except block and the `pytest.raises` context manager.\n   - With a standard try-except block, using `str(e)` directly on the exception variable gives the full message spread across multiple lines.\n   - However, with `pytest.raises`, `str(e)` results in a shortened message indicating only the type of exception and initial data, and suggests using `str(e.value)` to get the full message.\n\n2. **User's Expectations and Cause:**\n   - The user expects `str(e)` within the `pytest.raises` context to produce a complete error message similar to the default try-except usage.\n   - The issue stems from the design of `pytest.raises`, where the context manager returns an `ExceptionInfo` object, and the actual exception instance is stored as the `value` attribute.\n   - This design choice enhances flexibility, allowing `pytest.raises` to provide additional information beyond what a plain exception would, such as exception type, traceback, etc.\n\n3. **Inspecting the Code:**\n   - `RaisesContext.__enter__()` returns `self.excinfo`, which is an `ExceptionInfo` object for capturing exception details.\n   - Understanding the mismatch between user expectations and actuality stems from needing to dig into the attributes of this `ExceptionInfo` object.\n\n4. **File Content Evaluation:**\n   - The `RaisesContext` class and its `__enter__` method are pivotal since they're responsible for holding exception information in context usage.\n   - The `raises` function is responsible for catching exceptions and passing them into an instance of `RaisesContext`, mapping the user's expectations/demands to the function's design.\n\n5. **Relevance of the File:**\n   - Given that this file defines how the `raises` function and `RaisesContext` work, it is directly relevant to the reported issue.\n\n6. **Possible Solutions:**\n   - A possible improvement could entail documentation emphasis on using `.value` for retrieving complete error messages.\n   - Alternatively, introducing a method or property in `ExceptionInfo` that automates retrieving the full exception message could address user preferences directly.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "raises",
          "RaisesContext",
          "RaisesContext.__enter__"
        ],
        "root_cause_symbols": [
          "raises",
          "RaisesContext",
          "RaisesContext.__enter__"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:11:53.140394",
        "usage": "7951.6119956970215 ms"
      },
      "request": {
        "file_path": "src/_pytest/_code/code.py"
      },
      "response": {
        "scratch_pad": "1. Issue Analysis:\n- The issue is that using `str()` on the exception context variable in `pytest.raises` does not behave the same as using `str()` on a caught exception in a `try-except` block.\n- In a `try-except` block, `str(e)` gives the full error message, but with `pytest.raises`, `str(e)` returns a different format, and the full error message is only accessible via `str(e.value)`.\n- The user is concerned about this discrepancy in behavior and would like it standardized to avoid confusion.\n\n2. File Analysis:\n- The file `src/_pytest/_code/code.py` appears to define various classes related to exception handling and traceback processing, including `Code`, `Frame`, and `ExceptionInfo`.\n- `ExceptionInfo` class seems to wrap around exception information, and its methods like `exconly()` and `__str__()` handle the conversion of exception info to strings.\n- The `from_current()` method and `_excinfo` property of `ExceptionInfo` suggest it's used to deal with the current exception in a context manager style, typical for `pytest.raises`.\n- The `__str__` method of `ExceptionInfo` appears to produce a less detailed string representation than simply calling `str(e.value)` might provide.\n\n3. Relevance:\n- The file is relevant to the issue as it contains the `ExceptionInfo` class where the difference in behavior could be stemming from.\n- There is a possibility that updating the `__str__` method of the `ExceptionInfo` class to align closer to the typical behavior of exceptions could address the issue or at least provide a lead on behavior discrepancy.\n\n4. Conclusion:\n- The file isn't necessarily the root cause of the inconsistency with `str()` but provides insights into how exceptions are processed in pytest. Further investigation will be needed into how these are utilized in pytest.raises, possibly checking how the exception context is captured.\n- Two relevant symbols are `ExceptionInfo` and `ExceptionInfo.__str__` for examining the behavior for generating string representation of exceptions in pytest.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_io/capture.py",
          "src/_pytest/assertion/rewrite.py"
        ],
        "relevant_symbols": [
          "ExceptionInfo",
          "ExceptionInfo.__str__"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:12:01.092037",
        "usage": "5895.9596157073975 ms"
      },
      "request": {
        "file_path": "src/pytest.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user reported an issue where using str() on the pytest.raises context variable `e` doesn't exhibit the same behavior as a typical exception handling via `except` block. The direct `str(e)` within pytest.raises only prints a short message, not the full exception message which is observed in a typical `try-except` block.\n1.2 The reproduction steps include two code snippets: one using typical try-except handling and one using pytest.raises context manager. The different outputs from `str(e)` and `str(e.value)` indicate the context manager's `e` variable is different from the normal `except` variable.\n1.3 The issue is caused by how pytest implements its context manager and possibly how it stores the exception object within the `raises` function.\n1.4 The user expects the behavior of `str()` on the raised exception within pytest.raises to be consistent with the behavior in a try-except block without needing to access `e.value`. The inconsistency may be due to how the context manager captures and stores exceptions.\n1.6 Possible solutions might involve changing how pytest.raises handles the exception object, possibly initializing `e` directly with the exception message or modifying the `__str__` method for the context variable.\n\n2. Make File Evaluation:\n2.1 In `src/pytest.py`, various modules and components from `_pytest` are imported. Notably, `raises` from `_pytest.python_api` is imported here. \n2.2 There are no definitions or direct usages of pytest.raises in this file; it simply imports it.\n2.3 This file acts more as a module aggregator and doesn't define any logic related to the use of pytest.raises or how exceptions are handled within it.\n2.4 Given the content, this file isn't directly implementing the raises logic; it delegates to another module, `_pytest.python_api`.\n2.5 Cross-checking with references to `_pytest.python_api` might help explore further where `raises` is implemented.\n2.6 Thus, this file is not the root cause, it simply exposes functions/variables from other modules.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "_pytest/python_api.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:12:06.988045",
        "usage": "8933.621168136597 ms"
      },
      "request": {
        "file_path": "src/_pytest/runner.py"
      },
      "response": {
        "scratch_pad": "1. **Issue Analysis**:\n   1.1 The issue highlights a difference in behavior between regular Python exception handling and `pytest.raises` context manager in tests.\n   1.2 The user provides two code snippets: one using traditional `try/except` block, and another using `pytest.raises`. The expectation in both is to retrieve the full error message via `str(e)`.\n   1.3 The `pytest.raises` context variable, however, requires `str(e.value)` instead of `str(e)` to get the complete exception message.\n   1.4 The user's expectation is for `pytest.raises` to directly support `str(e)` to get the error message, similar to the traditional `try/except` mechanism.\n\n2. **Cause of Issue**:\n   - In pytest, the `raises` context manager stores the exception information in an `ExceptionInfo` object (most likely in this file), with the full exception available via `.value`, not the context variable directly.\n\n3. **File Evaluation**:\n   - The file `src/_pytest/runner.py` contains a lot of exception-related handling and structure, but primarily focuses on hooks and execution of tests rather than defining behavior for `pytest.raises`.\n   - The primary classes and functions related to exception handling are `CallInfo` and `ExceptionInfo`. `CallInfo` uses `ExceptionInfo` to handle exceptions, bundling the exception info when something is caught.\n   - `pytest_runtest_makereport` and `collect_one_node` use `CallInfo` to wrap function calls and deal with exceptions, potentially linking to how `pytest.raises` behaves under test circumstances.\n   - However, there is no explicit modification or alternative definition of the `pytest.raises` behavior for its context variable in this file.\n\n4. **Conclusion**:\n   - While `CallInfo` deals with exceptions, none of its methods or attributes directly inform or instruct `pytest.raises` to treat `str(e)` differently. Instead, this behavior is likely built into how `raises` is implemented elsewhere, potentially in the pytest assertion helpers or a similarly scoped utility module, which might encapsulate `ExceptionInfo`.\n\n5. **Possible Solutions**:\n   - Review how `ExceptionInfo` is designed to work in terms of string representation, perhaps enhancing its `__str__` method if possible.\n   - Verify if other files specifically dealing with `pytest.raises` might set up the behavior differently, potentially in assertion framework or plugin-utilizing files.\n6. **Relevant Files and Next Steps**:\n   - Identify locations where `pytest.raises` is defined to understand how it wraps exceptions.\n   - Scrutinize pytest's main exception handling and utility files for custom context manager behavior like in `raises`.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_code/code.py",
          "src/_pytest/outcomes.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:12:15.921706",
        "usage": "9386.070013046265 ms"
      },
      "request": {
        "file_path": "src/_pytest/assertion/util.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue**:\n   - The issue highlights a disparity in behavior between using `try...except` with `raise` and `pytest.raises` context manager when trying to convert the exception to a string using `str()`. \n   - When using `try...except`, calling `str(e)` on the exception object prints the complete message of the exception. However, when using `pytest.raises`, calling `str(e)` on this context variable prints a different format, and you need to use `str(e.value)` to get the full exception message.\n\n2. **Analyzing Reproduce Steps**:\n   - Two snippets are given, one using `try...except` and the other using `pytest.raises`.\n   - The mismatch occurs because, in `pytest.raises`, `e` represents a `ContextManager` object which holds the exception in its `value` attribute, rather than the exception itself.\n\n3. **How the Issue is Caused**:\n   - This discrepancy is due to the design of `pytest.raises`, where `e` is not the exception but a context manager object.\n   - The `.value` attribute of this context manager object holds the actual raised exception. Thus, `str(e)` does not directly equate to the exception's string representation.\n\n4. **User Expectation and Issue Cause**:\n   - The user expectation is that `str(e)` while catching exceptions with `pytest.raises` should provide the same output as with `try...except`.\n   - The issue arises from the need to access `e.value` instead of `e` to get the full exception message.\n\n5. **Possible Solutions**:\n   - A potential solution could involve modifying the behavior of `pytest.raises` or enhancing documentation or error messages to clarify this behavior. However, this isn't necessarily an issue with the `assertion` utilities themselves.\n\n6. **Evaluating the File for Relevance**:\n   - The provided file `util.py` contains utility functions for debugging assertions, but it does not directly deal with exception handling or the `pytest.raises` context manager functionality.\n   - The code in this file pertains to formatting explanations and comparisons of assertions, not handling exceptions or contexts.\n\n7. **Conclusion**:\n   - The file `util.py` is not relevant to the root cause of the issue since it doesn't handle or modify the behavior of `pytest.raises` context management, which is at the heart of the issue.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/_code/code.py",
          "src/_pytest/raises.py",
          "src/_pytest/outcomes.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:12:25.307859",
        "usage": "151.86619758605957 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/python_api.py",
            "relevant_symbol_keys": [
              "raises",
              "RaisesContext",
              "RaisesContext.__enter__"
            ],
            "root_cause_symbol_keys": [
              "raises",
              "RaisesContext",
              "RaisesContext.__enter__"
            ]
          },
          {
            "file_path": "src/_pytest/_code/code.py",
            "relevant_symbol_keys": [
              "ExceptionInfo",
              "ExceptionInfo.__str__"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/pytest.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/runner.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/assertion/util.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T12:12:25.459732",
        "usage": "15185.081958770752 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
            "start_line": 435,
            "start_column": 13339,
            "end_line": 4,
            "end_column": 13536,
            "start_byte": 13339,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          }
        ]
      },
      "response": {
        "scratch_pad": "1. The issue revolves around the discrepancy in behavior when converting an exception to a string using `str()` within the context of `pytest.raises` and a normal exception handling block.\n   - In a normal exception handler, `str(e)` gives the full message: \"A\\nB\\nC\".\n   - In `pytest.raises`, `str(e)` gives a summary: \"<console>:3: LookupError: A\", whereas `str(e.value)` gives the full message.\n2. The key difference is due to how `pytest.raises` captures exceptions and what `str()` returns when called on that captured context.\n3. Expected fix would be for `str(e)` in a pytest context to behave similarly to the regular try-except block.\n\nWe need to:\n1. Analyze `_pytest._code.ExceptionInfo` and check if the `__str__` or other relevant methods can be adapted.\n2. Examine how `RaisesContext` manages exceptions and what `__enter__` and `__exit__` return.\n3. Ensure that `str(e)` directly on the raises context returns the full message similar to `str(e.value)`.",
        "symbols": [
          {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "reason": "The `__str__` method directly affects what is printed when `str()` is called. Its current implementation seems to focus on providing a short summary, which is the root cause of the issue mentioned."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "- `_pytest.python_api._cmp_raises_type_error`: This symbol is not related to the issue of exception string representation. It's about comparison operators.\n",
          "- `_pytest.python_api.raises`: This symbol is relevant because it sets up the context for capturing exceptions. However, the main issue seems to lie in how exceptions are represented, not captured.\n",
          "- `_pytest.python_api.RaisesContext`: This class is relevant as it forms the context manager for handling exceptions in `pytest.raises`. The `__enter__` method returns `_pytest._code.ExceptionInfo`, which needs altering for string representation.\n",
          "- `_pytest.python_api.RaisesContext.__init__`: Sets up `RaisesContext`, but does not affect string representation directly.\n",
          "- `_pytest.python_api.RaisesContext.__enter__`: Returns an `ExceptionInfo` object which affects how exceptions are stored.\n",
          "- `_pytest.python_api.RaisesContext.__exit__`: Ensures the context manager suppresses or propagates exceptions correctly but does not deal with string representation directly.\n",
          "- `_pytest._code.ExceptionInfo`: This class wraps exceptions and provides methods for interacting with them. Relevant for how exceptions are represented as strings.\n",
          "- `_pytest._code.ExceptionInfo._assert_start_repr`: Internal configuration for assertion error representation; not directly relevant to the issue.\n",
          "- `_pytest._code.ExceptionInfo._excinfo`: Stores exception information; key to providing details about the exception.\n",
          "- `_pytest._code.ExceptionInfo._striptext`: Related to formatting exception output; might be influential in string output.\n",
          "- `_pytest._code.ExceptionInfo._traceback`: Deals with traceback representation; not directly relevant to string form of exception message.\n",
          "- `_pytest._code.ExceptionInfo.from_current`: Establishes the `ExceptionInfo` object from the current exception; doesn\u2019t deal with string representation output.\n",
          "- `_pytest._code.ExceptionInfo.for_later`: Returns an unfilled `ExceptionInfo`; not directly involved in string output.\n",
          "- `_pytest._code.ExceptionInfo.type`: Provides the exception class/type; not related to string conversion problem.\n",
          "- `_pytest._code.ExceptionInfo.value`: Provides the exception value; `str(e.value)` gives the full message so it's indirectly related.\n",
          "- `_pytest._code.ExceptionInfo.tb`: Represents traceback; not related to the string output of the message.\n",
          "- `_pytest._code.ExceptionInfo.typename`: Related to providing exception type name; not central to the string formatting issue.\n",
          "- `_pytest._code.ExceptionInfo.traceback`: Managing traceback doesn't affect string representation directly.\n",
          "- `_pytest._code.ExceptionInfo.__repr__`: Provides a representation of ExceptionInfo; not necessarily tied to `str()` output.\n",
          "- `_pytest._code.ExceptionInfo.exconly`: Manages how exception information is extracted; likely involved with how exception messages are abbreviated.\n",
          "- `_pytest._code.ExceptionInfo.errisinstance`: Not relevant to the issue of string representation.\n",
          "- `_pytest._code.ExceptionInfo._getreprcrash`: Manages crash information, not the string representation directly.\n",
          "- `_pytest._code.ExceptionInfo.getrepr`: Configures detailed exception information; not directly impacting string representation.\n",
          "- `_pytest._code.ExceptionInfo.__str__`: Directly prints exception; should align with the normal exception output for consistency.\n",
          "- `_pytest._code.ExceptionInfo.match`: Deals with matching exception messages to expressions; not directly relevant to string representation.\n",
          "- `_pytest._code.ReprExceptionInfo`: Provides detailed representation of exceptions; indirectly involved in string representation.\n",
          "- `_pytest._code.ReprExceptionInfo.__init__`: Initializes the repr object; not directly tied to string output.\n",
          "- `_pytest._code.ReprExceptionInfo.toterminal`: Prints representation to terminal; not related to `str()` output."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T12:12:40.644872",
        "usage": "2.8350353240966797 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest._code.ExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 372,
              "start_column": 11617,
              "end_line": 0,
              "end_column": 17390,
              "start_byte": 11617,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ExceptionInfo._assert_start_repr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_assert_start_repr = \"AssertionError('assert \"",
              "start_line": 378,
              "start_column": 11762,
              "end_line": 4,
              "end_column": 11808,
              "start_byte": 11762,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._excinfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_excinfo = attr.ib()",
              "start_line": 380,
              "start_column": 11814,
              "end_line": 4,
              "end_column": 11834,
              "start_byte": 11814,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._striptext",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_striptext = attr.ib(default=\"\")",
              "start_line": 381,
              "start_column": 11839,
              "end_line": 4,
              "end_column": 11871,
              "start_byte": 11839,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "_traceback = attr.ib(default=None)",
              "start_line": 382,
              "start_column": 11876,
              "end_line": 4,
              "end_column": 11910,
              "start_byte": 11876,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.from_current",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
              "start_line": 384,
              "start_column": 11916,
              "end_line": 4,
              "end_column": 12782,
              "start_byte": 11916,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.for_later",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
              "start_line": 409,
              "start_column": 12788,
              "end_line": 4,
              "end_column": 12905,
              "start_byte": 12788,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.type",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
              "start_line": 415,
              "start_column": 12911,
              "end_line": 4,
              "end_column": 13006,
              "start_byte": 12911,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.value",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
              "start_line": 420,
              "start_column": 13012,
              "end_line": 4,
              "end_column": 13108,
              "start_byte": 13012,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.tb",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
              "start_line": 425,
              "start_column": 13114,
              "end_line": 4,
              "end_column": 13215,
              "start_byte": 13114,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.typename",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
              "start_line": 430,
              "start_column": 13221,
              "end_line": 4,
              "end_column": 13333,
              "start_byte": 13221,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback",
              "start_line": 435,
              "start_column": 13339,
              "end_line": 4,
              "end_column": 13536,
              "start_byte": 13339,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.traceback",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
              "start_line": 442,
              "start_column": 13542,
              "end_line": 4,
              "end_column": 13623,
              "start_byte": 13542,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__repr__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
              "start_line": 446,
              "start_column": 13629,
              "end_line": 4,
              "end_column": 13829,
              "start_byte": 13629,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.exconly",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
              "start_line": 451,
              "start_column": 13835,
              "end_line": 4,
              "end_column": 14454,
              "start_byte": 13835,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.errisinstance",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
              "start_line": 467,
              "start_column": 14460,
              "end_line": 4,
              "end_column": 14599,
              "start_byte": 14460,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo._getreprcrash",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
              "start_line": 471,
              "start_column": 14605,
              "end_line": 4,
              "end_column": 14851,
              "start_byte": 14605,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.getrepr",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
              "start_line": 477,
              "start_column": 14857,
              "end_line": 4,
              "end_column": 16613,
              "start_byte": 14857,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
              "start_line": 536,
              "start_column": 16619,
              "end_line": 4,
              "end_column": 16837,
              "start_byte": 16619,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ExceptionInfo.match",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
              "start_line": 543,
              "start_column": 16843,
              "end_line": 4,
              "end_column": 17390,
              "start_byte": 16843,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 850,
              "start_column": 28209,
              "end_line": 0,
              "end_column": 28507,
              "start_byte": 28209,
              "end_byte": 0
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.__init__",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
              "start_line": 851,
              "start_column": 28253,
              "end_line": 4,
              "end_column": 28403,
              "start_byte": 28253,
              "end_byte": 4
            },
            {
              "name": "_pytest._code.ReprExceptionInfo.toterminal",
              "file_path": "src/_pytest/_code/code.py",
              "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
              "start_line": 856,
              "start_column": 28409,
              "end_line": 4,
              "end_column": 28507,
              "start_byte": 28409,
              "end_byte": 4
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.python_api._cmp_raises_type_error",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
              "start_line": 22,
              "start_column": 496,
              "end_line": 0,
              "end_column": 951,
              "start_byte": 496,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.raises",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
              "start_line": 542,
              "start_column": 20241,
              "end_line": 0,
              "end_column": 26789,
              "start_byte": 20241,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.RaisesContext",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 708,
              "start_column": 26828,
              "end_line": 0,
              "end_column": 27562,
              "start_byte": 26828,
              "end_byte": 0
            },
            {
              "name": "_pytest.python_api.RaisesContext.__init__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
              "start_line": 709,
              "start_column": 26853,
              "end_line": 4,
              "end_column": 27062,
              "start_byte": 26853,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__enter__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
              "start_line": 715,
              "start_column": 27068,
              "end_line": 4,
              "end_column": 27179,
              "start_byte": 27068,
              "end_byte": 4
            },
            {
              "name": "_pytest.python_api.RaisesContext.__exit__",
              "file_path": "src/_pytest/python_api.py",
              "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
              "start_line": 719,
              "start_column": 27185,
              "end_line": 4,
              "end_column": 27562,
              "start_byte": 27185,
              "end_byte": 4
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "1. The issue revolves around the discrepancy in behavior when converting an exception to a string using `str()` within the context of `pytest.raises` and a normal exception handling block.\n   - In a normal exception handler, `str(e)` gives the full message: \"A\\nB\\nC\".\n   - In `pytest.raises`, `str(e)` gives a summary: \"<console>:3: LookupError: A\", whereas `str(e.value)` gives the full message.\n2. The key difference is due to how `pytest.raises` captures exceptions and what `str()` returns when called on that captured context.\n3. Expected fix would be for `str(e)` in a pytest context to behave similarly to the regular try-except block.\n\nWe need to:\n1. Analyze `_pytest._code.ExceptionInfo` and check if the `__str__` or other relevant methods can be adapted.\n2. Examine how `RaisesContext` manages exceptions and what `__enter__` and `__exit__` return.\n3. Ensure that `str(e)` directly on the raises context returns the full message similar to `str(e.value)`.",
          "symbols": [
            {
              "name": "_pytest._code.ExceptionInfo.__str__",
              "file_path": "src/_pytest/_code/code.py",
              "reason": "The `__str__` method directly affects what is printed when `str()` is called. Its current implementation seems to focus on providing a short summary, which is the root cause of the issue mentioned."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "- `_pytest.python_api._cmp_raises_type_error`: This symbol is not related to the issue of exception string representation. It's about comparison operators.\n",
            "- `_pytest.python_api.raises`: This symbol is relevant because it sets up the context for capturing exceptions. However, the main issue seems to lie in how exceptions are represented, not captured.\n",
            "- `_pytest.python_api.RaisesContext`: This class is relevant as it forms the context manager for handling exceptions in `pytest.raises`. The `__enter__` method returns `_pytest._code.ExceptionInfo`, which needs altering for string representation.\n",
            "- `_pytest.python_api.RaisesContext.__init__`: Sets up `RaisesContext`, but does not affect string representation directly.\n",
            "- `_pytest.python_api.RaisesContext.__enter__`: Returns an `ExceptionInfo` object which affects how exceptions are stored.\n",
            "- `_pytest.python_api.RaisesContext.__exit__`: Ensures the context manager suppresses or propagates exceptions correctly but does not deal with string representation directly.\n",
            "- `_pytest._code.ExceptionInfo`: This class wraps exceptions and provides methods for interacting with them. Relevant for how exceptions are represented as strings.\n",
            "- `_pytest._code.ExceptionInfo._assert_start_repr`: Internal configuration for assertion error representation; not directly relevant to the issue.\n",
            "- `_pytest._code.ExceptionInfo._excinfo`: Stores exception information; key to providing details about the exception.\n",
            "- `_pytest._code.ExceptionInfo._striptext`: Related to formatting exception output; might be influential in string output.\n",
            "- `_pytest._code.ExceptionInfo._traceback`: Deals with traceback representation; not directly relevant to string form of exception message.\n",
            "- `_pytest._code.ExceptionInfo.from_current`: Establishes the `ExceptionInfo` object from the current exception; doesn\u2019t deal with string representation output.\n",
            "- `_pytest._code.ExceptionInfo.for_later`: Returns an unfilled `ExceptionInfo`; not directly involved in string output.\n",
            "- `_pytest._code.ExceptionInfo.type`: Provides the exception class/type; not related to string conversion problem.\n",
            "- `_pytest._code.ExceptionInfo.value`: Provides the exception value; `str(e.value)` gives the full message so it's indirectly related.\n",
            "- `_pytest._code.ExceptionInfo.tb`: Represents traceback; not related to the string output of the message.\n",
            "- `_pytest._code.ExceptionInfo.typename`: Related to providing exception type name; not central to the string formatting issue.\n",
            "- `_pytest._code.ExceptionInfo.traceback`: Managing traceback doesn't affect string representation directly.\n",
            "- `_pytest._code.ExceptionInfo.__repr__`: Provides a representation of ExceptionInfo; not necessarily tied to `str()` output.\n",
            "- `_pytest._code.ExceptionInfo.exconly`: Manages how exception information is extracted; likely involved with how exception messages are abbreviated.\n",
            "- `_pytest._code.ExceptionInfo.errisinstance`: Not relevant to the issue of string representation.\n",
            "- `_pytest._code.ExceptionInfo._getreprcrash`: Manages crash information, not the string representation directly.\n",
            "- `_pytest._code.ExceptionInfo.getrepr`: Configures detailed exception information; not directly impacting string representation.\n",
            "- `_pytest._code.ExceptionInfo.__str__`: Directly prints exception; should align with the normal exception output for consistency.\n",
            "- `_pytest._code.ExceptionInfo.match`: Deals with matching exception messages to expressions; not directly relevant to string representation.\n",
            "- `_pytest._code.ReprExceptionInfo`: Provides detailed representation of exceptions; indirectly involved in string representation.\n",
            "- `_pytest._code.ReprExceptionInfo.__init__`: Initializes the repr object; not directly tied to string output.\n",
            "- `_pytest._code.ReprExceptionInfo.toterminal`: Prints representation to terminal; not related to `str()` output."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/_code/code.py"
        ],
        "symbols": [
          "_pytest._code.ExceptionInfo.__str__"
        ],
        "code_spans": {
          "_pytest._code.ExceptionInfo": {
            "name": "_pytest._code.ExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@attr.s(repr=False)\nclass ExceptionInfo:\n    \"\"\" wraps sys.exc_info() objects and offers\n        help for navigating the traceback.\n    \"\"\"\n\n    _assert_start_repr = \"AssertionError('assert \"\n\n    _excinfo = attr.ib()\n    _striptext = attr.ib(default=\"\")\n    _traceback = attr.ib(default=None)\n\n    @classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)\n\n    @classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)\n\n    @property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]\n\n    @property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]\n\n    @property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]\n\n    @property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__\n\n    @property\n    def traceback(self):\n        \"\"\"the traceback\"\"\"\n        if self._traceback is None:\n            self._traceback = Traceback(self.tb, excinfo=ref(self))\n        return self._traceback\n\n    @traceback.setter\n    def traceback(self, value):\n        self._traceback = value\n\n    def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))\n\n    def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text\n\n    def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)\n\n    def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)\n\n    def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)\n\n    def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)\n\n    def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 372,
            "start_column": 11617,
            "end_line": 0,
            "end_column": 17390,
            "start_byte": 11617,
            "end_byte": 0
          },
          "_pytest._code.ExceptionInfo._assert_start_repr": {
            "name": "_pytest._code.ExceptionInfo._assert_start_repr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_assert_start_repr = \"AssertionError('assert \"",
            "start_line": 378,
            "start_column": 11762,
            "end_line": 4,
            "end_column": 11808,
            "start_byte": 11762,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._excinfo": {
            "name": "_pytest._code.ExceptionInfo._excinfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_excinfo = attr.ib()",
            "start_line": 380,
            "start_column": 11814,
            "end_line": 4,
            "end_column": 11834,
            "start_byte": 11814,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._striptext": {
            "name": "_pytest._code.ExceptionInfo._striptext",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_striptext = attr.ib(default=\"\")",
            "start_line": 381,
            "start_column": 11839,
            "end_line": 4,
            "end_column": 11871,
            "start_byte": 11839,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._traceback": {
            "name": "_pytest._code.ExceptionInfo._traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "_traceback = attr.ib(default=None)",
            "start_line": 382,
            "start_column": 11876,
            "end_line": 4,
            "end_column": 11910,
            "start_byte": 11876,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.from_current": {
            "name": "_pytest._code.ExceptionInfo.from_current",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def from_current(cls, exprinfo=None):\n        \"\"\"returns an ExceptionInfo matching the current traceback\n\n        .. warning::\n\n            Experimental API\n\n\n        :param exprinfo: a text string helping to determine if we should\n                         strip ``AssertionError`` from the output, defaults\n                         to the exception message/``__str__()``\n        \"\"\"\n        tup = sys.exc_info()\n        assert tup[0] is not None, \"no current exception\"\n        _striptext = \"\"\n        if exprinfo is None and isinstance(tup[1], AssertionError):\n            exprinfo = getattr(tup[1], \"msg\", None)\n            if exprinfo is None:\n                exprinfo = saferepr(tup[1])\n            if exprinfo and exprinfo.startswith(cls._assert_start_repr):\n                _striptext = \"AssertionError: \"\n\n        return cls(tup, _striptext)",
            "start_line": 384,
            "start_column": 11916,
            "end_line": 4,
            "end_column": 12782,
            "start_byte": 11916,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.for_later": {
            "name": "_pytest._code.ExceptionInfo.for_later",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@classmethod\n    def for_later(cls):\n        \"\"\"return an unfilled ExceptionInfo\n        \"\"\"\n        return cls(None)",
            "start_line": 409,
            "start_column": 12788,
            "end_line": 4,
            "end_column": 12905,
            "start_byte": 12788,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.type": {
            "name": "_pytest._code.ExceptionInfo.type",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def type(self):\n        \"\"\"the exception class\"\"\"\n        return self._excinfo[0]",
            "start_line": 415,
            "start_column": 12911,
            "end_line": 4,
            "end_column": 13006,
            "start_byte": 12911,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.value": {
            "name": "_pytest._code.ExceptionInfo.value",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def value(self):\n        \"\"\"the exception value\"\"\"\n        return self._excinfo[1]",
            "start_line": 420,
            "start_column": 13012,
            "end_line": 4,
            "end_column": 13108,
            "start_byte": 13012,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.tb": {
            "name": "_pytest._code.ExceptionInfo.tb",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def tb(self):\n        \"\"\"the exception raw traceback\"\"\"\n        return self._excinfo[2]",
            "start_line": 425,
            "start_column": 13114,
            "end_line": 4,
            "end_column": 13215,
            "start_byte": 13114,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.typename": {
            "name": "_pytest._code.ExceptionInfo.typename",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@property\n    def typename(self):\n        \"\"\"the type name of the exception\"\"\"\n        return self.type.__name__",
            "start_line": 430,
            "start_column": 13221,
            "end_line": 4,
            "end_column": 13333,
            "start_byte": 13221,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.traceback": {
            "name": "_pytest._code.ExceptionInfo.traceback",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "@traceback.setter\n    def traceback(self, value):\n        self._traceback = value",
            "start_line": 442,
            "start_column": 13542,
            "end_line": 4,
            "end_column": 13623,
            "start_byte": 13542,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__repr__": {
            "name": "_pytest._code.ExceptionInfo.__repr__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __repr__(self):\n        if self._excinfo is None:\n            return \"<ExceptionInfo for raises contextmanager>\"\n        return \"<ExceptionInfo %s tblen=%d>\" % (self.typename, len(self.traceback))",
            "start_line": 446,
            "start_column": 13629,
            "end_line": 4,
            "end_column": 13829,
            "start_byte": 13629,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.exconly": {
            "name": "_pytest._code.ExceptionInfo.exconly",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def exconly(self, tryshort=False):\n        \"\"\" return the exception as a string\n\n            when 'tryshort' resolves to True, and the exception is a\n            _pytest._code._AssertionError, only the actual exception part of\n            the exception representation is returned (so 'AssertionError: ' is\n            removed from the beginning)\n        \"\"\"\n        lines = format_exception_only(self.type, self.value)\n        text = \"\".join(lines)\n        text = text.rstrip()\n        if tryshort:\n            if text.startswith(self._striptext):\n                text = text[len(self._striptext) :]\n        return text",
            "start_line": 451,
            "start_column": 13835,
            "end_line": 4,
            "end_column": 14454,
            "start_byte": 13835,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.errisinstance": {
            "name": "_pytest._code.ExceptionInfo.errisinstance",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def errisinstance(self, exc):\n        \"\"\" return True if the exception is an instance of exc \"\"\"\n        return isinstance(self.value, exc)",
            "start_line": 467,
            "start_column": 14460,
            "end_line": 4,
            "end_column": 14599,
            "start_byte": 14460,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo._getreprcrash": {
            "name": "_pytest._code.ExceptionInfo._getreprcrash",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def _getreprcrash(self):\n        exconly = self.exconly(tryshort=True)\n        entry = self.traceback.getcrashentry()\n        path, lineno = entry.frame.code.raw.co_filename, entry.lineno\n        return ReprFileLocation(path, lineno + 1, exconly)",
            "start_line": 471,
            "start_column": 14605,
            "end_line": 4,
            "end_column": 14851,
            "start_byte": 14605,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.getrepr": {
            "name": "_pytest._code.ExceptionInfo.getrepr",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def getrepr(\n        self,\n        showlocals=False,\n        style=\"long\",\n        abspath=False,\n        tbfilter=True,\n        funcargs=False,\n        truncate_locals=True,\n        chain=True,\n    ):\n        \"\"\"\n        Return str()able representation of this exception info.\n\n        :param bool showlocals:\n            Show locals per traceback entry.\n            Ignored if ``style==\"native\"``.\n\n        :param str style: long|short|no|native traceback style\n\n        :param bool abspath:\n            If paths should be changed to absolute or left unchanged.\n\n        :param bool tbfilter:\n            Hide entries that contain a local variable ``__tracebackhide__==True``.\n            Ignored if ``style==\"native\"``.\n\n        :param bool funcargs:\n            Show fixtures (\"funcargs\" for legacy purposes) per traceback entry.\n\n        :param bool truncate_locals:\n            With ``showlocals==True``, make sure locals can be safely represented as strings.\n\n        :param bool chain: if chained exceptions in Python 3 should be shown.\n\n        .. versionchanged:: 3.9\n\n            Added the ``chain`` parameter.\n        \"\"\"\n        if style == \"native\":\n            return ReprExceptionInfo(\n                ReprTracebackNative(\n                    traceback.format_exception(\n                        self.type, self.value, self.traceback[0]._rawentry\n                    )\n                ),\n                self._getreprcrash(),\n            )\n\n        fmt = FormattedExcinfo(\n            showlocals=showlocals,\n            style=style,\n            abspath=abspath,\n            tbfilter=tbfilter,\n            funcargs=funcargs,\n            truncate_locals=truncate_locals,\n            chain=chain,\n        )\n        return fmt.repr_excinfo(self)",
            "start_line": 477,
            "start_column": 14857,
            "end_line": 4,
            "end_column": 16613,
            "start_byte": 14857,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.__str__": {
            "name": "_pytest._code.ExceptionInfo.__str__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __str__(self):\n        if self._excinfo is None:\n            return repr(self)\n        entry = self.traceback[-1]\n        loc = ReprFileLocation(entry.path, entry.lineno + 1, self.exconly())\n        return str(loc)",
            "start_line": 536,
            "start_column": 16619,
            "end_line": 4,
            "end_column": 16837,
            "start_byte": 16619,
            "end_byte": 4
          },
          "_pytest._code.ExceptionInfo.match": {
            "name": "_pytest._code.ExceptionInfo.match",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def match(self, regexp):\n        \"\"\"\n        Check whether the regular expression 'regexp' is found in the string\n        representation of the exception using ``re.search``. If it matches\n        then True is returned (so that it is possible to write\n        ``assert excinfo.match()``). If it doesn't match an AssertionError is\n        raised.\n        \"\"\"\n        __tracebackhide__ = True\n        if not re.search(regexp, str(self.value)):\n            assert 0, \"Pattern '{!s}' not found in '{!s}'\".format(regexp, self.value)\n        return True",
            "start_line": 543,
            "start_column": 16843,
            "end_line": 4,
            "end_column": 17390,
            "start_byte": 16843,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo": {
            "name": "_pytest._code.ReprExceptionInfo",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "class ReprExceptionInfo(ExceptionRepr):\n    def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash\n\n    def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 850,
            "start_column": 28209,
            "end_line": 0,
            "end_column": 28507,
            "start_byte": 28209,
            "end_byte": 0
          },
          "_pytest._code.ReprExceptionInfo.__init__": {
            "name": "_pytest._code.ReprExceptionInfo.__init__",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def __init__(self, reprtraceback, reprcrash):\n        super().__init__()\n        self.reprtraceback = reprtraceback\n        self.reprcrash = reprcrash",
            "start_line": 851,
            "start_column": 28253,
            "end_line": 4,
            "end_column": 28403,
            "start_byte": 28253,
            "end_byte": 4
          },
          "_pytest._code.ReprExceptionInfo.toterminal": {
            "name": "_pytest._code.ReprExceptionInfo.toterminal",
            "file_path": "src/_pytest/_code/code.py",
            "file_content": "def toterminal(self, tw):\n        self.reprtraceback.toterminal(tw)\n        super().toterminal(tw)",
            "start_line": 856,
            "start_column": 28409,
            "end_line": 4,
            "end_column": 28507,
            "start_byte": 28409,
            "end_byte": 4
          },
          "_pytest.python_api._cmp_raises_type_error": {
            "name": "_pytest.python_api._cmp_raises_type_error",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def _cmp_raises_type_error(self, other):\n    \"\"\"__cmp__ implementation which raises TypeError. Used\n    by Approx base classes to implement only == and != and raise a\n    TypeError for other comparisons.\n\n    Needed in Python 2 only, Python 3 all it takes is not implementing the\n    other operators at all.\n    \"\"\"\n    __tracebackhide__ = True\n    raise TypeError(\n        \"Comparison operators other than == and != not supported by approx objects\"\n    )",
            "start_line": 22,
            "start_column": 496,
            "end_line": 0,
            "end_column": 951,
            "start_byte": 496,
            "end_byte": 0
          },
          "_pytest.python_api.raises": {
            "name": "_pytest.python_api.raises",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def raises(expected_exception, *args, **kwargs):\n    r\"\"\"\n    Assert that a code block/function call raises ``expected_exception``\n    or raise a failure exception otherwise.\n\n    :kwparam match: if specified, a string containing a regular expression,\n        or a regular expression object, that is tested against the string\n        representation of the exception using ``re.search``. To match a literal\n        string that may contain `special characters`__, the pattern can\n        first be escaped with ``re.escape``.\n\n    __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n\n    :kwparam message: **(deprecated since 4.1)** if specified, provides a custom failure message\n        if the exception is not raised. See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. currentmodule:: _pytest._code\n\n    Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n    type::\n\n        >>> with raises(ZeroDivisionError):\n        ...    1/0\n\n    If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n    above), or no exception at all, the check will fail instead.\n\n    You can also use the keyword argument ``match`` to assert that the\n    exception matches a text or regex::\n\n        >>> with raises(ValueError, match='must be 0 or None'):\n        ...     raise ValueError(\"value must be 0 or None\")\n\n        >>> with raises(ValueError, match=r'must be \\d+$'):\n        ...     raise ValueError(\"value must be 42\")\n\n    The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n    details of the captured exception::\n\n        >>> with raises(ValueError) as exc_info:\n        ...     raise ValueError(\"value must be 42\")\n        >>> assert exc_info.type is ValueError\n        >>> assert exc_info.value.args[0] == \"value must be 42\"\n\n    .. deprecated:: 4.1\n\n        In the context manager form you may use the keyword argument\n        ``message`` to specify a custom failure message that will be displayed\n        in case the ``pytest.raises`` check fails. This has been deprecated as it\n        is considered error prone as users often mean to use ``match`` instead.\n        See :ref:`the deprecation docs <raises message deprecated>` for a workaround.\n\n    .. note::\n\n       When using ``pytest.raises`` as a context manager, it's worthwhile to\n       note that normal context manager rules apply and that the exception\n       raised *must* be the final line in the scope of the context manager.\n       Lines of code after that, within the scope of the context manager will\n       not be executed. For example::\n\n           >>> value = 15\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...     assert exc_info.type is ValueError  # this will not execute\n\n       Instead, the following approach must be taken (note the difference in\n       scope)::\n\n           >>> with raises(ValueError) as exc_info:\n           ...     if value > 10:\n           ...         raise ValueError(\"value must be <= 10\")\n           ...\n           >>> assert exc_info.type is ValueError\n\n    **Using with** ``pytest.mark.parametrize``\n\n    When using :ref:`pytest.mark.parametrize ref`\n    it is possible to parametrize tests such that\n    some runs raise an exception and others do not.\n\n    See :ref:`parametrizing_conditional_raising` for an example.\n\n    **Legacy form**\n\n    It is possible to specify a callable by passing a to-be-called lambda::\n\n        >>> raises(ZeroDivisionError, lambda: 1/0)\n        <ExceptionInfo ...>\n\n    or you can specify an arbitrary callable with arguments::\n\n        >>> def f(x): return 1/x\n        ...\n        >>> raises(ZeroDivisionError, f, 0)\n        <ExceptionInfo ...>\n        >>> raises(ZeroDivisionError, f, x=0)\n        <ExceptionInfo ...>\n\n    The form above is fully supported but discouraged for new code because the\n    context manager form is regarded as more readable and less error-prone.\n\n    .. note::\n        Similar to caught exception objects in Python, explicitly clearing\n        local references to returned ``ExceptionInfo`` objects can\n        help the Python interpreter speed up its garbage collection.\n\n        Clearing those references breaks a reference cycle\n        (``ExceptionInfo`` --> caught exception --> frame stack raising\n        the exception --> current frame stack --> local variables -->\n        ``ExceptionInfo``) which makes Python keep all objects referenced\n        from that cycle (including all local variables in the current\n        frame) alive until the next cyclic garbage collection run. See the\n        official Python ``try`` statement documentation for more detailed\n        information.\n\n    \"\"\"\n    __tracebackhide__ = True\n    for exc in filterfalse(isclass, always_iterable(expected_exception, BASE_TYPE)):\n        msg = (\n            \"exceptions must be old-style classes or\"\n            \" derived from BaseException, not %s\"\n        )\n        raise TypeError(msg % type(exc))\n\n    message = \"DID NOT RAISE {}\".format(expected_exception)\n    match_expr = None\n\n    if not args:\n        if \"message\" in kwargs:\n            message = kwargs.pop(\"message\")\n            warnings.warn(deprecated.RAISES_MESSAGE_PARAMETER, stacklevel=2)\n        if \"match\" in kwargs:\n            match_expr = kwargs.pop(\"match\")\n        if kwargs:\n            msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n            msg += \", \".join(sorted(kwargs))\n            raise TypeError(msg)\n        return RaisesContext(expected_exception, message, match_expr)\n    elif isinstance(args[0], str):\n        warnings.warn(deprecated.RAISES_EXEC, stacklevel=2)\n        code, = args\n        assert isinstance(code, str)\n        frame = sys._getframe(1)\n        loc = frame.f_locals.copy()\n        loc.update(kwargs)\n        # print \"raises frame scope: %r\" % frame.f_locals\n        try:\n            code = _pytest._code.Source(code).compile(_genframe=frame)\n            exec(code, frame.f_globals, loc)\n            # XXX didn't mean f_globals == f_locals something special?\n            #     this is destroyed here ...\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    else:\n        func = args[0]\n        try:\n            func(*args[1:], **kwargs)\n        except expected_exception:\n            return _pytest._code.ExceptionInfo.from_current()\n    fail(message)",
            "start_line": 542,
            "start_column": 20241,
            "end_line": 0,
            "end_column": 26789,
            "start_byte": 20241,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext": {
            "name": "_pytest.python_api.RaisesContext",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "class RaisesContext:\n    def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None\n\n    def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo\n\n    def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 708,
            "start_column": 26828,
            "end_line": 0,
            "end_column": 27562,
            "start_byte": 26828,
            "end_byte": 0
          },
          "_pytest.python_api.RaisesContext.__init__": {
            "name": "_pytest.python_api.RaisesContext.__init__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __init__(self, expected_exception, message, match_expr):\n        self.expected_exception = expected_exception\n        self.message = message\n        self.match_expr = match_expr\n        self.excinfo = None",
            "start_line": 709,
            "start_column": 26853,
            "end_line": 4,
            "end_column": 27062,
            "start_byte": 26853,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__enter__": {
            "name": "_pytest.python_api.RaisesContext.__enter__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __enter__(self):\n        self.excinfo = _pytest._code.ExceptionInfo.for_later()\n        return self.excinfo",
            "start_line": 715,
            "start_column": 27068,
            "end_line": 4,
            "end_column": 27179,
            "start_byte": 27068,
            "end_byte": 4
          },
          "_pytest.python_api.RaisesContext.__exit__": {
            "name": "_pytest.python_api.RaisesContext.__exit__",
            "file_path": "src/_pytest/python_api.py",
            "file_content": "def __exit__(self, *tp):\n        __tracebackhide__ = True\n        if tp[0] is None:\n            fail(self.message)\n        self.excinfo.__init__(tp)\n        suppress_exception = issubclass(self.excinfo.type, self.expected_exception)\n        if self.match_expr is not None and suppress_exception:\n            self.excinfo.match(self.match_expr)\n        return suppress_exception",
            "start_line": 719,
            "start_column": 27185,
            "end_line": 4,
            "end_column": 27562,
            "start_byte": 27185,
            "end_byte": 4
          }
        }
      }
    }
  ]
}