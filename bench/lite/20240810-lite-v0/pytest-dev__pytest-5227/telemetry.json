{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-5227",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:10:57.695618",
        "usage": "1505.5978298187256 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "getlocals",
          "delattr",
          "disabled",
          "compile",
          "fullsource",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "_some_str",
          "MODULE_NOT_FOUND_ERROR",
          "_match_lines",
          "run",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "_is_setup_py",
          "BOM_UTF8",
          "_getnextfixturedef",
          "append_skipped",
          "REPORT_COLLECTING_RESOLUTION",
          "PYTEST_CONFIG_GLOBAL",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_inject_setup_function_fixture",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "PY36",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "cached_result",
          "visit_Call_legacy",
          "ApproxDecimal",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "applymarker",
          "_check_all_skipped",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "check_xfail_no_run",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "__setattr__",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "get_terminal_writer",
          "exec_",
          "inline_genitems",
          "writeorg",
          "RAISES_MESSAGE_PARAMETER",
          "__eq__",
          "update_testcase_duration",
          "_callhelper",
          "USAGE_MSG",
          "collect_one_node",
          "_code",
          "PYTEST_ENSURETEMP",
          "append_pass",
          "N",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "value",
          "consider_preparse",
          "unittest",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "_exec_lsof",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "RaisesContext",
          "_get_non_fixture_func",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "junitxml",
          "_mk_tmp",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "PYTEST_LOGWARNING",
          "LEVELNAME_FMT_REGEX",
          "RN",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "_log_cli_enabled",
          "processoption",
          "_config",
          "getfuncargvalue",
          "TestCaseFunction",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "location",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "unary_map",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "format_explanation",
          "makeconftest",
          "alias",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "repr_unicode",
          "doctest",
          "fileno",
          "setns",
          "_validate_usepdb_cls",
          "Class",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "pytest_itemstart",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "last_failed_paths",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "families",
          "pytest_terminal_summary",
          "__nonzero__",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "_get_marks",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "done",
          "add_report_section",
          "PytestPluginManager",
          "getnode",
          "YIELD_TESTS",
          "update",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "PrintHelp",
          "MyOptionParser",
          "parseconfig",
          "pytest_doctest_prepare_content",
          "pyobj_property",
          "find_module",
          "scope2index",
          "getbasetemp",
          "EXIT_TESTSFAILED",
          "_addexcinfo",
          "_width_of_current_line",
          "NodeMarkers",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "is_true",
          "_ConfigDeprecated",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "errors",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "short_test_summary",
          "_call_and_format_exception",
          "parse_num",
          "_checkargnotcontained",
          "python_keywords_allowed_list",
          "collect_by_name",
          "parsefactories",
          "_ensure_only_one_capture_fixture",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "ASCII_IS_DEFAULT_ENCODING",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "repr",
          "SEP",
          "matchkeyword",
          "SubRequest",
          "load_module",
          "EXIT_INTERNALERROR",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_handle_skip",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "_getglobals",
          "generic_visit",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "PYTEST_WARNS_UNKNOWN_KWARGS",
          "autouse",
          "_importconftest",
          "args",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "exc_clear",
          "PytestDeprecationWarning",
          "pytest_logwarning",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "visit_Call_35",
          "__array_ufunc__",
          "MarkMapping",
          "summary_errors",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "format_exception_only",
          "MARK_GEN",
          "fspath",
          "_opentestcase",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "syspath_prepend",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "NoneType",
          "find_suffixes",
          "syspathinsert",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "istrue",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "set_when",
          "delenv",
          "_perform_collect",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "raiseerror",
          "fnmatch_ex",
          "_runtest_for_main",
          "Traceback",
          "pytest_runtestloop",
          "item_capture",
          "TestReport",
          "capfd",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "PyobjContext",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "cls",
          "getlocation",
          "isclass",
          "parseconfigure",
          "repr_locals",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "visit_Name",
          "report_collect",
          "finish",
          "getdecoded",
          "_compilecounter",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "AssertionState",
          "_find_last_non_hidden_frame",
          "ihook",
          "call_optional",
          "_get_override_ini_value",
          "ExceptionRepr",
          "putaround",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "_install_capture_fixture_on_item",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "_write_pyc",
          "__len__",
          "summary_stats",
          "__next__",
          "getrawcode",
          "find",
          "_initrequest",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_callfinalizers",
          "CollectErrorRepr",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "RemovedInPytest4Warning",
          "extract_suffixes",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "isiterable",
          "FSCollector",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "ensure_newline",
          "saferepr",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "_getcapture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "CaptureResult",
          "str",
          "isparseable",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "OptionGroup",
          "error",
          "_is_capturing",
          "_attempt_to_close_capture_file",
          "FixtureRequest",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "ReprFileLocation",
          "PY35",
          "format",
          "isfunction",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "scopeproperty",
          "getitem",
          "ensuretemp",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "_is_unittest_unexpected_success_a_failure",
          "initialnames",
          "LogXML",
          "__getitem__",
          "FIXTURE_NAMED_REQUEST",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "exists",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "patchsysdict",
          "start_global_capturing",
          "_fix_spoof_python2",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "compile_",
          "assert_contains_lines",
          "Entry",
          "chain",
          "setall",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "_teardown_towards",
          "capture_fixtures",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "safe_text_dupfile",
          "MoreQuietAction",
          "LineMatcher",
          "context",
          "fixtures",
          "__call__",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "matchmark",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "_PY3",
          "freeze_support",
          "params",
          "isnosetest",
          "_PY2",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "PYTEST_PARAM_UNKNOWN_KWARGS",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "_register_with_pkg_resources",
          "mkdir",
          "own_markers",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "EXIT_INTERRUPTED",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "readlines",
          "inline_runsource",
          "cmdline",
          "__delitem__",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "FunctionMixin",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "_show_fixtures_per_test",
          "collect",
          "winpymap",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "MarkEvaluator",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "_setup_collect_fakemodule",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "cached_eval",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "FixtureFunctionMarker",
          "__bool__",
          "_parse_lsof_output",
          "_import_pdbcls",
          "_format_final_exc_line",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "writelines",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "_warn_if_env_name_is_not_str",
          "restore",
          "runpytest",
          "__exit__",
          "_get_allow_unicode_flag",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_is_mocked",
          "_showfixtures_main",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "_setoption",
          "Node",
          "parametrize",
          "_setup_cli_logging",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "ReprEntry",
          "EXIT_USAGEERROR",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "_typ_map",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "defaultfuncargprefixmarker",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "is_package",
          "Interrupted",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "rmtree",
          "strip",
          "PYTEST_PLUGINS_FROM_NON_TOP_LEVEL_CONFTEST",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "getexplanation",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "_fix_unittest_skip_decorator",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "dummy_context_manager",
          "Exit",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "getcfg",
          "exit",
          "_imp_find_module",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "NoCapture",
          "_rewrite_test",
          "raise_on_kwargs",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "_get_xunit_setup_teardown",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "ecu",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "_patched_find_module",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "warn_about_none_ast",
          "wasvalid",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "cookie_re",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "__version__",
          "RAISES_EXEC",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "getslaveinfoline",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "FIXTURE_FUNCTION_CALL",
          "_test_pytest_function",
          "_preparse",
          "idmaker",
          "FDCaptureBinary",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "with_args",
          "EXIT_NOTESTSCOLLECTED",
          "_get_active_fixturedef",
          "yield_fixture",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "ApproxBase",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "check_strict_xfail",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "SHOW_PYTEST_WARNINGS_ARG",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "_state",
          "_PLUGGY_DIR",
          "get_actual_log_level",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "get_skip_exceptions",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "_prunetraceback",
          "addinivalue_line",
          "EXIT_OK",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "WARNS_EXEC",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "runitem",
          "_istrue",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "call_and_report",
          "nofuncargs",
          "Config",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "invalidraise",
          "Module",
          "KeywordMapping",
          "Item",
          "_idvalset",
          "pytest_addhooks",
          "__all__",
          "matchnodes",
          "read_global_capture",
          "_getini",
          "_pdb_cls",
          "istestfunction",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "FuncargnamesCompatAttr",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "addhooks",
          "GETFUNCARGVALUE",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "_cmp_raises_type_error",
          "nodes",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "binop_map",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "write",
          "get_fslocation_from_item",
          "session",
          "out",
          "deselect_by_mark",
          "__unicode__",
          "spawn_pytest",
          "scopenum_function",
          "_matchnodes",
          "import_plugin",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "builtin",
          "_collectfile",
          "addFailure",
          "catching_logs",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "PYTESTER_COPY_EXAMPLE",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "DEFAULT_LOG_FORMAT",
          "LoggingPlugin",
          "DEFAULT_LOG_DATE_FORMAT",
          "set_log_path",
          "get_actual_log_level",
          "_log",
          "record_property",
          "logging",
          "write_log_entry",
          "LogCaptureFixture"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:10:59.201267",
        "usage": "244.1699504852295 ms"
      },
      "request": {
        "tokens": [
          "DEFAULT_LOG_FORMAT",
          "LoggingPlugin",
          "DEFAULT_LOG_DATE_FORMAT",
          "set_log_path",
          "get_actual_log_level",
          "_log",
          "record_property",
          "logging",
          "write_log_entry",
          "LogCaptureFixture"
        ]
      },
      "response": {
        "results": {
          "logging": [
            "src/_pytest/logging.py",
            "src/_pytest/compat.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py"
          ],
          "record_property": [
            "src/_pytest/junitxml.py"
          ],
          "_log": [
            "src/_pytest/pytester.py"
          ],
          "write_log_entry": [
            "src/_pytest/resultlog.py"
          ],
          "DEFAULT_LOG_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "DEFAULT_LOG_DATE_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "get_actual_log_level": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "set_log_path": [
            "src/_pytest/logging.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:10:59.445456",
        "usage": "3345.151424407959 ms"
      },
      "request": {
        "keyword_search_results": {
          "logging": [
            "src/_pytest/logging.py",
            "src/_pytest/compat.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/junitxml.py"
          ],
          "record_property": [
            "src/_pytest/junitxml.py"
          ],
          "_log": [
            "src/_pytest/pytester.py"
          ],
          "write_log_entry": [
            "src/_pytest/resultlog.py"
          ],
          "DEFAULT_LOG_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "DEFAULT_LOG_DATE_FORMAT": [
            "src/_pytest/logging.py"
          ],
          "LogCaptureFixture": [
            "src/_pytest/logging.py"
          ],
          "get_actual_log_level": [
            "src/_pytest/logging.py"
          ],
          "LoggingPlugin": [
            "src/_pytest/logging.py"
          ],
          "set_log_path": [
            "src/_pytest/logging.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The reported issue is about updating the default logging format (DEFAULT_LOG_FORMAT) to include more details such as the module name and possibly the relative path.\n\nLooking at the keyword search results, the key terms here are `DEFAULT_LOG_FORMAT`, which directly indicates where this format might be defined or used.\n\n1. `DEFAULT_LOG_FORMAT`: Found in `src/_pytest/logging.py`. This file is almost certainly related since it contains the definition or usage of the logging format that needs to be modified. It should provide the current logging format and any logic around it, making it highly relevant.\n\nGiven the problem statement, `src/_pytest/logging.py` is the only file that explicitly mentions `DEFAULT_LOG_FORMAT`. Additionally, other logging-related keywords such as `LogCaptureFixture`, `get_actual_log_level`, and `LoggingPlugin` are also in `src/_pytest/logging.py`, suggesting this file deals extensively with logging functionality in general.\n\nNo other files seem to directly relate to the modification of logging formats based on the given issue description.",
        "file_paths": [
          "src/_pytest/logging.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:11:02.790632",
        "usage": "8368.837118148804 ms"
      },
      "request": {
        "file_path": "src/_pytest/logging.py"
      },
      "response": {
        "scratch_pad": "### Step 1: Analyze User Instructions\n1.1. The user is suggesting to enhance the default logging format by including the module name (`name`) and potentially the relative file path to provide more context in the logs. The current format only displays the filename, line number, log level, and message.\n1.2. The user provided examples of how logs are currently formatted and how they would appear with the suggested changes.\n1.3. The issue is caused by the current limitation in the logging format where only the filename is displayed without the module name, which reduces the context in logs, especially if files have the same name in different modules.\n1.4. The user expects the logging format to include the `name` (module name) and potentially a relative path for better log context and debugging.\n1.5. This could be realized by modifying the `DEFAULT_LOG_FORMAT` to incorporate the `name` and possibly the file path while ensuring the log readability isn't compromised.\n\n### Step 2: Make File Evaluation\n2.1. The `DEFAULT_LOG_FORMAT` is defined at the top of this file as `%filename)-25s %(lineno)4d %(levelname)-8s %(message)s`.\n2.2. In the context of this file, there are multiple instances where logging is formatted using this default. Primarily, these are set during the logging configuration within the `LoggingPlugin` class.\n2.3. The method `pytest_addoption` adds options to control log capturing which includes setting default logging formats.\n2.4. The `LoggingPlugin` class in this file handles setting up the format for logs using `logging.Formatter` initialized with `get_option_ini(config, \"log_format\")` which defaults to `DEFAULT_LOG_FORMAT`.\n\n### Summary:\nThe file configures logging, with the default log format defined here. Changing this will directly impact how logs are captured by default.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "DEFAULT_LOG_FORMAT",
          "LoggingPlugin",
          "pytest_addoption",
          "LoggingPlugin.set_log_path",
          "ColoredLevelFormatter"
        ],
        "root_cause_symbols": [
          "DEFAULT_LOG_FORMAT"
        ]
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:11:11.159522",
        "usage": "85.62684059143066 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/logging.py",
            "relevant_symbol_keys": [
              "DEFAULT_LOG_FORMAT",
              "LoggingPlugin",
              "pytest_addoption",
              "LoggingPlugin.set_log_path",
              "ColoredLevelFormatter"
            ],
            "root_cause_symbol_keys": [
              "DEFAULT_LOG_FORMAT"
            ]
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 21,
            "start_column": 503,
            "end_line": 0,
            "end_column": 2344,
            "start_byte": 503,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.LOGLEVEL_COLOROPTS",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }",
            "start_line": 26,
            "start_column": 648,
            "end_line": 4,
            "end_column": 921,
            "start_byte": 648,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.LEVELNAME_FMT_REGEX",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")",
            "start_line": 35,
            "start_column": 926,
            "end_line": 4,
            "end_column": 988,
            "start_byte": 926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )",
            "start_line": 37,
            "start_column": 994,
            "end_line": 4,
            "end_column": 2070,
            "start_byte": 994,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.format",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 64,
            "start_column": 2076,
            "end_line": 4,
            "end_column": 2344,
            "start_byte": 2076,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          }
        ]
      }
    },
    {
      "name": "SymbolsEvaluate",
      "metadata": {
        "start": "2024-08-19T12:11:11.245160",
        "usage": "8843.953132629395 ms"
      },
      "request": {
        "related_symbols": [
          {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 21,
            "start_column": 503,
            "end_line": 0,
            "end_column": 2344,
            "start_byte": 503,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.LOGLEVEL_COLOROPTS",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }",
            "start_line": 26,
            "start_column": 648,
            "end_line": 4,
            "end_column": 921,
            "start_byte": 648,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.LEVELNAME_FMT_REGEX",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")",
            "start_line": 35,
            "start_column": 926,
            "end_line": 4,
            "end_column": 988,
            "start_byte": 926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )",
            "start_line": 37,
            "start_column": 994,
            "end_line": 4,
            "end_column": 2070,
            "start_byte": 994,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.ColoredLevelFormatter.format",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 64,
            "start_column": 2076,
            "end_line": 4,
            "end_column": 2344,
            "start_byte": 2076,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          }
        ]
      },
      "response": {
        "scratch_pad": "The issue is requesting an improvement in the logging format for better contextual log outputs by including the module name (`name`) instead of or in addition to the base filename (`filename`). The desired format is `% (levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s`. \n\nThe `_pytest.logging.DEFAULT_LOG_FORMAT` in `src/_pytest/logging.py` currently defines the format as `% (filename)-25s %(lineno)4d %(levelname)-8s %(message)s`, only displaying the filename, line number, log level, and message.\n\nTo address this request, we need to change the `DEFAULT_LOG_FORMAT` to include `(name)`. The module name will provide additional context about where the log entry originated, allowing for enhanced debugging and log analysis.\n\nIn the provided symbols, the primary focus should be on updating `_pytest.logging.DEFAULT_LOG_FORMAT` to match the required format. The remaining symbols should be checked to confirm they rely on `DEFAULT_LOG_FORMAT`, and to verify no other changes are required regarding this update.",
        "symbols": [
          {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "reason": "The logging format needs to be updated to include the module name as requested in the issue."
          }
        ],
        "more_info": [],
        "is_done": true,
        "symbols_scratch_pad": [
          "This symbol directly defines the existing `DEFAULT_LOG_FORMAT`, which aligns with what the issue is about. It currently omits the `name` and uses only `filename`. To fix the issue, this single symbol needs modification to include `name`.",
          "This appears to be similar content about defining options, possibly re-declarations or option functions. The relevant part for format updates is likely still centralized in the `DEFAULT_LOG_FORMAT`. ",
          "These lines appear to be higher-level logic related to log handlers and plugin configurations. Again, the main concern here would be where formats like `DEFAULT_LOG_FORMAT` get applied.",
          "Appears to continue with the options handling patterns similar to previously shown setups. Not directly related to changing `DEFAULT_LOG_FORMAT` itself.",
          "This seems to show part of logic related to formatting, likely repetition of option specification patterns seen in other functions or extending log functionality, rather than defining `DEFAULT_LOG_FORMAT` specifically.",
          "This could be an extended handling of terminal colors based on the logging levels, which adds a display factor but doesn't inherently change the file format definitions relevant for `DEFAULT_LOG_FORMAT`.",
          "Already examined in the context of color handling, reiterating the importance of different logging formatting depending on color specifics (class handling coloring)."
        ]
      }
    },
    {
      "name": "SymbolSummary",
      "metadata": {
        "start": "2024-08-19T12:11:20.089166",
        "usage": "4.7817230224609375 ms"
      },
      "request": {
        "symbols": {
          "related_symbols": [
            {
              "name": "_pytest.assertion.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
              "start_line": 16,
              "start_column": 323,
              "end_line": 0,
              "end_column": 911,
              "start_byte": 323,
              "end_byte": 0
            },
            {
              "name": "_pytest.cacheprovider.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
              "start_line": 302,
              "start_column": 11191,
              "end_line": 0,
              "end_column": 12956,
              "start_byte": 11191,
              "end_byte": 0
            },
            {
              "name": "_pytest.capture.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
              "start_line": 25,
              "start_column": 455,
              "end_line": 0,
              "end_column": 934,
              "start_byte": 455,
              "end_byte": 0
            },
            {
              "name": "_pytest.debugging.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
              "start_line": 26,
              "start_column": 683,
              "end_line": 0,
              "end_column": 1381,
              "start_byte": 683,
              "end_byte": 0
            },
            {
              "name": "_pytest.doctest.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
              "start_line": 37,
              "start_column": 1019,
              "end_line": 0,
              "end_column": 2437,
              "start_byte": 1019,
              "end_byte": 0
            },
            {
              "name": "_pytest.helpconfig.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
              "start_line": 42,
              "start_column": 1294,
              "end_line": 0,
              "end_column": 2608,
              "start_byte": 1294,
              "end_byte": 0
            },
            {
              "name": "_pytest.hookspec.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
              "start_line": 37,
              "start_column": 1119,
              "end_line": 0,
              "end_column": 2377,
              "start_byte": 1119,
              "end_byte": 0
            },
            {
              "name": "_pytest.junitxml.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
              "start_line": 347,
              "start_column": 11276,
              "end_line": 0,
              "end_column": 12485,
              "start_byte": 11276,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.ColoredLevelFormatter",
              "file_path": "src/_pytest/logging.py",
              "file_content": "class ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
              "start_line": 21,
              "start_column": 503,
              "end_line": 0,
              "end_column": 2344,
              "start_byte": 503,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.ColoredLevelFormatter.LOGLEVEL_COLOROPTS",
              "file_path": "src/_pytest/logging.py",
              "file_content": "LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }",
              "start_line": 26,
              "start_column": 648,
              "end_line": 4,
              "end_column": 921,
              "start_byte": 648,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.ColoredLevelFormatter.LEVELNAME_FMT_REGEX",
              "file_path": "src/_pytest/logging.py",
              "file_content": "LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")",
              "start_line": 35,
              "start_column": 926,
              "end_line": 4,
              "end_column": 988,
              "start_byte": 926,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.ColoredLevelFormatter.__init__",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )",
              "start_line": 37,
              "start_column": 994,
              "end_line": 4,
              "end_column": 2070,
              "start_byte": 994,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.ColoredLevelFormatter.format",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
              "start_line": 64,
              "start_column": 2076,
              "end_line": 4,
              "end_column": 2344,
              "start_byte": 2076,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
              "start_line": 82,
              "start_column": 2586,
              "end_line": 0,
              "end_column": 5014,
              "start_byte": 2586,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin",
              "file_path": "src/_pytest/logging.py",
              "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
              "start_line": 378,
              "start_column": 12060,
              "end_line": 0,
              "end_column": 20813,
              "start_byte": 12060,
              "end_byte": 0
            },
            {
              "name": "_pytest.logging.LoggingPlugin.__init__",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
              "start_line": 382,
              "start_column": 12181,
              "end_line": 4,
              "end_column": 14040,
              "start_byte": 12181,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
              "start_line": 429,
              "start_column": 14046,
              "end_line": 4,
              "end_column": 15496,
              "start_byte": 14046,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.set_log_path",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
              "start_line": 462,
              "start_column": 15502,
              "end_line": 4,
              "end_column": 16175,
              "start_byte": 15502,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
              "start_line": 483,
              "start_column": 16181,
              "end_line": 4,
              "end_column": 16493,
              "start_byte": 16181,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_collection",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 491,
              "start_column": 16499,
              "end_line": 4,
              "end_column": 16920,
              "start_byte": 16499,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 503,
              "start_column": 16926,
              "end_line": 4,
              "end_column": 17232,
              "start_byte": 16926,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
              "start_line": 512,
              "start_column": 17238,
              "end_line": 4,
              "end_column": 18305,
              "start_byte": 17238,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
              "start_line": 541,
              "start_column": 18311,
              "end_line": 4,
              "end_column": 18452,
              "start_byte": 18311,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
              "start_line": 546,
              "start_column": 18458,
              "end_line": 4,
              "end_column": 18597,
              "start_byte": 18458,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
              "start_line": 551,
              "start_column": 18603,
              "end_line": 4,
              "end_column": 18750,
              "start_byte": 18603,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
              "start_line": 556,
              "start_column": 18756,
              "end_line": 4,
              "end_column": 18968,
              "start_byte": 18756,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
              "start_line": 563,
              "start_column": 18974,
              "end_line": 4,
              "end_column": 19114,
              "start_byte": 18974,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
              "start_line": 568,
              "start_column": 19120,
              "end_line": 4,
              "end_column": 19263,
              "start_byte": 19120,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
              "start_line": 573,
              "start_column": 19269,
              "end_line": 4,
              "end_column": 19972,
              "start_byte": 19269,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
              "start_line": 591,
              "start_column": 19978,
              "end_line": 4,
              "end_column": 20402,
              "start_byte": 19978,
              "end_byte": 4
            },
            {
              "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
              "file_path": "src/_pytest/logging.py",
              "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
              "start_line": 602,
              "start_column": 20408,
              "end_line": 4,
              "end_column": 20813,
              "start_byte": 20408,
              "end_byte": 4
            },
            {
              "name": "_pytest.main.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
              "start_line": 35,
              "start_column": 775,
              "end_line": 0,
              "end_column": 5042,
              "start_byte": 775,
              "end_byte": 0
            },
            {
              "name": "_pytest.mark.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
              "start_line": 39,
              "start_column": 1365,
              "end_line": 0,
              "end_column": 2919,
              "start_byte": 1365,
              "end_byte": 0
            },
            {
              "name": "_pytest.pastebin.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
              "start_line": 13,
              "start_column": 240,
              "end_line": 0,
              "end_column": 568,
              "start_byte": 240,
              "end_byte": 0
            },
            {
              "name": "_pytest.pytester.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
              "start_line": 39,
              "start_column": 994,
              "end_line": 0,
              "end_column": 1605,
              "start_byte": 994,
              "end_byte": 0
            },
            {
              "name": "_pytest.python.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
              "start_line": 63,
              "start_column": 1905,
              "end_line": 0,
              "end_column": 3675,
              "start_byte": 1905,
              "end_byte": 0
            },
            {
              "name": "_pytest.runner.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
              "start_line": 25,
              "start_column": 538,
              "end_line": 0,
              "end_column": 850,
              "start_byte": 538,
              "end_byte": 0
            },
            {
              "name": "_pytest.setuponly.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
              "start_line": 9,
              "start_column": 138,
              "end_line": 0,
              "end_column": 537,
              "start_byte": 138,
              "end_byte": 0
            },
            {
              "name": "_pytest.setupplan.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
              "start_line": 7,
              "start_column": 126,
              "end_line": 0,
              "end_column": 403,
              "start_byte": 126,
              "end_byte": 0
            },
            {
              "name": "_pytest.skipping.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
              "start_line": 12,
              "start_column": 353,
              "end_line": 0,
              "end_column": 833,
              "start_byte": 353,
              "end_byte": 0
            },
            {
              "name": "_pytest.stepwise.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
              "start_line": 3,
              "start_column": 16,
              "end_line": 0,
              "end_column": 479,
              "start_byte": 16,
              "end_byte": 0
            },
            {
              "name": "_pytest.terminal.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
              "start_line": 57,
              "start_column": 1520,
              "end_line": 0,
              "end_column": 4162,
              "start_byte": 1520,
              "end_byte": 0
            },
            {
              "name": "_pytest.warnings.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
              "start_line": 38,
              "start_column": 1068,
              "end_line": 0,
              "end_column": 1530,
              "start_byte": 1068,
              "end_byte": 0
            },
            {
              "name": "_pytest.resultlog.pytest_addoption",
              "file_path": "src/_pytest/logging.py",
              "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
              "start_line": 12,
              "start_column": 217,
              "end_line": 0,
              "end_column": 533,
              "start_byte": 217,
              "end_byte": 0
            }
          ],
          "root_caused_symbols": [
            {
              "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
              "file_path": "src/_pytest/logging.py",
              "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
              "start_line": 17,
              "start_column": 385,
              "end_line": 0,
              "end_column": 463,
              "start_byte": 385,
              "end_byte": 0
            }
          ]
        },
        "symbols_evaluate": {
          "scratch_pad": "The issue is requesting an improvement in the logging format for better contextual log outputs by including the module name (`name`) instead of or in addition to the base filename (`filename`). The desired format is `% (levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s`. \n\nThe `_pytest.logging.DEFAULT_LOG_FORMAT` in `src/_pytest/logging.py` currently defines the format as `% (filename)-25s %(lineno)4d %(levelname)-8s %(message)s`, only displaying the filename, line number, log level, and message.\n\nTo address this request, we need to change the `DEFAULT_LOG_FORMAT` to include `(name)`. The module name will provide additional context about where the log entry originated, allowing for enhanced debugging and log analysis.\n\nIn the provided symbols, the primary focus should be on updating `_pytest.logging.DEFAULT_LOG_FORMAT` to match the required format. The remaining symbols should be checked to confirm they rely on `DEFAULT_LOG_FORMAT`, and to verify no other changes are required regarding this update.",
          "symbols": [
            {
              "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
              "file_path": "src/_pytest/logging.py",
              "reason": "The logging format needs to be updated to include the module name as requested in the issue."
            }
          ],
          "more_info": [],
          "is_done": true,
          "symbols_scratch_pad": [
            "This symbol directly defines the existing `DEFAULT_LOG_FORMAT`, which aligns with what the issue is about. It currently omits the `name` and uses only `filename`. To fix the issue, this single symbol needs modification to include `name`.",
            "This appears to be similar content about defining options, possibly re-declarations or option functions. The relevant part for format updates is likely still centralized in the `DEFAULT_LOG_FORMAT`. ",
            "These lines appear to be higher-level logic related to log handlers and plugin configurations. Again, the main concern here would be where formats like `DEFAULT_LOG_FORMAT` get applied.",
            "Appears to continue with the options handling patterns similar to previously shown setups. Not directly related to changing `DEFAULT_LOG_FORMAT` itself.",
            "This seems to show part of logic related to formatting, likely repetition of option specification patterns seen in other functions or extending log functionality, rather than defining `DEFAULT_LOG_FORMAT` specifically.",
            "This could be an extended handling of terminal colors based on the logging levels, which adds a display factor but doesn't inherently change the file format definitions relevant for `DEFAULT_LOG_FORMAT`.",
            "Already examined in the context of color handling, reiterating the importance of different logging formatting depending on color specifics (class handling coloring)."
          ]
        }
      },
      "response": {
        "file_paths": [
          "src/_pytest/logging.py"
        ],
        "symbols": [
          "_pytest.logging.DEFAULT_LOG_FORMAT"
        ],
        "code_spans": {
          "_pytest.assertion.pytest_addoption": {
            "name": "_pytest.assertion.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: se",
            "start_line": 16,
            "start_column": 323,
            "end_line": 0,
            "end_column": 911,
            "start_byte": 323,
            "end_byte": 0
          },
          "_pytest.cacheprovider.pytest_addoption": {
            "name": "_pytest.cacheprovider.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getoption(setting_name)\n        if log_level is None:\n            log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_",
            "start_line": 302,
            "start_column": 11191,
            "end_line": 0,
            "end_column": 12956,
            "start_byte": 11191,
            "end_byte": 0
          },
          "_pytest.capture.pytest_addoption": {
            "name": "_pytest.capture.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ssage)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAM",
            "start_line": 25,
            "start_column": 455,
            "end_line": 0,
            "end_column": 934,
            "start_byte": 455,
            "end_byte": 0
          },
          "_pytest.debugging.pytest_addoption": {
            "name": "_pytest.debugging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ing.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname",
            "start_line": 26,
            "start_column": 683,
            "end_line": 0,
            "end_column": 1381,
            "start_byte": 683,
            "end_byte": 0
          },
          "_pytest.doctest.pytest_addoption": {
            "name": "_pytest.doctest.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "alwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(",
            "start_line": 37,
            "start_column": 1019,
            "end_line": 0,
            "end_column": 2437,
            "start_byte": 1019,
            "end_byte": 0
          },
          "_pytest.helpconfig.pytest_addoption": {
            "name": "_pytest.helpconfig.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "velname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(p",
            "start_line": 42,
            "start_column": 1294,
            "end_line": 0,
            "end_column": 2608,
            "start_byte": 1294,
            "end_byte": 0
          },
          "_pytest.hookspec.pytest_addoption": {
            "name": "_pytest.hookspec.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "     if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *na",
            "start_line": 37,
            "start_column": 1119,
            "end_line": 0,
            "end_column": 2377,
            "start_byte": 1119,
            "end_byte": 0
          },
          "_pytest.junitxml.pytest_addoption": {
            "name": "_pytest.junitxml.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "   log_level = config.getini(setting_name)\n        if log_level:\n            break\n    else:\n        return\n\n    if isinstance(log_level, six.string_types):\n        log_level = log_level.upper()\n    try:\n        return int(getattr(logging, log_level, log_level))\n    except ValueError:\n        # Python logging does not recognise this as a logging level\n        raise pytest.UsageError(\n            \"'{}' is not recognized as a logging level name for \"\n            \"'{}'. Please consider passing the \"\n            \"logging level num instead.\".format(log_level, setting_name)\n        )\n\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n\n\nclass LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically i",
            "start_line": 347,
            "start_column": 11276,
            "end_line": 0,
            "end_column": 12485,
            "start_byte": 11276,
            "end_byte": 0
          },
          "_pytest.logging.ColoredLevelFormatter": {
            "name": "_pytest.logging.ColoredLevelFormatter",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 21,
            "start_column": 503,
            "end_line": 0,
            "end_column": 2344,
            "start_byte": 503,
            "end_byte": 0
          },
          "_pytest.logging.ColoredLevelFormatter.LOGLEVEL_COLOROPTS": {
            "name": "_pytest.logging.ColoredLevelFormatter.LOGLEVEL_COLOROPTS",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }",
            "start_line": 26,
            "start_column": 648,
            "end_line": 4,
            "end_column": 921,
            "start_byte": 648,
            "end_byte": 4
          },
          "_pytest.logging.ColoredLevelFormatter.LEVELNAME_FMT_REGEX": {
            "name": "_pytest.logging.ColoredLevelFormatter.LEVELNAME_FMT_REGEX",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")",
            "start_line": 35,
            "start_column": 926,
            "end_line": 4,
            "end_column": 988,
            "start_byte": 926,
            "end_byte": 4
          },
          "_pytest.logging.ColoredLevelFormatter.__init__": {
            "name": "_pytest.logging.ColoredLevelFormatter.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )",
            "start_line": 37,
            "start_column": 994,
            "end_line": 4,
            "end_column": 2070,
            "start_byte": 994,
            "end_byte": 4
          },
          "_pytest.logging.ColoredLevelFormatter.format": {
            "name": "_pytest.logging.ColoredLevelFormatter.format",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)",
            "start_line": 64,
            "start_column": 2076,
            "end_line": 4,
            "end_column": 2344,
            "start_byte": 2076,
            "end_byte": 4
          },
          "_pytest.logging.pytest_addoption": {
            "name": "_pytest.logging.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )",
            "start_line": 82,
            "start_column": 2586,
            "end_line": 0,
            "end_column": 5014,
            "start_byte": 2586,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin": {
            "name": "_pytest.logging.LoggingPlugin",
            "file_path": "src/_pytest/logging.py",
            "file_content": "class LoggingPlugin(object):\n    \"\"\"Attaches to the logging module and captures log messages for each test.\n    \"\"\"\n\n    def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()\n\n    def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )\n\n    def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)\n\n    def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield\n\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 378,
            "start_column": 12060,
            "end_line": 0,
            "end_column": 20813,
            "start_byte": 12060,
            "end_byte": 0
          },
          "_pytest.logging.LoggingPlugin.__init__": {
            "name": "_pytest.logging.LoggingPlugin.__init__",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, config):\n        \"\"\"Creates a new plugin to capture log messages.\n\n        The formatter can be safely shared across all handlers so\n        create a single one for the entire test session here.\n        \"\"\"\n        self._config = config\n\n        # enable verbose output automatically if live logging is enabled\n        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n            config.option.verbose = 1\n\n        self.print_logs = get_option_ini(config, \"log_print\")\n        self.formatter = logging.Formatter(\n            get_option_ini(config, \"log_format\"),\n            get_option_ini(config, \"log_date_format\"),\n        )\n        self.log_level = get_actual_log_level(config, \"log_level\")\n\n        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n        self.log_file_date_format = get_option_ini(\n            config, \"log_file_date_format\", \"log_date_format\"\n        )\n        self.log_file_formatter = logging.Formatter(\n            self.log_file_format, datefmt=self.log_file_date_format\n        )\n\n        log_file = get_option_ini(config, \"log_file\")\n        if log_file:\n            self.log_file_handler = logging.FileHandler(\n                log_file, mode=\"w\", encoding=\"UTF-8\"\n            )\n            self.log_file_handler.setFormatter(self.log_file_formatter)\n        else:\n            self.log_file_handler = None\n\n        self.log_cli_handler = None\n\n        self.live_logs_context = lambda: dummy_context_manager()\n        # Note that the lambda for the live_logs_context is needed because\n        # live_logs_context can otherwise not be entered multiple times due\n        # to limitations of contextlib.contextmanager.\n\n        if self._log_cli_enabled():\n            self._setup_cli_logging()",
            "start_line": 382,
            "start_column": 12181,
            "end_line": 4,
            "end_column": 14040,
            "start_byte": 12181,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._setup_cli_logging": {
            "name": "_pytest.logging.LoggingPlugin._setup_cli_logging",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _setup_cli_logging(self):\n        config = self._config\n        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n        if terminal_reporter is None:\n            # terminal reporter is disabled e.g. by pytest-xdist.\n            return\n\n        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n        # if capturemanager plugin is disabled, live logging still works.\n        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n        log_cli_date_format = get_option_ini(\n            config, \"log_cli_date_format\", \"log_date_format\"\n        )\n        if (\n            config.option.color != \"no\"\n            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n        ):\n            log_cli_formatter = ColoredLevelFormatter(\n                create_terminal_writer(config),\n                log_cli_format,\n                datefmt=log_cli_date_format,\n            )\n        else:\n            log_cli_formatter = logging.Formatter(\n                log_cli_format, datefmt=log_cli_date_format\n            )\n        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n        self.log_cli_handler = log_cli_handler\n        self.live_logs_context = lambda: catching_logs(\n            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n        )",
            "start_line": 429,
            "start_column": 14046,
            "end_line": 4,
            "end_column": 15496,
            "start_byte": 14046,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.set_log_path": {
            "name": "_pytest.logging.LoggingPlugin.set_log_path",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def set_log_path(self, fname):\n        \"\"\"Public method, which can set filename parameter for\n        Logging.FileHandler(). Also creates parent directory if\n        it does not exist.\n\n        .. warning::\n            Please considered as an experimental API.\n        \"\"\"\n        fname = Path(fname)\n\n        if not fname.is_absolute():\n            fname = Path(self._config.rootdir, fname)\n\n        if not fname.parent.exists():\n            fname.parent.mkdir(exist_ok=True, parents=True)\n\n        self.log_file_handler = logging.FileHandler(\n            str(fname), mode=\"w\", encoding=\"UTF-8\"\n        )\n        self.log_file_handler.setFormatter(self.log_file_formatter)",
            "start_line": 462,
            "start_column": 15502,
            "end_line": 4,
            "end_column": 16175,
            "start_byte": 15502,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._log_cli_enabled": {
            "name": "_pytest.logging.LoggingPlugin._log_cli_enabled",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def _log_cli_enabled(self):\n        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n        or because --log-cli-level was given in the command-line.\n        \"\"\"\n        return self._config.getoption(\n            \"--log-cli-level\"\n        ) is not None or self._config.getini(\"log_cli\")",
            "start_line": 483,
            "start_column": 16181,
            "end_line": 4,
            "end_column": 16493,
            "start_byte": 16181,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_collection": {
            "name": "_pytest.logging.LoggingPlugin.pytest_collection",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"collection\")\n\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 491,
            "start_column": 16499,
            "end_line": 4,
            "end_column": 16920,
            "start_byte": 16499,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._runtest_for": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for(self, item, when):\n        with self._runtest_for_main(item, when):\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 503,
            "start_column": 16926,
            "end_line": 4,
            "end_column": 17232,
            "start_byte": 16926,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin._runtest_for_main": {
            "name": "_pytest.logging.LoggingPlugin._runtest_for_main",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@contextmanager\n    def _runtest_for_main(self, item, when):\n        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n        with catching_logs(\n            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n        ) as log_handler:\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(when)\n\n            if item is None:\n                yield  # run the test\n                return\n\n            if not hasattr(item, \"catch_log_handlers\"):\n                item.catch_log_handlers = {}\n            item.catch_log_handlers[when] = log_handler\n            item.catch_log_handler = log_handler\n            try:\n                yield  # run test\n            finally:\n                if when == \"teardown\":\n                    del item.catch_log_handler\n                    del item.catch_log_handlers\n\n            if self.print_logs:\n                # Add a captured log section to the report.\n                log = log_handler.stream.getvalue().strip()\n                item.add_report_section(when, \"log\", log)",
            "start_line": 512,
            "start_column": 17238,
            "end_line": 4,
            "end_column": 18305,
            "start_byte": 17238,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_setup": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_setup",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n        with self._runtest_for(item, \"setup\"):\n            yield",
            "start_line": 541,
            "start_column": 18311,
            "end_line": 4,
            "end_column": 18452,
            "start_byte": 18311,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_call": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n        with self._runtest_for(item, \"call\"):\n            yield",
            "start_line": 546,
            "start_column": 18458,
            "end_line": 4,
            "end_column": 18597,
            "start_byte": 18458,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_teardown": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_teardown",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n        with self._runtest_for(item, \"teardown\"):\n            yield",
            "start_line": 551,
            "start_column": 18603,
            "end_line": 4,
            "end_column": 18750,
            "start_byte": 18603,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logstart": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n        if self.log_cli_handler:\n            self.log_cli_handler.reset()\n        with self._runtest_for(None, \"start\"):\n            yield",
            "start_line": 556,
            "start_column": 18756,
            "end_line": 4,
            "end_column": 18968,
            "start_byte": 18756,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n        with self._runtest_for(None, \"finish\"):\n            yield",
            "start_line": 563,
            "start_column": 18974,
            "end_line": 4,
            "end_column": 19114,
            "start_byte": 18974,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtest_logreport": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_logreport",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n        with self._runtest_for(None, \"logreport\"):\n            yield",
            "start_line": 568,
            "start_column": 19120,
            "end_line": 4,
            "end_column": 19263,
            "start_byte": 19120,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_sessionfinish": {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionfinish",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionfinish\")\n            if self.log_file_handler is not None:\n                try:\n                    with catching_logs(\n                        self.log_file_handler, level=self.log_file_level\n                    ):\n                        yield\n                finally:\n                    # Close the FileHandler explicitly.\n                    # (logging.shutdown might have lost the weakref?!)\n                    self.log_file_handler.close()\n            else:\n                yield",
            "start_line": 573,
            "start_column": 19269,
            "end_line": 4,
            "end_column": 19972,
            "start_byte": 19269,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_sessionstart": {
            "name": "_pytest.logging.LoggingPlugin.pytest_sessionstart",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n        with self.live_logs_context():\n            if self.log_cli_handler:\n                self.log_cli_handler.set_when(\"sessionstart\")\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield\n            else:\n                yield",
            "start_line": 591,
            "start_column": 19978,
            "end_line": 4,
            "end_column": 20402,
            "start_byte": 19978,
            "end_byte": 4
          },
          "_pytest.logging.LoggingPlugin.pytest_runtestloop": {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtestloop",
            "file_path": "src/_pytest/logging.py",
            "file_content": "@pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n        \"\"\"Runs all collected test items.\"\"\"\n        with self.live_logs_context():\n            if self.log_file_handler is not None:\n                with catching_logs(self.log_file_handler, level=self.log_file_level):\n                    yield  # run all the tests\n            else:\n                yield  # run all the tests",
            "start_line": 602,
            "start_column": 20408,
            "end_line": 4,
            "end_column": 20813,
            "start_byte": 20408,
            "end_byte": 4
          },
          "_pytest.main.pytest_addoption": {
            "name": "_pytest.main.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "llow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-cli-date-format\",\n        dest=\"log_cli_date_format\",\n        default=None,\n        help=\"log date format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file\",\n        dest=\"log_file\",\n        default=None,\n        help=\"path to a file when logging will be written to.\",\n    )\n    add_option_ini(\n        \"--log-file-level\",\n        dest=\"log_file_level\",\n        default=None,\n        help=\"log file logging level.\",\n    )\n    add_option_ini(\n        \"--log-file-format\",\n        dest=\"log_file_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-file-date-format\",\n        dest=\"log_file_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n\n\n@contextmanager\ndef catch",
            "start_line": 35,
            "start_column": 775,
            "end_line": 0,
            "end_column": 5042,
            "start_byte": 775,
            "end_byte": 0
          },
          "_pytest.mark.pytest_addoption": {
            "name": "_pytest.mark.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(opti",
            "start_line": 39,
            "start_column": 1365,
            "end_line": 0,
            "end_column": 2919,
            "start_byte": 1365,
            "end_byte": 0
          },
          "_pytest.pastebin.pytest_addoption": {
            "name": "_pytest.pastebin.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "port pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Color",
            "start_line": 13,
            "start_column": 240,
            "end_line": 0,
            "end_column": 568,
            "start_byte": 240,
            "end_byte": 0
          },
          "_pytest.pytester.pytest_addoption": {
            "name": "_pytest.pytester.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "def __init__(self, terminalwriter, *args, **kwargs):\n        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n            formatted_levelname = levelname_fmt % {\n                \"level",
            "start_line": 39,
            "start_column": 994,
            "end_line": 0,
            "end_column": 1605,
            "start_byte": 994,
            "end_byte": 0
          },
          "_pytest.python.pytest_addoption": {
            "name": "_pytest.python.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "gs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the log",
            "start_line": 63,
            "start_column": 1905,
            "end_line": 0,
            "end_column": 3675,
            "start_byte": 1905,
            "end_byte": 0
          },
          "_pytest.runner.pytest_addoption": {
            "name": "_pytest.runner.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": ".Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n",
            "start_line": 25,
            "start_column": 538,
            "end_line": 0,
            "end_column": 850,
            "start_byte": 538,
            "end_byte": 0
          },
          "_pytest.setuponly.pytest_addoption": {
            "name": "_pytest.setuponly.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "int_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(loggin",
            "start_line": 9,
            "start_column": 138,
            "end_line": 0,
            "end_column": 537,
            "start_byte": 138,
            "end_byte": 0
          },
          "_pytest.setupplan.pytest_addoption": {
            "name": "_pytest.setupplan.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT",
            "start_line": 7,
            "start_column": 126,
            "end_line": 0,
            "end_column": 403,
            "start_byte": 126,
            "end_byte": 0
          },
          "_pytest.skipping.pytest_addoption": {
            "name": "_pytest.skipping.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "om _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n    \"\"\"\n    Colorize the %(levelname)..s part of the log format passed to __init__.\n    \"\"\"\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.",
            "start_line": 12,
            "start_column": 353,
            "end_line": 0,
            "end_column": 833,
            "start_byte": 353,
            "end_byte": 0
          },
          "_pytest.stepwise.pytest_addoption": {
            "name": "_pytest.stepwise.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "ontrol log capturing. \"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport logging\nimport re\nfrom contextlib import contextmanager\n\nimport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DAT",
            "start_line": 3,
            "start_column": 16,
            "end_line": 0,
            "end_column": 479,
            "start_byte": 16,
            "end_byte": 0
          },
          "_pytest.terminal.pytest_addoption": {
            "name": "_pytest.terminal.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "S.items():\n            formatted_levelname = levelname_fmt % {\n                \"levelname\": logging.getLevelName(level)\n            }\n\n            # add ANSI escape sequences around the formatted levelname\n            color_kwargs = {name: True for name in color_opts}\n            colorized_formatted_levelname = terminalwriter.markup(\n                formatted_levelname, **color_kwargs\n            )\n            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n                colorized_formatted_levelname, self._fmt\n            )\n\n    def format(self, record):\n        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n        if six.PY2:\n            self._fmt = fmt\n        else:\n            self._style._fmt = fmt\n        return super(ColoredLevelFormatter, self).format(record)\n\n\ndef get_option_ini(config, *names):\n    for name in names:\n        ret = config.getoption(name)  # 'default' arg won't work as expected\n        if ret is None:\n            ret = config.getini(name)\n        if ret:\n            return ret\n\n\ndef pytest_addoption(parser):\n    \"\"\"Add options to control log capturing.\"\"\"\n    group = parser.getgroup(\"logging\")\n\n    def add_option_ini(option, dest, default=None, type=None, **kwargs):\n        parser.addini(\n            dest, default=default, type=type, help=\"default value for \" + option\n        )\n        group.addoption(option, dest=dest, **kwargs)\n\n    add_option_ini(\n        \"--no-print-logs\",\n        dest=\"log_print\",\n        action=\"store_const\",\n        const=False,\n        default=True,\n        type=\"bool\",\n        help=\"disable printing caught logs on failed tests.\",\n    )\n    add_option_ini(\n        \"--log-level\",\n        dest=\"log_level\",\n        default=None,\n        help=\"logging level used by the logging module\",\n    )\n    add_option_ini(\n        \"--log-format\",\n        dest=\"log_format\",\n        default=DEFAULT_LOG_FORMAT,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_ini(\n        \"--log-date-format\",\n        dest=\"log_date_format\",\n        default=DEFAULT_LOG_DATE_FORMAT,\n        help=\"log date format as used by the logging module.\",\n    )\n    parser.addini(\n        \"log_cli\",\n        default=False,\n        type=\"bool\",\n        help='enable log display during test run (also known as \"live logging\").',\n    )\n    add_option_ini(\n        \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"cli logging level.\"\n    )\n    add_option_ini(\n        \"--log-cli-format\",\n        dest=\"log_cli_format\",\n        default=None,\n        help=\"log format as used by the logging module.\",\n    )\n    add_option_",
            "start_line": 57,
            "start_column": 1520,
            "end_line": 0,
            "end_column": 4162,
            "start_byte": 1520,
            "end_byte": 0
          },
          "_pytest.warnings.pytest_addoption": {
            "name": "_pytest.warnings.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "LevelFormatter, self).__init__(*args, **kwargs)\n        if six.PY2:\n            self._original_fmt = self._fmt\n        else:\n            self._original_fmt = self._style._fmt\n        self._level_to_fmt_mapping = {}\n\n        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n        if not levelname_fmt_match:\n            return\n        levelname_fmt = levelname_fmt_match.group()\n\n        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():",
            "start_line": 38,
            "start_column": 1068,
            "end_line": 0,
            "end_column": 1530,
            "start_byte": 1068,
            "end_byte": 0
          },
          "_pytest.resultlog.pytest_addoption": {
            "name": "_pytest.resultlog.pytest_addoption",
            "file_path": "src/_pytest/logging.py",
            "file_content": "mport py\nimport six\n\nimport pytest\nfrom _pytest.compat import dummy_context_manager\nfrom _pytest.config import create_terminal_writer\nfrom _pytest.pathlib import Path\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(lo",
            "start_line": 12,
            "start_column": 217,
            "end_line": 0,
            "end_column": 533,
            "start_byte": 217,
            "end_byte": 0
          },
          "_pytest.logging.DEFAULT_LOG_FORMAT": {
            "name": "_pytest.logging.DEFAULT_LOG_FORMAT",
            "file_path": "src/_pytest/logging.py",
            "file_content": "DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"",
            "start_line": 17,
            "start_column": 385,
            "end_line": 0,
            "end_column": 463,
            "start_byte": 385,
            "end_byte": 0
          }
        }
      }
    }
  ]
}