{
  "total_cost": 0,
  "task_id": "pytest-dev__pytest-7490",
  "model": "gpt-4o-2024-08-06",
  "spans": [
    {
      "name": "KeywordExtract",
      "metadata": {
        "start": "2024-08-19T12:21:54.176406",
        "usage": "2398.3540534973145 ms"
      },
      "request": {
        "repo_tokens": [
          "pytest_collect_directory",
          "add_attribute",
          "_getobj",
          "delattr",
          "_assertion_pass",
          "disabled",
          "compile",
          "fullsource",
          "_ensure_relative_to_basetemp",
          "_teardown_yield_fixture",
          "store_mark",
          "Frame",
          "find_spec",
          "resolve_from_str",
          "MarkGenerator",
          "catch_warnings_for_item",
          "_folded_skips",
          "exitstatus",
          "MODULE_NOT_FOUND_ERROR",
          "reprtraceback",
          "_match_lines",
          "run",
          "not_expr",
          "DEFAULT_ABSOLUTE_TOLERANCE",
          "_should_truncate_item",
          "toterminal",
          "getfailedcollections",
          "Source",
          "STRING_TYPES",
          "_is_setup_py",
          "_visit_filter",
          "_getnextfixturedef",
          "append_skipped",
          "expression",
          "REPORT_COLLECTING_RESOLUTION",
          "runpython",
          "PYC_EXT",
          "_getlines",
          "mkpydir",
          "scopemismatch",
          "reset",
          "print_teardown_sections",
          "_E",
          "_inject_setup_function_fixture",
          "Expression",
          "tmp_path",
          "explanation_param",
          "CLOSE_STDIN",
          "get",
          "get_closest_marker",
          "FunctionDefinition",
          "PytestArg",
          "pytest",
          "FormattedExcinfo",
          "scope",
          "main",
          "_fillfixtures",
          "pytestconfig",
          "maketxtfile",
          "_getconftestmodules",
          "_find_spec",
          "cached_result",
          "ApproxDecimal",
          "_parse_parametrize_args",
          "safeformat",
          "check_interactive_exception",
          "recursionindex",
          "cleanup_numbered_dir",
          "append_failure",
          "_with_exception",
          "applymarker",
          "_check_all_skipped",
          "evaluate_skip_marks",
          "ApproxNumpy",
          "bin_xml_escape",
          "set_location",
          "exprinfo",
          "RESULT_LOG",
          "_dump_lines",
          "_yield_comparisons",
          "re_match_lines_random",
          "_recursive_debug",
          "classnamefilter",
          "makepyfile",
          "FUNCARGNAMES",
          "INTERNAL_ERROR",
          "repr_instance",
          "record_tuples",
          "CollectReport",
          "_get_pdb_wrapper_class",
          "setuponly",
          "_import_plugin_specs",
          "pytest_runtest_teardown",
          "getstatementrange",
          "RunResult",
          "UnitTestCase",
          "write_log_entry",
          "DummyRewriteHook",
          "deprecated_call",
          "_write_pyc_fp",
          "get_terminal_writer",
          "_param_ids_from",
          "visit_Call",
          "inline_genitems",
          "writeorg",
          "no_summary",
          "__eq__",
          "update_testcase_duration",
          "USAGE_MSG",
          "_init_checker_class",
          "collect_one_node",
          "_code",
          "_check_non_top_pytest_plugins",
          "append_pass",
          "_iter_rewritable_modules",
          "teardown",
          "setattr",
          "_determine_main_color",
          "DontReadFromInput",
          "_start",
          "push_format_context",
          "OR",
          "value",
          "consider_preparse",
          "unittest",
          "_param_ids_generated",
          "_PYTEST_DIR",
          "exconly",
          "add_stats",
          "ReprTraceback",
          "exec_module",
          "InvocationParams",
          "_colorama_workaround",
          "get_source",
          "set_level",
          "_pformat_dispatch",
          "consider_pluginarg",
          "FixtureDef",
          "_format_args",
          "add_property",
          "source",
          "NFPlugin",
          "pytest_deselected",
          "_format_assertmsg",
          "from_parent",
          "__module__",
          "_set_opt_strings",
          "pytest_fixture_setup",
          "pytest_runtest_call",
          "FIXTURE_POSITIONAL_ARGUMENTS",
          "RaisesContext",
          "_excinfo",
          "get_direct_param_fixture_func",
          "_getcrashline",
          "AssertionRewriter",
          "LsofFdLeakChecker",
          "_recursive_list_map",
          "isattrs",
          "xfailed_key",
          "junitxml",
          "_mk_tmp",
          "importlib",
          "_ascii_escaped_by_config",
          "_pyfuncitem",
          "getcall",
          "write_fspath_result",
          "_matches_prefix_or_glob_option",
          "_trace",
          "HelpAction",
          "NODE_USE_FROM_PARENT",
          "pytest_assertion_pass",
          "LEVELNAME_FMT_REGEX",
          "_get_pos",
          "notset",
          "Cache",
          "stop_capturing",
          "get_location",
          "T",
          "V",
          "_log_cli_enabled",
          "on_rm_rf_error",
          "processoption",
          "_config",
          "LFPluginCollSkipfiles",
          "TestCaseFunction",
          "PYTESTER_COPY_EXAMPLE",
          "__contains__",
          "get_timeout_config_value",
          "DOCTEST_REPORT_CHOICES",
          "ParameterSet",
          "hasplugin",
          "capstdout",
          "iscoroutinefunction",
          "pytest_pycollect_makeitem",
          "_compare_eq_sequence",
          "PYTEST_COLLECT_MODULE",
          "location",
          "_report_kwargs_from_json",
          "genitems",
          "isinitpath",
          "stop",
          "_getfailureheadline",
          "getcrashentry",
          "CFG_PYTEST_SECTION",
          "DEFAULT_RELATIVE_TOLERANCE",
          "log_outcome",
          "pytest_runtest_makereport",
          "append_collect_skipped",
          "_FixtureFunc",
          "register",
          "get_default_arg_names",
          "cleanup_candidates",
          "EMPTY_PARAMETERSET_OPTION",
          "_check_record_param_type",
          "format_explanation",
          "makeconftest",
          "ParsedCall",
          "_finalize",
          "_addfinalizer",
          "getworkerinfoline",
          "pytest_fixture_post_finalizer",
          "_get_flag_lookup",
          "resume_fixture",
          "findsource",
          "doctest",
          "fileno",
          "_validate_usepdb_cls",
          "Class",
          "filter_traceback_for_conftest_import_failure",
          "_non_printable_ascii_translate_table",
          "cut",
          "_readline_workaround",
          "helpconfig",
          "getfirstlinesource",
          "DOCTEST_REPORT_CHOICE_NDIFF",
          "prepend",
          "reprentries",
          "old_mark_config_key",
          "create_cleanup_lock",
          "ensure_deletable",
          "rewrite",
          "scopename2class",
          "verbosity",
          "derive_importpath",
          "make_numbered_dir",
          "resolve",
          "_inject_setup_module_fixture",
          "entrysep",
          "DoctestTextfile",
          "RPAREN",
          "families",
          "pytest_terminal_summary",
          "_inject_setup_method_fixture",
          "PyobjMixin",
          "__array_priority__",
          "get_scope_node",
          "TerminalRepr",
          "getmodpath",
          "pastebin",
          "_should_repr_global_name",
          "Junit",
          "fnmatch_lines_random",
          "repr_args",
          "_node_location_to_relpath",
          "skipping",
          "_get_allow_bytes_flag",
          "section",
          "_ensure_unconfigure",
          "_getscopeitem",
          "warning_types",
          "messages",
          "filter_traceback",
          "getimfunc",
          "getcalls",
          "isatty",
          "README_CONTENT",
          "name2fixturedefs",
          "SysModulesSnapshot",
          "get_log_level_for_setting",
          "showlocals",
          "match",
          "PytestUnhandledCoroutineWarning",
          "get_empty_parameterset_mark",
          "tmpdir",
          "_resolve_arg_value_types",
          "call_runtest_hook",
          "done",
          "_get_teardown_reports",
          "add_report_section",
          "PytestPluginManager",
          "parse_summary_nouns",
          "getnode",
          "COLLECT_DIRECTORY_HOOK",
          "try_makedirs",
          "suspend",
          "_get_increasing_order",
          "getplugin",
          "ensure_extended_length_path",
          "pos",
          "D",
          "at_level",
          "attrs",
          "popen",
          "_importtestmodule",
          "visit_Attribute",
          "_get_unknown_ini_keys",
          "PrintHelp",
          "timing",
          "reject",
          "MyOptionParser",
          "_gethookproxy",
          "parseconfig",
          "scope2index",
          "getbasetemp",
          "_addexcinfo",
          "_width_of_current_line",
          "startTest",
          "_report_keyboardinterrupt",
          "snap",
          "_result",
          "_format",
          "format_session_duration",
          "from_item",
          "parseoutcomes",
          "warn",
          "reorder_items_atscope",
          "monkeypatch",
          "variable",
          "resolve_fixture_function",
          "default_plugins",
          "_log_text",
          "resume_capturing",
          "_add_simple",
          "raises",
          "COLLECT_FAKEMODULE_ATTRIBUTES",
          "_assert_state",
          "wcswidth",
          "execute",
          "approx",
          "matchreport",
          "LineComp",
          "add_global_property",
          "FaultHandlerHooks",
          "path_matches_patterns",
          "stop_global_capturing",
          "capstderr",
          "_version",
          "illegal_xml_re",
          "hookspec",
          "wrap_pytest_function_for_tracing",
          "short_test_summary",
          "parse_num",
          "_checkargnotcontained",
          "collect_by_name",
          "parsefactories",
          "getmodulecol",
          "getpathnode",
          "result",
          "__test__",
          "EOF",
          "ColoredLevelFormatter",
          "node_reporter",
          "merge_family",
          "DOCTEST_REPORT_CHOICE_NONE",
          "_rget_with_confmod",
          "pytester",
          "fail",
          "TeeCaptureIO",
          "pytest_unconfigure",
          "listoutcomes",
          "_validate_args",
          "mark_rewrite",
          "showversion",
          "iter_markers_with_node",
          "getvalue",
          "reorder_items",
          "_warn_incompatibility_with_xunit2",
          "_is_marked_for_rewrite",
          "_add_stats",
          "repr",
          "evaluate",
          "SEP",
          "SubRequest",
          "getreportopt",
          "ApproxScalar",
          "PytestUnknownMarkWarning",
          "_ET",
          "get_exconly",
          "get_open_files",
          "CACHEDIR_TAG_CONTENT",
          "hasopt",
          "_get_main_color",
          "check_testcase_implements_trial_reporter",
          "_is_numpy_array",
          "getsource",
          "ids",
          "tmp_path_factory",
          "_disable_output_capturing_for_darwin",
          "is_globally_capturing",
          "LPAREN",
          "display",
          "pytest_collectreport",
          "LOCK_TIMEOUT",
          "DEFAULT_LOG_FORMAT",
          "global_and_fixture_disabled",
          "fixture",
          "_expecting_failure",
          "pytest_cmdline_parse",
          "_enter_pdb",
          "add_marker",
          "cache_key",
          "freeze_includes",
          "node",
          "from_item_and_call",
          "linecomp",
          "makeini",
          "_format_action_invocation",
          "generic_visit",
          "_W",
          "extract_from",
          "pytest_collection_modifyitems",
          "create_new_paste",
          "getinicfg",
          "_report_unserialization_failure",
          "setupplan",
          "issequence",
          "StoreKey",
          "isset",
          "makefile",
          "LoggingPlugin",
          "__hash__",
          "DoctestItem",
          "traceback",
          "_ALLOW_MARKERS",
          "head_line",
          "_assert_expr_to_lineno",
          "autouse",
          "_importconftest",
          "PYTEST_TAG",
          "args",
          "_FileHandler",
          "_checkversion",
          "copy",
          "FastFilesCompleter",
          "PytestDeprecationWarning",
          "set_fixture",
          "visit_Compare",
          "_ensure_removed_sysmodule",
          "showfspath",
          "_parsearg",
          "start_capturing",
          "ArgumentError",
          "_truncate_by_char_count",
          "_prepareconfig",
          "pytest_pycollect_makemodule",
          "_has_param_ids",
          "__array_ufunc__",
          "summary_errors",
          "AlwaysDispatchingPrettyPrinter",
          "_ellipsize",
          "pytest_collection",
          "get_data",
          "pytest_report_collectionfinish",
          "_args_converter",
          "DOCTEST_REPORT_CHOICE_UDIFF",
          "conftest_options",
          "find_prefixed",
          "accept",
          "_check_scope",
          "outcomes",
          "_format_boolop",
          "DropShorterLongHelpFormatter",
          "_is_doctest",
          "HookRecorder",
          "getreports",
          "showhelp",
          "pytest_cmdline_main",
          "__attrs_post_init__",
          "MARK_GEN",
          "fspath",
          "USAGE_ERROR",
          "_opentestcase",
          "caplog_handler_key",
          "_recurse",
          "create_terminal_writer",
          "mark",
          "register_assert_rewrite",
          "MINUS_K_COLON",
          "locate_config",
          "_Markable",
          "syspath_prepend",
          "rm_rf",
          "fixturenames",
          "write_line",
          "MarkDecorator",
          "tb",
          "addUnexpectedSuccess",
          "pytest_collection_finish",
          "WARNING_CAPTURED_HOOK",
          "getstatementrange_ast",
          "ReprFuncArgs",
          "find_suffixes",
          "fill_unfilled",
          "syspathinsert",
          "_S",
          "num_mock_patch_args",
          "UsageError",
          "teardown_nose",
          "_validate_keys",
          "resume_global_capture",
          "IGNORE_PAM",
          "indent",
          "istext",
          "showlongtestinfo",
          "Code",
          "terminal",
          "_split_explanation",
          "assert_contains",
          "runpython_c",
          "_io",
          "cwd_relative_nodeid",
          "show_fixtures_per_test",
          "NOT",
          "pytest_warning_recorded",
          "_get_plugin_specs_as_list",
          "_strtobool",
          "addsection",
          "deindent",
          "NotSetType",
          "set_when",
          "_perform_collect",
          "delenv",
          "_format_repr_exception",
          "should_do_markup",
          "fromdictargs",
          "__setitem__",
          "_genfunctions",
          "fault_handler_stderr_key",
          "raiseerror",
          "fnmatch_ex",
          "reprfuncargs",
          "Traceback",
          "pytest_runtestloop",
          "_setupstate",
          "item_capture",
          "longrepr",
          "TestReport",
          "capfd",
          "_try_repr_or_str",
          "repr_excinfo",
          "__init__",
          "_truncate_recursive_traceback",
          "emit",
          "_resume",
          "getini",
          "_warn_already_imported",
          "argnames",
          "repr_failure",
          "_get_multicapture",
          "cls",
          "getlocation",
          "parseconfigure",
          "repr_locals",
          "_argcomplete",
          "obj",
          "assert_outcomes",
          "_validate_ids",
          "visit_Name",
          "report_collect",
          "finish",
          "iter_markers",
          "_patch_unwrap_mock_aware",
          "_get_line_with_reprcrash_message",
          "AssertionState",
          "ihook",
          "call_optional",
          "_highlight",
          "_get_override_ini_value",
          "ExceptionRepr",
          "deactivate_fixture",
          "set_log_path",
          "wrap_session",
          "pytest_warning_captured",
          "filename_arg",
          "get_plugin_manager",
          "function",
          "ReprExceptionInfo",
          "getfuncargnames",
          "ImportMode",
          "suspend_fixture",
          "SafeRepr",
          "LOGLEVEL_COLOROPTS",
          "__len__",
          "_is_last_item",
          "summary_stats",
          "__next__",
          "getrawcode",
          "_initrequest",
          "_CACHE_PREFIX_DIRS",
          "path",
          "inline_run",
          "pytest_make_parametrize_id",
          "name",
          "set_trace",
          "parse_known_and_unknown_args",
          "PseudoFixtureDef",
          "_fail",
          "_callfinalizers",
          "CollectErrorRepr",
          "KeywordMatcher",
          "runner",
          "call_fixture_func",
          "teardown_all",
          "errisinstance",
          "hookimpl",
          "capfdbinary",
          "addini",
          "IDENT",
          "runpytest_inprocess",
          "Failed",
          "flow_marker",
          "_AnyPurePath",
          "extract_suffixes",
          "_color_for_type_default",
          "pytest_collectstart",
          "setenv",
          "_schedule_finalizers",
          "_HandlerType",
          "isiterable",
          "FSCollector",
          "BINOP_MAP",
          "style",
          "_log",
          "pytest_internalerror",
          "pytest_enter_pdb",
          "visit_Starred",
          "_update_message",
          "FixtureLookupError",
          "FixtureManager",
          "doctest_namespace",
          "_getentrysource",
          "makedir",
          "_bytes_to_ascii",
          "ensure_newline",
          "saferepr",
          "evaluate_xfail_marks",
          "_basetemp",
          "chdir",
          "_matchfactories",
          "activate_fixture",
          "DOCTEST_REPORT_CHOICE_CDIFF",
          "gethookproxy",
          "_get_assertion_exprs",
          "Exception",
          "mode",
          "CaptureResult",
          "str",
          "OK",
          "get_unpacked_marks",
          "tbfilter",
          "pytest_report_teststatus",
          "pytestPDB",
          "_setup_fixtures",
          "_running_on_ci",
          "is_generator",
          "_idval",
          "_write_progress_information_filling_space",
          "getpluginversioninfo",
          "stopTest",
          "_consider_importhook",
          "PdbInvoke",
          "caplog",
          "OptionGroup",
          "error",
          "load_config_dict_from_file",
          "LFPluginCollWrapper",
          "NodeMeta",
          "_is_capturing",
          "FixtureRequest",
          "_esctable",
          "_cachedir",
          "_get_global_properties_node",
          "_write_report_lines_from_hooks",
          "_iter_all_modules",
          "_bestrelpath_cache",
          "extraline",
          "ReprFileLocation",
          "format",
          "reprlocals",
          "_ANSI_ESCAPE_SEQ",
          "_create",
          "set",
          "pytest_report_from_serializable",
          "essential_plugins",
          "invocation_dir",
          "_get_first_non_fixture_func",
          "scopeproperty",
          "getitem",
          "_sys_snapshot",
          "names",
          "is_capturing",
          "install_importhook",
          "DEFAULT_MAX_LINES",
          "initialnames",
          "LogXML",
          "__getitem__",
          "count_towards_summary",
          "for_config",
          "get_config",
          "FuncFixtureInfo",
          "Testdir",
          "parse_hookimpl_opts",
          "tracebackcutdir",
          "addExpectedFailure",
          "get_public_names",
          "cacheshow",
          "TracebackEntry",
          "relline",
          "_get_auto_indent",
          "_getconftest_pathlist",
          "get_scope_package",
          "Package",
          "IDENT_PREFIX",
          "patchsysdict",
          "start_global_capturing",
          "record_testsuite_property",
          "warns",
          "_pytest",
          "pytest_itemcollected",
          "assert_contains_lines",
          "chain",
          "parts",
          "FSHookProxy",
          "_NodeReporter",
          "_locationline",
          "TempdirFactory",
          "helper",
          "and_expr",
          "_write_entry_lines",
          "Skip",
          "_teardown_towards",
          "undo",
          "MultipleDoctestFailures",
          "set_session",
          "async_warn_and_skip",
          "lineno",
          "MoreQuietAction",
          "Token",
          "LineMatcher",
          "context",
          "get_extended_length_path_str",
          "fixtures",
          "__call__",
          "wcwidth",
          "countoutcomes",
          "nose",
          "_makeitem",
          "reports",
          "TYPE_CHECKING",
          "_compute_fixture_value",
          "_outrep_summary",
          "debugging",
          "assertrepr_compare",
          "_read_pyc",
          "_approx_scalar",
          "_issue_warning_captured",
          "get_cache_dir",
          "PytestAssertRewriteWarning",
          "scope2props",
          "records",
          "Argument",
          "_getvaluepath",
          "_import_pdb_cls",
          "listchain",
          "get_dirs_from_args",
          "_early_rewrite_bailout",
          "freeze_support",
          "CaptureIO",
          "params",
          "isnosetest",
          "makepyprojecttoml",
          "get_real_func",
          "get_common_ancestor",
          "warnings",
          "skipped_by_mark_key",
          "config",
          "list",
          "newinstance",
          "getfixturemarker",
          "fslocation",
          "wrap_function_to_error_out_if_called_directly",
          "delitem",
          "abspath",
          "_getautousenames",
          "_try_load_conftest",
          "for_later",
          "_plugin_nameversions",
          "repr_traceback",
          "_postmortem_traceback",
          "EncodedFile",
          "TERMINALWRITER_WRITER",
          "mkdir",
          "ishidden",
          "getitems",
          "_addoption_instance",
          "validate_basetemp",
          "import_path",
          "PytestWarning",
          "_processopt",
          "_force_symlink",
          "symlink_or_skip",
          "REGEX_TYPE",
          "assign",
          "_getindent",
          "finish_recording",
          "own_mark_names",
          "_format_lines",
          "plugins",
          "setdefault",
          "FILLFUNCARGS",
          "reportinfo",
          "fnmatch_lines",
          "gethookrecorder",
          "_params_converter",
          "get_terminal_width",
          "MonkeyPatch",
          "NOTSET",
          "_to_json",
          "Mark",
          "_handle_teardown_sections",
          "ExceptionInfo",
          "encoding",
          "annotated_getattr",
          "_remove_ansi_escape_sequences",
          "readlines",
          "console_main",
          "cmdline",
          "__delitem__",
          "inline_runsource",
          "summary_warnings",
          "pytest_exception_interact",
          "typename",
          "CaptureFixture",
          "write_captured_output",
          "CHECKER_CLASS",
          "_warn_about_missing_assertion",
          "SysCaptureBinary",
          "_make_xunit_fixture",
          "get_option_ini",
          "WarningReport",
          "NO_TESTS_COLLECTED",
          "close",
          "register_cleanup_lock_removal",
          "_inject_setup_teardown_fixtures",
          "deprecated",
          "eval",
          "_is_skipped",
          "ExceptionChainRepr",
          "pytest_generate_tests",
          "_testcase",
          "handleError",
          "_show_fixtures_per_test",
          "collect",
          "showfixtures",
          "_traceback",
          "astcache",
          "RUNNER_CLASS",
          "caplog_records_key",
          "_get_runner",
          "pytest_runtest_logstart",
          "get_user",
          "TimeoutExpired",
          "_given_basetemp",
          "skip",
          "SysCapture",
          "addfinalizer",
          "start",
          "pytest_runtest_protocol",
          "hasnew",
          "from_current",
          "text",
          "ConftestImportFailure",
          "append",
          "assertoutcome",
          "pytest_runtest_logfinish",
          "names_closure",
          "readline",
          "fail_marker",
          "pytest_plugin_registered",
          "pytest_pyfunc_call",
          "writer",
          "prune_dependency_tree",
          "set_repr_style",
          "make_properties_node",
          "__slots__",
          "FixtureFunctionMarker",
          "rex_session_duration",
          "_LiveLoggingStreamHandler",
          "popcall",
          "perform_collect",
          "simple",
          "clear",
          "_get_direct_parametrize_args",
          "_truncate_explanation",
          "Collector",
          "Notset",
          "message",
          "ApproxSequencelike",
          "_update_current_test_var",
          "_compare_eq_iterable",
          "listnames",
          "assertstate_key",
          "kwargs",
          "cache",
          "isdatacls",
          "truncate_if_required",
          "_PluggyPlugin",
          "no_re_match_line",
          "TokenType",
          "restore",
          "MINUS_K_DASH",
          "__exit__",
          "runpytest",
          "is_async_function",
          "_get_allow_unicode_flag",
          "_FixtureFunction",
          "_from_json",
          "pytest_load_initial_conftests",
          "try_cleanup",
          "_no_match_line",
          "_showfixtures_main",
          "_is_mocked",
          "to_xml",
          "instance",
          "repr_traceback_entry",
          "PytestConfigWarning",
          "getrepr",
          "Node",
          "parametrize",
          "strict",
          "is_rewrite_disabled",
          "write_sep",
          "truncate_locals",
          "_names",
          "_write_source",
          "_factorytraceback",
          "WarningsRecorder",
          "resultlog",
          "statement",
          "pytest_assertrepr_compare",
          "get_sections",
          "_NodeType",
          "_makepath",
          "get_lock_path",
          "__repr__",
          "spawn",
          "_legal_chars",
          "pop",
          "determine_setup",
          "fix_cache_order",
          "_parse_filter",
          "ReprEntry",
          "_reprcompare",
          "pytest_runtest_logreport",
          "_makefile",
          "CallSpec2",
          "_compare_eq_any",
          "_fixturemanager",
          "id",
          "_init_runner_class",
          "getfixturevalue",
          "_assert_start_repr",
          "_saferepr",
          "K",
          "StepwisePlugin",
          "when",
          "make_hook_recorder",
          "summary_failures",
          "pastebinfile_key",
          "_report_to_json",
          "CwdSnapshot",
          "_init_pdb",
          "_pluginmanager",
          "getfailures",
          "testdir",
          "expr",
          "_notin_text",
          "visit_BinOp",
          "ApproxMapping",
          "fullwidth",
          "ExitCode",
          "ResultLog",
          "FDCapture",
          "_ensure_supporting_files",
          "_seen",
          "lines",
          "_CACHE_PREFIX_VALUES",
          "MarkMatcher",
          "Interrupted",
          "unset_fixture",
          "assert_never",
          "_repr_failure_py",
          "keywords",
          "TerminalReporter",
          "strip",
          "_validate_plugins",
          "_wrapped_pdb_cls",
          "JUNIT_XML_DEFAULT_FAMILY",
          "pytest_report_header",
          "_saved",
          "ReprFailDoctest",
          "copy_example",
          "_initini",
          "_validate_if_using_arg_names",
          "parse_args",
          "EMPTY_BUFFER",
          "_get_number_flag",
          "recwarn",
          "mktemp",
          "summary_passes",
          "pytest_keyboard_interrupt",
          "addSuccess",
          "File",
          "directory_arg",
          "_T",
          "notify_exception",
          "__getattr__",
          "template",
          "_determine_show_progress_info",
          "_getreprcrash",
          "scopes",
          "_ensure_basetemp",
          "parse_known_args",
          "_PY_DIR",
          "xfail",
          "__ne__",
          "build_summary_stats_line",
          "_check_if_assertion_pass_impl",
          "ImportPathMismatchError",
          "unexpectedsuccess_key",
          "Exit",
          "stream",
          "_legal_xml_re",
          "setup",
          "nodeid",
          "consider_env",
          "normalize_mark_list",
          "_repr_style",
          "exit",
          "mangle_test_address",
          "_should_rewrite",
          "pytest_cmdline_preparse",
          "LineMatcher_fixture",
          "longreprtext",
          "_parse_parametrize_parameters",
          "buffer",
          "safe_getattr",
          "_get_continue_on_failure",
          "_match_lines_random",
          "from_config",
          "handler",
          "no_header",
          "NoCapture",
          "_rewrite_test",
          "PercentStyleMultiline",
          "_check_initialpaths_for_relpath",
          "__take_sys_modules_snapshot",
          "_split_lines",
          "reprfileloc",
          "Store",
          "FakeCollectModule",
          "suspend_capturing",
          "CollectError",
          "_config_for_test",
          "_compare_eq_set",
          "_surrounding_parens_on_own_lines",
          "get_statement_startend2",
          "_addoption",
          "pytest_addoption",
          "Function",
          "_collect",
          "_call_assertion_pass",
          "_compare_eq_dict",
          "pytest_runtest_setup",
          "UnformattedWarning",
          "_get_verbose_word",
          "__dir__",
          "token",
          "lex",
          "pytest_sessionfinish",
          "_getparser",
          "resume",
          "INTERRUPTED",
          "showheader",
          "_call_reprcompare",
          "is_potential_nosetest",
          "pytest_make_collect_report",
          "getfixtureinfo",
          "failed",
          "getfixturedefs",
          "funcargs",
          "_ensure_immutable_ids",
          "_get_report_choice",
          "addError",
          "pytest_collect_file",
          "width_of_current_line",
          "_in_venv",
          "matching_platform",
          "BaseReport",
          "DEPRECATED_EXTERNAL_PLUGINS",
          "write_docstring",
          "add_cleanup",
          "frame",
          "Parser",
          "_getpytestargs",
          "_translate_non_printable",
          "readouterr",
          "__version_tuple__",
          "python_api",
          "param",
          "_for_parametrize",
          "type",
          "sections",
          "__version__",
          "locals",
          "ensure_reset_dir",
          "visit_Assert",
          "stepwise",
          "_markers",
          "record_xml_attribute",
          "getfslineno",
          "_make_plural",
          "co_equal",
          "python",
          "version",
          "pytest_leave_pdb",
          "funcnamefilter",
          "_create_formatter",
          "_F",
          "_preparse",
          "AND",
          "_parse_ini_config",
          "idmaker",
          "FDCaptureBinary",
          "_FixtureCachedResult",
          "funcargnames",
          "cacheprovider",
          "cache_dir_from_config",
          "_non_numeric_type_error",
          "Xfail",
          "with_args",
          "_get_active_fixturedef",
          "yield_fixture",
          "ascii_escaped",
          "pop_format_context",
          "builtin_plugins",
          "re_match_lines",
          "resolve_package_path",
          "write_ensure_prefix",
          "setitem",
          "skipped",
          "_eval_scope_callable",
          "listextrakeywords",
          "SysPathsSnapshot",
          "PytestCacheWarning",
          "addSkip",
          "get_parametrized_fixture_keys",
          "duration",
          "ApproxBase",
          "_get_stderr_fileno",
          "_py_ext_re",
          "rex_outcome",
          "importorskip",
          "TempPathFactory",
          "pytest_ignore_collect",
          "WarningsChecker",
          "from_exc_info",
          "_pop_and_teardown",
          "isdict",
          "teardown_exact",
          "PYC_TAIL",
          "getoption",
          "PdbTrace",
          "add_funcarg_pseudo_fixture_def",
          "RE_IMPORT_ERROR_NAME",
          "SetupState",
          "KNOWN_TYPES",
          "fillfixtures",
          "markname",
          "append_error",
          "Session",
          "read",
          "maybe_wrap_pytest_function_for_tracing",
          "_state",
          "_in_suspended",
          "_PLUGGY_DIR",
          "_tmppath_factory",
          "getparam",
          "prepare",
          "maybe_delete_a_numbered_dir",
          "LFPlugin",
          "DoctestModule",
          "from_call",
          "NodeKeywords",
          "finalize",
          "evaluate_condition",
          "_prunetraceback",
          "addinivalue_line",
          "markup",
          "faulthandler",
          "PytestCollectionWarning",
          "append_collect_error",
          "compat",
          "parse",
          "MultiCapture",
          "runpytest_subprocess",
          "pytest_report_to_serializable",
          "runtestprotocol",
          "logging",
          "_suspend",
          "getvalueorskip",
          "pytest_configure",
          "OutcomeException",
          "_inject_setup_class_fixture",
          "excinfo",
          "AssertionRewritingHook",
          "_prepare_content",
          "_Key",
          "runitem",
          "_R",
          "clear_cache",
          "PyCollector",
          "record_testreport",
          "_diff_text",
          "_mark_plugins_for_rewrite",
          "consider_module",
          "_REPORTCHARS_DEFAULT",
          "XFailed",
          "LogCaptureFixture",
          "runtest",
          "rewrite_asserts",
          "create_module",
          "FILE_OR_DIR",
          "module",
          "_get_fixturestack",
          "pytest_sessionstart",
          "_show_fixture_action",
          "dir",
          "show_test_item",
          "record_property",
          "tmpdir_factory",
          "CallInfo",
          "get_optionflags",
          "_check_type",
          "make_numbered_dir_with_cleanup",
          "call_and_report",
          "nofuncargs",
          "Config",
          "reason",
          "_runtest_for",
          "get_lines_after",
          "version_tuple",
          "DEFAULT_MAX_CHARS",
          "Module",
          "Item",
          "_idvalset",
          "MatcherAdapter",
          "pytest_addhooks",
          "no_fnmatch_line",
          "__all__",
          "xml_key",
          "matchnodes",
          "read_global_capture",
          "_color_for_type",
          "Scanner",
          "_getini",
          "istestfunction",
          "_LiveLoggingNullHandler",
          "ParseError",
          "warning_record_to_str",
          "DEFAULT_LOG_DATE_FORMAT",
          "_compare_eq_cls",
          "_write_content",
          "assertion",
          "_PytestWrapper",
          "Metafunc",
          "_main",
          "_teardown_with_finalization",
          "_tryconvertpyarg",
          "resultlog_key",
          "get_real_method",
          "BASE_TYPE",
          "prog",
          "nodes",
          "reprcrash",
          "_resolve_arg_ids",
          "_assertion_supported",
          "getparent",
          "combined_with",
          "NoMatch",
          "_get_progress_information_message",
          "filter",
          "parse_setoption",
          "DOCTEST_REPORT_CHOICE_ONLY_FIRST_FAILURE",
          "_do_configure",
          "addoption",
          "getfixtureclosure",
          "TEST_OUTCOME",
          "ReprEntryNative",
          "_warn_or_fail_if_strict",
          "_striptext",
          "_call_with_optional_argument",
          "get_records",
          "getgroup",
          "_get_checker",
          "deselect_by_keyword",
          "_compare_eq_verbose",
          "capsysbinary",
          "capsys",
          "pop_outerr_to_orig",
          "category",
          "_set_initial_conftests",
          "_printcollecteditems",
          "Instance",
          "ReprTracebackNative",
          "pathlib",
          "nextitem",
          "parse_hookspec_opts",
          "formatrepr",
          "flush",
          "FixtureLookupErrorRepr",
          "_splitnode",
          "fail_fixturefunc",
          "visit_UnaryOp",
          "CaptureManager",
          "PytestExperimentalApiWarning",
          "getargs",
          "__enter__",
          "suspend_global_capture",
          "LogCaptureHandler",
          "__str__",
          "ischildnode",
          "_legal_ranges",
          "consider_conftest",
          "line",
          "write",
          "UNARY_MAP",
          "get_fslocation_from_item",
          "session",
          "store",
          "deselect_by_mark",
          "TESTS_FAILED",
          "spawn_pytest",
          "scopenum_function",
          "_WithException",
          "_matchnodes",
          "import_plugin",
          "TerminalWriter",
          "_FixtureValue",
          "istestclass",
          "_py36_windowsconsoleio_workaround",
          "__missing__",
          "hasinit",
          "visit_BoolOp",
          "post_mortem",
          "__iter__",
          "passed",
          "istestfunc",
          "ReprLocals",
          "getstatement",
          "_find_parametrized_scope",
          "_set_main_color",
          "builtin",
          "get_last_failed_paths",
          "_collectfile",
          "sep",
          "catching_logs",
          "addFailure",
          "setmulti2",
          "Skipped",
          "capture",
          "safe_isclass",
          "_typ_map",
          "tolerance"
        ]
      },
      "response": {
        "keywords": [
          "add_marker",
          "pytest",
          "xfail",
          "request",
          "mark",
          "assert"
        ]
      }
    },
    {
      "name": "FilesKeywordSearch",
      "metadata": {
        "start": "2024-08-19T12:21:56.574796",
        "usage": "274.4431495666504 ms"
      },
      "request": {
        "tokens": [
          "add_marker",
          "pytest",
          "xfail",
          "request",
          "mark",
          "assert"
        ]
      },
      "response": {
        "results": {
          "pytest": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/pytest/__main__.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/helpconfig.py",
            "src/pytest/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/timing.py",
            "src/_pytest/pytester.py",
            "src/pytest/collect.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "assert": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "mark": [
            "src/_pytest/mark/__init__.py",
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/warnings.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/skipping.py",
            "src/_pytest/nodes.py"
          ],
          "xfail": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/unittest.py",
            "src/pytest/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py"
          ],
          "request": [
            "src/_pytest/junitxml.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/runner.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py"
          ],
          "add_marker": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ]
        }
      }
    },
    {
      "name": "FilesFilter",
      "metadata": {
        "start": "2024-08-19T12:21:56.849255",
        "usage": "10792.145252227783 ms"
      },
      "request": {
        "keyword_search_results": {
          "pytest": [
            "src/_pytest/faulthandler.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/outcomes.py",
            "src/pytest/__main__.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/monkeypatch.py",
            "src/_pytest/helpconfig.py",
            "src/pytest/__init__.py",
            "src/_pytest/config/exceptions.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/deprecated.py",
            "src/_pytest/freeze_support.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/mark/expression.py",
            "src/_pytest/timing.py",
            "src/_pytest/pytester.py",
            "src/pytest/collect.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "assert": [
            "src/_pytest/cacheprovider.py",
            "src/_pytest/capture.py",
            "src/_pytest/doctest.py",
            "src/_pytest/compat.py",
            "src/_pytest/skipping.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/resultlog.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py",
            "src/_pytest/assertion/rewrite.py",
            "src/_pytest/_code/code.py",
            "src/_pytest/assertion/util.py",
            "src/_pytest/terminal.py",
            "src/_pytest/unittest.py",
            "src/_pytest/stepwise.py",
            "src/_pytest/mark/__init__.py",
            "src/_pytest/_io/terminalwriter.py",
            "src/_pytest/pathlib.py",
            "src/_pytest/config/argparsing.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/debugging.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/warnings.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/main.py",
            "src/_pytest/reports.py",
            "src/_pytest/runner.py",
            "src/_pytest/pytester.py",
            "src/_pytest/recwarn.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/logging.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/python_api.py",
            "src/_pytest/assertion/__init__.py",
            "src/_pytest/config/findpaths.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/nodes.py"
          ],
          "mark": [
            "src/_pytest/mark/__init__.py",
            "src/pytest/__init__.py",
            "src/_pytest/warning_types.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/config/__init__.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/warnings.py",
            "src/_pytest/python_api.py",
            "src/_pytest/python.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/skipping.py",
            "src/_pytest/nodes.py"
          ],
          "xfail": [
            "src/_pytest/mark/__init__.py",
            "src/_pytest/unittest.py",
            "src/pytest/__init__.py",
            "src/_pytest/mark/structures.py",
            "src/_pytest/skipping.py",
            "src/_pytest/outcomes.py",
            "src/_pytest/python.py",
            "src/_pytest/junitxml.py"
          ],
          "request": [
            "src/_pytest/junitxml.py",
            "src/_pytest/cacheprovider.py",
            "src/_pytest/runner.py",
            "src/_pytest/capture.py",
            "src/_pytest/fixtures.py",
            "src/_pytest/pytester.py",
            "src/_pytest/setupplan.py",
            "src/_pytest/tmpdir.py",
            "src/_pytest/logging.py",
            "src/_pytest/pastebin.py",
            "src/_pytest/python.py",
            "src/_pytest/hookspec.py",
            "src/_pytest/setuponly.py",
            "src/_pytest/unittest.py"
          ],
          "add_marker": [
            "src/_pytest/fixtures.py",
            "src/_pytest/python.py",
            "src/_pytest/nodes.py"
          ]
        }
      },
      "response": {
        "scratch_pad": "The issue is related to using the function `request.node.add_marker(mark)` to dynamically add an xfail marker in a test, which worked in pytest 5.x but not in 6.x. \n\nBased on the issue description, the relevant keywords here are likely `xfail`, `request`, and `add_marker`. These keywords directly pertain to marking tests and the request object in pytest, both central to the reported problem.\n\n1. **`xfail` keyword**: Relevance is high since xfail is related to the functionality of marking a test as expected to fail. Relevant files could provide insights on how the xfail marker is implemented or used in pytest. \n   - Files: \n     - `src/_pytest/mark/__init__.py`\n     - `src/_pytest/mark/structures.py`\n     - `src/_pytest/skipping.py`\n     - `src/_pytest/outcomes.py` (Outcomes often deal with test results and categories like skipped or xfailed)\n     - `src/_pytest/python.py` (Handles the python specific aspects of test collection and running, might involve xfail markers)\n\n2. **`request` keyword**: This keyword is relevant since `request.node.add_marker(mark)` is the method causing the problem. Files involving requests might explain changes in behavior from pytest 5.x to 6.x.\n    - Files: `src/_pytest/python.py`\n\n3. **`add_marker` keyword**: Central to the issue is the behavior of `add_marker`. This keyword's matching files may show changes or usage of the add_marker function.\n     - Files: \n       - `src/_pytest/python.py` \n       - `src/_pytest/fixtures.py` \n       - `src/_pytest/nodes.py` (Handling of nodes might have changed affecting the add_marker behavior)\n\nNow, choose the most relevant files that likely hold the implementation or documentation of changes related to dynamically adding xfail markers.",
        "file_paths": [
          "src/_pytest/mark/__init__.py",
          "src/_pytest/mark/structures.py",
          "src/_pytest/nodes.py",
          "src/_pytest/skipping.py",
          "src/_pytest/outcomes.py"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:22:07.641426",
        "usage": "9715.104103088379 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/__init__.py"
      },
      "response": {
        "scratch_pad": "1. Analyzing user issue:\n1.1. The user describes that in pytest 5.x, dynamically adding an xfail marker to a test using `request.node.add_marker(mark)` would treat the failing test like a test marked statically with xfail, which means it would not fail the test run. In pytest 6.0.0rc0, this behavior changed, and the test is not marked as xfail, leading to a failure.\n1.2. There are reproduce steps showing the problem occurs with code in `test_foo.py`, where an xfail marker is added dynamically and the test fails when it should not.\n1.3. The issue seems caused by an internal change in how pytest handles dynamically added markers.\n1.4. Users expect the dynamically added xfail marker to bypass the test failure and be recorded as xfail.\n1.6. A possible solution might be to revise the internal logic for marker evaluation or utilize a different mechanism for recognizing dynamically added markers as valid.\n\n2. Evaluating File:\n2.1. The file appears to be part of the pytest mark and select mechanism.\n2.2. Classes and functions related to mark handling include `Mark`, `MarkDecorator`, `MarkGenerator`, and `Matcher` classes.\n2.3. The `deselect_by_mark`, `pytest_collection_modifyitems`, and `MarkMatcher.from_item` functions deal with how marks are handled.\n2.4. There's a method of matching marker expressions inside `deselect_by_mark`, which could impact how dynamically added markers are evaluated.\n2.5. I don't see direct lines modifying marker behavior here related to `add_marker`, which indicates this file might not be where the regression occurred but likely plays a role in marker processing.\n\nConclusion:\n- This file is relevant but may not contain the root cause. It influences marker processing.\n- No direct handling for `node.add_marker` usage that aligns with the issue here. Further exploration into the framework might be needed to directly connect adding markers dynamically with the desired xfail functionality.\n- Suggest exploring files dealing with test node marker assignment and evaluation for regression details.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/runner.py",
          "src/_pytest/python.py"
        ],
        "relevant_symbols": [
          "KeywordMatcher",
          "MarkMatcher",
          "deselect_by_mark",
          "pytest_collection_modifyitems",
          "pytest_configure"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:22:17.356546",
        "usage": "9607.913970947266 ms"
      },
      "request": {
        "file_path": "src/_pytest/mark/structures.py"
      },
      "response": {
        "scratch_pad": "1. **Understanding the Issue:**\n   - The issue occurs when attempting to dynamically add an \"xfail\" marker to a test using `request.node.add_marker(mark)` in pytest version 6.0. In version 5.x, this addition correctly treated the test as expected to fail (and hence didn't cause the test or pytest to fail overall). However, in pytest 6.x, such a dynamically marked test fails with an `AssertionError`. This indicates a change in behavior from version 5.x to 6.x.\n\n2. **Reproducing the Issue:**\n   - The reproduction involves:\n     1. Writing a test that asserts False (`assert 0`).\n     2. Dynamically adding an \"xfail\" marker via `request.node.add_marker(mark)`.\n   - In pytest 5.x, such tests were xfailed as intended. In pytest 6.x, such tests are failing.\n\n3. **Analysis of the File:**\n   - The file `src/_pytest/mark/structures.py` seems to contain the implementation details related to markers in pytest.\n   - There are classes and functions that define and manipulate marks (`Mark`, `MarkDecorator`, `MarkGenerator`).\n   - The file defines logic for handling markers, including combining marks, checking mark validity, etc.\n   - While specific handling of `xfail` markers is not clearly outlined, the file is likely related due to being responsible for the conceptual handling of marker software architecture.\n\n4. **Expected Behavior vs Current Behavior:**\n   - **Expected:** Dynamically adding an xfail marker should cause a test that fails to be ignored (not cause an assertion failure) in both pytest 5.x and 6.x. \n   - **Actual:** In pytest 6.x, dynamically marked tests fail with an `AssertionError` instead of being ignored.\n\n5. **Possible Solutions and Considerations:**\n   - Reviewing changes to the behavior of marker handling between pytest 5.x and 6.x should be essential. The issue might arise from changes around how markers are processed or applied to nodes.\n   - Improvement might involve inspecting functions where `add_marker` affects the pytest node behavior. Identifying if there's a check preventing dynamically added xfail markers from being processed like statically defined ones could be useful.\n\n6. **Potentially Relevant Symbol:**\n   Based on the file's code, methods like `MarkDecorator.__call__`, `store_mark`, and `MarkGenerator.__getattr__` might be critical in deciding why this behavior differs between versions. If markers added during a test's runtime are improperly registered or processed, these areas could be problematic.\n\n7. **Determination of Root Cause:**\n   - This specific file is relevant but not the definitive root cause; rather, it could be related to logic for storing or applying marks. Further review of marker handling elsewhere in pytest 6 might be necessary.",
        "relevant": true,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/resultlog.py"
        ],
        "relevant_symbols": [
          "MarkDecorator.__call__",
          "store_mark",
          "MarkGenerator.__getattr__"
        ],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:22:26.964489",
        "usage": "12178.327083587646 ms"
      },
      "request": {
        "file_path": "src/_pytest/nodes.py"
      },
      "response": {
        "scratch_pad": "1. Understand the Issue:\n1.1 The issue suggests that dynamic addition of 'xfail' markers in pytest tests is behaving differently between versions 5.x and 6.0.0rc0. In 5.x, adding an 'xfail' mark via 'request.node.add_marker(mark)' treats the test as expected to fail, whereas in 6.0.0rc0, the test fails instead of being marked as expected to fail. \n1.2 Yes, the user provides steps for reproduction by writing a sample test 'test_xfail_test' and showing outputs from the two versions of pytest.\n1.3 This issue could be caused by changes in how markers are processed or registered in the newer version, potentially involving changes to the handling of request node properties.\n1.4 The user expects that dynamically added 'xfail' marks should work the same as static ones, indicating that somewhere in the code, these dynamic markers are not being processed correctly or there is a misalignment in expectations.\n1.5 The changes possibly lie in how 'request.node.add_marker' is handled in the newer version, where failure handling might have been modified.\n\n2. Evaluate the File:\n2.1 The file seems to define 'Nodes' and related classes which can be relevant because request.node is a Node object.\n2.2 In particular, the 'add_marker' method in the 'Node' class is crucial because it directly handles the addition of markers which is at the core of the issue.\n2.3 The logic for adding markers is implemented in 'add_marker'. It might have changed or is interacting differently with the rest of the pytest framework in 6.0.0rc0.\n2.4 The class hierarchy, use of base classes like 'Node', and dynamic marker addition through the 'add_marker' method are the sections most relevant to the issue.\n2.5 There might be other parts of the codebase where markers are handled, such as reporting or evaluating test outcomes, that are also affected by how markers are attached.\n2.6 Based on the presence of the 'add_marker' method, this file is likely to be directly responsible for the issue.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "Node.add_marker",
          "Node",
          "Item"
        ],
        "root_cause_symbols": [
          "Node.add_marker"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:22:39.142849",
        "usage": "8115.417957305908 ms"
      },
      "request": {
        "file_path": "src/_pytest/skipping.py"
      },
      "response": {
        "scratch_pad": "1. **Analyze User Instructions:**\n   - The issue discusses a change in how pytest handles dynamically added xfail markers between versions 5.x and 6.x.\n   - Earlier, using `request.node.add_marker(mark)` with an xfail marker would treat failing tests as expected failures, similar to statically marked xfail tests.\n   - In pytest 6.0.0, such tests fail, indicating a change in behavior.\n\n2. **Understanding the Issue:**\n   - User is facing a problem where dynamically added xfail markers behave differently in pytest version 6.x as compared to 5.x.\n   - This change might have been introduced unintentionally or as an intentional update in behavior.\n   - Expected behavior is to treat failed tests marked with xfail dynamically at runtime as xfail (expected failure). However, in pytest 6.x, this leads to a failure.\n\n3. **Evaluation of the File Content:**\n   - This file (`src/_pytest/skipping.py`) deals with skip and xfail functionalities in pytest.\n   - The functions `evaluate_xfail_marks()` and `pytest_runtest_call` are of particular interest:\n     - `evaluate_xfail_marks()` evaluates xfail marks against a test, determining if a test should be marked as an expected failure.\n     - `pytest_runtest_call` handles the test-running logic where xfail markers are considered.\n   - The changes or bug related to dynamic xfail behavior could be rooted in how the outcome of test calls is managed or how the rubber-stamped marks influence the call.\n\n4. **On Relevance:**\n   - The file is very likely relevant as it deals directly with the xfail functionality.\n   - Symbols like `evaluate_xfail_marks`, `pytest_runtest_call`, `pytest_runtest_makereport` appear central to the xfail behavior and its reporting, especially the conditional handling around dynamically set xfail markers.",
        "relevant": true,
        "root_cause": true,
        "relevant_files": [],
        "relevant_symbols": [
          "evaluate_xfail_marks",
          "pytest_runtest_call",
          "pytest_runtest_makereport"
        ],
        "root_cause_symbols": [
          "evaluate_xfail_marks",
          "pytest_runtest_call",
          "pytest_runtest_makereport"
        ]
      }
    },
    {
      "name": "FileEvaluate",
      "metadata": {
        "start": "2024-08-19T12:22:47.258296",
        "usage": "6145.9081172943115 ms"
      },
      "request": {
        "file_path": "src/_pytest/outcomes.py"
      },
      "response": {
        "scratch_pad": "1. Analyze User Instructions:\n1.1 The user reports that dynamically adding an xfail marker to tests no longer causes them to be treated as expected failures in pytest 6, as it did in pytest 5.\n1.2 The reproduction steps involve creating a test that dynamically adds an xfail marker with request.node.add_marker(mark) and then asserts a failure. In pytest 5, this would cause the test to be recorded as an expected failure, but in pytest 6, it results in a regular failure.\n1.3 The issue seems caused by changes in how pytest 6 handles dynamically added xfail markers, altering the behavior compared to pytest 5.\n1.4 The user expects that dynamically added xfail markers should cause tests to be marked as expected failures (as in pytest 5) instead of failing outright. The change in behavior may be due to internal changes in how pytest processes markers and test outcomes.\n1.6 Possible solutions might involve investigating changes in pytest 6 that affect marking, particularly around request.node.add_marker, and looking for a way to maintain the expected behavior.\n\n2. Make file evaluation:\n2.1 The file 'src/_pytest/outcomes.py' contains implementations of various exceptions related to test outcomes, such as Skipped, Failed, and XFailed.\n2.2 Notably, the file defines classes for handling test outcomes, including XFailed for xfail cases.\n2.3 It also defines the function xfail(reason: str = \"\") -> \"NoReturn\", which raises an XFailed exception with a given reason.\n2.4 The file provides mechanisms for tests to mark certain outcomes, which aligns with the issue concerning xfail markers.\n2.5 The file may be indirectly related due to how pytest internally processes xfail markers, but no explicit handling for dynamically adding markers is found here.\n2.6 Other parts of the pytest codebase responsible for handling request nodes may hold the root cause, but this file seems to primarily define outcomes, not process markers dynamically.",
        "relevant": false,
        "root_cause": false,
        "relevant_files": [
          "src/_pytest/nodes.py",
          "src/_pytest/mark/structures.py",
          "src/_pytest/runner.py"
        ],
        "relevant_symbols": [],
        "root_cause_symbols": []
      }
    },
    {
      "name": "FileSymbolSearch",
      "metadata": {
        "start": "2024-08-19T12:22:53.404286",
        "usage": "226.51910781860352 ms"
      },
      "request": {
        "files": [
          {
            "file_path": "src/_pytest/mark/__init__.py",
            "relevant_symbol_keys": [
              "KeywordMatcher",
              "MarkMatcher",
              "deselect_by_mark",
              "pytest_collection_modifyitems",
              "pytest_configure"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/mark/structures.py",
            "relevant_symbol_keys": [
              "MarkDecorator.__call__",
              "store_mark",
              "MarkGenerator.__getattr__"
            ],
            "root_cause_symbol_keys": []
          },
          {
            "file_path": "src/_pytest/nodes.py",
            "relevant_symbol_keys": [
              "Node.add_marker",
              "Node",
              "Item"
            ],
            "root_cause_symbol_keys": [
              "Node.add_marker"
            ]
          },
          {
            "file_path": "src/_pytest/skipping.py",
            "relevant_symbol_keys": [
              "evaluate_xfail_marks",
              "pytest_runtest_call",
              "pytest_runtest_makereport"
            ],
            "root_cause_symbol_keys": [
              "evaluate_xfail_marks",
              "pytest_runtest_call",
              "pytest_runtest_makereport"
            ]
          },
          {
            "file_path": "src/_pytest/outcomes.py",
            "relevant_symbol_keys": [],
            "root_cause_symbol_keys": []
          }
        ],
        "with_content": true
      },
      "response": {
        "related_symbols": [
          {
            "name": "_pytest.cacheprovider.LFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 289,
            "start_column": 10558,
            "end_line": 4,
            "end_column": 12796,
            "start_byte": 10558,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.NFPlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 361,
            "start_column": 13534,
            "end_line": 4,
            "end_column": 14397,
            "start_byte": 13534,
            "end_byte": 4
          },
          {
            "name": "_pytest.cacheprovider.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16918,
            "end_line": 0,
            "end_column": 17167,
            "start_byte": 16918,
            "end_byte": 0
          },
          {
            "name": "_pytest.config.PytestPluginManager.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 442,
            "start_column": 13883,
            "end_line": 4,
            "end_column": 14533,
            "start_byte": 13883,
            "end_byte": 4
          },
          {
            "name": "_pytest.debugging.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "f marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches ",
            "start_line": 61,
            "start_column": 1816,
            "end_line": 0,
            "end_column": 2649,
            "start_byte": 1816,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "from .structures import ParameterSet\nfrom _pytest.compat import TYPE_CHECKING\nfrom _pytest.config import Config\nfrom _pytest.config import ExitCode\nfrom _pytest.config import hookimpl\nfrom _pytest.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n          ",
            "start_line": 24,
            "start_column": 532,
            "end_line": 0,
            "end_column": 1486,
            "start_byte": 532,
            "end_byte": 0
          },
          {
            "name": "_pytest.faulthandler.FaultHandlerHooks.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSe",
            "start_line": 52,
            "start_column": 1666,
            "end_line": 4,
            "end_column": 1955,
            "start_byte": 1666,
            "end_byte": 4
          },
          {
            "name": "_pytest.fixtures.FixtureManager.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 1613,
            "start_column": 62458,
            "end_line": 4,
            "end_column": 62612,
            "start_byte": 62458,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "line()\n        config._ensure_unconfigure()\n        return 0\n\n    return None\n\n\n@attr.s(slots=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_key",
            "start_line": 117,
            "start_column": 4131,
            "end_line": 0,
            "end_column": 4632,
            "start_byte": 4131,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": ", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)\n\n\ndef pytest_configure(config: Config) -> None:\n    config._store[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageEr",
            "start_line": 231,
            "start_column": 8250,
            "end_line": 0,
            "end_column": 8658,
            "start_byte": 8250,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 439,
            "start_column": 15188,
            "end_line": 0,
            "end_column": 15980,
            "start_byte": 15188,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 501,
            "start_column": 17763,
            "end_line": 0,
            "end_column": 17914,
            "start_byte": 17763,
            "end_byte": 0
          },
          {
            "name": "_pytest.main.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "",
            "start_line": 372,
            "start_column": 12071,
            "end_line": 0,
            "end_column": 12584,
            "start_byte": 12071,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@attr.s(slots=True)\nclass KeywordMatcher:\n    \"\"\"A matcher for keywords.\n\n    Given a list of names, matches any substring of one of these names. The\n    string inclusion check is case-insensitive.\n\n    Will match on the name of colitem, including the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names = attr.ib(type=AbstractSet[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # add the markers to the keywords as we no longer handle them correctly\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)\n\n    def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 125,
            "start_column": 4211,
            "end_line": 0,
            "end_column": 5901,
            "start_byte": 4211,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.KeywordMatcher._names",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "_names = attr.ib(type=AbstractSet[str])",
            "start_line": 140,
            "start_column": 4734,
            "end_line": 4,
            "end_column": 4773,
            "start_byte": 4734,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.from_item",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"function\", None)\n        if function_obj:\n            mapped_names.update(function_obj.__dict__)\n\n        # add the markers to the keywords as we no longer handle them correctly\n        mapped_names.update(mark.name for mark in item.iter_markers())\n\n        return cls(mapped_names)",
            "start_line": 142,
            "start_column": 4779,
            "end_line": 4,
            "end_column": 5656,
            "start_byte": 4779,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.KeywordMatcher.__call__",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def __call__(self, subname: str) -> bool:\n        subname = subname.lower()\n        names = (name.lower() for name in self._names)\n\n        for name in names:\n            if subname in name:\n                return True\n        return False",
            "start_line": 166,
            "start_column": 5662,
            "end_line": 4,
            "end_column": 5901,
            "start_byte": 5662,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@attr.s(slots=True)\nclass MarkMatcher:\n    \"\"\"A matcher for markers which are present.\n\n    Tries to match on any marker names, attached to the given colitem.\n    \"\"\"\n\n    own_mark_names = attr.ib()\n\n    @classmethod\n    def from_item(cls, item) -> \"MarkMatcher\":\n        mark_names = {mark.name for mark in item.iter_markers()}\n        return cls(mark_names)\n\n    def __call__(self, name: str) -> bool:\n        return name in self.own_mark_names",
            "start_line": 214,
            "start_column": 7079,
            "end_line": 0,
            "end_column": 7525,
            "start_byte": 7079,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkMatcher.own_mark_names",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "own_mark_names = attr.ib()",
            "start_line": 221,
            "start_column": 7251,
            "end_line": 4,
            "end_column": 7277,
            "start_byte": 7251,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.from_item",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "@classmethod\n    def from_item(cls, item) -> \"MarkMatcher\":\n        mark_names = {mark.name for mark in item.iter_markers()}\n        return cls(mark_names)",
            "start_line": 223,
            "start_column": 7283,
            "end_line": 4,
            "end_column": 7438,
            "start_byte": 7283,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkMatcher.__call__",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def __call__(self, name: str) -> bool:\n        return name in self.own_mark_names",
            "start_line": 228,
            "start_column": 7444,
            "end_line": 4,
            "end_column": 7525,
            "start_byte": 7444,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.deselect_by_mark",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def deselect_by_mark(items: \"List[Item]\", config: Config) -> None:\n    matchexpr = config.option.markexpr\n    if not matchexpr:\n        return\n\n    try:\n        expression = Expression.compile(matchexpr)\n    except ParseError as e:\n        raise UsageError(\n            \"Wrong expression passed to '-m': {}: {}\".format(matchexpr, e)\n        ) from None\n\n    remaining = []\n    deselected = []\n    for item in items:\n        if expression.evaluate(MarkMatcher.from_item(item)):\n            remaining.append(item)\n        else:\n            deselected.append(item)\n\n    if deselected:\n        config.hook.pytest_deselected(items=deselected)\n        items[:] = remaining",
            "start_line": 232,
            "start_column": 7528,
            "end_line": 0,
            "end_column": 8194,
            "start_byte": 7528,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_collection_modifyitems(items: \"List[Item]\", config: Config) -> None:\n    deselect_by_keyword(items, config)\n    deselect_by_mark(items, config)",
            "start_line": 257,
            "start_column": 8197,
            "end_line": 0,
            "end_column": 8351,
            "start_byte": 8197,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "def pytest_configure(config: Config) -> None:\n    config._store[old_mark_config_key] = MARK_GEN._config\n    MARK_GEN._config = config\n\n    empty_parameterset = config.getini(EMPTY_PARAMETERSET_OPTION)\n\n    if empty_parameterset not in (\"skip\", \"xfail\", \"fail_at_collect\", None, \"\"):\n        raise UsageError(\n            \"{!s} must be one of skip, xfail or fail_at_collect\"\n            \" but it is {!r}\".format(EMPTY_PARAMETERSET_OPTION, empty_parameterset)\n        )",
            "start_line": 262,
            "start_column": 8354,
            "end_line": 0,
            "end_column": 8821,
            "start_byte": 8354,
            "end_byte": 0
          },
          {
            "name": "_pytest.pastebin.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "arsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def",
            "start_line": 30,
            "start_column": 778,
            "end_line": 0,
            "end_column": 1609,
            "start_byte": 778,
            "end_byte": 0
          },
          {
            "name": "_pytest.pytester.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions a",
            "start_line": 83,
            "start_column": 2138,
            "end_line": 0,
            "end_column": 2530,
            "start_byte": 2138,
            "end_byte": 0
          },
          {
            "name": "_pytest.python.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " the names of its parents.\n    Only matches names of items which are either a :class:`Class` or a\n    :class:`Function`.\n\n    Additionally, matches on names in the 'extra_keyword_matches' set of\n    any item, as well as names directly assigned to test functions.\n    \"\"\"\n\n    _names = attr.ib(type=AbstractSet[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"",
            "start_line": 138,
            "start_column": 4458,
            "end_line": 0,
            "end_column": 5374,
            "start_byte": 4458,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "lection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and classes whose name \"\n        \"contains 'test_method' or 'test_other', while -k 'not test_method' \"\n        \"matches those that don't contain 'test_method' in their names. \"\n        \"-k 'not test_method and not test_other' will eliminate the matches. \"\n        \"Additionally keywor",
            "start_line": 47,
            "start_column": 1193,
            "end_line": 0,
            "end_column": 2813,
            "start_byte": 1193,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": ".config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecate",
            "start_line": 28,
            "start_column": 728,
            "end_line": 0,
            "end_column": 866,
            "start_byte": 728,
            "end_byte": 0
          },
          {
            "name": "_pytest.stepwise.StepwisePlugin.pytest_collection_modifyitems",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "ize-marks>`.\n\n    .. code-block:: python\n\n        @pytest.mark.parametrize(\n            \"test_input,expected\",\n            [(\"3+5\", 8), pytest.param(\"6*9\", 42, marks=pytest.mark.xfail),],\n        )\n        def test_eval(test_input, expected):\n            assert eval(test_input) == expected\n\n    :param values: variable args of the values of the parameter set, in order.\n    :keyword marks: a single mark or a list of marks to be applied to this parameter set.\n    :keyword str id: the id to attribute to this parameter set.\n    \"\"\"\n    return ParameterSet.param(*values, marks=marks, id=id)\n\n\ndef pytest_addoption(parser: Parser) -> None:\n    group = parser.getgroup(\"general\")\n    group._addoption(\n        \"-k\",\n        action=\"store\",\n        dest=\"keyword\",\n        default=\"\",\n        metavar=\"EXPRESSION\",\n        help=\"only run tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other' matches all test functions and cl",
            "start_line": 48,
            "start_column": 1400,
            "end_line": 4,
            "end_column": 2535,
            "start_byte": 1400,
            "end_byte": 4
          },
          {
            "name": "_pytest.terminal.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " config.option.keyword.lstrip()\n    if not keywordexpr:\n        return\n\n    if keywordexpr.startswith(\"-\"):\n        # To be removed in pytest 7.0.0.\n        warnings.warn(MINUS_K_DASH, stacklevel=2)\n        keywordexpr = \"not \" + keywordexpr[1:]\n    selectuntil = False\n    if keywordexpr[-1:] == \":\":\n        # To be removed in pytest 7.0.0.\n        warnings.warn(MINUS_K_COLON, stacklevel=2)\n        selectuntil = Tru",
            "start_line": 224,
            "start_column": 5991,
            "end_line": 0,
            "end_column": 6410,
            "start_byte": 5991,
            "end_byte": 0
          },
          {
            "name": "_pytest.tmpdir.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "t[str])\n\n    @classmethod\n    def from_item(cls, item: \"Item\") -> \"KeywordMatcher\":\n        mapped_names = set()\n\n        # Add the names of the current item and any parent items\n        import pytest\n\n        for node in item.listchain():\n            if not isinstance(node, (pytest.Instance, pytest.Session)):\n                mapped_names.add(node.name)\n\n        # Add the names added as extra keywords to current or parent items\n        mapped_names.update(item.listextrakeywords())\n\n        # Add the names attached to the current function through direct assignment\n        function_obj = getattr(item, \"",
            "start_line": 138,
            "start_column": 4766,
            "end_line": 0,
            "end_column": 5374,
            "start_byte": 4766,
            "end_byte": 0
          },
          {
            "name": "_pytest.warnings.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": " tests which match the given substring expression. \"\n        \"An expression is a python evaluatable expression \"\n        \"where all names are substring-matched against test names \"\n        \"and their parent classes. Example: -k 'test_method or test_\"\n        \"other'",
            "start_line": 74,
            "start_column": 2235,
            "end_line": 0,
            "end_column": 2501,
            "start_byte": 2235,
            "end_byte": 0
          },
          {
            "name": "_pytest.resultlog.pytest_configure",
            "file_path": "src/_pytest/mark/__init__.py",
            "file_content": "est.config import UsageError\nfrom _pytest.config.argparsing import Parser\nfrom _pytest.deprecated import MINUS_K_COLON\nfrom _pytest.deprecated import MINUS_K_DASH\nfrom _pytest.store import StoreKey\n\nif TYPE_CHECKING:\n    from _pytest.nodes import Item\n\n\n__all__ = [\"Mark\", \"MarkDecorator\", \"MarkGenerator\", \"get_empty_parameterset_mark\"]\n\n\nold_mark_config_key = StoreKey[Optional[Config]]()\n\n\ndef param(\n    *values: object,\n    marks: \"Union[MarkDecorator, typing.Collection[Union[MarkDecorator, Mark]]]\" = (),\n    id: Optional[str] = None\n) -> ParameterSet:\n    \"\"\"Specify a parameter in `pytest.mark.parametrize`_ calls or\n    :ref:`parametrized fixtures <fixture-parametrize-marks>`.\n\n    .. code-block:: ",
            "start_line": 30,
            "start_column": 725,
            "end_line": 0,
            "end_column": 1434,
            "start_byte": 725,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload\n    def __call__(self, arg: _Markable) -> _Markable:  # type: ignore[misc]\n        raise NotImplementedError()",
            "start_line": 322,
            "start_column": 10861,
            "end_line": 4,
            "end_column": 10981,
            "start_byte": 10861,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "@overload  # noqa: F811\n    def __call__(  # noqa: F811\n        self, *args: object, **kwargs: object\n    ) -> \"MarkDecorator\":\n        raise NotImplementedError()",
            "start_line": 326,
            "start_column": 10987,
            "end_line": 4,
            "end_column": 11150,
            "start_byte": 10987,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.MarkDecorator.__call__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __call__(self, *args: object, **kwargs: object):  # noqa: F811\n        \"\"\"Call the MarkDecorator.\"\"\"\n        if args and not kwargs:\n            func = args[0]\n            is_class = inspect.isclass(func)\n            if len(args) == 1 and (istestfunc(func) or is_class):\n                store_mark(func, self.mark)\n                return func\n        return self.with_args(*args, **kwargs)",
            "start_line": 332,
            "start_column": 11156,
            "end_line": 4,
            "end_column": 11549,
            "start_byte": 11156,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.store_mark",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def store_mark(obj, mark: Mark) -> None:\n    \"\"\"Store a Mark on an object.\n\n    This is used to implement the Mark declarations/decorators correctly.\n    \"\"\"\n    assert isinstance(mark, Mark), mark\n    # Always reassign name to avoid updating pytestmark in a reference that\n    # was only borrowed.\n    obj.pytestmark = get_unpacked_marks(obj) + [mark]",
            "start_line": 369,
            "start_column": 12372,
            "end_line": 0,
            "end_column": 12724,
            "start_byte": 12372,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.MarkGenerator.__getattr__",
            "file_path": "src/_pytest/mark/structures.py",
            "file_content": "def __getattr__(self, name: str) -> MarkDecorator:\n        if name[0] == \"_\":\n            raise AttributeError(\"Marker name must NOT start with underscore\")\n\n        if self._config is not None:\n            # We store a set of markers as a performance optimisation - if a mark\n            # name is in the set we definitely know it, but a mark may be known and\n            # not in the set.  We therefore start by updating the set!\n            if name not in self._markers:\n                for line in self._config.getini(\"markers\"):\n                    # example lines: \"skipif(condition): skip the given test if...\"\n                    # or \"hypothesis: tests which use Hypothesis\", so to get the\n                    # marker name we split on both `:` and `(`.\n                    marker = line.split(\":\")[0].split(\"(\")[0].strip()\n                    self._markers.add(marker)\n\n            # If the name is not in the set of known marks after updating,\n            # then it really is time to issue a warning or an error.\n            if name not in self._markers:\n                if self._config.option.strict_markers:\n                    fail(\n                        \"{!r} not found in `markers` configuration option\".format(name),\n                        pytrace=False,\n                    )\n\n                # Raise a specific error for common misspellings of \"parametrize\".\n                if name in [\"parameterize\", \"parametrise\", \"parameterise\"]:\n                    __tracebackhide__ = True\n                    fail(\"Unknown '{}' mark, did you mean 'parametrize'?\".format(name))\n\n                warnings.warn(\n                    \"Unknown pytest.mark.%s - is this a typo?  You can register \"\n                    \"custom marks to avoid this warning - for details, see \"\n                    \"https://docs.pytest.org/en/stable/mark.html\" % name,\n                    PytestUnknownMarkWarning,\n                    2,\n                )\n\n        return MarkDecorator(Mark(name, (), {}))",
            "start_line": 479,
            "start_column": 16175,
            "end_line": 4,
            "end_column": 18166,
            "start_byte": 16175,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()\n\n    def get_closest_marker(  # noqa: F811\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self) -> Set[str]:\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls: \"Type[_NodeType]\") -> Optional[_NodeType]:\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self  # type: Optional[Node]\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbo",
            "start_line": 239,
            "start_column": 7363,
            "end_line": 0,
            "end_column": 12909,
            "start_byte": 7363,
            "end_byte": 0
          },
          {
            "name": "_pytest.doctest.DoctestItem.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ssert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> Non",
            "start_line": 240,
            "start_column": 7399,
            "end_line": 4,
            "end_column": 7815,
            "start_byte": 7399,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.from_parent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "     pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self,",
            "start_line": 253,
            "start_column": 7821,
            "end_line": 4,
            "end_column": 8271,
            "start_byte": 7821,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "r: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker,",
            "start_line": 268,
            "start_column": 8277,
            "end_line": 4,
            "end_column": 8674,
            "start_byte": 8277,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.runtest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param nam",
            "start_line": 278,
            "start_column": 8680,
            "end_line": 4,
            "end_column": 9179,
            "start_byte": 8680,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem._disable_output_capturing_for_darwin",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n",
            "start_line": 290,
            "start_column": 9185,
            "end_line": 4,
            "end_column": 9665,
            "start_byte": 9185,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "r mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()\n\n    def get_closest_marker(  # noqa: F811\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self) -> Set[str]:\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls: \"Type[_NodeType]\") -> Optional[_NodeType]:\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self  # type: Optional[Node]\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"a",
            "start_line": 304,
            "start_column": 9727,
            "end_line": 4,
            "end_column": 12770,
            "start_byte": 9727,
            "end_byte": 4
          },
          {
            "name": "_pytest.doctest.DoctestItem.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "== \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbo",
            "start_line": 371,
            "start_column": 12776,
            "end_line": 4,
            "end_column": 12909,
            "start_byte": 12776,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "e=self.__name__), stacklevel=2)\n        return super().__call__(*k, **kw)\n\n    def _create(self, *k, **kw):\n        return super().__call__(*k, **kw)\n\n\nclass Node(metaclass=NodeMeta):\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        if config:\n            self.config = config  # type: Config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: the session this node is part of\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"\n        Public Constructor for Nodes\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the construction\n\n        :param parent: the parent node of this test Node\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()\n\n    def get_c",
            "start_line": 106,
            "start_column": 2941,
            "end_line": 0,
            "end_column": 10139,
            "start_byte": 2941,
            "end_byte": 0
          },
          {
            "name": "_pytest.junitxml._NodeReporter.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "vel=2)\n        return super().__call__(*k, **kw)\n\n    def _create(self, *k, **kw):\n        return super().__call__(*k, **kw)\n\n\nclass Node(metaclass=NodeMeta):\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n ",
            "start_line": 107,
            "start_column": 2966,
            "end_line": 4,
            "end_column": 3380,
            "start_byte": 2966,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n    ",
            "start_line": 117,
            "start_column": 3386,
            "end_line": 4,
            "end_column": 3509,
            "start_byte": 3386,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_property",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "_dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config:",
            "start_line": 121,
            "start_column": 3515,
            "end_line": 4,
            "end_column": 3639,
            "start_byte": 3515,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.add_attribute",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nal[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,",
            "start_line": 124,
            "start_column": 3645,
            "end_line": 4,
            "end_column": 3757,
            "start_byte": 3645,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.make_properties_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "   nodeid: Optional[str] = None,\n    ) -> None:\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        if config:\n            self.config = config  # type: Config\n        else:\n            if not parent:\n                raise TypeError(\"conf",
            "start_line": 127,
            "start_column": 3763,
            "end_line": 4,
            "end_column": 4148,
            "start_byte": 3763,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.record_testreport",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "parent must be provided\")\n            self.config = parent.config\n\n        #: the session this node is part of\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid",
            "start_line": 139,
            "start_column": 4154,
            "end_line": 4,
            "end_column": 5356,
            "start_byte": 4154,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.to_xml",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n",
            "start_line": 169,
            "start_column": 5362,
            "end_line": 4,
            "end_column": 5613,
            "start_byte": 5362,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._add_simple",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lassmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"\n        Public Constructor for Nodes\n\n        This indirection got introduced in order to enable removing\n        t",
            "start_line": 176,
            "start_column": 5619,
            "end_line": 4,
            "end_column": 5805,
            "start_byte": 5619,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.write_captured_output",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "gile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the construction\n\n        :param parent: the parent node of this test Node\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :ra",
            "start_line": 181,
            "start_column": 5811,
            "end_line": 4,
            "end_column": 6846,
            "start_byte": 5811,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._prepare_content",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "lueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python",
            "start_line": 204,
            "start_column": 6852,
            "end_line": 4,
            "end_column": 6977,
            "start_byte": 6852,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter._write_content",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "        node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):",
            "start_line": 207,
            "start_column": 6983,
            "end_line": 4,
            "end_column": 7152,
            "start_byte": 6983,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_pass",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "       raise ValueError(\n                \"warning must be an instance of PytestWarn",
            "start_line": 211,
            "start_column": 7158,
            "end_line": 4,
            "end_column": 7241,
            "start_byte": 7158,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        ",
            "start_line": 214,
            "start_column": 7247,
            "end_line": 4,
            "end_column": 7927,
            "start_byte": 7247,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "turn list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse(",
            "start_line": 229,
            "start_column": 7933,
            "end_line": 4,
            "end_column": 8214,
            "start_byte": 7933,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_collect_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "    return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamic",
            "start_line": 236,
            "start_column": 8220,
            "end_line": 4,
            "end_column": 8360,
            "start_byte": 8220,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_error",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "dd a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.m",
            "start_line": 239,
            "start_column": 8366,
            "end_line": 4,
            "end_column": 8877,
            "start_byte": 8366,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.append_skipped",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    ",
            "start_line": 252,
            "start_column": 8883,
            "end_line": 4,
            "end_column": 9847,
            "start_byte": 8883,
            "end_byte": 4
          },
          {
            "name": "_pytest.junitxml._NodeReporter.finalize",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()\n\n    def get_c",
            "start_line": 278,
            "start_column": 9853,
            "end_line": 4,
            "end_column": 10139,
            "start_byte": 9853,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "patterns = self.config.getini(\"norecursedirs\")\n\n    @classmethod\n    def from_parent(cls, parent, *, fspath, **kw):\n        \"\"\"\n        The public constructor\n        \"\"\"\n        return super().from_parent(parent=parent, fspath=fspath, **kw)\n\n    def _gethookproxy(self, fspath: py.path.local):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n        pm = self.config.pluginmanager\n        my_conftestmodules = pm._getconftestmodules(\n            fspath, self.config.getoption(\"importmode\")\n        )\n        remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mods:\n            # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(pm, remove_mods)\n        else:\n            # all plugins are active for this fspath\n            proxy = self.config.hook\n        return proxy\n\n    def gethookproxy(self, fspath: py.path.local):\n        raise NotImp",
            "start_line": 523,
            "start_column": 18198,
            "end_line": 0,
            "end_column": 19158,
            "start_byte": 18198,
            "end_byte": 0
          },
          {
            "name": "_pytest.mark.NodeKeywords.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ssmethod\n    def from_parent(cls, parent, *, fspath, **kw):\n        \"\"\"\n        The public constructor\n        \"\"\"\n        ret",
            "start_line": 524,
            "start_column": 18254,
            "end_line": 4,
            "end_column": 18380,
            "start_byte": 18254,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__getitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "per().from_parent(parent=parent, fspath=fspath, **kw)\n\n    def _gethookproxy(self, fspath: py.path.local):\n        # check if we have the common case of running\n        # hooks with all conftest.py files\n  ",
            "start_line": 529,
            "start_column": 18386,
            "end_line": 4,
            "end_column": 18592,
            "start_byte": 18386,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__setitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "pm = self.config.pluginmanager\n        my_conftestmodules = pm._getco",
            "start_line": 537,
            "start_column": 18598,
            "end_line": 4,
            "end_column": 18667,
            "start_byte": 18598,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__delitem__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "modules(\n            fspath, self.config.getoption(\"importmode\")\n        )\n        remove_",
            "start_line": 540,
            "start_column": 18673,
            "end_line": 4,
            "end_column": 18763,
            "start_byte": 18673,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__iter__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": " pm._conftest_plugins.difference(my_conftestmodules)\n        if remove_mo",
            "start_line": 543,
            "start_column": 18769,
            "end_line": 4,
            "end_column": 18842,
            "start_byte": 18769,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords._seen",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "          # one or more conftests are not in use at this fspath\n            proxy = FSHookProxy(pm, remove_mods)\n        else:\n            # all plugins",
            "start_line": 547,
            "start_column": 18848,
            "end_line": 4,
            "end_column": 19000,
            "start_byte": 18848,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__len__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "ctive for this fspath\n            proxy = self.config.hook",
            "start_line": 553,
            "start_column": 19006,
            "end_line": 4,
            "end_column": 19064,
            "start_byte": 19006,
            "end_byte": 4
          },
          {
            "name": "_pytest.mark.NodeKeywords.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "   return proxy\n\n    def gethookproxy(self, fspath: py.path.local):\n        raise NotImp",
            "start_line": 556,
            "start_column": 19070,
            "end_line": 4,
            "end_column": 19158,
            "start_byte": 19070,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes._NodeType",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "_NodeType = TypeVar(\"_NodeType\", bound=\"Node\")",
            "start_line": 89,
            "start_column": 2783,
            "end_line": 0,
            "end_column": 2829,
            "start_byte": 2783,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.NodeMeta",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class NodeMeta(type):\n    def __call__(self, *k, **kw):\n        warnings.warn(NODE_USE_FROM_PARENT.format(name=self.__name__), stacklevel=2)\n        return super().__call__(*k, **kw)\n\n    def _create(self, *k, **kw):\n        return super().__call__(*k, **kw)",
            "start_line": 92,
            "start_column": 2832,
            "end_line": 0,
            "end_column": 3090,
            "start_byte": 2832,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.NodeMeta.__call__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __call__(self, *k, **kw):\n        warnings.warn(NODE_USE_FROM_PARENT.format(name=self.__name__), stacklevel=2)\n        return super().__call__(*k, **kw)",
            "start_line": 93,
            "start_column": 2858,
            "end_line": 4,
            "end_column": 3014,
            "start_byte": 2858,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.NodeMeta._create",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _create(self, *k, **kw):\n        return super().__call__(*k, **kw)",
            "start_line": 97,
            "start_column": 3020,
            "end_line": 4,
            "end_column": 3090,
            "start_byte": 3020,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Node(metaclass=NodeMeta):\n    \"\"\" base class for Collector and Item the test collection tree.\n    Collector subclasses have children, Items are terminal nodes.\"\"\"\n\n    # Use __slots__ to make attribute access faster.\n    # Note that __dict__ is still available.\n    __slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )\n\n    def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        if config:\n            self.config = config  # type: Config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: the session this node is part of\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()\n\n    @classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"\n        Public Constructor for Nodes\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the construction\n\n        :param parent: the parent node of this test Node\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)\n\n    @property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)\n\n    def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))\n\n    def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )\n\n    # methods for ordering nodes\n    @property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid\n\n    def __hash__(self) -> int:\n        return hash(self._nodeid)\n\n    def setup(self) -> None:\n        pass\n\n    def teardown(self) -> None:\n        pass\n\n    def listchain(self) -> List[\"Node\"]:\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain\n\n    def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)\n\n    def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))\n\n    def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark\n\n    @overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()\n\n    @overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()\n\n    def get_closest_marker(  # noqa: F811\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)\n\n    def listextrakeywords(self) -> Set[str]:\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords\n\n    def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]\n\n    def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)\n\n    def getparent(self, cls: \"Type[_NodeType]\") -> Optional[_NodeType]:\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self  # type: Optional[Node]\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current\n\n    def _prunetraceback(self, excinfo):\n        pass\n\n    def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != Path(str(self.config.invocation_dir))\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )\n\n    def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 101,
            "start_column": 3093,
            "end_line": 0,
            "end_column": 14319,
            "start_byte": 3093,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Node.__slots__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "__slots__ = (\n        \"name\",\n        \"parent\",\n        \"config\",\n        \"session\",\n        \"fspath\",\n        \"_nodeid\",\n        \"_store\",\n        \"__dict__\",\n    )",
            "start_line": 107,
            "start_column": 3365,
            "end_line": 4,
            "end_column": 3530,
            "start_byte": 3365,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self,\n        name: str,\n        parent: \"Optional[Node]\" = None,\n        config: Optional[Config] = None,\n        session: \"Optional[Session]\" = None,\n        fspath: Optional[py.path.local] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        #: a unique name within the scope of the parent node\n        self.name = name\n\n        #: the parent collector node.\n        self.parent = parent\n\n        #: the pytest config object\n        if config:\n            self.config = config  # type: Config\n        else:\n            if not parent:\n                raise TypeError(\"config or parent must be provided\")\n            self.config = parent.config\n\n        #: the session this node is part of\n        if session:\n            self.session = session\n        else:\n            if not parent:\n                raise TypeError(\"session or parent must be provided\")\n            self.session = parent.session\n\n        #: filesystem path where this node was collected from (can be None)\n        self.fspath = fspath or getattr(parent, \"fspath\", None)\n\n        #: keywords/markers collected from all scopes\n        self.keywords = NodeKeywords(self)\n\n        #: the marker objects belonging to this node\n        self.own_markers = []  # type: List[Mark]\n\n        #: allow adding of extra keywords to use for matching\n        self.extra_keyword_matches = set()  # type: Set[str]\n\n        # used for storing artificial fixturedefs for direct parametrization\n        self._name2pseudofixturedef = {}  # type: Dict[str, FixtureDef]\n\n        if nodeid is not None:\n            assert \"::()\" not in nodeid\n            self._nodeid = nodeid\n        else:\n            if not self.parent:\n                raise TypeError(\"nodeid or parent must be provided\")\n            self._nodeid = self.parent.nodeid\n            if self.name != \"()\":\n                self._nodeid += \"::\" + self.name\n\n        # A place where plugins can store information on the node for their\n        # own use. Currently only intended for internal plugins.\n        self._store = Store()",
            "start_line": 118,
            "start_column": 3536,
            "end_line": 4,
            "end_column": 5611,
            "start_byte": 3536,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.from_parent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@classmethod\n    def from_parent(cls, parent: \"Node\", **kw):\n        \"\"\"\n        Public Constructor for Nodes\n\n        This indirection got introduced in order to enable removing\n        the fragile logic from the node constructors.\n\n        Subclasses can use ``super().from_parent(...)`` when overriding the construction\n\n        :param parent: the parent node of this test Node\n        \"\"\"\n        if \"config\" in kw:\n            raise TypeError(\"config is not a valid argument for from_parent\")\n        if \"session\" in kw:\n            raise TypeError(\"session is not a valid argument for from_parent\")\n        return cls._create(parent=parent, **kw)",
            "start_line": 178,
            "start_column": 5617,
            "end_line": 4,
            "end_column": 6269,
            "start_byte": 5617,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.ihook",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def ihook(self):\n        \"\"\" fspath sensitive hook proxy used to call pytest hooks\"\"\"\n        return self.session.gethookproxy(self.fspath)",
            "start_line": 196,
            "start_column": 6275,
            "end_line": 4,
            "end_column": 6428,
            "start_byte": 6275,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__repr__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __repr__(self) -> str:\n        return \"<{} {}>\".format(self.__class__.__name__, getattr(self, \"name\", None))",
            "start_line": 201,
            "start_column": 6434,
            "end_line": 4,
            "end_column": 6546,
            "start_byte": 6434,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.warn",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def warn(self, warning: \"PytestWarning\") -> None:\n        \"\"\"Issue a warning for this item.\n\n        Warnings will be displayed after the test session, unless explicitly suppressed\n\n        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.\n\n        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.\n\n        Example usage:\n\n        .. code-block:: python\n\n            node.warn(PytestWarning(\"some message\"))\n\n        \"\"\"\n        from _pytest.warning_types import PytestWarning\n\n        if not isinstance(warning, PytestWarning):\n            raise ValueError(\n                \"warning must be an instance of PytestWarning or subclass, got {!r}\".format(\n                    warning\n                )\n            )\n        path, lineno = get_fslocation_from_item(self)\n        assert lineno is not None\n        warnings.warn_explicit(\n            warning, category=None, filename=str(path), lineno=lineno + 1,\n        )",
            "start_line": 204,
            "start_column": 6552,
            "end_line": 4,
            "end_column": 7540,
            "start_byte": 6552,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.nodeid",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@property\n    def nodeid(self) -> str:\n        \"\"\" a ::-separated string denoting its collection tree address. \"\"\"\n        return self._nodeid",
            "start_line": 235,
            "start_column": 7579,
            "end_line": 4,
            "end_column": 7721,
            "start_byte": 7579,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.__hash__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __hash__(self) -> int:\n        return hash(self._nodeid)",
            "start_line": 240,
            "start_column": 7727,
            "end_line": 4,
            "end_column": 7787,
            "start_byte": 7727,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.setup",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def setup(self) -> None:\n        pass",
            "start_line": 243,
            "start_column": 7793,
            "end_line": 4,
            "end_column": 7830,
            "start_byte": 7793,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.teardown",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def teardown(self) -> None:\n        pass",
            "start_line": 246,
            "start_column": 7836,
            "end_line": 4,
            "end_column": 7876,
            "start_byte": 7836,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listchain",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listchain(self) -> List[\"Node\"]:\n        \"\"\" return list of all parent collectors up to self,\n            starting from root of collection tree. \"\"\"\n        chain = []\n        item = self  # type: Optional[Node]\n        while item is not None:\n            chain.append(item)\n            item = item.parent\n        chain.reverse()\n        return chain",
            "start_line": 249,
            "start_column": 7882,
            "end_line": 4,
            "end_column": 8236,
            "start_byte": 7882,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        \"\"\"\n        return (x[1] for x in self.iter_markers_with_node(name=name))",
            "start_line": 284,
            "start_column": 9079,
            "end_line": 4,
            "end_column": 9360,
            "start_byte": 9079,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.iter_markers_with_node",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def iter_markers_with_node(\n        self, name: Optional[str] = None\n    ) -> Iterator[Tuple[\"Node\", Mark]]:\n        \"\"\"\n        :param name: if given, filter the results by the name attribute\n\n        iterate over all markers of the node\n        returns sequence of tuples (node, mark)\n        \"\"\"\n        for node in reversed(self.listchain()):\n            for mark in node.own_markers:\n                if name is None or getattr(mark, \"name\", None) == name:\n                    yield node, mark",
            "start_line": 292,
            "start_column": 9366,
            "end_line": 4,
            "end_column": 9863,
            "start_byte": 9366,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload\n    def get_closest_marker(self, name: str) -> Optional[Mark]:\n        raise NotImplementedError()",
            "start_line": 306,
            "start_column": 9869,
            "end_line": 4,
            "end_column": 9977,
            "start_byte": 9869,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@overload  # noqa: F811\n    def get_closest_marker(self, name: str, default: Mark) -> Mark:  # noqa: F811\n        raise NotImplementedError()",
            "start_line": 310,
            "start_column": 9983,
            "end_line": 4,
            "end_column": 10124,
            "start_byte": 9983,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.get_closest_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def get_closest_marker(  # noqa: F811\n        self, name: str, default: Optional[Mark] = None\n    ) -> Optional[Mark]:\n        \"\"\"return the first marker matching the name, from closest (for example function) to farther level (for example\n        module level).\n\n        :param default: fallback return value of no marker was found\n        :param name: name to filter by\n        \"\"\"\n        return next(self.iter_markers(name=name), default)",
            "start_line": 314,
            "start_column": 10130,
            "end_line": 4,
            "end_column": 10571,
            "start_byte": 10130,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listextrakeywords",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listextrakeywords(self) -> Set[str]:\n        \"\"\" Return a set of all extra keywords in self and any parents.\"\"\"\n        extra_keywords = set()  # type: Set[str]\n        for item in self.listchain():\n            extra_keywords.update(item.extra_keyword_matches)\n        return extra_keywords",
            "start_line": 325,
            "start_column": 10577,
            "end_line": 4,
            "end_column": 10871,
            "start_byte": 10577,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.listnames",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def listnames(self) -> List[str]:\n        return [x.name for x in self.listchain()]",
            "start_line": 332,
            "start_column": 10877,
            "end_line": 4,
            "end_column": 10960,
            "start_byte": 10877,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.addfinalizer",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def addfinalizer(self, fin: Callable[[], object]) -> None:\n        \"\"\" register a function to be called when this node is finalized.\n\n        This method can only be called when this node is active\n        in a setup chain, for example during self.setup().\n        \"\"\"\n        self.session._setupstate.addfinalizer(fin, self)",
            "start_line": 335,
            "start_column": 10966,
            "end_line": 4,
            "end_column": 11291,
            "start_byte": 10966,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.getparent",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def getparent(self, cls: \"Type[_NodeType]\") -> Optional[_NodeType]:\n        \"\"\" get the next parent node (including ourself)\n        which is an instance of the given class\"\"\"\n        current = self  # type: Optional[Node]\n        while current and not isinstance(current, cls):\n            current = current.parent\n        assert current is None or isinstance(current, cls)\n        return current",
            "start_line": 343,
            "start_column": 11297,
            "end_line": 4,
            "end_column": 11694,
            "start_byte": 11297,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._prunetraceback",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _prunetraceback(self, excinfo):\n        pass",
            "start_line": 352,
            "start_column": 11700,
            "end_line": 4,
            "end_column": 11748,
            "start_byte": 11700,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node._repr_failure_py",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def _repr_failure_py(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> TerminalRepr:\n        if isinstance(excinfo.value, ConftestImportFailure):\n            excinfo = ExceptionInfo(excinfo.value.excinfo)\n        if isinstance(excinfo.value, fail.Exception):\n            if not excinfo.value.pytrace:\n                style = \"value\"\n        if isinstance(excinfo.value, FixtureLookupError):\n            return excinfo.value.formatrepr()\n        if self.config.getoption(\"fulltrace\", False):\n            style = \"long\"\n        else:\n            tb = _pytest._code.Traceback([excinfo.traceback[-1]])\n            self._prunetraceback(excinfo)\n            if len(excinfo.traceback) == 0:\n                excinfo.traceback = tb\n            if style == \"auto\":\n                style = \"long\"\n        # XXX should excinfo.getrepr record all data and toterminal() process it?\n        if style is None:\n            if self.config.getoption(\"tbstyle\", \"auto\") == \"short\":\n                style = \"short\"\n            else:\n                style = \"long\"\n\n        if self.config.getoption(\"verbose\", 0) > 1:\n            truncate_locals = False\n        else:\n            truncate_locals = True\n\n        # excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.\n        # It is possible for a fixture/test to change the CWD while this code runs, which\n        # would then result in the user seeing confusing paths in the failure message.\n        # To fix this, if the CWD changed, always display the full absolute path.\n        # It will be better to just always display paths relative to invocation_dir, but\n        # this requires a lot of plumbing (#6428).\n        try:\n            abspath = Path(os.getcwd()) != Path(str(self.config.invocation_dir))\n        except OSError:\n            abspath = True\n\n        return excinfo.getrepr(\n            funcargs=True,\n            abspath=abspath,\n            showlocals=self.config.getoption(\"showlocals\", False),\n            style=style,\n            tbfilter=False,  # pruned already, or in --fulltrace mode.\n            truncate_locals=truncate_locals,\n        )",
            "start_line": 355,
            "start_column": 11754,
            "end_line": 4,
            "end_column": 13943,
            "start_byte": 11754,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Node.repr_failure",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def repr_failure(\n        self,\n        excinfo: ExceptionInfo[BaseException],\n        style: \"Optional[_TracebackStyle]\" = None,\n    ) -> Union[str, TerminalRepr]:\n        \"\"\"\n        Return a representation of a collection or test failure.\n\n        :param excinfo: Exception information for the failure.\n        \"\"\"\n        return self._repr_failure_py(excinfo, style)",
            "start_line": 408,
            "start_column": 13949,
            "end_line": 4,
            "end_column": 14319,
            "start_byte": 13949,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "class Item(Node):\n    \"\"\" a basic test invocation item. Note that for a single function\n    there might be multiple test invocation items.\n    \"\"\"\n\n    nextitem = None\n\n    def __init__(\n        self,\n        name,\n        parent=None,\n        config: Optional[Config] = None,\n        session: Optional[\"Session\"] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, object]]\n\n    def runtest(self) -> None:\n        raise NotImplementedError(\"runtest must be implemented by Item subclass\")\n\n    def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))\n\n    def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n        return self.fspath, None, \"\"\n\n    @cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])",
            "start_line": 609,
            "start_column": 20810,
            "end_line": 0,
            "end_column": 22898,
            "start_byte": 20810,
            "end_byte": 0
          },
          {
            "name": "_pytest.nodes.Item.nextitem",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "nextitem = None",
            "start_line": 614,
            "start_column": 20962,
            "end_line": 4,
            "end_column": 20977,
            "start_byte": 20962,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.__init__",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def __init__(\n        self,\n        name,\n        parent=None,\n        config: Optional[Config] = None,\n        session: Optional[\"Session\"] = None,\n        nodeid: Optional[str] = None,\n    ) -> None:\n        super().__init__(name, parent, config, session, nodeid=nodeid)\n        self._report_sections = []  # type: List[Tuple[str, str, str]]\n\n        #: user properties is a list of tuples (name, value) that holds user\n        #: defined properties for this test.\n        self.user_properties = []  # type: List[Tuple[str, object]]",
            "start_line": 616,
            "start_column": 20983,
            "end_line": 4,
            "end_column": 21517,
            "start_byte": 20983,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.runtest",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def runtest(self) -> None:\n        raise NotImplementedError(\"runtest must be implemented by Item subclass\")",
            "start_line": 631,
            "start_column": 21523,
            "end_line": 4,
            "end_column": 21631,
            "start_byte": 21523,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.add_report_section",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_report_section(self, when: str, key: str, content: str) -> None:\n        \"\"\"\n        Adds a new report section, similar to what's done internally to add stdout and\n        stderr captured output::\n\n            item.add_report_section(\"call\", \"stdout\", \"report section contents\")\n\n        :param str when:\n            One of the possible capture states, ``\"setup\"``, ``\"call\"``, ``\"teardown\"``.\n        :param str key:\n            Name of the section, can be customized at will. Pytest uses ``\"stdout\"`` and\n            ``\"stderr\"`` internally.\n\n        :param str content:\n            The full contents as a string.\n        \"\"\"\n        if content:\n            self._report_sections.append((when, key, content))",
            "start_line": 634,
            "start_column": 21637,
            "end_line": 4,
            "end_column": 22355,
            "start_byte": 21637,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.reportinfo",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def reportinfo(self) -> Tuple[Union[py.path.local, str], Optional[int], str]:\n        return self.fspath, None, \"\"",
            "start_line": 653,
            "start_column": 22361,
            "end_line": 4,
            "end_column": 22475,
            "start_byte": 22361,
            "end_byte": 4
          },
          {
            "name": "_pytest.nodes.Item.location",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "@cached_property\n    def location(self) -> Tuple[str, Optional[int], str]:\n        location = self.reportinfo()\n        if isinstance(location[0], py.path.local):\n            fspath = location[0]\n        else:\n            fspath = py.path.local(location[0])\n        relfspath = self.session._node_location_to_relpath(fspath)\n        assert type(location[2]) is str\n        return (relfspath, location[1], location[2])",
            "start_line": 656,
            "start_column": 22481,
            "end_line": 4,
            "end_column": 22898,
            "start_byte": 22481,
            "end_byte": 4
          }
        ],
        "root_caused_symbols": [
          {
            "name": "_pytest.nodes.Node.add_marker",
            "file_path": "src/_pytest/nodes.py",
            "file_content": "def add_marker(\n        self, marker: Union[str, MarkDecorator], append: bool = True\n    ) -> None:\n        \"\"\"dynamically add a marker object to the node.\n\n        :type marker: ``str`` or ``pytest.mark.*``  object\n        :param marker:\n            ``append=True`` whether to append the marker,\n            if ``False`` insert at position ``0``.\n        \"\"\"\n        from _pytest.mark import MARK_GEN\n\n        if isinstance(marker, MarkDecorator):\n            marker_ = marker\n        elif isinstance(marker, str):\n            marker_ = getattr(MARK_GEN, marker)\n        else:\n            raise ValueError(\"is not a string or pytest.mark.* Marker\")\n        self.keywords[marker_.name] = marker_\n        if append:\n            self.own_markers.append(marker_.mark)\n        else:\n            self.own_markers.insert(0, marker_.mark)",
            "start_line": 260,
            "start_column": 8242,
            "end_line": 4,
            "end_column": 9073,
            "start_byte": 8242,
            "end_byte": 4
          },
          {
            "name": "_pytest.capture.CaptureManager.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 740,
            "start_column": 23827,
            "end_line": 4,
            "end_column": 24003,
            "start_byte": 23827,
            "end_byte": 4
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 464,
            "start_column": 16497,
            "end_line": 0,
            "end_column": 16671,
            "start_byte": 16497,
            "end_byte": 0
          },
          {
            "name": "_pytest.hookspec.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 486,
            "start_column": 17380,
            "end_line": 0,
            "end_column": 17867,
            "start_byte": 17380,
            "end_byte": 0
          },
          {
            "name": "_pytest.logging.LoggingPlugin.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "",
            "start_line": 698,
            "start_column": 25610,
            "end_line": 4,
            "end_column": 25826,
            "start_byte": 25610,
            "end_byte": 4
          },
          {
            "name": "_pytest.runner.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "        msglines = [\n                \"Error evaluating %r condition as a boolean\" % mark.name,\n                *traceback.format_exception_only(type(exc), exc),\n            ]\n            fail(\"\\n\".join(msglines), pytrace=False)\n\n    reason = mark.kwargs.get(\"reason\", None)\n    if reason is None:\n        if isinstance(condition, str):\n            reason = \"condition: \" + condition\n        else:\n            # XXX better be checked at collection time\n            msg = (\n                \"Error evaluating %r: \" % mark.name\n           ",
            "start_line": 143,
            "start_column": 4461,
            "end_line": 0,
            "end_column": 4996,
            "start_byte": 4461,
            "end_byte": 0
          },
          {
            "name": "_pytest.runner.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "ort_teststatus(report: BaseReport) -> Optional[Tuple[str, str, str]]:\n    if hasattr(report, \"wasxfail\"):\n        if report.skipped",
            "start_line": 318,
            "start_column": 10464,
            "end_line": 0,
            "end_column": 10595,
            "start_byte": 10464,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.evaluate_xfail_marks",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:\n    \"\"\"Evaluate xfail marks on item, returning Xfail if triggered.\"\"\"\n    for mark in item.iter_markers(name=\"xfail\"):\n        run = mark.kwargs.get(\"run\", True)\n        strict = mark.kwargs.get(\"strict\", item.config.getini(\"xfail_strict\"))\n        raises = mark.kwargs.get(\"raises\", None)\n        if \"condition\" not in mark.kwargs:\n            conditions = mark.args\n        else:\n            conditions = (mark.kwargs[\"condition\"],)\n\n        # Unconditional.\n        if not conditions:\n            reason = mark.kwargs.get(\"reason\", \"\")\n            return Xfail(reason, run, strict, raises)\n\n        # If any of the conditions are true.\n        for condition in conditions:\n            result, reason = evaluate_condition(item, mark, condition)\n            if result:\n                return Xfail(reason, run, strict, raises)\n\n    return None",
            "start_line": 199,
            "start_column": 6507,
            "end_line": 0,
            "end_column": 7408,
            "start_byte": 6507,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_call",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_call(item: Item) -> Generator[None, None, None]:\n    xfailed = item._store.get(xfailed_key, None)\n    if xfailed is None:\n        item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)\n\n    if not item.config.option.runxfail:\n        if xfailed and not xfailed.run:\n            xfail(\"[NOTRUN] \" + xfailed.reason)\n\n    yield",
            "start_line": 246,
            "start_column": 8107,
            "end_line": 0,
            "end_column": 8487,
            "start_byte": 8107,
            "end_byte": 0
          },
          {
            "name": "_pytest.skipping.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "@hookimpl(hookwrapper=True)\ndef pytest_runtest_makereport(item: Item, call: CallInfo[None]):\n    outcome = yield\n    rep = outcome.get_result()\n    xfailed = item._store.get(xfailed_key, None)\n    # unittest special case, see setting of unexpectedsuccess_key\n    if unexpectedsuccess_key in item._store and rep.when == \"call\":\n        reason = item._store[unexpectedsuccess_key]\n        if reason:\n            rep.longrepr = \"Unexpected success: {}\".format(reason)\n        else:\n            rep.longrepr = \"Unexpected success\"\n        rep.outcome = \"failed\"\n    elif item.config.option.runxfail:\n        pass  # don't interfere\n    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):\n        assert call.excinfo.value.msg is not None\n        rep.wasxfail = \"reason: \" + call.excinfo.value.msg\n        rep.outcome = \"skipped\"\n    elif not rep.skipped and xfailed:\n        if call.excinfo:\n            raises = xfailed.raises\n            if raises is not None and not isinstance(call.excinfo.value, raises):\n                rep.outcome = \"failed\"\n            else:\n                rep.outcome = \"skipped\"\n                rep.wasxfail = xfailed.reason\n        elif call.when == \"call\":\n            if xfailed.strict:\n                rep.outcome = \"failed\"\n                rep.longrepr = \"[XPASS(strict)] \" + xfailed.reason\n            else:\n                rep.outcome = \"passed\"\n                rep.wasxfail = xfailed.reason\n\n    if (\n        item._store.get(skipped_by_mark_key, True)\n        and rep.skipped\n        and type(rep.longrepr) is tuple\n    ):\n        # skipped by mark.skipif; change the location of the failure\n        # to point to the item definition, otherwise it will display\n        # the location of where the skip exception was raised within pytest\n        _, _, reason = rep.longrepr\n        filename, line = item.reportinfo()[:2]\n        assert line is not None\n        rep.longrepr = str(filename), line + 1, reason",
            "start_line": 259,
            "start_column": 8490,
            "end_line": 0,
            "end_column": 10447,
            "start_byte": 8490,
            "end_byte": 0
          },
          {
            "name": "_pytest.unittest.pytest_runtest_makereport",
            "file_path": "src/_pytest/skipping.py",
            "file_content": "urn \"xpassed\", \"X\", \"XPASS\"\n    return None\n",
            "start_line": 290,
            "start_column": 10683,
            "end_line": 0,
            "end_column": 11441,
            "start_byte": 10683,
            "end_byte": 0
          }
        ]
      }
    }
  ]
}